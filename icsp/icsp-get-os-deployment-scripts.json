{
    "type": "OsdPaginatedCollection",
    "members": [
        {
            "codeType": "OGFS",
            "displayCodeType": "OGFS",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "1",
                    "createdBy": "opsware",
                    "createdDate": "2015-06-13T04:48:40.000Z",
                    "usage": "This script inject required settings into the autoinst.xml file. It injects the\nrequired pre- chroot- and post- exitpoint scripts.\npre-exitpoint       to start the agent before the installation starts.\nchroot-exitpoint    to stall the installation before the AutoYaST reboot between \n                    the 1st and second installation phase. This also triggers\n                    the integration of the HP SA agent installation executed \n                    during the next reboot.\npost-exitpoint      to write info file that the installation has finished                    \n\nUsage:\n\tinject_required_ay.py [HP SA Agent Name]\n\n\t\tHP SA Agent Name\n\t\t\tThe OGFS agent that needs to be started during installation.\n\t\t\tThe name of the agent doesn't require quotes. \n\nExample:\n\t\n\t\tinject_required_ks.py SuSE Linux Enterprise Server 11\n\t\tWill inject required settings, and starting SuSE Linux Enterprise\n        Server 11\n\nPrerequisites:\n- Target server runs a maintenance Linux OS.\n- The user provided or default autoinst.xml file must be in /tmp/user.autoinst.cfg.",
                    "current": false
                },
                {
                    "versionLabel": "2",
                    "createdBy": "opsware",
                    "createdDate": "2015-08-04T07:29:44.000Z",
                    "usage": "This script inject required settings into the autoinst.xml file. It injects the\nrequired pre- chroot- and post- exitpoint scripts.\npre-exitpoint       to start the agent before the installation starts.\nchroot-exitpoint    to stall the installation before the AutoYaST reboot between \n                    the 1st and second installation phase. This also triggers\n                    the integration of the HP SA agent installation executed \n                    during the next reboot.\npost-exitpoint      to write info file that the installation has finished                    \n\nUsage:\n\tinject_required_ay.py [HP SA Agent Name]\n\n\t\tHP SA Agent Name\n\t\t\tThe OGFS agent that needs to be started during installation.\n\t\t\tThe name of the agent doesn't require quotes. \n\nExample:\n\t\n\t\tinject_required_ks.py SuSE Linux Enterprise Server 11\n\t\tWill inject required settings, and starting SuSE Linux Enterprise\n        Server 11\n\nPrerequisites:\n- Target server runs a maintenance Linux OS.\n- The user provided or default autoinst.xml file must be in /tmp/user.autoinst.cfg.",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-08-04T07:29:44.000Z",
            "version": {
                "versionLabel": "2",
                "createdBy": "opsware",
                "createdDate": "2015-08-04T07:29:44.000Z",
                "usage": "This script inject required settings into the autoinst.xml file. It injects the\nrequired pre- chroot- and post- exitpoint scripts.\npre-exitpoint       to start the agent before the installation starts.\nchroot-exitpoint    to stall the installation before the AutoYaST reboot between \n                    the 1st and second installation phase. This also triggers\n                    the integration of the HP SA agent installation executed \n                    during the next reboot.\npost-exitpoint      to write info file that the installation has finished                    \n\nUsage:\n\tinject_required_ay.py [HP SA Agent Name]\n\n\t\tHP SA Agent Name\n\t\t\tThe OGFS agent that needs to be started during installation.\n\t\t\tThe name of the agent doesn't require quotes. \n\nExample:\n\t\n\t\tinject_required_ks.py SuSE Linux Enterprise Server 11\n\t\tWill inject required settings, and starting SuSE Linux Enterprise\n        Server 11\n\nPrerequisites:\n- Target server runs a maintenance Linux OS.\n- The user provided or default autoinst.xml file must be in /tmp/user.autoinst.cfg.",
                "current": true
            },
            "source": "#!/usr/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n\"\"\" \n    (C) Copyright 2009-2015 Hewlett-Packard Development Company, L.P.\n\n    Inject required options and move the file onto the boot\n    partition.\n\"\"\"\n\nimport sys\n\nfrom osprov import helpers, media\nfrom osprov.osbp import ThisTargetServer, logger\nfrom osprov.errors import ShowErrorMessage, NotSupportedError\nfrom osprov.osbp.constants import CODE_HEADER, CODE_FOOTER, CODE_WARNING, MONITORING_STOP_FLAG\nfrom osprov.platform_util import isSLES\nfrom osprov.profile import AutoYaST, ProfileError\nfrom osprov.scripts import bootmode\n\nLOG = logger.getIt(\"inject_required_ay\")\n\nBASE_AY_FILE = \"tmp/user.autoinst.xml\"\n\n\ndef injectRequiredOsprov(ayobj):\n    \"\"\" Inject settings required for OS provisioning to work correctly. \"\"\"\n    # Make sure that keep_install_network is in the profile we rely on it\n    # to do the mac association. We need this every time,  even if we are doing\n    # DHCP provisioning, otherwise  the NIC won't get configured in the final OS\n    keepNet = ayobj.createPath(\"profile/networking/keep_install_network\")\n    keepNet.setAttribute(\"config:type\", \"boolean\")\n    ayobj.setNodeTextValue(keepNet, \"true\")\n\n\ndef injectUefiPartitioning(ayobj):\n    \"\"\"Sles installer in some situations can not determine a valid partitioning plan for UEFI servers\n    If the user does not have a defined partitioning plan, we will create a default one that works for these UEFI cases\n    \"\"\"\n    partitioning = ayobj.getNode(\"profile/partitioning\")\n    if partitioning:\n        # searching for a list of partitions\n        for drive in partitioning.getElementsByTagName(\"drive\"):\n            if ayobj.getNode(\"partitions\", drive):\n                # In case the user defines a partitioning plan it's is expected to also set the disklabel accordingly\n                LOG.debug(\"The found autoyast profile already has a partition list defined. Will keep it untouched.\")\n                return\n    else:\n        # Installer should be able to calculate a partitioning plan in this case\n        LOG.debug(\"The found autoyast profile does not have a partitioning tag defined. Will keep it untouched.\")\n        return\n    # Identifying the most appropriate drive to use for installation\n    installdrive = None\n    for drive in partitioning.getElementsByTagName(\"drive\"):\n        if ayobj.getNode(\"disklabel\", drive):\n            drivedisklabel = ayobj.getNode(\"disklabel/#text\", drive)\n            if drivedisklabel and drivedisklabel.data == \"gpt\":\n                installdrive = drive\n                break\n        if not installdrive:\n            installdrive = drive\n    # Create new drive if no drive was found\n    if not installdrive:\n        installdrive = ayobj.createPath(\"profile/partitioning/drive\")\n    # Dealing with disklabel configuration\n    disklabel = ayobj.getNode(\"disklabel\", installdrive)\n    if disklabel:\n        if ayobj.getNode(\"#text\", parentNode=disklabel).data != \"gpt\":\n            LOG.warning(\"UEFI boot mode detected but the installation disk will not have a gpt partition table!\")\n    else:\n        # Create a new disklabel tag\n        disklabel = ayobj.document.createElement(\"disklabel\")\n        ayobj.setNodeTextValue(disklabel, \"gpt\")\n        installdrive.appendChild(disklabel)\n    # If we have found a gpt drive to partition we will add a list of partitions that will work for UEFI systems\n    if ayobj.getNode(\"disklabel/#text\", installdrive).data == \"gpt\":\n        LOG.debug(\"Adding UEFI partitions list to autoyast profile.\")\n        partitions = ayobj.document.createElement(\"partitions\")\n        partitions.setAttribute(\"config:type\", \"list\")\n        installdrive.appendChild(partitions)\n        efipartition = ayobj.document.createElement(\"partition\")\n        efipartition_nr = ayobj.document.createElement(\"partition_nr\")\n        efipartition_nr.setAttribute(\"config:type\", \"integer\")\n        ayobj.setNodeTextValue(efipartition_nr, \"1\")\n        efipartition.appendChild(efipartition_nr)\n        efipartition_fs = ayobj.document.createElement(\"filesystem\")\n        efipartition_fs.setAttribute(\"config:type\", \"symbol\")\n        ayobj.setNodeTextValue(efipartition_fs, \"vfat\")\n        efipartition.appendChild(efipartition_fs)\n        efipartition_mount = ayobj.document.createElement(\"mount\")\n        ayobj.setNodeTextValue(efipartition_mount, \"/boot/efi\")\n        efipartition.appendChild(efipartition_mount)\n        efipartition_size = ayobj.document.createElement(\"size\")\n        ayobj.setNodeTextValue(efipartition_size, \"auto\")\n        efipartition.appendChild(efipartition_size)\n        partitions.appendChild(efipartition)\n        swappartition = ayobj.document.createElement(\"partition\")\n        swappartition_mount = ayobj.document.createElement(\"mount\")\n        ayobj.setNodeTextValue(swappartition_mount, \"swap\")\n        swappartition.appendChild(swappartition_mount)\n        swappartition_size = ayobj.document.createElement(\"size\")\n        ayobj.setNodeTextValue(swappartition_size, \"auto\")\n        swappartition.appendChild(swappartition_size)\n        partitions.appendChild(swappartition)\n        rootpartition = ayobj.document.createElement(\"partition\")\n        rootpartition_mount = ayobj.document.createElement(\"mount\")\n        ayobj.setNodeTextValue(rootpartition_mount, \"/\")\n        rootpartition.appendChild(rootpartition_mount)\n        partitions.appendChild(rootpartition)\n\n\ndef removeConflictingOsprov(ayobj):\n    \"\"\" Removes conflicting options from the autoinst.xml \"\"\"\n\n    #   <general>\n    #       <mode>\n    #           <reboot config:type=\"boolean\">false</reboot>\n    #       </mode>\n    #   </general>\n\n    if \"profile/general/mode/reboot/#text\" in ayobj:\n        ayobj.getNode(\"profile/general/mode/reboot/#text\").data = \"false\"\n\n# using code from prelim. xml\n\n\ndef injectPre(ayobj, targetServer):\n    \"\"\" Inject code in the pre hook to start the OGFS agent \"\"\"\n\n    agwIpPort = targetServer.getRandomAgentGateway()\n    flags = {\"mount\": False, \"async\": True, \"quiet\": True}\n    startCode = CODE_HEADER + \\\n        targetServer.localServer.getOgfsAgentStartupScript(agwIpPort, flags=flags)\n\n    ayobj.addPreScript(scriptCode=startCode, scriptFileName=\"pre.sh\", scriptInterpreter=\"shell\")\n\n\ndef injectChroot(ayobj):\n    \"\"\" Inject code to stall the installer\"\"\"\n\n    chrootCode = \"\"\"\n#!/bin/sh\n{header}\n{warning}\n# next line ends the monitor BP step\necho \"DONE\" > {stopFlag}\necho \"Starting SA Integration .... \"\n# wait until the continue_hook.log file is present\ntouch /tmp/waitForContinuationOfPhase1;\nwhile [ -f /tmp/waitForContinuationOfPhase1 ]; do\n    if [ -f /tmp/continue_hook.log ]; then break;\n    fi;\n    if [ -f /mnt/tmp/continue_hook.log ]; then break;\n    fi;\n    sleep 5;\ndone\nexit 0\n{footer}\n    \"\"\".format(\n        header=CODE_HEADER,\n        warning=CODE_WARNING,\n        footer=CODE_FOOTER,\n        stopFlag=MONITORING_STOP_FLAG\n    )\n\n    ayobj.addChrootScript(scriptCode=chrootCode, scriptFileName=\"chroot_wait4agent.sh\",\n                          scriptInterpreter=\"shell\", chrooted=True)\n\n    friendly_device = \"\"\"@friendly_mpath_device:false@\"\"\"\n    if friendly_device and friendly_device.lower() == \"true\":\n        friendlyMPathCode = \"echo \\\"defaults {\\n \\\nuser_friendly_names yes\\n \\\nbindings_file /etc/multipath_bindings\\n \\\n}\\\"> /etc/multipath.conf\\n \\\n        sleep 1\\n \\\n        cat /etc/fstab | sed 's/mapper\\/.*_part/disk\\/by-id\\/scsi-mpatha-part/' > /etc/fstab.mod\\n \\\n        mv /etc/fstab /etc/fstab.orig\\n \\\n        mv /etc/fstab.mod /etc/fstab\\n \\\n        sleep 1\\n \\\n        mkinitrd -f multipath\\n \"\n        ayobj.addChrootScript(scriptCode=friendlyMPathCode, scriptFileName=None, scriptInterpreter=\"shell\",\n                              chrooted=True, debug=True, feedback=False)\n\n\ndef injectPost(ayobj):\n    \"\"\" Inject code to indicate the installer has finished\"\"\"\n    postCode = \"\"\"\n#!/bin/sh\n%s\n#### DO NOT REMOVE THE ABOVE COMMENT ###\n    echo \"DONE\" > /tmp/post_hook.log\n    exit 0\n### END OF HPSA CODE ###\"\"\" % CODE_HEADER\n    ayobj.addPostScript(scriptCode=postCode, scriptFileName=\"post.sh\", scriptInterpreter=\"shell\")\n\n\ndef encapsulateShCode(code):\n    return \"\"\"#!/bin/sh\\n\"\"\" + CODE_HEADER + code + \"\"\"\\n### END OF HPSA CODE ###\"\"\"\n\n\ndef getFirewallConfigBackupInstructions():\n    return \"\"\"\nfwconf=/etc/sysconfig/SuSEfirewall2\ncp -a $fwconf $fwconf.orig\"\"\"\n\n\ndef getFirewallEnableInstructions():\n    return \"\"\"\necho \"Init-script start firewall: Permanently enabling the firewall\"\nchkconfig SuSEfirewall2_init on\nchkconfig SuSEfirewall2_setup on\"\"\"\n\n\ndef getFirewallStartInstructions():\n    return \"\"\"\necho \"Init-script start firewall: Starting the firewall\"\nservice SuSEfirewall2_init start\nservice SuSEfirewall2_setup start\"\"\"\n\n\ndef getFirewallConfigManipulationInstruction(ay, node):\n    # Will take in consideration just the nodes that start their name with FW\n    property_name = node.nodeName\n    if not property_name.startswith(\"FW\"):\n        if not property_name == \"#text\" and \\\n                not property_name == \"enable_firewall\" and not property_name == \"start_firewall\":\n            print \"WARNING: Did not recognize the %s setting as a valid firewall setting; it will be ignored!\" % property_name\n        return \"\"\n    else:\n        valuenode = ay.getNode(\"#text\", node)\n        if valuenode:\n            property_value = valuenode.nodeValue\n        else:\n            property_value = \"\"\n        LOG.debug(\"Composing the manipulation instruction for %s firewall setting\" % property_name)\n        #Composing the new definition line for SuSE firewall configuration file\n        firewallProperty = '%s=\"%s\"' % (property_name, property_value)\n        # Composing the sh instruction\n        return '''\ngrep '^%s=\".*' $fwconf 1>/dev/null && \\\nsed -i 's/^%s=\".*/%s/g' $fwconf || \\\necho '%s' >> $fwconf''' % (property_name, property_name, firewallProperty, firewallProperty)\n\n\ndef injectFixForAutoYastFirewallSettingsIgnorance(ayobj):\n    \"\"\" Inject code that will configure, enable and start the SuSEfirewall2 services if they were configured\n    This is a work-around for a SLES 11 SP3 autoyast defect we have just filled in\"\"\"\n\n    firewallServiceCode = \"\"\n\n    fw = ayobj.getNode(\"profile/firewall\")\n    if not fw:\n        return\n    else:\n        for node in fw.childNodes:\n            firewallServiceCode += getFirewallConfigManipulationInstruction(ayobj, node)\n    # Backup original configuration file if any manipulation is needed\n    if len(firewallServiceCode) > 0:\n        print \"The SuSE firewall configuration file will be manipulated to apply the specified AutoYaST settings\"\n        firewallServiceCode = getFirewallConfigBackupInstructions() + firewallServiceCode\n\n    fw_enable = ayobj.getNode(\"profile/firewall/enable_firewall/#text\")\n    if fw_enable and fw_enable.nodeValue.lower() == \"true\":\n        print \"The SuSEfirewall2 services will be enabled as specified in the AutoYaST\"\n        firewallServiceCode += getFirewallEnableInstructions()\n\n    fw_start = ayobj.getNode(\"profile/firewall/start_firewall/#text\")\n    if fw_start and fw_start.nodeValue.lower() == \"true\":\n        print \"The SuSEfirewall2 services will be started as specified in the AutoYaST\"\n        firewallServiceCode += getFirewallStartInstructions()\n\n    if len(firewallServiceCode) > 0:\n        firewallServiceCode = encapsulateShCode(firewallServiceCode)\n        ayobj.addInitScript(scriptCode=firewallServiceCode, scriptFileName=\"fixfirewall.sh\", scriptInterpreter=\"shell\")\n\n\ndef writeFinalAy(ayobj):\n    \"\"\" Write the kickstart file onto the boot disk \"\"\"\n    ayfile = open(BASE_AY_FILE, \"w\")\n    ayfile.write(str(ayobj))\n    ayfile.close()\n    print \"AutoYaST file written to disk\"\n\n\ndef main():\n    \"\"\" Do the injection into the AutoYast profile \"\"\"\n    try:\n        targetServer = ThisTargetServer()\n        targetServer.setWorkDir(targetServer.getRemoteRoot())\n        keys = helpers.getDataStore(targetServer)\n        keys.platform.full_name = \" \".join(sys.argv[1:])\n        helpers.putDataStore(keys, targetServer)\n        if keys.media.url:\n            url = media.parseUrl(keys.media.url)\n            if url.scheme == \"https\":\n                print \"Warning: SLES can't install if you have self signed certificates.\"\n                print \"Make sure that your http servers certificates are signed by a trusted CA. \"\n            if url.username:\n                print \"Warning: SLES only supports basic authentication.\"\n                print \"Make sure that your server isn't set up with digest or some other authentication method.\"\n            if not isSLES(keys.platform.full_name, version=\"12\") \\\n               and url.scheme == \"nfs\" and targetServer.isIPv6Managed():\n                raise NotSupportedError(\"Provisioning %s with a media on NFS over IPv6 is not supported. Try with HTTP.\"\n                                        % keys.platform.full_name)\n        ayobj = AutoYaST(open(BASE_AY_FILE))\n        removeConflictingOsprov(ayobj)\n        injectRequiredOsprov(ayobj)\n        if \"UEFI\" in bootmode.getCurrentBootMode(targetServer, LOG):\n            injectUefiPartitioning(ayobj)\n            if not ayobj.installsPackage(\"shim\"):\n                ayobj.injectPackage(\"shim\")\n                print(\"Injected package 'shim' since in UEFI mode\")\n        injectPost(ayobj)\n        injectChroot(ayobj)\n        injectPre(ayobj, targetServer)\n        injectFixForAutoYastFirewallSettingsIgnorance(ayobj)\n        writeFinalAy(ayobj)\n        print \"Successfully injected required settings\"\n    except (IOError, OSError, ShowErrorMessage, ProfileError), why:\n        LOG.exception(why)\n        sys.stderr.write(\"Failed to inject required settings.%s\\n\" % why)\n        sys.exit(1)\n\nif __name__ == \"__main__\":\n    main()\n",
            "description": "This script inject required settings into the autoinst.xml file. It injects the\nrequired pre- chroot- and post- exitpoint scripts.\npre-exitpoint       to start the agent before the installation starts.\nchroot-exitpoint    to stall the installation before the AutoYaST reboot between \n                    the 1st and second installation phase. This also triggers\n                    the integration of the HP SA agent installation executed \n                    during the next reboot.\npost-exitpoint      to write info file that the installation has finished                    \n\nUsage:\n\tinject_required_ay.py [HP SA Agent Name]\n\n\t\tHP SA Agent Name\n\t\t\tThe OGFS agent that needs to be started during installation.\n\t\t\tThe name of the agent doesn't require quotes. \n\nExample:\n\t\n\t\tinject_required_ks.py SuSE Linux Enterprise Server 11\n\t\tWill inject required settings, and starting SuSE Linux Enterprise\n        Server 11\n\nPrerequisites:\n- Target server runs a maintenance Linux OS.\n- The user provided or default autoinst.xml file must be in /tmp/user.autoinst.cfg.",
            "status": null,
            "name": "Inject Required AutoYaST Settings",
            "state": null,
            "eTag": "2015-08-04T07:29:44.000Z",
            "modified": "2015-08-04T07:29:44.000Z",
            "created": "2015-06-13T04:48:40.000Z",
            "category": "os-deployment-ogfs-scripts",
            "uri": "/rest/os-deployment-ogfs-scripts/350001"
        },
        {
            "codeType": "OGFS",
            "displayCodeType": "OGFS",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "1",
                    "createdBy": "opsware",
                    "createdDate": "2015-06-13T04:48:41.000Z",
                    "usage": "This script integrates a Windows OS install with Server Automation.\nFeatures\n * Downloading the HP SA agent installer\n * Creating a script that will execute the HP SA Agent installer when the final OS first boots.\n * Copying the server's unique MID and cryptographic certificates into place\n * Setting up the agent installer to run at first boot\n\nUsage:  [--systemdrive H] [--platform Windows 2008 x64] [--unattend=\"path_to_unattend\"] [--installdir=\"path_to_install_agent\"]\n  systemdrive:\n    (Optional) The Windows drive letter where OS is installed.  The default is  \"C\".\n  unattend:\n    (Optional) Path to the unattend file.  By default the script looks for the usual X:\\Windows\\Temp\\Unattend.xml file.\n  platform:\n    (Optional) HP SA Platform name. Used to download the appropriate agent installer package. If not provided, the correct agent package will be auto-selected based on the running Windows PE environment (32 or 64 bit).\n  installdir:\n    (Optional) Agent installation directory. Default is \"%SystemDrive%\\Program Files\\Common Files\\Opsware\\agent\". The script  will append agent to  installdir if path does not end in agent.\nPrerequisites:\n - Target server runs a maintenance Windows PE OS.\n - Target answer file must be a valid Unattend answer file.",
                    "current": false
                },
                {
                    "versionLabel": "2",
                    "createdBy": "opsware",
                    "createdDate": "2015-08-04T07:30:20.000Z",
                    "usage": "This script integrates a Windows OS install with Server Automation.\nFeatures\n * Downloading the HP SA agent installer\n * Creating a script that will execute the HP SA Agent installer when the final OS first boots.\n * Copying the server's unique MID and cryptographic certificates into place\n * Setting up the agent installer to run at first boot\n\nUsage:  [--systemdrive H] [--platform Windows 2008 x64] [--unattend=\"path_to_unattend\"] [--installdir=\"path_to_install_agent\"]\n  systemdrive:\n    (Optional) The Windows drive letter where OS is installed.  The default is  \"C\".\n  unattend:\n    (Optional) Path to the unattend file.  By default the script looks for the usual X:\\Windows\\Temp\\Unattend.xml file.\n  platform:\n    (Optional) HP SA Platform name. Used to download the appropriate agent installer package. If not provided, the correct agent package will be auto-selected based on the running Windows PE environment (32 or 64 bit).\n  installdir:\n    (Optional) Agent installation directory. Default is \"%SystemDrive%\\Program Files\\Common Files\\Opsware\\agent\". The script  will append agent to  installdir if path does not end in agent.\nPrerequisites:\n - Target server runs a maintenance Windows PE OS.\n - Target answer file must be a valid Unattend answer file.",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-08-04T07:30:20.000Z",
            "version": {
                "versionLabel": "2",
                "createdBy": "opsware",
                "createdDate": "2015-08-04T07:30:20.000Z",
                "usage": "This script integrates a Windows OS install with Server Automation.\nFeatures\n * Downloading the HP SA agent installer\n * Creating a script that will execute the HP SA Agent installer when the final OS first boots.\n * Copying the server's unique MID and cryptographic certificates into place\n * Setting up the agent installer to run at first boot\n\nUsage:  [--systemdrive H] [--platform Windows 2008 x64] [--unattend=\"path_to_unattend\"] [--installdir=\"path_to_install_agent\"]\n  systemdrive:\n    (Optional) The Windows drive letter where OS is installed.  The default is  \"C\".\n  unattend:\n    (Optional) Path to the unattend file.  By default the script looks for the usual X:\\Windows\\Temp\\Unattend.xml file.\n  platform:\n    (Optional) HP SA Platform name. Used to download the appropriate agent installer package. If not provided, the correct agent package will be auto-selected based on the running Windows PE environment (32 or 64 bit).\n  installdir:\n    (Optional) Agent installation directory. Default is \"%SystemDrive%\\Program Files\\Common Files\\Opsware\\agent\". The script  will append agent to  installdir if path does not end in agent.\nPrerequisites:\n - Target server runs a maintenance Windows PE OS.\n - Target answer file must be a valid Unattend answer file.",
                "current": true
            },
            "source": "#!/usr/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n#\n\"\"\"\n    (C) Copyright 2009-2015 Hewlett-Packard Development Company, L.P.\n\n    Integrates the HP SA Agent into a Windows Install\n\n    This consists of:\n    * Copying the MID and crypto into place\n    * Downloading the agent installer binary\n    * Computing the correct opswgw_addr_list args for the agent installer\n    * Writing a wrapper .cmd that will install the agent\n    * 2008 & later: Update Unattend.xml\n\"\"\"\nimport glob\nimport optparse\nimport os\nimport re\nimport shutil\nimport string\nimport sys\nimport time\nimport random\n\nfrom osprov.osbp import ThisTargetServer\n\nDEFAULT_INSTAL_DIR = \"\\\\Program Files\\\\Common Files\\\\Opsware\"\nPRODUCTION_INSTALL_DRIVE = \"@SystemDrive:C@\"\nTMP_DIR = \"/Windows/Temp/agent\"\nMID_DIR = \"\"\nCRYPTO_DIR = \"\"\n\nWINPE_CRYPTO_DIR = \"X/Program Files/Common Files/Opsware/crypto/agent\"\nOGFS_MID = \"../../.id\"\n\nEC_USAGE = 1\nEC_INSTALLER_MISSING = 10\nEC_TARGET_DIR = 11\nEC_NO_UNATTEND = 12\nEC_EXCEPTION = 100\n\n\nclass LocalException(Exception):\n    pass\n\n\ndef setup_tmp(midDir=\"/etc/agent\", cryptoDir=\"/crypto/agent\"):\n    global TMP_DIR\n    global MID_DIR\n    global CRYPTO_DIR\n    TMP_DIR += \"_\" + str(random.randrange(100000, 999999, 1))\n    MID_DIR = TMP_DIR + midDir\n    CRYPTO_DIR = TMP_DIR + cryptoDir\n\n\ndef copy(src, dest):\n    \"\"\" Recursively copy files and folders and overwrite them \"\"\"\n    if os.path.isdir(src):\n        if not os.path.isdir(dest):\n            os.makedirs(dest)\n        files = os.listdir(src)\n        for f in files:\n            copy(os.path.join(src, f),\n                 os.path.join(dest, f))\n    else:\n        shutil.copyfile(src, dest)\n\n\ndef findSystemDrive(systemDrive):\n    \"\"\" Note that this will not work with multiple windows installs \"\"\"\n    if os.path.isdir(systemDrive + \"/Windows\") or os.path.exists(systemDrive + \"/boot.ini\"):\n        return systemDrive\n    # We want letters c-z. A and B are for floppy drives\n    driveLetters = list(string.letters[2:26].upper())\n    # X is for WinPE\n    driveLetters.remove(\"X\")\n    for driveLetter in driveLetters:\n        if os.path.isdir(driveLetter + \"/Windows\"):\n            return driveLetter\n    # Well, the default system drive is not there\n    # Nor is any other drive letter\n    # Just fall back to the default and let things proceed\n    return systemDrive\n\n\ndef findInstallerByPlatform(targetServer, platformName):\n    twistServer = targetServer.twistServer\n    if not platformName:\n        envVars = targetServer.rosh().getStdout([\"cmd.exe\", \"/c\", \"set\"])\n        # The windows agents are all the same on a given architecture,\n        # So if they are running 32 bit WinPE, just grab the Windows 2008 agent,\n        # Ditto for WinPE 64 bit\n        if re.search(\"^opswbasig=WINPE32\", envVars, re.M):\n            platformName = \"Windows 2008\"\n        elif re.search(\"^opswbasig=WINPE64\", envVars, re.M):\n            platformName = \"Windows 2012 x64\"\n    if not (platformName or platformName.strip()):\n        raise LocalException(\n            \"Platform could not be guessed based on the WinPE environment. You must provide a platform name as a command line argument to this script.\", EC_USAGE)\n    from pytwist.com.opsware.search import Filter\n    unitFilter = Filter()\n    unitFilter.setObjectType(\"software_unit\")\n    # Customer ID 15 is \"Opsware\"\n    unitFilter.setExpression('('\n                             '(PackageVO.fileName BEGINS_WITH opsware-agent-) & '\n                             '(UnitVO.unitType EQUAL_TO UNKNOWN) & '\n                             '(PackageVO.fileType EQUAL_TO UNKNOWN) & '\n                             '(software_customer_id EQUAL_TO 15) & '\n                             '(software_platform_name EQUAL_TO \"%s\"))' % platformName)\n    refs = twistServer.search.SearchService.findObjRefs(unitFilter)\n    vos = list(twistServer.pkg.UnknownPkgService.getUnknownPkgVOs(refs))\n    # Sort them and choose the one with the most recent (greatest) modified date\n    vos.sort(lambda x, y: cmp(x.getModifiedDate(), y.getModifiedDate()))\n    if vos:\n        return vos[-1]\n    else:\n        raise LocalException(\"Unable to find HP SA Agent Installer package for platform '%s'. Most likely your platform name is incorrect or misspelled.\" %\n                             platformName, EC_INSTALLER_MISSING)\n\n\ndef downloadInstaller(targetServer, pkgVO, systemDrive):\n    \"\"\"Stages the HP SA Agent Installer binary on the target system in a temporary location\"\"\"\n    tmpDir = systemDrive + TMP_DIR\n    if not os.path.exists(tmpDir):\n        try:\n            os.makedirs(tmpDir)\n        except OSError, info:\n            raise LocalException(\"Unable to create target directory '%s'. %s\" %\n                                 (tmpDir, str(info)), EC_TARGET_DIR)\n    pkgPath = systemDrive + \":\" + TMP_DIR.replace(\"/\", \"\\\\\") + \"\\\\\" + pkgVO.getFileName()\n    targetServer.downloadUnitToTarget(pkgVO.getRef().getId(), pkgPath)\n    print \"HP SA Agent installer binary downloaded to %s\" % pkgPath\n    return pkgVO.getFileName()\n\n\ndef copyMidCrypto(systemDrive):\n    \"\"\"Copies the essential identity files from the OGFS Agent to the agent installer tmp\n    This include the unique machine identifier (MID) and the device  specific crypto certificates\n    \"\"\"\n    try:\n        os.makedirs(systemDrive + MID_DIR)\n    except IOError, info:\n        raise LocalException(\n                \"Unable to create dir '%s'. %s\" % (systemDrive + MID_DIR, str(info)), EC_EXCEPTION)\n\n    try:\n        copy(OGFS_MID, systemDrive + MID_DIR + \"/mid\")\n    except IOError, info:\n        raise LocalException(\n                \"Unable to copy '%s' to '%s'. %s\" % (OGFS_MID, systemDrive + MID_DIR, str(info)), EC_EXCEPTION)\n    try:\n        os.makedirs(systemDrive + CRYPTO_DIR)\n    except IOError, info:\n        raise LocalException(\n                \"Unable to create dir '%s'. %s\" % (systemDrive + MID_DIR, str(info)), EC_EXCEPTION)\n    try:\n        copy(WINPE_CRYPTO_DIR, systemDrive + CRYPTO_DIR)\n    except IOError, info:\n        raise LocalException(\n                \"Unable to copy cryptographic material. It's probable that the agent files are already present in the WIM Image. %s\" % (str(info)), EC_EXCEPTION)\n    print \"This server's unique MID and crypto material successfully installed\"\n\n\ndef setup_agent_install_cmd(gwIpPort, logPath, pkgName, tmpPath, installPath):\n    installCmd = \"\"\"@echo off\nsetlocal\nsetlocal EnableDelayedExpansion\nset LOG=\"${logPath}\"\nmkdir /s ${installPath}\nif exist \"${tmpPath}\\\\${pkgName}\" (\n    echo Waiting for network interface to get an IP Address >> %LOG%\n    set tmpFile=%TEMP%\\ipconfig%RANDOM%\n    set retryCount=5\n    :RECHECK\n    ipconfig > !tmpFile!\n    find /i \"Autoconfiguration IPv4 Address\" !tmpFile! > NUL\n    if !ERRORLEVEL! == 1 goto IPOK\n    timeout /T 10\n    set /a retryCount=retryCount-1\n    if \"%retryCount%\" == \"0\" (\n        echo ERROR: No connected adapter was detected. We will run the HP SA Agent Installer anyway >> %LOG%\n        goto IPOK\n    )\n    echo No connected adapter was detected. Waiting 10 seconds. >> %LOG%\n    goto RECHECK\n    :IPOK\n    echo Copying files to agent install dir ${installPath} >> %LOG%\n    robocopy \"${tmpPath}\" \"${installPath}\" -e\n    echo Running HP SA Agent installer >> %LOG%\n    ipconfig >> %LOG%\n    \"${installPath}\\\\${pkgName}\" -s ${installArg} --settime --force_full_hw_reg --force_sw_reg --logfile \"${logPath}\" --opsw_gw_addr ${gwIpPort}\n    if !ERRORLEVEL! == 0 (\n        echo HP SA Agent installed successfully\n        echo HP SA Agent installed successfully >> %LOG%\n        echo Deleting temporary files >> %LOG%\n        del /q /f \"${tmpPath}\"\n        del /q /f \"${installPath}\\\\${pkgName}\"\n    ) else (\n        echo ERROR: HP SA Agent installer failed. Exit status !ERRORLEVEL!.\n        echo ERROR: HP SA Agent installer failed. Exit status !ERRORLEVEL!. >> %LOG%\n        exit /B !ERRORLEVEL!\n    )\n) else (\n    echo HP SA Agent Installer executable not found at ${tmpPath}\\\\${pkgName}\n    echo ERROR: HP SA Agent not installed\n    exit /B 5\n)\n\"\"\"\n    installCmd = installCmd.replace(\"\\n\", \"\\r\\n\")\n    template = string.Template(installCmd)\n    dataDict = {\"pkgName\": pkgName,\n                \"tmpPath\": tmpPath,\n                \"gwIpPort\": gwIpPort,\n                \"logPath\": logPath,\n                \"installPath\": installPath,\n                \"installArg\": '--installdir \"%s\"' % installPath if \"%SystemDrive%\" +  DEFAULT_INSTAL_DIR != installPath else \"\"\n                }\n    installCmd = template.safe_substitute(dataDict)\n    return installCmd\n\n\ndef get_agent_install_cmd(pkgName, installPath, targetServer):\n    global TMP_DIR\n    agwIpPort = targetServer.getRandomAgentGateway()\n    tmpPath = \"%SystemDrive%\" + TMP_DIR.replace(\"/\", \"\\\\\")\n    logPath = installPath + \"\\\\agent_install.log\"\n    return setup_agent_install_cmd(agwIpPort, logPath, pkgName, tmpPath, installPath)\n\n\ndef parseArgs(args):\n    \"\"\"\n    Parse the arguments.\n    \"\"\"\n    # setup and return parsed arguments\n    parser = optparse.OptionParser(\n        description=__doc__,\n        version=\"0.2.1\",\n        usage=\"%prog [Platform Name]\"\n    )\n    parser.set_defaults(systemdrive=\"@SystemDrive:C@\", platform=\"\", installdir=None)\n    parser.add_option(\"-s\", \"--systemdrive\", dest=\"systemdrive\", metavar=\"DRIVE_LETTER\",\n                      help=\"The Windows drive letter where OS is installed\")\n    parser.add_option(\"-i\", \"--installdir\", dest=\"installdir\", metavar=\"FILE_PATH\",\n                      help=\"Agent installation directory\")\n    parser.add_option(\"-u\", \"--unattend\", dest=\"unattend\", metavar=\"FILE_PATH\",\n                      help=\"Windows file system path to the Unattend.xml file to update\")\n    parser.add_option(\"-p\", \"--platform\", dest=\"platform\", metavar=\"PLATFORM_NAME\",\n                      help=\"HP SA Platform name. Used to download the appropriate agent installer package. If not provided, the correct agent package will be auto-selected based on the running Windows PE environment (32 or 64 bit).\")\n    return parser.parse_args(args)\n\n\nHPSA_CMD = \"hp_sa_agent_install.cmd\"\nHPSA_CMD_PATH = \"%SystemDrive%\\\\\" + HPSA_CMD\nHPSA_CMD_LAUNCHER = 'if exist \"%s\" ( \"%s\" )' % (HPSA_CMD_PATH, HPSA_CMD_PATH)\n\n\ndef updateSetupCompleteCmd(setup_complete_contents):\n    setup_complete_contents = setup_complete_contents.replace(HPSA_CMD_LAUNCHER, \"\")\n    setup_complete_contents = \"\\n\" + HPSA_CMD_LAUNCHER + \"\\n\" + setup_complete_contents\n    return setup_complete_contents\n\n\ndef main(argv=None):\n    if argv is None:\n        argv = sys.argv\n    opt, args = parseArgs(argv[1:])\n    opt.systemdrive = opt.systemdrive.upper()\n\n    targetServer = ThisTargetServer()\n    targetServer.setWorkDir(targetServer.getRemoteRoot())\n    twistServer = targetServer.twistServer\n\n\n    # This is the drive that the WinPE mapped, the production one might be different (for production we rely %SystemDrive%)\n    opt.systemdrive = findSystemDrive(opt.systemdrive)\n    if not opt.installdir:\n        opt.installdir = \"%SystemDrive%\" + DEFAULT_INSTAL_DIR\n        setup_tmp()\n    else:\n        opt.installdir = opt.installdir.rstrip(\"\\\\\")\n        if opt.installdir.split(\"\\\\\")[-1].lower() != \"agent\":\n            # append agent folder so that the installer is consistent\n            opt.installdir = opt.installdir.rstrip(\"\\\\\") + \"\\\\agent\"\n        setup_tmp(\"/etc\", \"/crypto\")\n    print \"Agent will be installed in: [%s] \" % opt.installdir\n    unattend_xml = opt.unattend or opt.systemdrive + \":\\\\Windows\\\\Panther\\\\unattend.xml\"\n\n    try:\n        copyMidCrypto(opt.systemdrive)\n        pkgName = downloadInstaller(\n            targetServer, findInstallerByPlatform(targetServer, opt.platform),\n            opt.systemdrive)\n\n        if os.path.exists(targetServer.pathToOGFS(unattend_xml)):\n            setup_complete_path = opt.systemdrive + \":\\\\Windows\\\\Setup\\\\Scripts\\\\SetupComplete.cmd\"\n            setup_complete_ogfs_path = targetServer.pathToOGFS(setup_complete_path)\n\n            if not os.path.exists(setup_complete_ogfs_path):\n                if not os.path.exists(os.path.dirname(setup_complete_ogfs_path)):\n                    os.makedirs(os.path.dirname(setup_complete_ogfs_path))\n                setup_complete_contents = HPSA_CMD_LAUNCHER\n            else:\n                # useful so we don't add up lines\n                print(\"Found existing SetupComplete.cmd, updating it...\")\n                setup_complete_contents = updateSetupCompleteCmd(\n                    open(setup_complete_ogfs_path, \"rb\").read())\n\n            targetServer.writeFile(opt.systemdrive + \":\\\\\" + HPSA_CMD,\n                                   get_agent_install_cmd(pkgName, opt.installdir, targetServer))\n            targetServer.writeFile(setup_complete_path, setup_complete_contents)\n    except LocalException, ex:\n        sys.stderr.write(ex.args[0] + \"\\n\")\n        return ex.args[1]\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n",
            "description": "This script integrates a Windows OS install with Server Automation.\nFeatures\n * Downloading the HP SA agent installer\n * Creating a script that will execute the HP SA Agent installer when the final OS first boots.\n * Copying the server's unique MID and cryptographic certificates into place\n * Setting up the agent installer to run at first boot\n\nUsage:  [--systemdrive H] [--platform Windows 2008 x64] [--unattend=\"path_to_unattend\"] [--installdir=\"path_to_install_agent\"]\n  systemdrive:\n    (Optional) The Windows drive letter where OS is installed.  The default is  \"C\".\n  unattend:\n    (Optional) Path to the unattend file.  By default the script looks for the usual X:\\Windows\\Temp\\Unattend.xml file.\n  platform:\n    (Optional) HP SA Platform name. Used to download the appropriate agent installer package. If not provided, the correct agent package will be auto-selected based on the running Windows PE environment (32 or 64 bit).\n  installdir:\n    (Optional) Agent installation directory. Default is \"%SystemDrive%\\Program Files\\Common Files\\Opsware\\agent\". The script  will append agent to  installdir if path does not end in agent.\nPrerequisites:\n - Target server runs a maintenance Windows PE OS.\n - Target answer file must be a valid Unattend answer file.",
            "status": null,
            "name": "Integrate HP SA Agent",
            "state": null,
            "eTag": "2015-08-04T07:30:20.000Z",
            "modified": "2015-08-04T07:30:20.000Z",
            "created": "2015-06-13T04:48:41.000Z",
            "category": "os-deployment-ogfs-scripts",
            "uri": "/rest/os-deployment-ogfs-scripts/360001"
        },
        {
            "codeType": "OGFS",
            "displayCodeType": "OGFS",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "1",
                    "createdBy": "opsware",
                    "createdDate": "2015-06-13T04:48:41.000Z",
                    "usage": "Monitors a given log file every DELAY seconds and timeouts after\nCOUNT checks in which the log has not changed.\n\nIf no log file is given it will monitor the installation log for the supported installers:\n- Red Hat, CentOS and OEL\n- SLES\n- Ubuntu\n- Solaris 10\n- Solaris 11 AI\n\nusage: monitor_install_log.py [options]\n\noptions:\n  -h, --help     show this help message and exit\n  --log=LOG      the log file that will be monitored\n  --count=COUNT  the number of times it counts before timing out\n  --delay=DELAY  the delay in seconds between every log check\n\nPrerequisites:\n  - Script needs to be run as part of a build plan.",
                    "current": false
                },
                {
                    "versionLabel": "2",
                    "createdBy": "opsware",
                    "createdDate": "2015-08-04T07:29:49.000Z",
                    "usage": "Monitors a given log file every DELAY seconds and timeouts after\nCOUNT checks in which the log has not changed.\n\nIf no log file is given it will monitor the installation log for the supported installers:\n- Red Hat, CentOS and OEL\n- SLES\n- Ubuntu\n- Solaris 10\n- Solaris 11 AI\n\nusage: monitor_install_log.py [options]\n\noptions:\n  -h, --help     show this help message and exit\n  --log=LOG      the log file that will be monitored\n  --count=COUNT  the number of times it counts before timing out\n  --delay=DELAY  the delay in seconds between every log check\n\nPrerequisites:\n  - Script needs to be run as part of a build plan.",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-08-04T07:29:49.000Z",
            "version": {
                "versionLabel": "2",
                "createdBy": "opsware",
                "createdDate": "2015-08-04T07:29:49.000Z",
                "usage": "Monitors a given log file every DELAY seconds and timeouts after\nCOUNT checks in which the log has not changed.\n\nIf no log file is given it will monitor the installation log for the supported installers:\n- Red Hat, CentOS and OEL\n- SLES\n- Ubuntu\n- Solaris 10\n- Solaris 11 AI\n\nusage: monitor_install_log.py [options]\n\noptions:\n  -h, --help     show this help message and exit\n  --log=LOG      the log file that will be monitored\n  --count=COUNT  the number of times it counts before timing out\n  --delay=DELAY  the delay in seconds between every log check\n\nPrerequisites:\n  - Script needs to be run as part of a build plan.",
                "current": true
            },
            "source": "#!/usr/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n#\n\"\"\"\n    (C) Copyright 2014-2015 Hewlett-Packard Development Company, L.P.\n\n    Monitors a given log file every DELAY seconds and timeouts after\n    COUNT checks in which the log has not changed.\n\n    If no log file is given it will monitor the installation log for the supported installers:\n    - Red Hat, CentOS and OEL\n    - SLES\n    - Ubuntu\n    - Solaris 10\n    - Solaris 11 AI\n\"\"\"\n\nimport os\nimport sys\nimport time\nfrom optparse import OptionError\nfrom StringIO import StringIO\n\nfrom librunplan import PlanOutputHandler\n\nfrom osprov import platform_util\nfrom osprov.decorators import HandleShowErrorMessage\nfrom osprov.errors import ShowErrorMessage, TimeoutError, NotSupportedError, ProcessExecutionError\nfrom osprov.optparse_ext import OptionParser\nfrom osprov.osbp import ThisTargetServer, logger\nfrom osprov.osbp.constants import MONITORING_STOP_FLAG\n\n# waits CHECK_DELAY * TIMEOUT_COUNT, 10 minutes by default\n\nCHECK_DELAY = 6  # seconds\nTIMEOUT_COUNT = 100\n\nLOG = logger.getIt(\"Monitor Installation\")\n\n\nclass MonitorStepOptionsParser(OptionParser):\n\n    \"\"\" An options' parser for this step. \"\"\"\n\n    def defineOptions(self):\n        self.add_option(\"--log\", help=\"the log file that will be monitored\")\n        self.add_option(\"--count\", default=TIMEOUT_COUNT, type=int,\n                        help=\"the number of times it counts before timing out\")\n        self.add_option(\"--delay\", default=CHECK_DELAY, type=float,\n                        help=\"the delay in seconds between every log check\")\n\n    def validateArgs(self, opt, args):\n        if opt.count and opt.count < 0:\n            raise OptionError(\"not a positive number\", \"count\")\n        if opt.delay and opt.delay < 0:\n            raise OptionError(\"not a positive number\", \"delay\")\n\n\nclass LogMonitor (object):\n\n    \"\"\" Monitors logs until one of the stop files is encountered or times out. \"\"\"\n\n    def __init__(self, targetServer, logPath, stopFilePaths=(MONITORING_STOP_FLAG,), output=PlanOutputHandler()):\n        self.targetServer = targetServer\n        self.output = output\n        self.logPath = self.targetServer.pathToOGFS(logPath)\n        self.stopFilePaths = [self.targetServer.pathToOGFS(path) for path in stopFilePaths]\n        self.lastLine = None\n        self.checkDelaySeconds = 6\n        self.defaultTimeoutCount = 100\n        self.timeoutCount = self.defaultTimeoutCount\n        self.numberOfReportedLines = 50\n        self._cachedLastLines = []\n        self.installFailedUserMessage = \"\"\n\n    def waitForLogFile(self):\n        \"\"\"Waits self.checkDelay * self.timeoutCount for self.logPath to appear.\"\"\"\n        failedCheckCount = 0\n        while failedCheckCount < self.timeoutCount:\n            if os.path.exists(self.logPath):\n                return\n            else:\n                failedCheckCount += 1\n            time.sleep(self.checkDelaySeconds)\n        else:\n            raise ShowErrorMessage(\"The install log %s did not appear.\" % self.logPath)\n\n    def _generateLog(self):\n        raise NotImplementedError(\"abstract\")\n\n    def _openLog(self, canGenerate=True):\n        \"\"\" Returns a file object to self.logPath. \"\"\"\n        return open(self.logPath, \"rb\")\n\n    def getLastLines(self, count, canGenerate=True):\n        \"\"\"Returns the last lineNo lines of supplied file object.\"\"\"\n        try:\n            self._cachedLastLines = self._openLog(canGenerate=canGenerate).readlines()[-count:]\n            return self._cachedLastLines\n        except IOError, error:\n            LOG.error(\"Failed to read the log file\")\n            LOG.exception(error)\n            self._cachedLastLines = []\n            return []\n\n    def getLatestLines(self):\n        \"\"\" Returns the latest lines from the log file.\"\"\"\n        lastLines = self.getLastLines(self.numberOfReportedLines)\n        if not lastLines:\n            return []\n        if self.lastLine is None:\n            self.lastLine = lastLines[-1]\n            return lastLines\n        else:\n            curLastLine = lastLines[-1]\n            if curLastLine == self.lastLine:\n                return []\n            else:\n                self.lastLine = curLastLine\n                return lastLines\n\n    def isInstallDone(self):\n        \"\"\" Returns True if the installation has finished. \"\"\"\n        for path in self.stopFilePaths:\n            if os.path.exists(path):\n                return True\n        else:\n            return False\n\n    def isInstallFailed(self):\n        \"\"\"\n        Returns True if the installation is known to have failed.\n        To be implemented by subclasses if needed.\n        \"\"\"\n\n        return False\n\n    def adjustTimeout(self):\n        \"\"\"Hook for dynamically adjusting the timeout. Gets called at each iteration. \"\"\"\n\n        pass\n\n    def main(self):\n        \"\"\" Main monitoring function \"\"\"\n        print(\"Monitoring %s log file\" % self.logPath)\n\n        print(\"Waiting for %s to appear\" % self.logPath)\n        self.waitForLogFile()\n        print(\"Found the log file\")\n\n        failedCheckCount = 0\n        while failedCheckCount < self.timeoutCount and not self.isInstallDone() and not self.isInstallFailed():\n            lastLines = self.getLatestLines()\n            if lastLines:\n                failedCheckCount = 0\n                self.output.replaceMessages(\"Monitoring Installation\", \"\".join(lastLines))\n            else:\n                failedCheckCount += 1\n            self.adjustTimeout()\n            time.sleep(self.checkDelaySeconds)\n        else:\n            print(\"Here are the last %d lines of the log:\" % self.numberOfReportedLines)\n            print(\"\".join(self.getLastLines(self.numberOfReportedLines, canGenerate=False)))\n            if self.isInstallDone():\n                print(\"Installation completed.\")\n                return 0\n            elif self.isInstallFailed():\n                raise ShowErrorMessage(\n                    \"The installation failed: %s\" % self.installFailedUserMessage)\n            else:\n                raise TimeoutError(\"Monitoring the log file timed out.\")\n\n\nclass RPMBasedInstallerLogMonitor(LogMonitor):\n\n    def __init__(self, targetServer, logPath, stopFilePaths=(MONITORING_STOP_FLAG,), output=PlanOutputHandler(), rpmArguments=\"\"):\n        LogMonitor.__init__(self, targetServer, logPath, stopFilePaths, output)\n        self._rpmArguments = rpmArguments\n\n    def _openLog(self, canGenerate=True):\n        if canGenerate:\n            generatedLog = self._generateLog()\n            if generatedLog.strip():\n                return StringIO(generatedLog)\n        return open(self.logPath, \"rb\")\n\n    def _generateLog(self):\n        try:\n            return self.targetServer.rosh().getStdout(\n                \"\\\"rpm {rpmArguments} -qa --queryformat '{queryFormat}' | sort -n | tail -n 50 \\\"\".format(\n                    rpmArguments=self._rpmArguments,\n                    queryFormat=\"(%{installtime:date}) Installed rpm: %{name}\\n\"\n                ),\n            )\n        except ProcessExecutionError, e:\n            LOG.exception(e)\n            return \"\"\n\n\nclass Rhel5InstallationLogMonitor(LogMonitor):\n\n    def __init__(self, targetServer):\n        LogMonitor.__init__(\n            self, targetServer,\n            logPath=\"/tmp/anaconda.log\",\n            stopFilePaths=(\n                os.path.join(\"/mnt/sysimage/tmp\", os.path.basename(MONITORING_STOP_FLAG)),\n                MONITORING_STOP_FLAG\n            )\n        )\n\n\nclass Rhel6InstallationLogMonitor(RPMBasedInstallerLogMonitor):\n\n    def __init__(self, targetServer):\n        RPMBasedInstallerLogMonitor.__init__(\n            self, targetServer,\n            logPath=\"/tmp/anaconda.log\",\n            stopFilePaths=(\n                os.path.join(\"/mnt/sysimage/tmp\", os.path.basename(MONITORING_STOP_FLAG)),\n                MONITORING_STOP_FLAG\n            )\n        )\n\n\nclass Rhel7InstallationLogMonitor(LogMonitor):\n\n    def __init__(self, targetServer):\n        LogMonitor.__init__(\n            self, targetServer,\n            logPath=\"/tmp/packaging.log\",\n            stopFilePaths=(\n                os.path.join(\"/mnt/sysimage/tmp\", os.path.basename(MONITORING_STOP_FLAG)),\n                MONITORING_STOP_FLAG,\n            )\n        )\n\n\nclass SlesInstallationLogMonitor(RPMBasedInstallerLogMonitor):\n    def __init__(self, targetServer):\n        RPMBasedInstallerLogMonitor.__init__(\n            self, targetServer,\n            logPath=\"/var/log/YaST2/y2log\",\n            stopFilePaths=(\n                os.path.join(\"/mnt/tmp\", os.path.basename(MONITORING_STOP_FLAG)),\n                MONITORING_STOP_FLAG\n            ),\n            rpmArguments=\"--dbpath /mnt/var/lib/rpm\"\n        )\n\n\nclass UbuntuInstallationLogMonitor(LogMonitor):\n\n    def __init__(self, targetServer):\n        LogMonitor.__init__(self, targetServer, \"/var/log/syslog\")\n\n\nclass Solaris11InstallationMonitor(LogMonitor):\n\n    def __init__(self, targetServer):\n        LogMonitor.__init__(self, targetServer, \"/system/volatile/install_log\")\n        self.installDoneMessage = \"automated installation succeeded\"\n        self.installFailedMessage = \"automated installation failed\"\n        self.installFailedUserMessage = \"The install log reported failure.\"\n        self._installPhaseStartedMessage = \"install phase ... started\"\n        self._installPhaseDoneMessage = \"install phase ... done\"\n\n    def isInstallDone(self):\n        \"\"\" Returns True if the installation has finished. \"\"\"\n        return self.installDoneMessage in \"\\n\".join(self._cachedLastLines).lower()\n\n    def isInstallFailed(self):\n        \"\"\"Return True if the install log contains a failure message.\"\"\"\n        return self.installFailedMessage in \"\\n\".join(self._cachedLastLines).lower()\n\n    def adjustTimeout(self):\n        \"\"\"Sets a larger timeout after the 'Install Phase ... Started' message is detected in the log.\"\"\"\n        if self._installPhaseStartedMessage in \"\\n\".join(self._cachedLastLines).lower():\n            self.timeoutCount = 600\n        if self._installPhaseDoneMessage in \"\\n\".join(self._cachedLastLines).lower():\n            self.timeoutCount = self.defaultTimeoutCount\n\n\nclass Solaris10InstallationMonitor(LogMonitor):\n\n    def __init__(self, targetServer):\n        LogMonitor.__init__(self, targetServer, \"/a/var/sadm/system/logs/install_log\")\n        self.installFailedMessage = \"installation: failed\"\n        self.installFailedUserMessage = \"The install log reported failure.\"\n\n    def isInstallFailed(self):\n        \"\"\"Return True if the install log contains a failure message.\"\"\"\n        return self.installFailedMessage in \"\\n\".join(self._cachedLastLines).lower()\n\n\ndef factorLogMonitor(targetServer):\n    \"\"\" Return a LogMonitor based on the reported OS version\"\"\"\n    osVersion = targetServer.getServerVO().getOsVersion().lower()\n    if platform_util.isSLES(osVersion):\n        return SlesInstallationLogMonitor(targetServer)\n    elif platform_util.isRHELCompatible(osVersion, version=5):\n        return Rhel5InstallationLogMonitor(targetServer)\n    elif platform_util.isRHELCompatible(osVersion, version=6):\n        return Rhel6InstallationLogMonitor(targetServer)\n    elif platform_util.isRHELCompatible(osVersion, version=7):\n        return Rhel7InstallationLogMonitor(targetServer)\n    elif platform_util.isUbuntu(osVersion):\n        return UbuntuInstallationLogMonitor(targetServer)\n    elif platform_util.isSolaris(osVersion, version=11):\n        return Solaris11InstallationMonitor(targetServer)\n    elif platform_util.isSolaris(osVersion, version=10):\n        return Solaris10InstallationMonitor(targetServer)\n    raise NotSupportedError(\"Monitoring installation for %s is not supported\" % osVersion)\n\n\n@HandleShowErrorMessage(\"monitor installation\", LOG)\ndef main():\n    options, remainingArgs = MonitorStepOptionsParser().parse_args()\n\n    targetServer = ThisTargetServer()\n\n    logFile = options.log\n    if not logFile:\n        logMonitor = factorLogMonitor(targetServer)\n    else:\n        logMonitor = LogMonitor(targetServer, logFile)\n    logMonitor.checkDelaySeconds = options.delay\n    logMonitor.timeoutCount = options.count\n\n    return logMonitor.main()\n\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n",
            "description": "Monitors a given log file every DELAY seconds and timeouts after\nCOUNT checks in which the log has not changed.\n\nIf no log file is given it will monitor the installation log for the supported installers:\n- Red Hat, CentOS and OEL\n- SLES\n- Ubuntu\n- Solaris 10\n- Solaris 11 AI\n\nusage: monitor_install_log.py [options]\n\noptions:\n  -h, --help     show this help message and exit\n  --log=LOG      the log file that will be monitored\n  --count=COUNT  the number of times it counts before timing out\n  --delay=DELAY  the delay in seconds between every log check\n\nPrerequisites:\n  - Script needs to be run as part of a build plan.",
            "status": null,
            "name": "Monitor Installation",
            "state": null,
            "eTag": "2015-08-04T07:29:49.000Z",
            "modified": "2015-08-04T07:29:49.000Z",
            "created": "2015-06-13T04:48:41.000Z",
            "category": "os-deployment-ogfs-scripts",
            "uri": "/rest/os-deployment-ogfs-scripts/370001"
        },
        {
            "codeType": "OGFS",
            "displayCodeType": "OGFS",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "1",
                    "createdBy": "opsware",
                    "createdDate": "2015-06-13T04:48:42.000Z",
                    "usage": "Triggers the SuSE AutoYaST installation to continue after it was stalled for\nHP SA Agent injection or other tasks before the reboot into the 2nd phase of the \nSuSE AutoYaST installation process.\n\nUsage:\n\tcomplete_ay_installation_phase.py - no parameters -",
                    "current": false
                },
                {
                    "versionLabel": "2",
                    "createdBy": "opsware",
                    "createdDate": "2015-08-04T07:30:27.000Z",
                    "usage": "Triggers the SuSE AutoYaST installation to continue after it was stalled for\nHP SA Agent injection or other tasks before the reboot into the 2nd phase of the \nSuSE AutoYaST installation process.\n\nUsage:\n\tcomplete_ay_installation_phase.py - no parameters -",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-08-04T07:30:27.000Z",
            "version": {
                "versionLabel": "2",
                "createdBy": "opsware",
                "createdDate": "2015-08-04T07:30:27.000Z",
                "usage": "Triggers the SuSE AutoYaST installation to continue after it was stalled for\nHP SA Agent injection or other tasks before the reboot into the 2nd phase of the \nSuSE AutoYaST installation process.\n\nUsage:\n\tcomplete_ay_installation_phase.py - no parameters -",
                "current": true
            },
            "source": "#!/usr/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n\"\"\"\n    (C) Copyright 2009-2015 Hewlett-Packard Development Company, L.P.\n\n    Inject required options and move the file onto the boot\n    partition.\n\"\"\"\n\nimport sys\nimport os\n\nfrom osprov.osbp import ThisTargetServer, logger\nfrom osprov.errors import ShowErrorMessage, ProcessExecutionError\n\nBASE_AY_CONT_FILE = \"tmp/continue_hook.log\"\nLOG = logger.getIt(\"complete_ay_installation_phase\")\n\n\ndef rootPartition():\n    \"\"\" Get the root partition  \"\"\"\n    # fixed as this is for SLES / AutoYaST only for now\n    return \"/mnt\"\n\n\ndef main(argv=sys.argv, stdin=sys.stdin,\n         stdout=sys.stdout, stderr=sys.stderr):\n    \"\"\" trigger completion of AutoYaST phase 1\"\"\"\n    sys.stdin = stdin\n    sys.stdout = stdout\n    sys.stderr = stderr\n\n    # let the AutoYaST continue...\n    try:\n        targetServer = ThisTargetServer()\n        contfilename = os.path.join(rootPartition(), BASE_AY_CONT_FILE)\n        targetServer.rosh(overall_timeout=10).getStdoutStderr(\"touch \\\"%s\\\"\" % contfilename)\n        print (\"Successfully triggered completion of AutoYaST phase 1\")\n    except (IOError, OSError, ShowErrorMessage), why:\n        LOG.exception(why)\n        sys.stderr.write(\n            \"Failed to trigger completion of AutoYaST phase 1. %s\\n\" % why)\n        sys.exit(1)\n\nif __name__ == \"__main__\":\n    main()\n",
            "description": "Triggers the SuSE AutoYaST installation to continue after it was stalled for\nHP SA Agent injection or other tasks before the reboot into the 2nd phase of the \nSuSE AutoYaST installation process.\n\nUsage:\n\tcomplete_ay_installation_phase.py - no parameters -",
            "status": null,
            "name": "Continue SuSE AutoYaST Installation",
            "state": null,
            "eTag": "2015-08-04T07:30:27.000Z",
            "modified": "2015-08-04T07:30:27.000Z",
            "created": "2015-06-13T04:48:42.000Z",
            "category": "os-deployment-ogfs-scripts",
            "uri": "/rest/os-deployment-ogfs-scripts/380001"
        },
        {
            "codeType": "OGFS",
            "displayCodeType": "OGFS",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "1",
                    "createdBy": "opsware",
                    "createdDate": "2015-06-13T04:48:42.000Z",
                    "usage": "Installs the ESXi installation build image onto a stub partition on the target server.\n\nthis is a composite step consisting of the following:\n\n1. Run: Create Stub Partition\n2. Run: Copy Boot Media\n3. Deploy: ESXi Installation Utilities\n4. Run: Install bootloader for ESXi 4.1\n5. Run: Copy Installation Profile\n\n\nThis script does not reboot the target server, but when this script completes, \nthe target server may be rebooted and the ESXi scripted install will occur.\n\nUsage:\n\nThis script expects no command line arguments",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-06-13T04:48:42.000Z",
            "version": {
                "versionLabel": "1",
                "createdBy": "opsware",
                "createdDate": "2015-06-13T04:48:42.000Z",
                "usage": "Installs the ESXi installation build image onto a stub partition on the target server.\n\nthis is a composite step consisting of the following:\n\n1. Run: Create Stub Partition\n2. Run: Copy Boot Media\n3. Deploy: ESXi Installation Utilities\n4. Run: Install bootloader for ESXi 4.1\n5. Run: Copy Installation Profile\n\n\nThis script does not reboot the target server, but when this script completes, \nthe target server may be rebooted and the ESXi scripted install will occur.\n\nUsage:\n\nThis script expects no command line arguments",
                "current": true
            },
            "source": "#!/usr/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n\"\"\" (c) Copyright 2009 Hewlett-Packard Development Company, L.P.\n   bundle together all the steps into a single install boot image step\n\"\"\"\n\nimport os\nimport sys\n\nfrom pytwist.com.opsware.common import NotFoundException\nfrom pytwist.com.opsware.osprov import RunScriptPlanStep\nfrom pytwist.com.opsware.osprov import InstallZIPPlanStep\nfrom pytwist.com.opsware.script import ServerScriptRef\nfrom pytwist.com.opsware.script import OGFSScriptRef\n\nfrom librunplan import PlanRunner\nfrom librunplan import PlanOutputHandler\n\nfrom osprov import sa\nfrom osprov.osbp import ThisTargetServer\nfrom osprov.osbp import logger\nfrom osprov.errors import ShowErrorMessage\n\nSteps = (('Linux/Create Stub Partition', None), ('Linux/Copy Boot Media', None), ('Linux/ESXi Installation Utilities', '/tmp'), ('Deploy Agent', '-d /opt/hpsa_agent/ogfs-agent.zip -p \"Red Hat Enterprise Linux Server 5 X86_64\" -u'), ('Linux/Add ESXi Module', '-s /opt/hpsa_agent  -d'), ('Linux/Add ESXi Module', '-s /tmp/user.ks.cfg -a ks.cfg'), ('Linux/Install bootloader for ESXi', '--kernel_arguments=\"@kernel_arguments@\"'))\n\n\ndef main(argv=sys.argv, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr):\n    sys.stdin = stdin\n    sys.stderr = stderr\n    sys.stdout = stdout\n    Twist = sa.getTwistServer()\n    Target = ThisTargetServer(twistServer=Twist)\n    runnerOH = PlanOutputHandler(stdout, stderr, logger.getIt(\"Composite step\"))\n    runnerOH.NO_APX_PROGRESS = True  # don't break the papx reporting\n    runnerOH.ADV_STEP_MSG = None  # don't update the main message\n    runnerOH.ADV_STEP_MSG_LONG = \"\\nSub Step: %(action)s '%(name)s'\"\n    runnerOH.ERR_HEADER = \"\\nErrors from sub step %(current)d '%(name)s':\\n\"\n    Runner = PlanRunner(None, targetServer=Target, outputHandler=runnerOH)\n    for scriptPath, parameters in Steps:\n        scriptElems = [x for x in scriptPath.split(\"/\") if x]\n        try:\n            stepRef = Twist.folder.FolderService.getFNode(\n                [\"Opsware\", \"Tools\", \"OS Provisioning\", \"OS Build Plan Steps\"] +\n                scriptElems)\n            if isinstance(stepRef, ServerScriptRef) or isinstance(stepRef, OGFSScriptRef):\n                step = RunScriptPlanStep()\n                step.setScript(stepRef)\n                step.setParameters(parameters)\n            else:\n                step = InstallZIPPlanStep()\n                step.setZip(stepRef)\n                step.setInstallPath(parameters)\n            Runner.doStep(step, stepNo=int(os.environ[\"CURRENT_STEP_NO\"]))\n        except (NotFoundException), why:\n            runnerOH.exception(\"Error : sub step '%s' not found! %s\" %\n                              (scriptPath, why), why)\n            sys.exit(101)\n        except ShowErrorMessage, why:\n            runnerOH.exception(\"Sub Step '%s' failed: %s\" % (scriptPath, why[0]), why)\n            sys.exit(100)\n\nif __name__ == \"__main__\":\n    main()\n",
            "description": "Installs the ESXi installation build image onto a stub partition on the target server.\n\nthis is a composite step consisting of the following:\n\n1. Run: Create Stub Partition\n2. Run: Copy Boot Media\n3. Deploy: ESXi Installation Utilities\n4. Run: Install bootloader for ESXi 4.1\n5. Run: Copy Installation Profile\n\n\nThis script does not reboot the target server, but when this script completes, \nthe target server may be rebooted and the ESXi scripted install will occur.\n\nUsage:\n\nThis script expects no command line arguments",
            "status": null,
            "name": "Install And Configure ESXi Build Image",
            "state": null,
            "eTag": "2015-06-13T04:48:42.000Z",
            "modified": "2015-06-13T04:48:42.000Z",
            "created": "2015-06-13T04:48:42.000Z",
            "category": "os-deployment-ogfs-scripts",
            "uri": "/rest/os-deployment-ogfs-scripts/390001"
        },
        {
            "codeType": "OGFS",
            "displayCodeType": "OGFS",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "1",
                    "createdBy": "opsware",
                    "createdDate": "2015-06-13T04:48:42.000Z",
                    "usage": "Waits for the HP SA Agent to register / come back online. Used to wait for the agent to become available again \neg. after a reboot of the target \n\nIt is recommended to add this step at the beginning of each newly created\nbuild plan with the --maintenance argument to wait for the maintenance agent\nbefore running the build plan. This  discovers any problems with the communication\nto the agent early.\n\nusage: wait_for_agent.py [options]\n\noptions:\n  -h, --help                    show this help message and exit\n  --ogfs, --maintenance         indicates we are expecting a maintenance (ogfs) agent\n  --production                  indicates we are expecting a production agent\n  --atLeast=MINUTES             the number of minutes to wait before actively checking\n                                for the agent; if not specified an optimized strategy is used\n  --atMost=MINUTES              the maximum number of minutes to wait for the agent to\n                                come back online; default value: 15 minute(s)\n  --reportingAtLeast=MINUES     Number of minutes to wait for the agent to constantly report",
                    "current": false
                },
                {
                    "versionLabel": "2",
                    "createdBy": "opsware",
                    "createdDate": "2015-08-04T07:30:23.000Z",
                    "usage": "Waits for the HP SA Agent to register / come back online. Used to wait for the agent to become available again \neg. after a reboot of the target \n\nIt is recommended to add this step at the beginning of each newly created\nbuild plan with the --maintenance argument to wait for the maintenance agent\nbefore running the build plan. This  discovers any problems with the communication\nto the agent early.\n\nusage: wait_for_agent.py [options]\n\noptions:\n  -h, --help                    show this help message and exit\n  --ogfs, --maintenance         indicates we are expecting a maintenance (ogfs) agent\n  --production                  indicates we are expecting a production agent\n  --atLeast=MINUTES             the number of minutes to wait before actively checking\n                                for the agent; if not specified an optimized strategy is used\n  --atMost=MINUTES              the maximum number of minutes to wait for the agent to\n                                come back online; default value: 15 minute(s)\n  --reportingAtLeast=MINUES     Number of minutes to wait for the agent to constantly report",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-08-04T07:30:23.000Z",
            "version": {
                "versionLabel": "2",
                "createdBy": "opsware",
                "createdDate": "2015-08-04T07:30:23.000Z",
                "usage": "Waits for the HP SA Agent to register / come back online. Used to wait for the agent to become available again \neg. after a reboot of the target \n\nIt is recommended to add this step at the beginning of each newly created\nbuild plan with the --maintenance argument to wait for the maintenance agent\nbefore running the build plan. This  discovers any problems with the communication\nto the agent early.\n\nusage: wait_for_agent.py [options]\n\noptions:\n  -h, --help                    show this help message and exit\n  --ogfs, --maintenance         indicates we are expecting a maintenance (ogfs) agent\n  --production                  indicates we are expecting a production agent\n  --atLeast=MINUTES             the number of minutes to wait before actively checking\n                                for the agent; if not specified an optimized strategy is used\n  --atMost=MINUTES              the maximum number of minutes to wait for the agent to\n                                come back online; default value: 15 minute(s)\n  --reportingAtLeast=MINUES     Number of minutes to wait for the agent to constantly report",
                "current": true
            },
            "source": "#!/usr/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# lint_ignore=E501,I0011,C0301,E501\n# pylint: disable=C0301\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n\"\"\"\n    (C) Copyright 2013-2015 Hewlett-Packard Development Company, L.P.\n\"\"\"\n\nWAIT_AT_MOST = 15\n\nDEFAULT_WAIT_TIME_SHORT = 5\nDEFAULT_WAIT_TIME_LONG = 20\n# The first and last x seconds are called hot edges because we check more often during those periods\nHOT_EDGE_DURATION = 3 * 60\n\nimport sys\nimport time\n\nsys.path.append(\"/opsw/apx/runtime/script/osprov.run_os_build_plan_papx/\")\nsys.path.append(\"/opt/opsware/pylibs2/\")\n\nfrom osprov import boot\nfrom osprov.util import NullLog\nfrom osprov.server.sa import State\nfrom osprov.osbp import ThisTargetServer, logger\nfrom osprov.decorators import HandleShowErrorMessage\nfrom osprov.errors import ShowErrorMessage, NotSupportedError\nfrom osprov.optparse_ext import OptionParser, OptionValueError\n\nLOG = logger.getIt(\"wait_for_agent\")\n\n\nclass ServerValidationError(ShowErrorMessage):\n    \"\"\" Raised locally when server is not yet in a good state \"\"\"\n    pass\n\n\nclass WaitSomeMore(ShowErrorMessage):\n    \"\"\" Raised locally to show that the server is good, but we need to wait some more \"\"\"\n\n\nclass WaitForAgentParser(OptionParser):\n    \"\"\" Parse the arguments of the step\"\"\"\n\n    def defineOptions(self):\n\n        self.add_option(\"--ogfs\", \"--maintenance\",\n                        action=\"store_true\", dest=\"expectMaintenance\",\n                        help=\"indicates we are expecting a maintenance (ogfs) agent\")\n        self.add_option(\"--production\",\n                        action=\"store_false\", dest=\"expectMaintenance\",\n                        help=\"indicates we are expecting a production agent\")\n        self.add_option(\"--atLeast\",\n                        type=\"int\", metavar=\"MINUTES\", default=None,\n                        help=\"the number of minutes to wait before actively checking \\\n                    for the agent; if not specified an optimized strategy is used\")\n        self.add_option(\"--atMost\",\n                        type=\"int\", metavar=\"MINUTES\", default=WAIT_AT_MOST,\n                        help=\"the maximum number of minutes to wait for the agent to \\\n                    come back online; default value: %default minute(s)\")\n        self.add_option(\"--reportingAtLeast\",\n                        type=\"int\", metavar=\"MINUTES\", default=None,\n                        help=\"the number of minutes the agent must continuously be reporting\")\n        # deprecated, left here for backwards compatibility\n        self.add_option(\"--ignoreServiceOS\",\n                        default=False, action=\"store_true\", dest=\"ignoreServiceOS\",\n                        help=\"(DEPRECATED) disables a check for the correct Service OS\")\n\n    def validateArgs(self, options, remainingArgs):\n        # cannot call super because OptionParser is not a new-style class\n        OptionParser.validateArgs(self, options, remainingArgs)\n        if options.atLeast is not None:\n            if options.atLeast < 1:\n                raise OptionValueError(\"atLeast cannot be less than 1 (minute)\")\n            if options.atLeast >= options.atMost:\n                raise OptionValueError(\"atLeast must be smaller than atMost (%d and %d)\" %\n                                      (options.atLeast, options.atMost))\n        if options.atMost < 1:\n            raise OptionValueError(\"atMost cannot be less than 1 (minute)\")\n\n        if options.reportingAtLeast is not None:\n            if options.reportingAtLeast < 1:\n                raise OptionValueError(\"reportingAtLeast cannot be less than 1 (minute)\")\n        if options.reportingAtLeast:\n            options.reportingAtLeast *= 60\n        if options.atLeast:\n            options.atLeast *= 60\n        options.atMost *= 60\n\n\nclass AgentWaiter(object):\n    \"\"\"Wait for the agent to become available in the desired mode (maintenance or production)\"\"\"\n\n    def __init__(self, options, log=NullLog()):\n\n        self.options = options\n        self.waitTime = DEFAULT_WAIT_TIME_SHORT\n        self.log = log\n        self.targetServer = None\n        self.startTime = None\n        self.deadLine = None\n        self.reportingStartTime = None\n\n    def wait(self):\n        \"\"\"Sleep for the required amount of time, based on internal state.\"\"\"\n        self.log.debug(\"Will sleep for %d seconds, been waiting for %s seconds\", self.waitTime, time.time() - self.startTime)\n        time.sleep(self.waitTime)\n\n    def setTiming(self):\n        \"\"\"Set timing rules for regular wait.\"\"\"\n        if self.targetServer.isAgentListening():\n            self.waitTime = DEFAULT_WAIT_TIME_SHORT\n        else:\n            waitingFor = time.time() - self.startTime\n            timeToDeadline = self.deadLine - time.time()\n            if waitingFor <= HOT_EDGE_DURATION or timeToDeadline <= HOT_EDGE_DURATION:\n                self.waitTime = DEFAULT_WAIT_TIME_SHORT\n            else:\n                self.waitTime = DEFAULT_WAIT_TIME_LONG\n\n    def renewTargetServer(self):\n        \"\"\"Renew self.targetServer if present, or create new instance if not.\"\"\"\n        if self.targetServer is None:\n            self.targetServer = ThisTargetServer()\n        else:\n            self.targetServer = self.targetServer.renew()\n        self.log.debug(\"Renewed target server is: %s\", self.targetServer)\n\n    def recoverUnreachable(self):\n        \"\"\"Update the TargetServer state when we know better.\"\"\"\n        if self.targetServer.serverVO.state != State.UNREACHABLE:\n            self.log.debug(\"Server is %s, not unreachable, no need to recover it\", self.targetServer.serverVO.state)\n            return\n        if not self.targetServer.isProduction():\n            # if no agent service was found (not production) we must be in maintenance\n            targetState = State.MAINTENANCE\n        elif not self.targetServer.isAgentless():\n            # Only recover to OK if the server is managed\n            targetState = State.OK\n        else:\n            return\n        self.log.debug(\"Recovering server from UNREACHABLE state\")\n        try:\n            self.targetServer.updateState(state=targetState)\n        except:  # pylint: disable=W0702\n            # just except, pytwist doesn't raise proper error QC: 143883\n            self.log.exception(\"Failed to update device state\")\n            raise NotSupportedError(\"Failed to update server state\")\n\n    def validateServerState(self):\n        \"\"\"Verify that the server is in the required state when the agent is accessible.\"\"\"\n        self.renewTargetServer()\n        if self.options.expectMaintenance:\n            if not self.targetServer.isMaintenance():\n                raise ServerValidationError(\n                    \"The target server did not start in MAINTENANCE but was expected to.\"\n                )\n        else:\n            if self.targetServer.isAgentless() or self.targetServer.isMaintenance():\n                # the ogfs agent is \"agentless\" because there is no management path\n                raise ServerValidationError(\n                    \"The target server is in MAINTENANCE but was not expected to.\"\n                )\n\n    def validateReportingAtLeast(self):\n        if not self.options.reportingAtLeast:\n            return\n        now = time.time()\n        if not self.reportingStartTime:\n            self.reportingStartTime = now\n        reportingPeriod = now - self.reportingStartTime\n        if reportingPeriod < self.options.reportingAtLeast:\n            raise WaitSomeMore(\n                \"The target server was not reporting correctly for at least %s minutes, only %s.\" % (\n                    int(self.options.reportingAtLeast / 60), int(reportingPeriod / 60)\n                )\n            )\n\n    def validateAgentAccessible(self):\n        if not self.targetServer.isAgentListening():\n            raise ServerValidationError(\"The agent did not appear on the network (is not listening on its port).\")\n        if not self.targetServer.isAccessible():\n            # isAccessible instead of hasRosh access, because for some target servers\n            # this will just yield no\n            raise ServerValidationError(\"The agent does not have working remote shell capability\")\n        self.log.debug(\"Agent is accessible\")\n\n    def waitUpfront(self):\n        \"\"\" Wait before checking for the agent if --atLeast \"\"\"\n        if self.options.atLeast is not None:\n            print \"Sleeping for %d minutes before checking for agent\" % (self.options.atLeast / 60)\n            time.sleep(self.options.atLeast)\n\n    def needToWait(self):\n        \"\"\" Do we still need to wait ?  \"\"\"\n        return time.time() < self.deadLine\n\n    def run(self):\n        \"\"\"Start waiting for the agent.\"\"\"\n        self.startTime = time.time()\n        self.deadLine = self.startTime + self.options.atMost\n\n        if self.options.ignoreServiceOS:\n            print \"Ignoring deprecated option: ignoreServiceOS\"\n\n        self.waitUpfront()\n\n        if self.options.expectMaintenance:\n            print \"Waiting for registration of agent running on maintenance OS\"\n        else:\n            print \"Waiting for registration of agent running on production OS\"\n\n        # Main wait loop\n        error = None\n        while self.needToWait():\n            try:\n                self.renewTargetServer()\n                # The validation types, order important !\n                self.validateAgentAccessible()\n                self.recoverUnreachable()\n                self.validateServerState()\n                self.validateReportingAtLeast()\n\n                if self.options.expectMaintenance:\n                    print \"Maintenance agent is accessible\"\n                else:\n                    print \"Production agent is accessible\"\n                break\n            except (NotSupportedError, ServerValidationError) as why:\n                error = why\n                self.reportingStartTime = None\n                self.log.debug(\"Agent is not yet accessible exception follows, will keep on waiting\")\n                self.log.exception(error)\n            except WaitSomeMore, why:\n                error = why\n\n            self.setTiming()\n\n            self.wait()\n        else:\n            if error is not None:\n                raise error  # pylint: disable=E0702\n            else:\n                raise ShowErrorMessage(\"unknown error while waiting for agent\")\n\n\n@HandleShowErrorMessage(\"wait for the HP SA Agent\", log=LOG)\ndef main():\n    options, args = WaitForAgentParser(noRemainingArgs=True).parse_args()\n    del args\n    try:\n        AgentWaiter(options, log=LOG).run()\n    except ShowErrorMessage, e:\n        bootController = boot.getPreviouslyUsedBootController(ThisTargetServer())\n        if bootController is not None:\n            log = bootController.getLog()\n            if log:\n                raise e.__class__(\"%s\\nAdditional information from boot control:\\n%s\" % (str(e), log), e.exitCode)\n        raise e\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n",
            "description": "Waits for the HP SA Agent to register / come back online. Used to wait for the agent to become available again \neg. after a reboot of the target \n\nIt is recommended to add this step at the beginning of each newly created\nbuild plan with the --maintenance argument to wait for the maintenance agent\nbefore running the build plan. This  discovers any problems with the communication\nto the agent early.\n\nusage: wait_for_agent.py [options]\n\noptions:\n  -h, --help                    show this help message and exit\n  --ogfs, --maintenance         indicates we are expecting a maintenance (ogfs) agent\n  --production                  indicates we are expecting a production agent\n  --atLeast=MINUTES             the number of minutes to wait before actively checking\n                                for the agent; if not specified an optimized strategy is used\n  --atMost=MINUTES              the maximum number of minutes to wait for the agent to\n                                come back online; default value: 15 minute(s)\n  --reportingAtLeast=MINUES     Number of minutes to wait for the agent to constantly report",
            "status": null,
            "name": "Wait for HP SA Agent",
            "state": null,
            "eTag": "2015-08-04T07:30:23.000Z",
            "modified": "2015-08-04T07:30:23.000Z",
            "created": "2015-06-13T04:48:42.000Z",
            "category": "os-deployment-ogfs-scripts",
            "uri": "/rest/os-deployment-ogfs-scripts/400001"
        },
        {
            "codeType": "OGFS",
            "displayCodeType": "OGFS",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "1",
                    "createdBy": "opsware",
                    "createdDate": "2015-06-13T04:48:43.000Z",
                    "usage": "Assigns specified customer to server.\n\nUsage:\n\tcustomer_id | \"customer_display_name\"\n\nWhere:\n\t- customer_id - is the id of the customer\n\t- customer_display_name - display name of the customer\n\nPrerequisites:\n  - Needs to be part of a build plan.\n  - User must have write permission to the provided customer object",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-06-13T04:48:43.000Z",
            "version": {
                "versionLabel": "1",
                "createdBy": "opsware",
                "createdDate": "2015-06-13T04:48:43.000Z",
                "usage": "Assigns specified customer to server.\n\nUsage:\n\tcustomer_id | \"customer_display_name\"\n\nWhere:\n\t- customer_id - is the id of the customer\n\t- customer_display_name - display name of the customer\n\nPrerequisites:\n  - Needs to be part of a build plan.\n  - User must have write permission to the provided customer object",
                "current": true
            },
            "source": "#!/usr/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n#\n\"\"\"\n    (C) Copyright 2010-2015 Hewlett-Packard Development Company, L.P.\n\n    Assigns the target Server to the specified Customer.\n\"\"\"\n\nimport sys\nimport optparse\n# pylint: disable=F0401,E0611\n\nfrom pytwist.com.opsware.fido import AuthorizationDeniedException\nfrom pytwist.com.opsware.locality import CustomerRef\nfrom pytwist.com.opsware.server import ServerRef\n\n# pylint: enable=F0401,E0611\nfrom osprov import sa\nfrom osprov.osbp import ThisTargetServer\n\ntwistServer = sa.getTwistServer()\n\nEC_USAGE = 1\nEC_AUTHORIZATION_DENIED = 120\nEC_NOT_FOUND = 125\nEC_TARGET_SERVER = 5\nEC_INPUT_ERROR = 20\nINTERNAL_ACCOUNTS = [\"15\", \"0\", \"opsware\", \"customer independent\"]\n\nparser = optparse.OptionParser(\n    description=__doc__,\n    version=\"0.0.1\",\n    usage=\"%prog [Customer Id | Customer Name]\"\n)\n\n\ndef getCustomer(customer):\n    custRef = ''\n    filters = ['(CustomerVO.displayName = \\\"%s\\\")']\n    if customer.isdigit():\n        filters.append('(CustomerVO.pK = %s)')\n\n    if customer.lower() in INTERNAL_ACCOUNTS:\n        print (\"Cannot assign server to the reserved internal Customer \"\n               \"(Name/ID: %s).\" % customer)\n        return EC_INPUT_ERROR\n\n    for filt in filters:\n        try:\n            custRef = twistServer.search.SearchService.findObjRefs(filt % customer, \"customer\")[0]\n            break\n        except IndexError:\n            pass\n\n    if not custRef:\n        print (\"Unable to locate Customer (Name/ID: %s). It does not exist, or you do\"\n               \" not have the proper permissions.\" % customer)\n        return EC_NOT_FOUND\n\n    if not twistServer.locality.CustomerService.getCustomerVO(custRef).getFacilities():\n        print (\"Cannot assign server to the Customer (Name/ID: %s), as \"\n               \"this Customer is not  associated with any Facilities.\" % customer)\n        return EC_INPUT_ERROR\n\n    return custRef\n\n\ndef assignCustomer(mid, customer):\n    custRef = getCustomer(customer)\n    if not isinstance(custRef, CustomerRef):\n        return custRef\n\n    try:\n        server = twistServer.server.ServerService.getServerVO(ServerRef(mid))\n        if server.getCustomer().getId() == custRef.getId():  # pylint: disable=E1103\n            print \"Server (ID: %s) is already assigned to Customer (Name/ID: %s)\" % \\\n                (mid, customer)\n            return 0\n        server.customer = custRef\n        twistServer.server.ServerService.update(ServerRef(mid), server, 1, 0)\n        print \"Server successfully assigned to Customer (Name/ID: %s)\" % customer\n        return 0\n    except AuthorizationDeniedException:\n        print \"You do not have sufficient permissions to perform customer assignment\"\n        return EC_AUTHORIZATION_DENIED\n\n\ndef main(argv=None):\n    if argv is None:\n        argv = sys.argv\n    opt, args = parser.parse_args(argv[1:])\n\n    if len(args) != 1:\n        parser.print_help(sys.stderr)\n        return EC_USAGE\n\n    try:\n        mid = ThisTargetServer().id\n    except (IOError, OSError), ose:\n        sys.stderr.write(\"Unable to read the target server's MID in the OGFS. %s\\n\" % ose.args[0])\n        return EC_TARGET_SERVER\n\n    cust = args[0].strip()\n    return assignCustomer(mid, cust)\n\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n",
            "description": "Assigns specified customer to server.\n\nUsage:\n\tcustomer_id | \"customer_display_name\"\n\nWhere:\n\t- customer_id - is the id of the customer\n\t- customer_display_name - display name of the customer\n\nPrerequisites:\n  - Needs to be part of a build plan.\n  - User must have write permission to the provided customer object",
            "status": null,
            "name": "Assign Customer",
            "state": null,
            "eTag": "2015-06-13T04:48:43.000Z",
            "modified": "2015-06-13T04:48:43.000Z",
            "created": "2015-06-13T04:48:43.000Z",
            "category": "os-deployment-ogfs-scripts",
            "uri": "/rest/os-deployment-ogfs-scripts/420001"
        },
        {
            "codeType": "OGFS",
            "displayCodeType": "OGFS",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "1",
                    "createdBy": "opsware",
                    "createdDate": "2015-06-13T04:48:44.000Z",
                    "usage": "Inject required settings into the kickstart profile. The install nfs directive\nwill be inserted with the values used at the mount NFS share step. This step\nalso checks for to see if an encrypted password was used, since such a password,\ncan't be used to automatically manage the hypervizor.\n\nUsage:\n\tinject_required_ks_esx.py [--accept-encrypted-password] [--disableWarning]\n\nArguments:\n    accept-encrypted-password - accept the password to be encrypted\n    disableWarning - Do not show warnings of old hpsa_netconfig format\n\nPrerequisites:\n- Target server runs a maintenance Linux OS.\n- The user provided or default ks file must be in /tmp/user.ks.cfg.",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-06-13T04:48:44.000Z",
            "version": {
                "versionLabel": "1",
                "createdBy": "opsware",
                "createdDate": "2015-06-13T04:48:44.000Z",
                "usage": "Inject required settings into the kickstart profile. The install nfs directive\nwill be inserted with the values used at the mount NFS share step. This step\nalso checks for to see if an encrypted password was used, since such a password,\ncan't be used to automatically manage the hypervizor.\n\nUsage:\n\tinject_required_ks_esx.py [--accept-encrypted-password] [--disableWarning]\n\nArguments:\n    accept-encrypted-password - accept the password to be encrypted\n    disableWarning - Do not show warnings of old hpsa_netconfig format\n\nPrerequisites:\n- Target server runs a maintenance Linux OS.\n- The user provided or default ks file must be in /tmp/user.ks.cfg.",
                "current": true
            },
            "source": "#!/usr/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n\"\"\"\n    (C) Copyright 2013-2015 Hewlett-Packard Development Company, L.P.\n\n    Inject required options and move the required boot files onto the stub partition.\n\"\"\"\nimport os\nimport sys\nimport optparse\nfrom StringIO import StringIO\n\nfrom osprov import helpers\nfrom osprov.osbp import ThisTargetServer\nfrom osprov.errors import ShowErrorMessage\nfrom osprov.osbp.helpers import getMediaURL\nfrom osprov.parsers.netconfig import SmartNetconfig, OLD_SYNTAX_WARNING\nfrom osprov.profile import Kickstart, ProfileError\nfrom osprov.profile.kickstart import Script, Directive\n\nHPSA_NETCONFIG = \"\"\"@hpsa_netconfig@\"\"\"\n\nBASE_KS_FILE = \"tmp/user.ks.cfg\"\n\n\ndef initKickstart(baseFile):\n    \"\"\" Initialize a Kickstart object \"\"\"\n    return Kickstart(open(baseFile, \"r\"))\n\n\ndef removeConflictingOsprov(ksobj):\n    \"\"\" Remove conflicting directives  \"\"\"\n    if hasattr(ksobj, \"install\"):\n        for instance in ksobj.getDirectiveList(\"install\"):\n            print \"Removing %s from the profile\" % instance\n            instance.name = \"#%s\" % instance.name\n\n\ndef injectRequiredOsprov(ksobj, mediaUrl):\n    \"\"\" inject settings required for OS provisioning to work\n            currently it only injects the nfs share. ESX uses different syntax.\n    \"\"\"\n    if not hasattr(ksobj, \"install\"):\n        inst = Directive(\"install\")\n        if mediaUrl.scheme == \"nfs\":\n            inst[1] = \"nfs\"\n            inst[\"server\"] = mediaUrl.netloc\n            inst[\"dir\"] = mediaUrl.path\n        elif mediaUrl.scheme in [\"http\", \"https\"]:\n            if mediaUrl.username:\n                raise ShowErrorMessage(\n                    \"ESXi 4.1 doesn't support installing from a media server that requires authentication.\", 100)\n            inst[1] = \"url\"\n            inst[2] = mediaUrl.canonical()\n        else:\n            raise ShowErrorMessage(\n                \"ERROR: %s is not supported at this time\" % mediaUrl.scheme)\n        ksobj.directives.append(inst)\n\n\ndef hasEncPasswd(ksobj):\n    \"\"\"Check if the root pwd is encrypted \"\"\"\n    try:\n        if ksobj.rootpw[\"iscrypted\"]:\n            pass\n        return True\n    except (KeyError, AttributeError):\n        return False\n\n\ndef injectPost(ksobj, unsupported, agentGW, mid, crypto):\n    \"\"\" Inject code to stall the installer\"\"\"\n    # Don't inject the IP change script  if this is static provisioning\n\n    for script in ksobj.scripts:\n        if script.type == \"post\" and \\\n                \"###  CODE BY HPSA ###\" in [x.strip() for x in script.contents]:\n            return\n\n    agentSrv, opswareCaCrt = crypto\n\n    contents = []\n    contents.append(\"###  CODE BY HPSA ###\")\n    contents.append(\"#### DON'T REMOVE THE ABOVE COMMENT ###\")\n\n    contents.extend((\"\"\"\n\ncat > /tmp/hpsa_agent_mid << EOF\n%(mid)s\nEOF\n\ncat > /tmp/hpsa_agent.srv << EOF\n%(agentSrv)s\nEOF\n\ncat > /tmp/hpsa_ca.crt << EOF\n%(opswareCaCrt)s\nEOF\n\ncd /tmp\ntar xzf /hpsa_agent.tar.gz\ncd usr/hpsa_agent\ncp osprov/esxi_reg.sh /tmp/esxi_reg.sh\nchmod 755 /tmp/esxi_reg.sh\nif which localcli ; then\n    localcli network firewall set -e false\n    localcli network firewall get >> /tmp/hpsa_osprov.out\nfi\n/tmp/esxi_reg.sh \"/tmp/usr/hpsa_agent\" \"%(agentGw)s\"\nRC=$?\nif which localcli ; then\n    localcli network firewall set -e true\n    localcli network firewall get >> /tmp/hpsa_osprov.out\nfi\nexit $RC\n\"\"\" % {'mid': mid, 'agentSrv': agentSrv, 'opswareCaCrt': opswareCaCrt, 'agentGw': agentGW}).split(\"\\n\"))\n\n    contents.append('### END OF HPSA CODE ###')\n\n    post = Script(\"post\")\n    if unsupported:\n        post[\"unsupported\"] = None\n    post[\"interpreter\"] = \"busybox\"\n    post[\"ignorefailure\"] = \"false\"\n\n    post.contents.extend(contents)\n    ksobj.scripts.append(post)\n\n\ndef writeFinalKs(ksobj):\n    \"\"\" Write the kickstart file onto the boot disk \"\"\"\n    ksfile = open(BASE_KS_FILE, \"w\")\n    ksfile.write(str(ksobj))\n    ksfile.close()\n    print \"Kickstart file written to disk\"\n\n\ndef handleOsprov(ksobj, keys):\n    \"\"\" change the profile to suit the environment \"\"\"\n    removeConflictingOsprov(ksobj)\n    injectRequiredOsprov(ksobj, getMediaURL(keys))\n\n\ndef parseArgs(args):\n    \"\"\"Parse the command line arguments\"\"\"\n    parser = optparse.OptionParser(description=__doc__, version='0.0.1', )\n    parser.add_option('--accept-encrypted-password', default=False, dest=\"acceptencrypted\",\n                      help=\"Continue installation even if user has given an encrypted password \",\n                      action=\"store_true\")\n    parser.add_option(\"--disableWarning\", dest=\"disableWarning\", action=\"store_true\",\n                      default=False,\n                      help=\"Do not show warnings of old hpsa_netconfig format\")\n\n    opt, args = parser.parse_args(args)\n    return opt\n\n\ndef injectDevice(ksobj, targetServer):\n    ksobj.network[\"device\"] = targetServer.getMACAddress()\n\n\ndef getProvisioningNIC(netinfo):\n    \"\"\" Searches for and return the provisioning NIC \"\"\"\n    provisioningNics = [nic for nic in netinfo.nics if nic.provisioning]\n    if len(provisioningNics) > 1:\n        print \"Warning: Only one provisioning NIC will be configured from the netconfig\"\n    return provisioningNics[0]\n\n\ndef main():\n\n    opt = parseArgs(sys.argv[1:])\n\n    unsupported = False\n    unsupported = True\n    # parse out flags\n    try:\n        targetServer = ThisTargetServer()\n        targetServer.setWorkDir(targetServer.getRemoteRoot())\n        ksobj = initKickstart(BASE_KS_FILE)\n        # exit if unable to retrieve password from ks.cfg\n        try:\n            ksobj.rootpw[1]\n        except (KeyError, AttributeError):\n            print \"Unable to read root password from kick start file. \"\\\n                  \"Please verify kickstart configuration in the build plan\"\n            return 10\n\n        if hasEncPasswd(ksobj) and not opt.acceptencrypted:\n            print \"Can not proceed with installation as the root password is encrypted\"\n            return 11\n        else:\n            # Save the root password for lather use\n            keys = helpers.getDataStore(targetServer)\n            keys.profile.username = \"root\"\n            keys.profile.password = ksobj.rootpw[1]\n            helpers.putDataStore(keys, targetServer)\n        # Extra steps\n        # Below comment is used to generate scripts with additional actions,\n        # don't remove\n        handleOsprov(ksobj, keys)\n\n        netconfigParser = SmartNetconfig.readwrite(\n            StringIO(HPSA_NETCONFIG),\n            activeMacAddress=targetServer.getMACAddress(),\n            ipv6default=targetServer.isIPv6Managed()\n        )\n        netinfo = netconfigParser.info()\n        if netinfo.oldSyntax and not opt.disableWarning:\n            newFormat = netconfigParser.format()\n            print OLD_SYNTAX_WARNING + \"\\n%s\" % str(newFormat)\n\n        typosList = netconfigParser.getTyposList()\n        if typosList:\n            print(\"The following keys were not recognized in the netconfig CA and could be typos: %s\" % typosList)\n\n        provisioningNIC = getProvisioningNIC(netinfo)\n\n        if not (provisioningNIC.ipv4Networks or provisioningNIC.ipv6Networks):\n            agwIpPort = targetServer.getRandomAgentGateway()\n            mid = targetServer.getId()\n            agentSrv = targetServer.readFile(\n                os.path.join(targetServer.localServer.CRYPTO_DIR, \"agent.srv\"))\n            opswareCaCrt = targetServer.readFile(\n                os.path.join(targetServer.localServer.CRYPTO_DIR, \"opsware-ca.crt\"))\n            injectPost(ksobj, unsupported, agwIpPort, mid, (agentSrv, opswareCaCrt))\n        injectDevice(ksobj, targetServer)\n        writeFinalKs(ksobj)\n        print \"Successfully injected required settings\"\n    except (IOError, OSError, ProfileError, ShowErrorMessage), why:\n        sys.stderr.write(\"Failed to inject required settings.%s\\n\" % why)\n        return 1\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n",
            "description": "Inject required settings into the kickstart profile. The install nfs directive\nwill be inserted with the values used at the mount NFS share step. This step\nalso checks for to see if an encrypted password was used, since such a password,\ncan't be used to automatically manage the hypervizor.\n\nUsage:\n\tinject_required_ks_esx.py [--accept-encrypted-password] [--disableWarning]\n\nArguments:\n    accept-encrypted-password - accept the password to be encrypted\n    disableWarning - Do not show warnings of old hpsa_netconfig format\n\nPrerequisites:\n- Target server runs a maintenance Linux OS.\n- The user provided or default ks file must be in /tmp/user.ks.cfg.",
            "status": null,
            "name": "Inject Required ESXi Kickstart Settings",
            "state": null,
            "eTag": "2015-06-13T04:48:44.000Z",
            "modified": "2015-06-13T04:48:44.000Z",
            "created": "2015-06-13T04:48:44.000Z",
            "category": "os-deployment-ogfs-scripts",
            "uri": "/rest/os-deployment-ogfs-scripts/430001"
        },
        {
            "codeType": "OGFS",
            "displayCodeType": "OGFS",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "1",
                    "createdBy": "opsware",
                    "createdDate": "2015-06-13T04:48:44.000Z",
                    "usage": "HP ProLiant Gen8 (G8) devices need a special prepare disks step to handle the Virtual Installation Device (VID).\nThis can be handled automatically when the BIOS setting for the VID is set to \"Hidden\".\nWhen using SA functionality to use iLO and WinPE service OS of the Gen8-specific Intelligent Provisioning (G8IP),\nthe VID is visible. To prevent the Windows OS installation from installing Windows to the VID,\nthis step must be included early in the build plan.\n\nWhile this build plan step is specific to WinPE G8IP service OS, it will not fail under other service OSs\n(embedded or not) or on non G8 targets when used with the default settings. (See parameters below)\n\nUsage:\n   [-s | --strict ] [-c ca_name | --ca ca_name ]\n\nWhere:\n   -s | --strict \n      use strict checking: abort when it can't set the custom attribute regardless of reason (a non G8\n      device; a target G8 device that doesn't runs the embedded WinPE service OS; a target G8\n      device that runs the embedded WinPE service OS and can't discover the disk)\n   -c ca_name | --ca ca_name\n      override the default custom attribute \"SystemDiskNumber\" to set or check for a preset value to\n     carry the disk number found to be used as target disk\n\nPrerequisites:\n- Target servers runs a maintenance Windows PE Intelligent Provisioning service OS.",
                    "current": false
                },
                {
                    "versionLabel": "2",
                    "createdBy": "opsware",
                    "createdDate": "2015-08-04T07:30:14.000Z",
                    "usage": "HP ProLiant Gen8 (G8) devices need a special prepare disks step to handle the Virtual Installation Device (VID).\nThis can be handled automatically when the BIOS setting for the VID is set to \"Hidden\".\nWhen using SA functionality to use iLO and WinPE service OS of the Gen8-specific Intelligent Provisioning (G8IP),\nthe VID is visible. To prevent the Windows OS installation from installing Windows to the VID,\nthis step must be included early in the build plan.\n\nWhile this build plan step is specific to WinPE G8IP service OS, it will not fail under other service OSs\n(embedded or not) or on non G8 targets when used with the default settings. (See parameters below)\n\nUsage:\n   [-s | --strict ] [-c ca_name | --ca ca_name ]\n\nWhere:\n   -s | --strict \n      use strict checking: abort when it can't set the custom attribute regardless of reason (a non G8\n      device; a target G8 device that doesn't runs the embedded WinPE service OS; a target G8\n      device that runs the embedded WinPE service OS and can't discover the disk)\n   -c ca_name | --ca ca_name\n      override the default custom attribute \"SystemDiskNumber\" to set or check for a preset value to\n     carry the disk number found to be used as target disk\n\nPrerequisites:\n- Target servers runs a maintenance Windows PE Intelligent Provisioning service OS.",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-08-04T07:30:14.000Z",
            "version": {
                "versionLabel": "2",
                "createdBy": "opsware",
                "createdDate": "2015-08-04T07:30:14.000Z",
                "usage": "HP ProLiant Gen8 (G8) devices need a special prepare disks step to handle the Virtual Installation Device (VID).\nThis can be handled automatically when the BIOS setting for the VID is set to \"Hidden\".\nWhen using SA functionality to use iLO and WinPE service OS of the Gen8-specific Intelligent Provisioning (G8IP),\nthe VID is visible. To prevent the Windows OS installation from installing Windows to the VID,\nthis step must be included early in the build plan.\n\nWhile this build plan step is specific to WinPE G8IP service OS, it will not fail under other service OSs\n(embedded or not) or on non G8 targets when used with the default settings. (See parameters below)\n\nUsage:\n   [-s | --strict ] [-c ca_name | --ca ca_name ]\n\nWhere:\n   -s | --strict \n      use strict checking: abort when it can't set the custom attribute regardless of reason (a non G8\n      device; a target G8 device that doesn't runs the embedded WinPE service OS; a target G8\n      device that runs the embedded WinPE service OS and can't discover the disk)\n   -c ca_name | --ca ca_name\n      override the default custom attribute \"SystemDiskNumber\" to set or check for a preset value to\n     carry the disk number found to be used as target disk\n\nPrerequisites:\n- Target servers runs a maintenance Windows PE Intelligent Provisioning service OS.",
                "current": true
            },
            "source": "#!/usr/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n#\n\"\"\"\n    (C) Copyright 2013-2015 Hewlett-Packard Development Company, L.P.\n\n    Prepares the disks to be used as part of an OS installation on a HP ProLiant Gen8.\n    This step works with both Linux and WinPE service OS.\n\"\"\"\nimport sys\nfrom optparse import OptionParser\nfrom osprov.osbp import ThisTargetServer, logger\nfrom osprov.osbp.vid import HPVid\nfrom osprov.osbp.vid import DISK_CA_PARAMETER, DISK_CA_LINUX, DISK_CA_WINDOWS\nfrom osprov.errors import ShowErrorMessage, ProcessExecutionError, DiscoveryError, NotSupportedError\nfrom osprov.osbp.TargetServer import GaiusWinPETargetServer\n\nLOG = logger.getIt(\"Prepare Disks\")\n\n# ScriptWeaver will parametrize the @data@ below at run time\npresetCA = {DISK_CA_LINUX: \"@SystemDiskDevice@\", DISK_CA_WINDOWS: \"@SystemDiskNumber@\"}\n\nEC_SUCCESS = 0\nEC_ERROR_MSG = 10\nEC_PREP_DISK_ERROR = 20\nEC_NOT_SUPPORTED = 30\n\n\ndef parseArgs(args):\n    \"\"\" parse and normalise arguments for the script \"\"\"\n    parser = OptionParser()\n    parser.add_option(\"-c\", \"--ca\", metavar=\"CA\",\n                      default=None,\n                      help=\"The name of the custom attribute to set\")\n    parser.add_option(\"-s\", \"--strict\", metavar=\"STRICT\",\n                      action=\"store_true\", default=False,\n                      help=\"Preparing disk discovery errors are treated as fatal errors\")\n    parser.add_option(\"-v\", \"--withVID\", metavar=\"WITHVID\",\n                      action=\"store_true\", default=False,\n                      help=\"HP ProLiant Gen8 VID handling\")\n    options, args = parser.parse_args(args)\n    if args:\n        parser.error(\"Additional positional arguments are not supported\")\n    return options\n\n\ndef main():\n    \"\"\" Main entry point. \"\"\"\n    options = parseArgs(sys.argv[1:])\n    try:\n        targetServer = ThisTargetServer()\n        # Checking that the embedded WinPE OS was booted\n        if not isinstance(targetServer, GaiusWinPETargetServer):\n            if options.strict:\n                print \"Strict check option enabled - This step should be run on a Gen8-specific Intelligent \\\nProvisioning WinPE service OS, aborting the step as you don't use one\"\n                return EC_NOT_SUPPORTED\n            else:\n                print \"You are not using the Gen8-specific Intelligent Provisioning WinPE service OS; \\\nskipping this step\"\n                return EC_SUCCESS\n        vid = HPVid.factor(targetServer)\n        if options.ca:\n            # add content of the CA to the presetCA list\n            presetCA[DISK_CA_PARAMETER] = vid.getTargetDeviceCA(options.ca)\n        targetdevice = vid.findTargetBootDisk(presetCA, options.withVID)\n        if targetdevice:\n            print \"Setting disk %s as boot target disk\" % targetdevice\n            vid.setTargetDeviceCA(targetdevice, caname=options.ca)\n    except ProcessExecutionError, why:\n        print \"Execution error - Failed to prepare disks:\"\n        print why\n        print why.stderr\n        return EC_PREP_DISK_ERROR\n    except NotSupportedError, why:\n        print \"Error while preparing disks:\"\n        print why\n        if options.strict:\n            print \"Strict error handling option enabled - ending with error.\"\n            return EC_NOT_SUPPORTED\n        print \"Step did not complete but returning success since the strict error handling option was not used.\"\n        return EC_SUCCESS\n    except DiscoveryError, why:\n        print \"Discovery Error - while preparing disks:\"\n        print why\n        return EC_PREP_DISK_ERROR\n    except ShowErrorMessage, why:\n        LOG.exception(why)\n        print why\n        return EC_ERROR_MSG\n\n    print \"Preparing disks finished successfully.\"\n    return EC_SUCCESS\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n",
            "description": "HP ProLiant Gen8 (G8) devices need a special prepare disks step to handle the Virtual Installation Device (VID).\nThis can be handled automatically when the BIOS setting for the VID is set to \"Hidden\".\nWhen using SA functionality to use iLO and WinPE service OS of the Gen8-specific Intelligent Provisioning (G8IP),\nthe VID is visible. To prevent the Windows OS installation from installing Windows to the VID,\nthis step must be included early in the build plan.\n\nWhile this build plan step is specific to WinPE G8IP service OS, it will not fail under other service OSs\n(embedded or not) or on non G8 targets when used with the default settings. (See parameters below)\n\nUsage:\n   [-s | --strict ] [-c ca_name | --ca ca_name ]\n\nWhere:\n   -s | --strict \n      use strict checking: abort when it can't set the custom attribute regardless of reason (a non G8\n      device; a target G8 device that doesn't runs the embedded WinPE service OS; a target G8\n      device that runs the embedded WinPE service OS and can't discover the disk)\n   -c ca_name | --ca ca_name\n      override the default custom attribute \"SystemDiskNumber\" to set or check for a preset value to\n     carry the disk number found to be used as target disk\n\nPrerequisites:\n- Target servers runs a maintenance Windows PE Intelligent Provisioning service OS.",
            "status": null,
            "name": "Prepare Disks on HP ProLiant Gen8",
            "state": null,
            "eTag": "2015-08-04T07:30:14.000Z",
            "modified": "2015-08-04T07:30:14.000Z",
            "created": "2015-06-13T04:48:44.000Z",
            "category": "os-deployment-ogfs-scripts",
            "uri": "/rest/os-deployment-ogfs-scripts/440001"
        },
        {
            "codeType": "OGFS",
            "displayCodeType": "OGFS",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "1",
                    "createdBy": "opsware",
                    "createdDate": "2015-06-13T04:48:45.000Z",
                    "usage": "Replaced step. No longer in use. Please refer to \"User Guide: Provisioning\" for using the new steps",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-06-13T04:48:45.000Z",
            "version": {
                "versionLabel": "1",
                "createdBy": "opsware",
                "createdDate": "2015-06-13T04:48:45.000Z",
                "usage": "Replaced step. No longer in use. Please refer to \"User Guide: Provisioning\" for using the new steps",
                "current": true
            },
            "source": "#!/usr/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n#\n\"\"\"\n    (C) Copyright 2013-2015 Hewlett-Packard Development Company, L.P.\n\n    Captures the RAID configuration on the target server and stores\n    it as a Software Policy.\n\"\"\"\nimport sys\nimport os\nfrom osprov.osbp import logger\n\nLOG = logger.getIt(\"capture raid\")\n\n\n\n\ndef main():\n    \"\"\" Main entry point  \"\"\"\n\n    print(\"Warning: Capture RAID step is replaced. Please refer to 'User Guide: Provisioning' for using the new steps!\")\n    return 1\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n",
            "description": "Replaced step. No longer in use. Please refer to \"User Guide: Provisioning\" for using the new steps",
            "status": null,
            "name": "Capture HP RAID Configuration",
            "state": null,
            "eTag": "2015-06-13T04:48:45.000Z",
            "modified": "2015-06-13T04:48:45.000Z",
            "created": "2015-06-13T04:48:45.000Z",
            "category": "os-deployment-ogfs-scripts",
            "uri": "/rest/os-deployment-ogfs-scripts/470001"
        },
        {
            "codeType": "OGFS",
            "displayCodeType": "OGFS",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "1",
                    "createdBy": "opsware",
                    "createdDate": "2015-06-13T04:48:46.000Z",
                    "usage": "Injects settings for personalization into a AutoYAST installation profile.\nPersonalization settings include network settings.\n\nUsage: inject_ay_personalization_settings.py [OPTIONS]\n\nOptions:\n--require-netconfig=[true,false]\n        Specify whether a netconfig is mandatory or not.\n        Optional argument, defaults to false.\n\n--disableWarning\n        Do not show warnings of old hpsa_netconfig format\n        Optional argument, defaults to false.\n\n--oesMedia=URL\n        Novell OES media add-on path.\n\nPrerequisites:\n- Target server runs a maintenance Linux OS.",
                    "current": false
                },
                {
                    "versionLabel": "2",
                    "createdBy": "opsware",
                    "createdDate": "2015-08-04T07:30:20.000Z",
                    "usage": "Injects settings for personalization into a AutoYAST installation profile.\nPersonalization settings include network settings.\n\nUsage: inject_ay_personalization_settings.py [OPTIONS]\n\nOptions:\n--require-netconfig=[true,false]\n        Specify whether a netconfig is mandatory or not.\n        Optional argument, defaults to false.\n\n--disableWarning\n        Do not show warnings of old hpsa_netconfig format\n        Optional argument, defaults to false.\n\n--oesMedia=URL\n        Novell OES media add-on path.\n\nPrerequisites:\n- Target server runs a maintenance Linux OS.",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-08-04T07:30:20.000Z",
            "version": {
                "versionLabel": "2",
                "createdBy": "opsware",
                "createdDate": "2015-08-04T07:30:20.000Z",
                "usage": "Injects settings for personalization into a AutoYAST installation profile.\nPersonalization settings include network settings.\n\nUsage: inject_ay_personalization_settings.py [OPTIONS]\n\nOptions:\n--require-netconfig=[true,false]\n        Specify whether a netconfig is mandatory or not.\n        Optional argument, defaults to false.\n\n--disableWarning\n        Do not show warnings of old hpsa_netconfig format\n        Optional argument, defaults to false.\n\n--oesMedia=URL\n        Novell OES media add-on path.\n\nPrerequisites:\n- Target server runs a maintenance Linux OS.",
                "current": true
            },
            "source": "#!/usr/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# lint_ignore=E501,I0011\n# Please do not change the two lines above. See PEP 8, PEP 263.\n\"\"\"\n    (C) Copyright 2010-2015 Hewlett-Packard Development Company, L.P.\n\n    This program will inject personalized settings into the autoinst.xml\n    file.\n\"\"\"\n\nimport sys\nfrom cStringIO import StringIO\n\nfrom osprov.optparse_ext import OptionParser, OptionValueError\nfrom osprov.profile import AutoYaST\nfrom osprov.osbp import ThisTargetServer, logger\nfrom osprov.errors import ShowErrorMessage\nfrom osprov.parsers.netconfig import SmartNetconfig, OLD_SYNTAX_WARNING\nfrom osprov.networking import validation\nfrom osprov.networking.discovery import GenericNetworkDiscovery\nfrom osprov import helpers\n\nEC_NO_ERR = 0\nEC_NO_CA = 20\nEC_EXCEPTION = 100\nAY_PATH = \"tmp/user.autoinst.xml\"\n\nLOG = logger.getIt('inject_ay_pers')\n\nHPSA_NETCONFIG = \"\"\"@hpsa_netconfig@\"\"\"\n\ndef injectOesAddon(ay, oesMediaUrl):\n    \"\"\"\n        Inject Novell OES Addon\n    \"\"\"\n    ay.setNodeTextValue(ay.getNode(\"profile/add-on/add_on_products/listentry/media_url\"), oesMediaUrl)\n\n\n\ndef initializeInterface(ay, provisioningNIC, netinfo, ipv6Managed):\n    \"\"\" Initialize the interface definition in the AY profile\n\n        Configure static vs DHCP configuration\n    \"\"\"\n    ay.createPath(\"profile/networking/interfaces\").setAttribute(\"config:type\", \"list\")\n    ay.setNodeTextValue(ay.createPath(\"profile/networking/interfaces/interface/device\"), provisioningNIC.deviceName)\n    ay.setNodeTextValue(ay.createPath(\"profile/networking/interfaces/interface/startmode\"), \"auto\")\n    interface = ay.createPath(\"profile/networking/interfaces/interface\")\n\n    # A static configuration will always have priority if static network info is defined\n    bootproto = \"dhcp\"\n    # Will always use the provided dns server names if provided\n    dhcpdns = \"true\"\n    # Will always use the provided hostname if provided\n    dhcpname = \"true\"\n    if ipv6Managed:\n        if provisioningNIC.ipv6Networks and provisioningNIC.ipv6Networks[0] and not provisioningNIC.ipv6Autoconfig:\n            bootproto = \"static\"\n        elif not provisioningNIC.ipv6Autoconfig:\n            print \"Can not complete network personalization. \" \\\n                  \"Auto configuration is turned off for IPv6 and there is no static address defined\"\n            sys.exit(37)\n        if len(provisioningNIC.ipv6DnsServers) > 0:\n            dhcpdns = \"false\"\n        elif not provisioningNIC.ipv6Autoconfig:\n            dhcpdns = \"false\"\n        if netinfo.hostname:\n            dhcpname = \"false\"\n        elif not provisioningNIC.ipv6Autoconfig:\n            dhcpname = \"false\"\n    else:\n        if provisioningNIC.ipv4Networks and provisioningNIC.ipv4Networks[0]:\n            bootproto = \"static\"\n        elif not provisioningNIC.dhcpv4:\n            print \"Can not complete network personalization. \" \\\n                  \"DHCP is turned off for IPv4 and there is no static address defined\"\n            sys.exit(38)\n        if len(provisioningNIC.ipv4DnsServers) > 0:\n            dhcpdns = \"false\"\n        elif not provisioningNIC.dhcpv4:\n            dhcpdns = \"false\"\n        if netinfo.hostname:\n            dhcpname = \"false\"\n        elif not provisioningNIC.dhcpv4:\n            dhcpname = \"false\"\n    print \"Configuring boot protocol to: %s\" % bootproto\n    ay.setNodeTextValue(ay.createPath(\"profile/networking/interfaces/interface/bootproto\"), bootproto)\n\n    dhcp_hostname = ay.createPath(\"profile/networking/dns/dhcp_hostname\")\n    dhcp_hostname.setAttribute(\"config:type\", \"boolean\")\n    ay.setNodeTextValue(dhcp_hostname, dhcpname)\n    dhcp_resolv = ay.createPath(\"profile/networking/dns/dhcp_resolv\")\n    dhcp_resolv.setAttribute(\"config:type\", \"boolean\")\n    ay.setNodeTextValue(dhcp_resolv, dhcpdns)\n    return interface\n\n\ndef personalizeDns(ay, provisioningNIC, ipv6Managed):\n    \"\"\" Personalize the DNS settings \"\"\"\n    # will use just the DNS servers specific for the SOS mode ipv4/ipv6\n    if ipv6Managed:\n        providedDnsServers = provisioningNIC.ipv6DnsServers\n    else:\n        providedDnsServers = provisioningNIC.ipv4DnsServers\n    if providedDnsServers:\n        print \"Will use name server(s): %s\" % \",\".join([str(x) for x in providedDnsServers])\n        nameservers = ay.createPath(\"profile/networking/dns/nameservers\")\n        nameservers.setAttribute(\"config:type\", \"list\")\n    for dnsServer in providedDnsServers:\n        nameserver = ay.document.createElement(\"nameserver\")\n        ay.setNodeTextValue(nameserver, dnsServer)\n        nameservers.appendChild(nameserver)\n\n    searchlist = ay.createPath(\"profile/networking/dns/searchlist\")\n    searchlist.setAttribute(\"config:type\", \"list\")\n    if provisioningNIC.dnsSearch:\n        print \"Will use search domain(s): %s\" % \",\".join(provisioningNIC.dnsSearch)\n    for dnsSearch in provisioningNIC.dnsSearch:\n        search = ay.document.createElement(\"search\")\n        ay.setNodeTextValue(search, dnsSearch)\n        searchlist.appendChild(search)\n\n\ndef personalizeFqdn(ay, netinfo):\n    \"\"\" Personalize the server FQDN \"\"\"\n    if netinfo.domainName:\n        print \"Setting domain name to: %s\" % netinfo.domainName\n        ay.setNodeTextValue(ay.createPath(\"profile/networking/dns/domain\"), netinfo.domainName)\n    if netinfo.hostname:\n        print \"Setting hostname to: %s\" % netinfo.hostname\n        ay.setNodeTextValue(ay.createPath(\"profile/networking/dns/hostname\"), netinfo.hostname)\n\n\ndef personalizeGateway(ay, provisioningRoute):\n    \"\"\" Inject Gateway settings \"\"\"\n    print \"Will use default gateway: %s\" % provisioningRoute.gateway\n    routes = ay.createPath(\"profile/networking/routing/routes\")\n    routes.setAttribute(\"config:type\", \"list\")\n    route = ay.document.createElement(\"route\")\n\n    netmask = ay.document.createElement(\"netmask\")\n    ay.setNodeTextValue(netmask, \"-\")\n    route.appendChild(netmask)\n\n    destination = ay.document.createElement(\"destination\")\n    ay.setNodeTextValue(destination, \"default\")\n    route.appendChild(destination)\n\n    device = ay.document.createElement(\"device\")\n    ay.setNodeTextValue(device, \"-\")\n    route.appendChild(device)\n\n    gateway = ay.document.createElement(\"gateway\")\n    ay.setNodeTextValue(gateway, provisioningRoute.gateway)\n    route.appendChild(gateway)\n\n    routes.appendChild(route)\n\n\ndef injectPersonalization(ay, netinfo, ipv6Managed=False):\n    \"\"\" Inject static networking configuration into the ay profile\"\"\"\n    provisioningNIC = netinfo.getProvisioningNIC()\n    print \"Going to provision using interface with MAC address %s\" % provisioningNIC.macAddress\n    interface = initializeInterface(ay, provisioningNIC, netinfo, ipv6Managed)\n    personalizeFqdn(ay, netinfo)\n    personalizeDns(ay, provisioningNIC, ipv6Managed)\n\n    if ipv6Managed:\n        if provisioningNIC.ipv6Networks and not provisioningNIC.ipv6Autoconfig:\n            ipv6Network = provisioningNIC.ipv6Networks[0]  # we will configure just the first network\n            print \"Configuring IPv6 network: %s\" % ipv6Network\n            ipv6_config = ay.createPath(\"profile/networking/ipv6_config\")\n            ipv6_config.setAttribute(\"config:type\", \"boolean\")\n            ay.setNodeTextValue(ipv6_config, \"true\")\n            ipaddr = ay.document.createElement(\"ipaddr\")\n            ay.setNodeTextValue(ipaddr, ipv6Network.ip)\n            interface.appendChild(ipaddr)\n            netmask = ay.document.createElement(\"prefixlen\")\n            ay.setNodeTextValue(netmask, ipv6Network.prefixlen)\n            interface.appendChild(netmask)\n\n        if provisioningNIC.ipv4Networks:\n            print \"Found IPv6-based service OS, ignoring IPv4 network personalization\"\n\n    else:\n        if provisioningNIC.ipv4Networks:\n            ipv4Network = provisioningNIC.ipv4Networks[0]  # we will configure just the first network\n            print \"Configuring IPv4 network: %s\" % ipv4Network\n            ipaddr = ay.document.createElement(\"ipaddr\")\n            ay.setNodeTextValue(ipaddr, ipv4Network.ip)\n            interface.appendChild(ipaddr)\n            netmask = ay.document.createElement(\"netmask\")\n            ay.setNodeTextValue(netmask, ipv4Network.netmask)\n            interface.appendChild(netmask)\n\n        if provisioningNIC.ipv6Networks:\n            print \"Found IPv4-based service OS, ignoring IPv6 network personalization\"\n\n    if ipv6Managed:\n        provisioningRoutes = [iproute for iproute in netinfo.ipv6Routes if iproute.nic == provisioningNIC]\n    else:\n        provisioningRoutes = [iproute for iproute in netinfo.ipv4Routes if iproute.nic == provisioningNIC]\n    if len(provisioningRoutes) > 0:\n        personalizeGateway(ay, provisioningRoutes[0])  # will keep just 1 gateway\n\n\ndef writeAyFile(ayFile, ay):\n    \"\"\" Write the autoyast file to disk  \"\"\"\n    ayf = open(ayFile, \"w+\")\n    ayf.write(str(ay))\n    ayf.close()\n\n\ndef getOptions():\n    \"\"\"Returns the command-line options.\"\"\"\n    optparser = OptionParser()\n    optparser.add_option(\"--require-netconfig\", default=\"false\")\n    optparser.add_option(\"--oesMediaUrl\",\n                         metavar=\"URL\", default=None,\n                         help=\"Specify the Novell OES add-on path.\")\n    optparser.add_option(\"--disableWarning\", dest=\"disableWarning\", action=\"store_true\",\n                         default=False,\n                         help=\"Do not show warnings of old hpsa_netconfig format\")\n    (options, args) = optparser.parse_args()\n    del args\n    if not options.require_netconfig.lower() in (\"true\", \"false\"):\n        raise OptionValueError(\n            \"Invalid value for --require-netconfig: %s.\\nShould be 'true' or 'false'.\")\n    options.require_netconfig = options.require_netconfig.lower() == \"true\"\n\n    return options\n\n\ndef main():\n    \"\"\" Parse and inject netconfig in the AY profile \"\"\"\n    try:\n        targetServer = ThisTargetServer()\n        targetServer.setWorkDir(targetServer.getRemoteRoot())\n        options = getOptions()\n\n        netconfigParser = SmartNetconfig.readwrite(\n            StringIO(HPSA_NETCONFIG),\n            activeMacAddress=targetServer.getMACAddress(),\n            ipv6default=targetServer.isIPv6Managed(),\n            log=LOG\n        )\n        netinfo = netconfigParser.info()\n        if netinfo.oldSyntax and not options.disableWarning:\n            newFormat = netconfigParser.format()\n            print OLD_SYNTAX_WARNING + \"\\n%s\" % str(newFormat)\n\n        typosList = netconfigParser.getTyposList()\n        if typosList:\n            print(\"The following keys were not recognized in the netconfig CA and could be typos: %s\" % typosList)\n\n        if not HPSA_NETCONFIG and options.require_netconfig:\n            print \"Network configuration (hpsa_netconfig) for this server was not found, even though \"\n            print \"it is required by the value true of the CA require_netconfig. \"\n            print \"Check the hpsa_netconfig custom attribute and verify the target server \"\n            print \"has been configured for static networking.\"\n            return 1\n\n        validation.validateProvisioningNIC(netinfo.getProvisioningNIC(), targetServer)\n        # Populating device names according to SOS detection\n        GenericNetworkDiscovery(targetServer).discoverInterfaceNames(netinfo)\n\n        ayObj = AutoYaST(open(AY_PATH))\n        injectPersonalization(ayObj, netinfo, targetServer.isIPv6Managed())\n        if options.oesMediaUrl:\n            injectOesAddon(ayObj, options.oesMediaUrl)\n        writeAyFile(AY_PATH, ayObj)\n    except (OSError, IOError, ShowErrorMessage), why:\n        LOG.exception(why)\n        print \"Failed to inject personalization settings:\\n%s\" % why\n        return EC_EXCEPTION\n\n\nif __name__ == \"__main__\":\n    sys.exit(main())",
            "description": "Injects settings for personalization into a AutoYAST installation profile.\nPersonalization settings include network settings.\n\nUsage: inject_ay_personalization_settings.py [OPTIONS]\n\nOptions:\n--require-netconfig=[true,false]\n        Specify whether a netconfig is mandatory or not.\n        Optional argument, defaults to false.\n\n--disableWarning\n        Do not show warnings of old hpsa_netconfig format\n        Optional argument, defaults to false.\n\n--oesMedia=URL\n        Novell OES media add-on path.\n\nPrerequisites:\n- Target server runs a maintenance Linux OS.",
            "status": null,
            "name": "Inject AutoYaST Personalization Settings",
            "state": null,
            "eTag": "2015-08-04T07:30:20.000Z",
            "modified": "2015-08-04T07:30:20.000Z",
            "created": "2015-06-13T04:48:46.000Z",
            "category": "os-deployment-ogfs-scripts",
            "uri": "/rest/os-deployment-ogfs-scripts/490001"
        },
        {
            "codeType": "OGFS",
            "displayCodeType": "OGFS",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "1",
                    "createdBy": "opsware",
                    "createdDate": "2015-06-13T04:48:47.000Z",
                    "usage": "Injects settings for personalization into a Windows setup answer file. Personalization settings include network settings and certain OS settings that are often computer specific like Adminastrator password.\n\nUsage:\n\ninject_personalization_settings.py [OPTIONS] [PATH_TO_FILE]\n\nOptions:\n\n--require-netconfig=[true,false]\n\tSpecify whether a netconfig is mandatory or not.\n\tOptional argument, defaults to false.\n--disableWarning\n    Do not show warnings of old hpsa_netconfig format\n    Optional argument, defaults to false.\n\nYou may specify an alternate path to the Unattend.xml, Unattend.txt, or sysprep.inf file here. This parameter can normally be omitted and the script will use the standard file locations. The file name extension (txt or xml) is used to \ndetermine whether plain text (Windows prior to 2008) or XML (Windows 2008 and newer) processing should be used. The following path locations are checked (in order), and if that file exists, it is updated and no further files are checked. X/Windows/Temp/Unattend.xml (For Windows 2008 OS Media installs), C/Windows/Panther/unattend.xml (For Windows 2008 WIM installs)\n\nPrerequisites:\n * Target file must be a valid Unattend answer file\n * Target file must be writable",
                    "current": false
                },
                {
                    "versionLabel": "2",
                    "createdBy": "opsware",
                    "createdDate": "2015-08-04T07:29:53.000Z",
                    "usage": "Injects settings for personalization into a Windows setup answer file. Personalization settings include network settings and certain OS settings that are often computer specific like Adminastrator password.\n\nUsage:\n\ninject_personalization_settings.py [OPTIONS] [PATH_TO_FILE]\n\nOptions:\n\n--require-netconfig=[true,false]\n\tSpecify whether a netconfig is mandatory or not.\n\tOptional argument, defaults to false.\n--disableWarning\n    Do not show warnings of old hpsa_netconfig format\n    Optional argument, defaults to false.\n\nYou may specify an alternate path to the Unattend.xml, Unattend.txt, or sysprep.inf file here. This parameter can normally be omitted and the script will use the standard file locations. The file name extension (txt or xml) is used to \ndetermine whether plain text (Windows prior to 2008) or XML (Windows 2008 and newer) processing should be used. The following path locations are checked (in order), and if that file exists, it is updated and no further files are checked. X/Windows/Temp/Unattend.xml (For Windows 2008 OS Media installs), C/Windows/Panther/unattend.xml (For Windows 2008 WIM installs)\n\nPrerequisites:\n * Target file must be a valid Unattend answer file\n * Target file must be writable",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-08-04T07:29:53.000Z",
            "version": {
                "versionLabel": "2",
                "createdBy": "opsware",
                "createdDate": "2015-08-04T07:29:53.000Z",
                "usage": "Injects settings for personalization into a Windows setup answer file. Personalization settings include network settings and certain OS settings that are often computer specific like Adminastrator password.\n\nUsage:\n\ninject_personalization_settings.py [OPTIONS] [PATH_TO_FILE]\n\nOptions:\n\n--require-netconfig=[true,false]\n\tSpecify whether a netconfig is mandatory or not.\n\tOptional argument, defaults to false.\n--disableWarning\n    Do not show warnings of old hpsa_netconfig format\n    Optional argument, defaults to false.\n\nYou may specify an alternate path to the Unattend.xml, Unattend.txt, or sysprep.inf file here. This parameter can normally be omitted and the script will use the standard file locations. The file name extension (txt or xml) is used to \ndetermine whether plain text (Windows prior to 2008) or XML (Windows 2008 and newer) processing should be used. The following path locations are checked (in order), and if that file exists, it is updated and no further files are checked. X/Windows/Temp/Unattend.xml (For Windows 2008 OS Media installs), C/Windows/Panther/unattend.xml (For Windows 2008 WIM installs)\n\nPrerequisites:\n * Target file must be a valid Unattend answer file\n * Target file must be writable",
                "current": true
            },
            "source": "#!/usr/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# lint_ignore=E501,I0011\n# Please do not change the two lines above. See PEP 8, PEP 263.\n#\n\"\"\"\n    (C) Copyright 2009-2015 Hewlett-Packard Development Company, L.P.\n\n    Injects personalization settings into Unattend.xml\n\n    This consists of the following:\n    * The magic custom attributes: ComputerName, ProductKey, AdminPassword\n    * Network settings from the DHCPless feature\n\"\"\"\nimport os\nimport re\nimport sys\nfrom cStringIO import StringIO\n\nfrom osprov.optparse_ext import OptionParser, OptionValueError\nfrom osprov.errors import ShowErrorMessage\nfrom osprov.osbp import ThisTargetServer, logger\nfrom osprov.decorators import HandleShowErrorMessage\nfrom osprov.profile import unattend\nfrom osprov import helpers\nfrom osprov.parsers.netconfig import SmartNetconfig, OLD_SYNTAX_WARNING\nfrom osprov.networking import validation\n\nLOG = logger.getIt(\"inject personalization\")\n\nEC_NO_ERR = 0\nEC_USAGE = 1\nEC_TARGET_SERVER = 5\nEC_NO_CA = 20\nEC_NO_UNATTEND = 12\nEC_EXCEPTION = 100\nUSAGE = \"Usage: %s Unattend_path_in_OGFS\"\n\nHPSA_NETCONFIG = \"\"\"@hpsa_netconfig@\"\"\"\nCOMPUTER_NAME = \"\"\"@ComputerName@\"\"\"\n\n\ndef determineHostname(netinfo):\n    \"\"\" Determin the hotname based on hpsa_netconfig and ComputerName CAs \"\"\"\n    if COMPUTER_NAME and \"@\" not in COMPUTER_NAME:\n        LOG.debug(\"Computer name set from CA %s\", COMPUTER_NAME)\n        return COMPUTER_NAME\n    elif netinfo.hostname:\n        LOG.debug(\"Computer name set from hpsa_netconfig %s\", netinfo.hostname)\n        return netinfo.hostname\n    else:\n        return \"*\"\n\n\ndef getOptions():\n    \"\"\"Returns the command-line options.\"\"\"\n    optparser = OptionParser()\n    optparser.add_option(\"--require-netconfig\", default=\"false\")\n    optparser.add_option(\"--disableWarning\", dest=\"disableWarning\", action=\"store_true\",\n                        default=False,\n                        help=\"Do not show warnings of old hpsa_netconfig format\")\n    (options, args) = optparser.parse_args()\n    if not options.require_netconfig.lower() in (\"true\", \"false\"):\n        raise OptionValueError(\n            \"Invalid value for --require-netconfig: %s.\\nShould be 'true' or 'false'.\")\n    options.require_netconfig = options.require_netconfig.lower() == \"true\"\n    return (options, args)\n\n\ndef injectXmlPersonalization(unattendPathOGFS, netinfo, isIPv6Managed):\n    \"\"\" Inject the personalization in the XML profile \"\"\"\n    provisioningNIC = [x for x in netinfo.nics if x.provisioning][0]\n    print \"Going to provision through interface with MAC address %s\" % provisioningNIC.macAddress\n\n    if isIPv6Managed:\n        if provisioningNIC.ipv6Networks:\n            print \"Configuring boot protocol to: static\"\n            print \"Configuring IPv6 networks: %s\" % str(provisioningNIC.ipv6Networks)\n        elif provisioningNIC.ipv6Autoconfig:\n            print \"Configuring boot protocol to: auto ipv6\"\n        else:\n            print \"Can not complete network personalization. \" \\\n                  \"Auto configuration is turned off for IPv6 and there is no static address defined\"\n            sys.exit(37)\n    else:\n        if provisioningNIC.ipv4Networks:\n            print \"Configuring boot protocol to: static\"\n            print \"Configuring IPv4 networks: %s\" % str(provisioningNIC.ipv4Networks)\n        elif provisioningNIC.dhcpv4:\n            print \"Configuring boot protocol to: dhcp\"\n        else:\n            print \"Can not complete network personalization. \" \\\n                  \"DHCP is turned off for IPv4 and there is no static address defined\"\n            sys.exit(38)\n\n    if not isIPv6Managed and provisioningNIC.ipv4DnsServers:\n        print \"Will use name server(s) %s\" % str(provisioningNIC.ipv4DnsServers)\n    elif isIPv6Managed and provisioningNIC.ipv6DnsServers:\n        print \"Will use name server(s) %s\" % str(provisioningNIC.ipv6DnsServers)\n\n    provisioningRoutes = [iproute for iproute in (netinfo.ipv6Routes if isIPv6Managed else netinfo.ipv4Routes) if iproute.nic == provisioningNIC]\n    provisioningRoute = provisioningRoutes[0] if provisioningRoutes else None\n    if provisioningRoute is not None:\n        print \"Will use default gateway: %s\" % provisioningRoute.gateway\n\n    unattendFile = unattend.Unattend(unattendPathOGFS)\n    unattendFile.addInterface(provisioningNIC, provisioningRoutes, isIPv6Managed)\n    unattendFile.addDns(provisioningNIC, netinfo, isIPv6Managed)\n    unattendFile.replaceComputerNameXml(determineHostname(netinfo))\n\n    return unattendFile.toXml()\n\n\ndef discoverUnattendPath(args):\n    \"\"\" discover the path to the anwser file  \"\"\"\n    if args:\n        return args[0]\n    else:\n        commonPaths = [\n            \"X/Windows/Temp/Unattend.xml\",\n            helpers.getSystemDrive(\"@SystemDrive:C@\") + \"/Windows/Panther/unattend.xml\",\n        ]\n        for unattendPathOGFS in commonPaths:\n            if os.path.isfile(unattendPathOGFS):\n                return unattendPathOGFS\n        raise ShowErrorMessage(USAGE % sys.argv[0] + \"\\n\")\n\n\n@HandleShowErrorMessage(\"Inject Personalizations\", LOG)\ndef main():\n    \"\"\" Main entry point \"\"\"\n\n    options, args = getOptions()\n\n    if not HPSA_NETCONFIG and options.require_netconfig:\n        raise ShowErrorMessage(\n            \"Network configuration (hpsa_netconfig) for this server was not found, even though \\n\" +\n            \"it is required by the value true of the CA require_netconfig.\\n\" +\n            \"Check the hpsa_netconfig custom attribute and verify the target server\\n\" +\n            \"has been configured for static networking.\"\n        )\n\n    targetServer = ThisTargetServer()\n    targetServer.setWorkDir(targetServer.getRemoteRoot())\n    isIPv6Managed = targetServer.isIPv6Managed()\n\n    netconfigParser = SmartNetconfig.readwrite(\n        StringIO(HPSA_NETCONFIG),\n        activeMacAddress=targetServer.getMACAddress(),\n        ipv6default=isIPv6Managed,\n        log=LOG\n    )\n    netinfo = netconfigParser.info()\n    if netinfo.oldSyntax and not options.disableWarning:\n        newFormat = netconfigParser.format()\n        print OLD_SYNTAX_WARNING + \"\\n%s\" % str(newFormat)\n\n    typosList = netconfigParser.getTyposList()\n    if typosList:\n        print(\"The following keys were not recognized in the netconfig CA and could be typos: %s\" % typosList)\n\n    validation.validateProvisioningNIC(netinfo.getProvisioningNIC(), targetServer)\n\n    unattendPathOGFS = discoverUnattendPath(args)\n    profileContents = targetServer.readFile(unattendPathOGFS)\n\n    if unattendPathOGFS.lower().endswith(\".xml\"):\n        profileContents = injectXmlPersonalization(unattendPathOGFS, netinfo, isIPv6Managed)\n    else:\n        print \"Nothing to inject for: %s\" % unattendPathOGFS\n    LOG.debug(\"Using profile:\\n%s\", profileContents)\n    try:\n        targetServer.writeFile(unattendPathOGFS, profileContents)\n    except (IOError, OSError) as why:\n        raise ShowErrorMessage(\"Unable to write unattend file: %s\" % why, cause=why)\nif __name__ == \"__main__\":\n    sys.exit(main())\n",
            "description": "Injects settings for personalization into a Windows setup answer file. Personalization settings include network settings and certain OS settings that are often computer specific like Adminastrator password.\n\nUsage:\n\ninject_personalization_settings.py [OPTIONS] [PATH_TO_FILE]\n\nOptions:\n\n--require-netconfig=[true,false]\n\tSpecify whether a netconfig is mandatory or not.\n\tOptional argument, defaults to false.\n--disableWarning\n    Do not show warnings of old hpsa_netconfig format\n    Optional argument, defaults to false.\n\nYou may specify an alternate path to the Unattend.xml, Unattend.txt, or sysprep.inf file here. This parameter can normally be omitted and the script will use the standard file locations. The file name extension (txt or xml) is used to \ndetermine whether plain text (Windows prior to 2008) or XML (Windows 2008 and newer) processing should be used. The following path locations are checked (in order), and if that file exists, it is updated and no further files are checked. X/Windows/Temp/Unattend.xml (For Windows 2008 OS Media installs), C/Windows/Panther/unattend.xml (For Windows 2008 WIM installs)\n\nPrerequisites:\n * Target file must be a valid Unattend answer file\n * Target file must be writable",
            "status": null,
            "name": "Inject Personalization Settings",
            "state": null,
            "eTag": "2015-08-04T07:29:53.000Z",
            "modified": "2015-08-04T07:29:53.000Z",
            "created": "2015-06-13T04:48:47.000Z",
            "category": "os-deployment-ogfs-scripts",
            "uri": "/rest/os-deployment-ogfs-scripts/520001"
        },
        {
            "codeType": "OGFS",
            "displayCodeType": "OGFS",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "1",
                    "createdBy": "opsware",
                    "createdDate": "2015-06-13T04:48:48.000Z",
                    "usage": "Manipulates the Windows answer file to better integrate it with HP SA features.\n\nUsage:\ninject_required_unattend_xml.py\n\nParameters:\n--WindowsPartitionID='Skip' (doesn't change the <PartitionID> tag from unattend.xml)\n                     'Autodetect' (try to autodetect the the correct partition id and write it to unattend.xml)\n                     a number representing the partition id to be used in unattend.xml\n  If this parameter is not present we have the same behavior as 'Skip' parameter\n--unattend=path to unattend.xml (optional)\n  You may specify an alternate path to the Unattend.xml file here. This parameter can normally be omitted and the script will use the standard file locations. The following path locations are checked (in order), and if that file exists, it is updated and no further files are checked: X/Windows/Temp/Unattend.xml, C/Windows/Panther/unattend.xml\n\nPrerequisites:\n - Target file must be a valid Unattend answer file\n - Target file must be writable",
                    "current": false
                },
                {
                    "versionLabel": "2",
                    "createdBy": "opsware",
                    "createdDate": "2015-08-04T07:30:10.000Z",
                    "usage": "Manipulates the Windows answer file to better integrate it with HP SA features.\n\nUsage:\ninject_required_unattend_xml.py\n\nParameters:\n--WindowsPartitionID='Skip' (doesn't change the <PartitionID> tag from unattend.xml)\n                     'Autodetect' (try to autodetect the the correct partition id and write it to unattend.xml)\n                     a number representing the partition id to be used in unattend.xml\n  If this parameter is not present we have the same behavior as 'Skip' parameter\n--unattend=path to unattend.xml (optional)\n  You may specify an alternate path to the Unattend.xml file here. This parameter can normally be omitted and the script will use the standard file locations. The following path locations are checked (in order), and if that file exists, it is updated and no further files are checked: X/Windows/Temp/Unattend.xml, C/Windows/Panther/unattend.xml\n\nPrerequisites:\n - Target file must be a valid Unattend answer file\n - Target file must be writable",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-08-04T07:30:10.000Z",
            "version": {
                "versionLabel": "2",
                "createdBy": "opsware",
                "createdDate": "2015-08-04T07:30:10.000Z",
                "usage": "Manipulates the Windows answer file to better integrate it with HP SA features.\n\nUsage:\ninject_required_unattend_xml.py\n\nParameters:\n--WindowsPartitionID='Skip' (doesn't change the <PartitionID> tag from unattend.xml)\n                     'Autodetect' (try to autodetect the the correct partition id and write it to unattend.xml)\n                     a number representing the partition id to be used in unattend.xml\n  If this parameter is not present we have the same behavior as 'Skip' parameter\n--unattend=path to unattend.xml (optional)\n  You may specify an alternate path to the Unattend.xml file here. This parameter can normally be omitted and the script will use the standard file locations. The following path locations are checked (in order), and if that file exists, it is updated and no further files are checked: X/Windows/Temp/Unattend.xml, C/Windows/Panther/unattend.xml\n\nPrerequisites:\n - Target file must be a valid Unattend answer file\n - Target file must be writable",
                "current": true
            },
            "source": "#!/usr/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n\"\"\"\n    (C) Copyright 2012-2015 Hewlett-Packard Development Company, L.P.\n\"\"\"\n\nimport sys\nimport os\n\nfrom optparse import OptionError\nfrom osprov.profile import unattend\nfrom osprov.optparse_ext import OptionParser\nfrom osprov.osbp import ThisTargetServer, logger\nfrom osprov.decorators import HandleShowErrorMessage\nfrom osprov.errors import ShowErrorMessage, NotFoundError\nfrom osprov import helpers\n\n\n# pylint: disable=F0401,E0611\nfrom pytwist.com.opsware.custattr import NoSuchFieldException\n# pylint: enable=F0401,E0611\n\nLOG = logger.getIt(\"inject required unattend\")\n\nUSAGE = \"Usage: %s Unattend_path_in_OGFS\"\nEC_EXCEPTION = 100\nSYSTEM_DISK_NUMBER_CA = \"\"\"@SystemDiskNumber@\"\"\"\nWINDOWS_PARTITION_ID_CA = \"\"\"@WindowsPartitionID@\"\"\"\n\n\nclass InjectRequiredUnattendOptionParser(OptionParser):\n    \"\"\" Option parser for this step \"\"\"\n\n    def defineOptions(self):\n        self.add_option(\"--WindowsPartitionID\", type=\"string\",\n                        help=\"Specifies how to handle <PartitionID> tag from unattend.xml\"\n                             \"Arguments:\"\n                             \"--WindowsPartitionID=Skip : doesn't change the <PartitionID> tag from unattend.xml\"\n                             \"--WindowsPartitionID=Autodetect : try to autodetect the the correct partition id and write it to unattend.xml\"\n                             \"--WindowsPartitionID=1 : a number representing the partition id to be used in unattend.xml\")\n        self.add_option(\"--unattend\", type=\"string\",\n                        help=\"Specify the path to unattend.xml file\")\n\n    def validateArgs(self, opt, args):\n        if opt.WindowsPartitionID:\n            validArgument = False\n            if opt.WindowsPartitionID.isdigit():\n                validArgument = True\n            if opt.WindowsPartitionID.lower() in ['skip', 'autodetect']:\n                validArgument = True\n            if not validArgument:\n                raise OptionError(\n                    \"Invalid value for '--WindowsPartitionID' \" + opt.WindowsPartitionID, \"WindowsPartitionID\")\n\n\ndef handleCredentials(targetServer):\n    \"\"\" Persist the credentials to access the server \"\"\"\n    keys = helpers.getDataStore(targetServer)\n    keys.profile.username = \"@DomainName@\\\\@DomainUser@\"\n    keys.profile.password = \"@DomainPassword@\"\n    helpers.putDataStore(keys, targetServer)\n\n\ndef injectWindowsPartitionId(targetServer, unattendFilePath, options):\n    partitionId = None\n\n    # check if we have to change <PartitionID> tag\n    if not options.WindowsPartitionID:\n        return\n    if options.WindowsPartitionID.lower() == \"skip\":\n        return\n\n    # check if we have to autodetect the partition id\n    if options.WindowsPartitionID.lower() == \"autodetect\":\n        # get partitionId from datastore\n        datastore = helpers.getDataStore(targetServer=targetServer, log=LOG)\n        if datastore.windows.partition_id:\n            partitionId = datastore.windows.partition_id\n        else:\n            raise ShowErrorMessage(\n                \"Unable to autodetect Windows Partition Id\", EC_EXCEPTION)\n\n    # check if client provided to us the partition id\n    if options.WindowsPartitionID.isdigit():\n        partitionId = options.WindowsPartitionID\n\n    if partitionId == None:\n        raise ShowErrorMessage(\n            \"No valid value for Windows Partition Id\", EC_EXCEPTION)\n\n    # replace PartitionID\n    try:\n        unattendFile = unattend.Unattend(unattendFilePath)\n        unattendFile.replacePartitionIdXml(partitionId)\n        targetServer.writeFile(unattendFilePath, unattendFile.toXml())\n    except OSError, error:\n        LOG.exception(error)\n        raise ShowErrorMessage(\n            \"Unable to update answer file over OGFS. %s\" % error.args[0], EC_EXCEPTION)\n    except IOError, error:\n        LOG.exception(error)\n        raise ShowErrorMessage(\n            \"Unable to update answer file over OGFS. %s\" % error.args[0], EC_EXCEPTION)\n\n\ndef handleProductKey(targetServer, unattendFilePath):\n    try:\n        unattendFile = unattend.Unattend(unattendFilePath)\n        trimmed = unattendFile.trimProductKey()\n        if trimmed:\n            print \"Warning: Whitespaces were removed from the product key.\"\n        unattendFile.validateProductKeyThroughUnattend()\n        targetServer.writeFile(unattendFilePath, unattendFile.toXml())\n    except NotFoundError as error:\n        LOG.exception(error)\n    except OSError as error:\n        LOG.exception(error)\n        raise ShowErrorMessage(\n            \"Unable to update answer file over OGFS. %s\" % error.args[0], EC_EXCEPTION)\n    except IOError as error:\n        LOG.exception(error)\n        raise ShowErrorMessage(\n            \"Unable to update answer file over OGFS. %s\" % error.args[0], EC_EXCEPTION)\n\n\ndef handleDiskIdChange(targetServer, unattendFilePath):\n    # get partitionId from datastore\n    datastore = helpers.getDataStore(targetServer=targetServer, log=LOG)\n    if datastore.windows.disk_id is None:\n        return\n    diskId = datastore.windows.disk_id\n    # replace DiskId\n    try:\n        unattendFile = unattend.Unattend(unattendFilePath)\n        unattendFile.replaceDiskId(diskId)\n        targetServer.writeFile(unattendFilePath, unattendFile.toXml())\n    except OSError, error:\n        LOG.exception(error)\n        raise ShowErrorMessage(\n            \"Unable to update answer file over OGFS. %s\" % error.args[0], EC_EXCEPTION)\n    except IOError, error:\n        LOG.exception(error)\n        raise ShowErrorMessage(\n            \"Unable to update answer file over OGFS. %s\" % error.args[0], EC_EXCEPTION)\n\n\ndef handleUnattendXML(targetServer, options):\n    targetServer.setWorkDir(targetServer.getRemoteRoot())\n    if not options.unattend:\n        discoveredDefault = False\n        commonPaths = []\n        commonPaths.append(\"X/Windows/Temp/Unattend.xml\")  # 2012 OS Media\n        commonPaths.append(\"@SystemDrive:C@/Windows/Panther/unattend.xml\")  # 2012 WIM\n        for unattendPathOGFS in commonPaths:\n            if os.path.isfile(unattendPathOGFS):\n                discoveredDefault = True\n                break\n        if not discoveredDefault:\n            raise ShowErrorMessage(USAGE % sys.argv[0] + \"\\n\")\n    else:\n        unattendPathOGFS = options.unattend\n\n    # inject the proper \"<PartitionId>?</PartitionId>\" if necessary\n    injectWindowsPartitionId(targetServer, unattendPathOGFS, options)\n    # inject the proper \"<DiskID>?</DiskID>\" if necessary\n    handleProductKey(targetServer, unattendPathOGFS)\n    handleDiskIdChange(targetServer, unattendPathOGFS)\n    # do cleanup in unattend.xml\n    cleanUnattendXML(targetServer, unattendPathOGFS)\n\n\ndef cleanUnattendXML(targetServer, unattendPathOGFS):\n    try:\n        profile = unattend.Unattend(unattendPathOGFS)\n        cleanEmptyElementsXML(profile)\n        targetServer.writeFile(unattendPathOGFS, profile.toXml())\n    except OSError, error:\n        LOG.exception(error)\n        raise ShowErrorMessage(\n            \"Unable to update answer file over OGFS. %s\" % error.args[0], EC_EXCEPTION)\n    except IOError, error:\n        LOG.exception(error)\n        raise ShowErrorMessage(\n            \"Unable to update answer file over OGFS. %s\" % error.args[0], EC_EXCEPTION)\n\n\ndef cleanEmptyElementsXML(profile):\n    settings = profile.doc.getElementsByTagName(\"settings\")\n    nodes_under_specialize_pass = profile._getNodeListByNameValue(settings, \"pass\", \"specialize\")\n    if nodes_under_specialize_pass:\n        specialize_node = nodes_under_specialize_pass[0].parentNode\n        profile.removeEmptyElements(specialize_node)\n    return profile.toXml()\n\n\n@HandleShowErrorMessage(\"Inject Required Unattend\", LOG)\ndef main():\n    \"\"\" main entry point in the script \"\"\"\n\n    # get and parse arguments\n    options, remainingArgs = InjectRequiredUnattendOptionParser().parse_args()\n\n    targetServer = ThisTargetServer()\n    handleCredentials(targetServer)\n    handleUnattendXML(targetServer, options)\n\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n",
            "description": "Manipulates the Windows answer file to better integrate it with HP SA features.\n\nUsage:\ninject_required_unattend_xml.py\n\nParameters:\n--WindowsPartitionID='Skip' (doesn't change the <PartitionID> tag from unattend.xml)\n                     'Autodetect' (try to autodetect the the correct partition id and write it to unattend.xml)\n                     a number representing the partition id to be used in unattend.xml\n  If this parameter is not present we have the same behavior as 'Skip' parameter\n--unattend=path to unattend.xml (optional)\n  You may specify an alternate path to the Unattend.xml file here. This parameter can normally be omitted and the script will use the standard file locations. The following path locations are checked (in order), and if that file exists, it is updated and no further files are checked: X/Windows/Temp/Unattend.xml, C/Windows/Panther/unattend.xml\n\nPrerequisites:\n - Target file must be a valid Unattend answer file\n - Target file must be writable",
            "status": null,
            "name": "Inject Required Unattend.xml Settings",
            "state": null,
            "eTag": "2015-08-04T07:30:10.000Z",
            "modified": "2015-08-04T07:30:10.000Z",
            "created": "2015-06-13T04:48:48.000Z",
            "category": "os-deployment-ogfs-scripts",
            "uri": "/rest/os-deployment-ogfs-scripts/530001"
        },
        {
            "codeType": "OGFS",
            "displayCodeType": "OGFS",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "1",
                    "createdBy": "opsware",
                    "createdDate": "2015-06-13T04:48:49.000Z",
                    "usage": "Boots a target server into the user selected Service OS, with the goal of reaching MAINTENANCE state.\nNote that it will reboot the target server, so it should be followed by a \"Wait for HPSA Agent\" step.\n\nUsage: boot.py --serviceOS='SERVICE_OS' [--method='METHOD'] [--force] [--ipv6] [--disableWarning]\n\n --serviceOS: it represents the Service OS into which to boot; See the method parameter for the supported Service OSs.\n --method: the boot method to be used. Possible values:\n            auto\n                - it will behave as embedded or network, depending on the target server\n            embedded\n                - supported only if the IloService is enabled on the target server and this is a HP ProLiant Gen8 or newer\n                - the following service OSs are possible: linux, linux64, linux64_6, linux64_7 linux32, winpe32, winpe64, winpe64_40\n            network\n                - configures PXE network booting into the selected Service OS\n                - specifying an ogfs PXE-option as the Service OS is supported\n                - if the IloService is enabled on the target server it will also set the one time boot option to NETWORK\n --force: Forces the boot configuration and reboot of the target server.\n --ipv6: Boots into an IPv6 Service OS\n --disableWarning: Do not show warnings of old hpsa_netconfig format\n\n For ProLiant servers only:\n If using --serviceOS=linux or linux64 the Service OS will be determined upon the version of iLO:\n        - if iLO version < 4 (regardless of --method option): will boot in linux64_6\n        - if iLO version = 4 and --method=auto: will boot in embedded service OS\n        - if iLO version = 4 and --method=network: will boot in linux64_7",
                    "current": false
                },
                {
                    "versionLabel": "2",
                    "createdBy": "opsware",
                    "createdDate": "2015-08-04T07:30:26.000Z",
                    "usage": "Boots a target server into the user selected Service OS, with the goal of reaching MAINTENANCE state.\nNote that it will reboot the target server, so it should be followed by a \"Wait for HPSA Agent\" step.\n\nUsage: boot.py --serviceOS='SERVICE_OS' [--method='METHOD'] [--force] [--ipv6] [--disableWarning]\n\n --serviceOS: it represents the Service OS into which to boot; See the method parameter for the supported Service OSs.\n --method: the boot method to be used. Possible values:\n            auto\n                - it will behave as embedded or network, depending on the target server\n            embedded\n                - supported only if the IloService is enabled on the target server and this is a HP ProLiant Gen8 or newer\n                - the following service OSs are possible: linux, linux64, linux64_6, linux64_7 linux32, winpe32, winpe64, winpe64_40\n            network\n                - configures PXE network booting into the selected Service OS\n                - specifying an ogfs PXE-option as the Service OS is supported\n                - if the IloService is enabled on the target server it will also set the one time boot option to NETWORK\n --force: Forces the boot configuration and reboot of the target server.\n --ipv6: Boots into an IPv6 Service OS\n --disableWarning: Do not show warnings of old hpsa_netconfig format\n\n For ProLiant servers only:\n If using --serviceOS=linux or linux64 the Service OS will be determined upon the version of iLO:\n        - if iLO version < 4 (regardless of --method option): will boot in linux64_6\n        - if iLO version = 4 and --method=auto: will boot in embedded service OS\n        - if iLO version = 4 and --method=network: will boot in linux64_7",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-08-04T07:30:26.000Z",
            "version": {
                "versionLabel": "2",
                "createdBy": "opsware",
                "createdDate": "2015-08-04T07:30:26.000Z",
                "usage": "Boots a target server into the user selected Service OS, with the goal of reaching MAINTENANCE state.\nNote that it will reboot the target server, so it should be followed by a \"Wait for HPSA Agent\" step.\n\nUsage: boot.py --serviceOS='SERVICE_OS' [--method='METHOD'] [--force] [--ipv6] [--disableWarning]\n\n --serviceOS: it represents the Service OS into which to boot; See the method parameter for the supported Service OSs.\n --method: the boot method to be used. Possible values:\n            auto\n                - it will behave as embedded or network, depending on the target server\n            embedded\n                - supported only if the IloService is enabled on the target server and this is a HP ProLiant Gen8 or newer\n                - the following service OSs are possible: linux, linux64, linux64_6, linux64_7 linux32, winpe32, winpe64, winpe64_40\n            network\n                - configures PXE network booting into the selected Service OS\n                - specifying an ogfs PXE-option as the Service OS is supported\n                - if the IloService is enabled on the target server it will also set the one time boot option to NETWORK\n --force: Forces the boot configuration and reboot of the target server.\n --ipv6: Boots into an IPv6 Service OS\n --disableWarning: Do not show warnings of old hpsa_netconfig format\n\n For ProLiant servers only:\n If using --serviceOS=linux or linux64 the Service OS will be determined upon the version of iLO:\n        - if iLO version < 4 (regardless of --method option): will boot in linux64_6\n        - if iLO version = 4 and --method=auto: will boot in embedded service OS\n        - if iLO version = 4 and --method=network: will boot in linux64_7",
                "current": true
            },
            "source": "#!/usr/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n\"\"\"\n    (C) Copyright 2013-2015 Hewlett-Packard Development Company, L.P.\n\n    This python script tries to boot a machine into the user selected Service OS.\n\"\"\"\n\nimport sys\nfrom cStringIO import StringIO\n\nfrom osprov import boot\nfrom osprov.optparse_ext import OptionParser\nfrom osprov.decorators import HandleShowErrorMessage\nfrom osprov.parsers.netconfig import SmartNetconfig, OLD_SYNTAX_WARNING\nfrom osprov.osbp import ThisTargetServer, logger\nfrom osprov.power import getPowerController\nfrom osprov.errors import PowerControlException\nfrom osprov.boot import OTBNotSupportedError, NetworkBootController\nfrom osprov.osbp.TargetServer import GaiusWinPETargetServer, SlesSOSTargetServer\n\n\nfrom pytwist.com.opsware.common import OpswareException, OpswareSystemException\n\nlog = logger.getIt(\"Boot\")\n\nEC_OK = 0\nEC_INVALID_ARGS = 1\nEC_UNSUPPORTED = 2\nEC_FAILED_BOOT = 3\nEC_FAILED_BOOT_SETUP = 4\nEC_FAILED_POWER_OFF = 5\n\nHPSA_NETCONFIG = \"\"\"@hpsa_netconfig@\"\"\"\nREQUIRE_NETCONFIG = \"@require_netconfig:false@\"\n\n\nclass BootStepOptionsParser(OptionParser):\n\n    def defineOptions(self):\n        self.add_option(\"--serviceOS\",\n                        help=\"The Service OS to boot into.\"\n                        \"Possible options: linux32, linux64 (linux), linux64_6, linux64_7, winpe32, winpe64 (winpe), winpe64_40, solaris\")\n        self.add_option(\"--method\", default=\"auto\",\n                        help=\"it represents the boot method to be used.\")\n        self.add_option(\"--force\", action=\"store_true\", default=False,\n                        help=\"Forces the boot configuration and reboot of the target server.\")\n        self.add_option(\"--ipv6\", action=\"store_true\", default=False,\n                        help=\"Starts the selected Service OS in IPv6 mode\")\n        self.add_option(\"--disableWarning\", dest=\"disableWarning\", action=\"store_true\",\n                        default=False,\n                        help=\"Do not show warnings of old hpsa_netconfig format\")\n\n\ndef isSameStack(targetServer, ipv6Opt):\n    return targetServer.isIPv6Managed(cached=False) == ipv6Opt\n\n\ndef isSameBootMethod(targetServer, bootMethod):\n    return (\"embedded\"\n            if isinstance(targetServer, GaiusWinPETargetServer) or\n            isinstance(targetServer, SlesSOSTargetServer) else\n            \"network\") == bootMethod\n\n\ndef isSameArch(targetServer, serviceOS):\n    return targetServer.is64bit(cached=False) == (\"32\" not in serviceOS)\n\n\ndef isSameOS(targetServer, bootcontroller, serviceOS):\n    if isinstance(bootcontroller, NetworkBootController):\n        serviceOS = bootcontroller.getPXEOptionForServiceOS(serviceOS)\n    if (\"linux\" in serviceOS) and (\"linux\" in targetServer.PXEOption):\n        return (\"7\" in serviceOS and \"7\" in targetServer.PXEOption) or \\\n               (not \"7\" in serviceOS and not \"7\" in targetServer.PXEOption)\n    else:\n        # it's ok to not differentiate winpe64 from winpe64_40\n        return serviceOS[:5] in targetServer.PXEOption\n\n\ndef shouldSkip(targetServer, bootcontroller, options):\n    return isSameOS(targetServer, bootcontroller, options.serviceOS) \\\n           and isSameStack(targetServer, options.ipv6) \\\n           and isSameBootMethod(targetServer, bootcontroller.getName()) \\\n           and isSameArch(targetServer, options.serviceOS) \\\n           and not options.force\n\n\n@HandleShowErrorMessage(\"boot target server\", log)\ndef main():\n    \"\"\" build plan script to boot the target system \"\"\"\n    parser = BootStepOptionsParser()\n    options, args = parser.parse_args()\n\n    serviceOS = options.serviceOS\n    method = options.method\n\n    targetServer = ThisTargetServer()\n\n    print(\"Boot method: \" + method)\n    bootController = boot.getBootController(targetServer, serviceOS=serviceOS,\n                                            ipv6=options.ipv6, method=method, log=log)\n\n    if targetServer.isMaintenance():\n        if not targetServer.isAccessible():\n            print \"The target server is in MAINTENANCE but not accessible, continuing...\"\n        elif shouldSkip(targetServer, bootController, options):\n            print \"Skipping boot configuration, the target server is booted into the same Service OS with the same architecture, IP stack and boot method.\"\n            return EC_OK\n\n    powerController = getPowerController(targetServer, log=log)\n    try:\n        # powering off so that the running system would not interfere with changing system settings\n        if not targetServer.isAgentListening():\n            print (\"Agent is unreachable. Powering off server...\")\n            powerController.poweroff()\n    except PowerControlException, why:\n        log.exception(why)\n        sys.stderr.write(\"Failed to power off server: %s\" % str(why))\n        return EC_FAILED_POWER_OFF\n\n    try:\n        print(\"Configuring boot to Service OS: %s\" % serviceOS)\n        netconfigParser = SmartNetconfig.readwrite(StringIO(HPSA_NETCONFIG),\n                                                   activeMacAddress=None,\n                                                   ipv6default=targetServer.isIPv6Managed(),\n                                                   log=log)\n        netconfig = netconfigParser.info()\n        if netconfig.oldSyntax and not options.disableWarning:\n            newFormat = netconfigParser.format()\n            print OLD_SYNTAX_WARNING + \"\\n%s\" % str(newFormat)\n\n        typosList = netconfigParser.getTyposList()\n        if typosList:\n            print(\"The following keys were not recognized in the hpsa_netconfig custom attribute and could be typos: %s\" % typosList)\n\n        try:\n            bootController.configureBoot(serviceOS, netconfig, ipv6=options.ipv6)\n        except OTBNotSupportedError as why:\n            log.exception(why)\n            print('Warning: The server needs to boot from the network, but no suitable management path was found to set '\n                  'one time boot. Ensure that \"Network\" is set first in the boot order if it fails')\n\n        print(\"Rebooting the target server...\")\n        targetServer.reboot(powerController)\n    except (OpswareException, OpswareSystemException), why:\n        log.exception(why)\n        sys.stderr.write(\"Failed to boot:\\n%s\\n\" % str(why))\n        return EC_FAILED_BOOT\n    return EC_OK\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n",
            "description": "Boots a target server into the user selected Service OS, with the goal of reaching MAINTENANCE state.\nNote that it will reboot the target server, so it should be followed by a \"Wait for HPSA Agent\" step.\n\nUsage: boot.py --serviceOS='SERVICE_OS' [--method='METHOD'] [--force] [--ipv6] [--disableWarning]\n\n --serviceOS: it represents the Service OS into which to boot; See the method parameter for the supported Service OSs.\n --method: the boot method to be used. Possible values:\n            auto\n                - it will behave as embedded or network, depending on the target server\n            embedded\n                - supported only if the IloService is enabled on the target server and this is a HP ProLiant Gen8 or newer\n                - the following service OSs are possible: linux, linux64, linux64_6, linux64_7 linux32, winpe32, winpe64, winpe64_40\n            network\n                - configures PXE network booting into the selected Service OS\n                - specifying an ogfs PXE-option as the Service OS is supported\n                - if the IloService is enabled on the target server it will also set the one time boot option to NETWORK\n --force: Forces the boot configuration and reboot of the target server.\n --ipv6: Boots into an IPv6 Service OS\n --disableWarning: Do not show warnings of old hpsa_netconfig format\n\n For ProLiant servers only:\n If using --serviceOS=linux or linux64 the Service OS will be determined upon the version of iLO:\n        - if iLO version < 4 (regardless of --method option): will boot in linux64_6\n        - if iLO version = 4 and --method=auto: will boot in embedded service OS\n        - if iLO version = 4 and --method=network: will boot in linux64_7",
            "status": null,
            "name": "Boot",
            "state": null,
            "eTag": "2015-08-04T07:30:26.000Z",
            "modified": "2015-08-04T07:30:26.000Z",
            "created": "2015-06-13T04:48:49.000Z",
            "category": "os-deployment-ogfs-scripts",
            "uri": "/rest/os-deployment-ogfs-scripts/560001"
        },
        {
            "codeType": "OGFS",
            "displayCodeType": "OGFS",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "1",
                    "createdBy": "opsware",
                    "createdDate": "2015-06-13T04:48:50.000Z",
                    "usage": "Creates a checkpoint by saving the current step into the 'CurrentStepCheckpoint' or the given custom attribute on the server. An existing checkpoint will be overwritten.\n\nusage: create_checkpoint.py [-h] [--name NAME]\n\noptional arguments:\n  -h, --help   show this help message and exit\n  --name NAME  Name of the custom attribute to use. Defaults to\n               'CurrentStepCheckpoint'",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-06-13T04:48:50.000Z",
            "version": {
                "versionLabel": "1",
                "createdBy": "opsware",
                "createdDate": "2015-06-13T04:48:50.000Z",
                "usage": "Creates a checkpoint by saving the current step into the 'CurrentStepCheckpoint' or the given custom attribute on the server. An existing checkpoint will be overwritten.\n\nusage: create_checkpoint.py [-h] [--name NAME]\n\noptional arguments:\n  -h, --help   show this help message and exit\n  --name NAME  Name of the custom attribute to use. Defaults to\n               'CurrentStepCheckpoint'",
                "current": true
            },
            "source": "#!/usr/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n\"\"\"\n    (C) Copyright 2014-2015 Hewlett-Packard Development Company, L.P.\n\"\"\"\n\nimport os\nimport sys\nfrom argparse import ArgumentParser\nfrom types import StringType\n\nfrom osprov.osbp import ThisTargetServer\n\nCURRENT_STEP_CHECKPOINT_CA = \"CurrentStepCheckpoint\"\n\n\ndef getCurrentStep():\n    return long(os.environ[\"CURRENT_STEP_NO\"])\n\n\ndef main():\n    argsParser = ArgumentParser()\n    argsParser.add_argument(\"--name\", type=StringType, metavar=\"NAME\",\n                            default=CURRENT_STEP_CHECKPOINT_CA,\n                            help=\"Name of the custom attribute to use. \"\n                            \"Defaults to '%s'\" % CURRENT_STEP_CHECKPOINT_CA)\n    args = argsParser.parse_args()\n\n    currentStep = getCurrentStep()\n    ThisTargetServer().writeCustomAttribute(args.name, str(currentStep))\n    print \"Created checkpoint '%s' to step %d \" % (args.name, currentStep)\n\n\nif __name__ == \"__main__\":\n    sys.exit(main())",
            "description": "Creates a checkpoint by saving the current step into the 'CurrentStepCheckpoint' or the given custom attribute on the server. An existing checkpoint will be overwritten.\n\nusage: create_checkpoint.py [-h] [--name NAME]\n\noptional arguments:\n  -h, --help   show this help message and exit\n  --name NAME  Name of the custom attribute to use. Defaults to\n               'CurrentStepCheckpoint'",
            "status": null,
            "name": "Create Checkpoint",
            "state": null,
            "eTag": "2015-06-13T04:48:50.000Z",
            "modified": "2015-06-13T04:48:50.000Z",
            "created": "2015-06-13T04:48:50.000Z",
            "category": "os-deployment-ogfs-scripts",
            "uri": "/rest/os-deployment-ogfs-scripts/580001"
        },
        {
            "codeType": "OGFS",
            "displayCodeType": "OGFS",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "1",
                    "createdBy": "opsware",
                    "createdDate": "2015-06-13T04:48:51.000Z",
                    "usage": "This step further inject windows active directory domain or workgroup related configuration into windows unattend file. \nThis is supported only from Windows Server 2008 onwards. \n\nIt requires 4 self-explanatory inputs - DomainName, DomainUser, DomainPassword, Workgroup. \nThe first 3 and the last one are mutually exclusive. The step reads these values using custom attributes with same names. \n\nUsage:\n\ninject_domain_workgroup_unattend.py [PATH_TO_FILE]\n\nwhere PATH_TO_FILE is the OGFS path or absolute path on the target server to the Unattend.xml file. You may omit this parameter, in which case the script automatically looks for an existing file at \"X:\\Windows\\Temp\\Unattend.txt\".\n\nThe current required settings include:\n\n * Unattended/OemPreInstall must be yes\n \nPrerequisites:\n * Target file must be a valid answer file\n * Target file must be writable\n * The target server should have the DomainName, DomainUser, DomainPassword custom attributes set to configure Windows Domain.\n * The target server should have the WorkGroup custom attributes set to configure WorkGroup.",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-06-13T04:48:51.000Z",
            "version": {
                "versionLabel": "1",
                "createdBy": "opsware",
                "createdDate": "2015-06-13T04:48:51.000Z",
                "usage": "This step further inject windows active directory domain or workgroup related configuration into windows unattend file. \nThis is supported only from Windows Server 2008 onwards. \n\nIt requires 4 self-explanatory inputs - DomainName, DomainUser, DomainPassword, Workgroup. \nThe first 3 and the last one are mutually exclusive. The step reads these values using custom attributes with same names. \n\nUsage:\n\ninject_domain_workgroup_unattend.py [PATH_TO_FILE]\n\nwhere PATH_TO_FILE is the OGFS path or absolute path on the target server to the Unattend.xml file. You may omit this parameter, in which case the script automatically looks for an existing file at \"X:\\Windows\\Temp\\Unattend.txt\".\n\nThe current required settings include:\n\n * Unattended/OemPreInstall must be yes\n \nPrerequisites:\n * Target file must be a valid answer file\n * Target file must be writable\n * The target server should have the DomainName, DomainUser, DomainPassword custom attributes set to configure Windows Domain.\n * The target server should have the WorkGroup custom attributes set to configure WorkGroup.",
                "current": true
            },
            "source": "#!/usr/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n#\n\"\"\"\n    (C) Copyright 2009-2015 Hewlett-Packard Development Company, L.P.\n\n    Injects personalization settings specific to Domain and WorkGroup into Unattend.xml\n\n    This consists of the following:\n    * The magic custom attributes: DomainName, DomainUser, DomainPassword, WorkGroup\n\"\"\"\nimport os\nimport sys\n\nfrom osprov.profile import unattend\nfrom osprov.errors import ShowErrorMessage\nfrom osprov.osbp import ThisTargetServer, logger\nfrom osprov.decorators import HandleShowErrorMessage\nfrom osprov import helpers\n\nLOG = logger.getIt(\"inject domain or workgroup\")\n\nEC_NO_ERR = 0\nEC_USAGE = 1\nEC_TARGET_SERVER = 5\nEC_NO_CA = 20\nEC_NO_UNATTEND = 12\nEC_EXCEPTION = 100\nEC_NOT_SUPPORTED = 21\nUSAGE = \"Usage: %s Unattend_path_in_OGFS\"\n\n\ndef _open(filePath, fileMode=\"r\"):\n    return open(filePath, fileMode)\n\n\ndef injectXML(unattendFile):\n    \"\"\"inject into XML \"\"\"\n\n    # Check for the specialize pass. This is not a required pass.\n    settings = unattendFile.doc.getElementsByTagName(\"settings\")\n    nodes_under_specialize_pass = unattendFile._getNodeListByNameValue(\n        settings, \"pass\", \"specialize\")\n\n    if not nodes_under_specialize_pass:\n        # There is no specialize_pass. We must create everything.\n        specialize_node = unattendFile.createSpecializePass()\n        # Put <settings pass=\"specialize\"> inside of <unattend>\n        settings[0].parentNode.appendChild(specialize_node)\n    else:\n        specialize_node = nodes_under_specialize_pass[0].parentNode\n\n    #...\n    specialize_components = specialize_node.getElementsByTagName(\"component\")\n    component = unattendFile.domainOrWorkGroupConfiguration(\n        \"\"\"@DomainName@\"\"\", \"\"\"@DomainUser@\"\"\", \"\"\"@DomainPassword@\"\"\", \"\"\"@WorkGroup@\"\"\")\n    specialize_node.appendChild(component)\n\n    # QC 151176 - specialize phases will fail if there are empty elements, for some known elements.\n    unattendFile.removeEmptyElements(specialize_node)\n\n\ndef injectDomainWorkGroupSettings(targetServer, unattendPathOGFS):\n    \"\"\" Do the injecting \"\"\"\n    unattendPathOGFS = targetServer.expandEnvVars(unattendPathOGFS)\n    unattendPathOGFS = targetServer.pathToOGFS(unattendPathOGFS)\n    if not os.path.isfile(unattendPathOGFS):\n        raise ShowErrorMessage(\"Could not find Unattend file at %s.\" %\n                               unattendPathOGFS, EC_NO_UNATTEND)\n    #\"\"\"This step will only support Windows 2008 or higher as it only supports xml\"\"\"\n    if unattendPathOGFS[-3:].lower() == \"xml\":\n        unattendFile = unattend.Unattend(unattendPathOGFS)\n        injectXML(unattendFile)\n        fileData = unattendFile.toXml()\n    else:\n        raise ShowErrorMessage(\n            \"Not supported type of Unattend file.\", EC_NOT_SUPPORTED)\n\n    try:\n        outFile = _open(unattendPathOGFS, \"w\")\n        outFile.write(fileData)\n        outFile.close()\n        print \"Answer file at '%s' successfully updated\\n\" % unattendPathOGFS\n    except OSError, error:\n        raise ShowErrorMessage(\n            \"Unable to write updated answer file over OGFS. %s. \" % error, EC_EXCEPTION)\n\n\n@HandleShowErrorMessage(\"Inject Domain or Workgroup\", LOG)\ndef main():\n    \"\"\" Main entry point \"\"\"\n    targetServer = ThisTargetServer()\n    targetServer.setWorkDir(targetServer.getRemoteRoot())\n\n    unattendPathOGFS = None\n    if len(sys.argv) < 2:\n        discoveredDefault = False\n        commonPaths = []\n        commonPaths.append(\"X/Windows/Temp/Unattend.xml\")  # 2008 OS Media\n        commonPaths.append(helpers.getSystemDrive(\n            \"@SystemDrive:C@\") + \"/Windows/Panther/unattend.xml\")  # 2008 WIM\n        for unattendPathOGFS in commonPaths:\n            if os.path.isfile(unattendPathOGFS):\n                discoveredDefault = True\n                break\n        if not discoveredDefault:\n            raise ShowErrorMessage(USAGE % sys.argv[0] + \"\\n\")\n    else:\n        unattendPathOGFS = sys.argv[1]\n    injectDomainWorkGroupSettings(targetServer, unattendPathOGFS)\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n",
            "description": "This step further inject windows active directory domain or workgroup related configuration into windows unattend file. \nThis is supported only from Windows Server 2008 onwards. \n\nIt requires 4 self-explanatory inputs - DomainName, DomainUser, DomainPassword, Workgroup. \nThe first 3 and the last one are mutually exclusive. The step reads these values using custom attributes with same names. \n\nUsage:\n\ninject_domain_workgroup_unattend.py [PATH_TO_FILE]\n\nwhere PATH_TO_FILE is the OGFS path or absolute path on the target server to the Unattend.xml file. You may omit this parameter, in which case the script automatically looks for an existing file at \"X:\\Windows\\Temp\\Unattend.txt\".\n\nThe current required settings include:\n\n * Unattended/OemPreInstall must be yes\n \nPrerequisites:\n * Target file must be a valid answer file\n * Target file must be writable\n * The target server should have the DomainName, DomainUser, DomainPassword custom attributes set to configure Windows Domain.\n * The target server should have the WorkGroup custom attributes set to configure WorkGroup.",
            "status": null,
            "name": "Inject Windows Domain or Workgroup Personalization Settings",
            "state": null,
            "eTag": "2015-06-13T04:48:51.000Z",
            "modified": "2015-06-13T04:48:51.000Z",
            "created": "2015-06-13T04:48:50.000Z",
            "category": "os-deployment-ogfs-scripts",
            "uri": "/rest/os-deployment-ogfs-scripts/590001"
        },
        {
            "codeType": "OGFS",
            "displayCodeType": "OGFS",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "1",
                    "createdBy": "opsware",
                    "createdDate": "2015-06-13T04:48:51.000Z",
                    "usage": "Step to hide or unhide the Virtual Installation Device (VID) of HP ProLiant Gen8 devices.\nWhen the BIOS setting for the VID is set to its default \"Hidden\" this is handled automatically.\nWhen using SA functionality based on iLO and a Gen8-specific Intelligent Provisioning service OS (Linux or Windows PE) the VID is visible during the execution of the embedded Service OS.\nTo prevent OS installations from trying to install the OS to the VID, this step can be used early in the build plan. It uses the hponcfg utility.\n\nWhile this build plan step is specific to HP ProLiant Gen8 servers, it will not fail on non HP ProLiant Gen8\ntargets when used with the default settings. (See parameters below)\n\nUsage:\n   [-s | --strict ] [-h | --hideVID ] [-u | --unhideVID ]\n\nWhere:\n   -s | --strict \n      HP ProLiant VID handling errors are treated as fatal errors\n   -h | --hideVID\n      Hide HP ProLiant VID\n   -u | --unhideVID\n      Unhide HP ProLiant VID\n      This step has no default behavior.\n      Exactly one of the options -h (--hideVID) or -u (--unhideVID) must be used\n\nPrerequisites:\n- Target servers runs a maintenance Linux or Windows PE OS.",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-06-13T04:48:51.000Z",
            "version": {
                "versionLabel": "1",
                "createdBy": "opsware",
                "createdDate": "2015-06-13T04:48:51.000Z",
                "usage": "Step to hide or unhide the Virtual Installation Device (VID) of HP ProLiant Gen8 devices.\nWhen the BIOS setting for the VID is set to its default \"Hidden\" this is handled automatically.\nWhen using SA functionality based on iLO and a Gen8-specific Intelligent Provisioning service OS (Linux or Windows PE) the VID is visible during the execution of the embedded Service OS.\nTo prevent OS installations from trying to install the OS to the VID, this step can be used early in the build plan. It uses the hponcfg utility.\n\nWhile this build plan step is specific to HP ProLiant Gen8 servers, it will not fail on non HP ProLiant Gen8\ntargets when used with the default settings. (See parameters below)\n\nUsage:\n   [-s | --strict ] [-h | --hideVID ] [-u | --unhideVID ]\n\nWhere:\n   -s | --strict \n      HP ProLiant VID handling errors are treated as fatal errors\n   -h | --hideVID\n      Hide HP ProLiant VID\n   -u | --unhideVID\n      Unhide HP ProLiant VID\n      This step has no default behavior.\n      Exactly one of the options -h (--hideVID) or -u (--unhideVID) must be used\n\nPrerequisites:\n- Target servers runs a maintenance Linux or Windows PE OS.",
                "current": true
            },
            "source": "#!/usr/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n#\n\"\"\"\n    (C) Copyright 2013-2015 Hewlett-Packard Development Company, L.P.\n\n    Prepares the disks to be used as part of an OS installation on a HP ProLiant Gen8++ .\n    This step works with both Linux and WinPE service OS.\n\"\"\"\nimport sys\nfrom optparse import OptionParser\nfrom osprov.osbp import ThisTargetServer, logger\nfrom osprov.osbp.vid import HPVid\nfrom osprov.errors import ShowErrorMessage, ProcessExecutionError, NotSupportedError\n\nLOG = logger.getIt(\"Handle ProLiant VID\")\n\nEC_SUCCESS = 0\nEC_ERROR_MSG = 10\nEC_HANDLE_VID_ERROR = 20\nEC_NOT_SUPPORTED = 30\n\n\ndef parseArgs(args):\n    \"\"\" parse and normalise arguments for the script \"\"\"\n    parser = OptionParser()\n    parser.add_option(\"-s\", \"--strict\", metavar=\"STRICT\",\n                      action=\"store_true\", default=False,\n                      help=\"HP ProLiant VID handling errors are treated as fatal errors\")\n    # using -d and not the maybe more logical -h here as -h is reserved for help ...\n    parser.add_option(\"-d\", \"--hideVID\", metavar=\"HIDEVID\",\n                      action=\"store_true\", default=False,\n                      help=\"Hide HP ProLiant VID\")\n    parser.add_option(\"-u\", \"--unhideVID\", metavar=\"UNHIDEVID\",\n                      action=\"store_true\", default=False,\n                      help=\"Unhide HP ProLiant VID /n\"\n                      \"This step has no default behavior. /n\"\n                      \"Exactly one of the options -h (--hideVID) or -u (--unhideVID) must be used.\")\n    options, args = parser.parse_args(args)\n    # checking proper options\n    if args:\n        parser.error(\"Additional positional arguments are not supported\")\n    if options.hideVID and options.unhideVID:\n        parser.error(\n            \"Options -d (--hideVID) and -u (--unhideVID) are mutually exclusive - please use only one of them\")\n    if not options.hideVID and not options.unhideVID:\n        parser.error(\n            \"No option given. Exactly one of the options -d (--hideVID) or -u (--unhideVID) must be used\")\n    return options\n\n\ndef main():\n    \"\"\" Main entry point. \"\"\"\n\n    options = parseArgs(sys.argv[1:])\n    try:\n        targetServer = ThisTargetServer()\n        vid = HPVid.factor(targetServer)\n        if options.hideVID:\n            vid.hideVID()\n        elif options.unhideVID:\n            vid.unhideVID()\n    except ProcessExecutionError, why:\n        print \"Execution error - Failed to handle HP ProLiant Virtual Installation Device (VID):\"\n        print why\n        print why.stderr\n        return EC_HANDLE_VID_ERROR\n    except NotSupportedError, why:\n        print \"Error while handling HP ProLiant Virtual Installation Device (VID):\"\n        print why\n        if options.strict:\n            print \"Strict error handling option enabled - ending with error.\"\n            return EC_NOT_SUPPORTED\n        print \"Step did not complete but returning success since the strict error handling option was not used.\"\n        return EC_SUCCESS\n    except ShowErrorMessage, why:\n        LOG.exception(why)\n        print why\n        return EC_ERROR_MSG\n\n    print \"HP ProLiant VID handling finished successfully.\"\n    return EC_SUCCESS\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n",
            "description": "Step to hide or unhide the Virtual Installation Device (VID) of HP ProLiant Gen8 devices.\nWhen the BIOS setting for the VID is set to its default \"Hidden\" this is handled automatically.\nWhen using SA functionality based on iLO and a Gen8-specific Intelligent Provisioning service OS (Linux or Windows PE) the VID is visible during the execution of the embedded Service OS.\nTo prevent OS installations from trying to install the OS to the VID, this step can be used early in the build plan. It uses the hponcfg utility.\n\nWhile this build plan step is specific to HP ProLiant Gen8 servers, it will not fail on non HP ProLiant Gen8\ntargets when used with the default settings. (See parameters below)\n\nUsage:\n   [-s | --strict ] [-h | --hideVID ] [-u | --unhideVID ]\n\nWhere:\n   -s | --strict \n      HP ProLiant VID handling errors are treated as fatal errors\n   -h | --hideVID\n      Hide HP ProLiant VID\n   -u | --unhideVID\n      Unhide HP ProLiant VID\n      This step has no default behavior.\n      Exactly one of the options -h (--hideVID) or -u (--unhideVID) must be used\n\nPrerequisites:\n- Target servers runs a maintenance Linux or Windows PE OS.",
            "status": null,
            "name": "Handle HP ProLiant Gen8 Virtual Installation Device",
            "state": null,
            "eTag": "2015-06-13T04:48:51.000Z",
            "modified": "2015-06-13T04:48:51.000Z",
            "created": "2015-06-13T04:48:51.000Z",
            "category": "os-deployment-ogfs-scripts",
            "uri": "/rest/os-deployment-ogfs-scripts/610001"
        },
        {
            "codeType": "OGFS",
            "displayCodeType": "OGFS",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "1",
                    "createdBy": "opsware",
                    "createdDate": "2015-06-13T04:48:53.000Z",
                    "usage": "Cleans up files which refer to MAC of source VM",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-06-13T04:48:53.000Z",
            "version": {
                "versionLabel": "1",
                "createdBy": "opsware",
                "createdDate": "2015-06-13T04:48:53.000Z",
                "usage": "Cleans up files which refer to MAC of source VM",
                "current": true
            },
            "source": "#!/usr/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n#\n\"\"\"\n    (C) Copyright 2012-2015 Hewlett-Packard Development Company, L.P.\n\n    Clean up old MAC addresses from source VM\n\"\"\"\n\nimport os\nimport glob\nimport ConfigParser\nimport StringIO\n\nfrom osprov.osbp import ThisTargetServer, logger\nfrom osprov import constants\n\nLOG = logger.getIt(\"cleanup_old_macs\")\n\n\ndef cleanup_persistent_rules(root_mount_dir):\n    net_rules_path = root_mount_dir + '/etc/udev/rules.d/70-persistent-net.rules'\n    if os.path.exists(net_rules_path):\n        os.unlink(net_rules_path)\n        LOG.debug(\"Cleaning up file with old MAC address: \" + net_rules_path)\n\n\ndef is_a_backup_file(ifcfg_filename):\n    filename, extension = os.path.splitext(ifcfg_filename)\n    # bak is from observations, the rest are documented here\n    # https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/7/pdf/Networking_Guide/Red_Hat_Enterprise_Linux-7-Networking_Guide-en-US.pdf\n    return extension in ['.bak', '.old', '.orig', '.rpmnew', '.rpmorig', '.rpmsave']\n\n\ndef extract_interface_name(ifcfg_filename):\n    return ifcfg_filename.split(\"/ifcfg-\")[-1]\n\n\ndef remove_quotes_from_string(interface_type):\n    single_quote = \"'\"\n    double_quote = '\"'\n    return interface_type.replace(single_quote, '').replace(double_quote, '')\n\n\ndef is_ethernet_type(ifcfg_filename):\n    sectioned_content = '[root]\\n' + open(ifcfg_filename, 'r').read()\n    fp = StringIO.StringIO(sectioned_content)\n    config = ConfigParser.RawConfigParser()\n    config.readfp(fp, filename=ifcfg_filename)\n\n    try:\n        interface_type = config.get('root', 'TYPE')\n        unquoted_interface_type = remove_quotes_from_string(interface_type)\n        return unquoted_interface_type.lower() in ['ethernet']\n    except ConfigParser.NoOptionError, e:\n        return True\n\n\ndef is_loopback_interface(interface_name):\n    return interface_name == \"lo\" \\\n        or interface_name.startswith(\"lo:\") \\\n        or interface_name.startswith(\"lo-\")\n\n\ndef find_ethernet_interfaces(network_scripts_dir):\n    result = []\n\n    ifcfg_path = network_scripts_dir + '/ifcfg-*'\n    for ifcfg_filename in glob.glob(ifcfg_path):\n        if is_a_backup_file(ifcfg_filename):\n            continue\n\n        if is_ethernet_type(ifcfg_filename):\n            interface_name = extract_interface_name(ifcfg_filename)\n\n            if is_loopback_interface(interface_name):\n                continue\n\n            result.append((interface_name, ifcfg_filename))\n\n    return result\n\n\ndef reset_ifcfg_files_to_allow_guest_customization(root_mount_dir):\n    interfaces = find_ethernet_interfaces(root_mount_dir + '/etc/sysconfig/network-scripts')\n    LOG.debug(\"guest customization will minimize contents of NICs: \" + str(interfaces))\n\n    for dvc, ifcfg_path in interfaces:\n        # QC150287 - when these files contain more than the minimal information, then guest customization fails\n        # Over-write contents of file to minimal information.\n        # This minimal information will be over-written when Guest Customization script\n        #     performs network personalization.\n        ifcfg = open(ifcfg_path, \"w\")\n        ifcfg.write(\"DEVICE=\" + dvc + \"\\n\")\n        ifcfg.write(\"BOOTPROTO=dhcp\\n\")\n        ifcfg.write(\"ONBOOT=yes\\n\")\n        ifcfg.write(\"PEERDNS=yes\\n\")\n        ifcfg.close()\n\n\ndef disable_kudzu(root_mount_dir):\n    kudzu_path = root_mount_dir + '/etc/init.d/kudzu'\n    if os.path.exists(kudzu_path):\n        LOG.info(\"Disabling kudzu. New network interfaces were already configured:\" + kudzu_path)\n        kudzu_rc_path = root_mount_dir + '/etc/rc*.d/*kudzu'\n        filenames = glob.glob(kudzu_rc_path)\n        for filename in filenames:\n            LOG.debug(\"Removing symlink for kudzu:\" + filename)\n            os.unlink(filename)\n\n\ndef main():\n    TARGET = ThisTargetServer()\n    MOUNTED_ROOT_DIR = TARGET.pathToOGFS(constants.OGFS_SYSTEM_ROOT)\n\n    # clean up files with old MAC addresses while still in maintenance mode\n    cleanup_persistent_rules(MOUNTED_ROOT_DIR)\n\n    # for each ifcfg file, use minimal settings to avoid issues in guest customization\n    reset_ifcfg_files_to_allow_guest_customization(MOUNTED_ROOT_DIR)\n\n    disable_kudzu(MOUNTED_ROOT_DIR)\n\n\nif __name__ == \"__main__\":\n    main()\n",
            "description": "Cleans up files which refer to MAC of source VM",
            "status": null,
            "name": "Clean up old MAC Addresses (RedHat Enterprise Linux Server)",
            "state": null,
            "eTag": "2015-06-13T04:48:53.000Z",
            "modified": "2015-06-13T04:48:53.000Z",
            "created": "2015-06-13T04:48:53.000Z",
            "category": "os-deployment-ogfs-scripts",
            "uri": "/rest/os-deployment-ogfs-scripts/640001"
        },
        {
            "codeType": "OGFS",
            "displayCodeType": "OGFS",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "1",
                    "createdBy": "opsware",
                    "createdDate": "2015-06-13T04:48:53.000Z",
                    "usage": "Monitors a given log file every DELAY seconds and timeouts after\nCOUNT checks in which the log has not changed.\n\nIf no log file is given it will monitor the installation log for the supported installers:\n- Red Hat, CentOS and OEL\n- SLES\n- Ubuntu\n- Solaris 10\n- Solaris 11 AI\n\nusage: monitor_install_log.py [options]\n\noptions:\n  -h, --help     show this help message and exit\n  --log=LOG      the log file that will be monitored\n  --count=COUNT  the number of times it counts before timing out\n  --delay=DELAY  the delay in seconds between every log check\n\nPrerequisites:\n  - Script needs to be run as part of a build plan.",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-06-13T04:48:53.000Z",
            "version": {
                "versionLabel": "1",
                "createdBy": "opsware",
                "createdDate": "2015-06-13T04:48:53.000Z",
                "usage": "Monitors a given log file every DELAY seconds and timeouts after\nCOUNT checks in which the log has not changed.\n\nIf no log file is given it will monitor the installation log for the supported installers:\n- Red Hat, CentOS and OEL\n- SLES\n- Ubuntu\n- Solaris 10\n- Solaris 11 AI\n\nusage: monitor_install_log.py [options]\n\noptions:\n  -h, --help     show this help message and exit\n  --log=LOG      the log file that will be monitored\n  --count=COUNT  the number of times it counts before timing out\n  --delay=DELAY  the delay in seconds between every log check\n\nPrerequisites:\n  - Script needs to be run as part of a build plan.",
                "current": true
            },
            "source": "#!/usr/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n#\n\"\"\"\n    (C) Copyright 2014-2015 Hewlett-Packard Development Company, L.P.\n\n    Monitors a given log file every DELAY seconds and timeouts after\n    COUNT checks in which the log has not changed.\n\n    If no log file is given it will monitor the installation log for the supported installers:\n    - Red Hat, CentOS and OEL\n    - SLES\n    - Ubuntu\n    - Solaris 10\n    - Solaris 11 AI\n\"\"\"\n\nimport os\nimport sys\nimport time\nfrom optparse import OptionError\nfrom StringIO import StringIO\n\nfrom librunplan import PlanOutputHandler\n\nfrom osprov import platform_util\nfrom osprov.decorators import HandleShowErrorMessage\nfrom osprov.errors import ShowErrorMessage, TimeoutError, NotSupportedError, ProcessExecutionError\nfrom osprov.optparse_ext import OptionParser\nfrom osprov.osbp import ThisTargetServer, logger\nfrom osprov.osbp.constants import MONITORING_STOP_FLAG\n\n# waits CHECK_DELAY * TIMEOUT_COUNT, 10 minutes by default\n\nCHECK_DELAY = 6  # seconds\nTIMEOUT_COUNT = 100\n\nLOG = logger.getIt(\"Monitor Installation\")\n\n\nclass MonitorStepOptionsParser(OptionParser):\n\n    \"\"\" An options' parser for this step. \"\"\"\n\n    def defineOptions(self):\n        self.add_option(\"--log\", help=\"the log file that will be monitored\")\n        self.add_option(\"--count\", default=TIMEOUT_COUNT, type=int,\n                        help=\"the number of times it counts before timing out\")\n        self.add_option(\"--delay\", default=CHECK_DELAY, type=float,\n                        help=\"the delay in seconds between every log check\")\n\n    def validateArgs(self, opt, args):\n        if opt.count and opt.count < 0:\n            raise OptionError(\"not a positive number\", \"count\")\n        if opt.delay and opt.delay < 0:\n            raise OptionError(\"not a positive number\", \"delay\")\n\n\nclass LogMonitor (object):\n\n    \"\"\" Monitors logs until one of the stop files is encountered or times out. \"\"\"\n\n    def __init__(self, targetServer, logPath, stopFilePaths=(MONITORING_STOP_FLAG,), output=PlanOutputHandler()):\n        self.targetServer = targetServer\n        self.output = output\n        self.logPath = self.targetServer.pathToOGFS(logPath)\n        self.stopFilePaths = [self.targetServer.pathToOGFS(path) for path in stopFilePaths]\n        self.lastLine = None\n        self.checkDelaySeconds = 6\n        self.defaultTimeoutCount = 100\n        self.timeoutCount = self.defaultTimeoutCount\n        self.numberOfReportedLines = 50\n        self._cachedLastLines = []\n        self.installFailedUserMessage = \"\"\n\n    def waitForLogFile(self):\n        \"\"\"Waits self.checkDelay * self.timeoutCount for self.logPath to appear.\"\"\"\n        failedCheckCount = 0\n        while failedCheckCount < self.timeoutCount:\n            if os.path.exists(self.logPath):\n                return\n            else:\n                failedCheckCount += 1\n            time.sleep(self.checkDelaySeconds)\n        else:\n            raise ShowErrorMessage(\"The install log %s did not appear.\" % self.logPath)\n\n    def _generateLog(self):\n        raise NotImplementedError(\"abstract\")\n\n    def _openLog(self, canGenerate=True):\n        \"\"\" Returns a file object to self.logPath. \"\"\"\n        return open(self.logPath, \"rb\")\n\n    def getLastLines(self, count, canGenerate=True):\n        \"\"\"Returns the last lineNo lines of supplied file object.\"\"\"\n        try:\n            self._cachedLastLines = self._openLog(canGenerate=canGenerate).readlines()[-count:]\n            return self._cachedLastLines\n        except IOError, error:\n            LOG.error(\"Failed to read the log file\")\n            LOG.exception(error)\n            self._cachedLastLines = []\n            return []\n\n    def getLatestLines(self):\n        \"\"\" Returns the latest lines from the log file.\"\"\"\n        lastLines = self.getLastLines(self.numberOfReportedLines)\n        if not lastLines:\n            return []\n        if self.lastLine is None:\n            self.lastLine = lastLines[-1]\n            return lastLines\n        else:\n            curLastLine = lastLines[-1]\n            if curLastLine == self.lastLine:\n                return []\n            else:\n                self.lastLine = curLastLine\n                return lastLines\n\n    def isInstallDone(self):\n        \"\"\" Returns True if the installation has finished. \"\"\"\n        for path in self.stopFilePaths:\n            if os.path.exists(path):\n                return True\n        else:\n            return False\n\n    def isInstallFailed(self):\n        \"\"\"\n        Returns True if the installation is known to have failed.\n        To be implemented by subclasses if needed.\n        \"\"\"\n\n        return False\n\n    def adjustTimeout(self):\n        \"\"\"Hook for dynamically adjusting the timeout. Gets called at each iteration. \"\"\"\n\n        pass\n\n    def main(self):\n        \"\"\" Main monitoring function \"\"\"\n        print(\"Monitoring %s log file\" % self.logPath)\n\n        print(\"Waiting for %s to appear\" % self.logPath)\n        self.waitForLogFile()\n        print(\"Found the log file\")\n\n        failedCheckCount = 0\n        while failedCheckCount < self.timeoutCount and not self.isInstallDone() and not self.isInstallFailed():\n            lastLines = self.getLatestLines()\n            if lastLines:\n                failedCheckCount = 0\n                self.output.replaceMessages(\"Monitoring Installation\", \"\".join(lastLines))\n            else:\n                failedCheckCount += 1\n            self.adjustTimeout()\n            time.sleep(self.checkDelaySeconds)\n        else:\n            print(\"Here are the last %d lines of the log:\" % self.numberOfReportedLines)\n            print(\"\".join(self.getLastLines(self.numberOfReportedLines, canGenerate=False)))\n            if self.isInstallDone():\n                print(\"Installation completed.\")\n                return 0\n            elif self.isInstallFailed():\n                raise ShowErrorMessage(\n                    \"The installation failed: %s\" % self.installFailedUserMessage)\n            else:\n                raise TimeoutError(\"Monitoring the log file timed out.\")\n\n\nclass RPMBasedInstallerLogMonitor(LogMonitor):\n\n    def __init__(self, targetServer, logPath, stopFilePaths=(MONITORING_STOP_FLAG,), output=PlanOutputHandler(), rpmArguments=\"\"):\n        LogMonitor.__init__(self, targetServer, logPath, stopFilePaths, output)\n        self._rpmArguments = rpmArguments\n\n    def _openLog(self, canGenerate=True):\n        if canGenerate:\n            generatedLog = self._generateLog()\n            if generatedLog.strip():\n                return StringIO(generatedLog)\n        return open(self.logPath, \"rb\")\n\n    def _generateLog(self):\n        try:\n            return self.targetServer.rosh().getStdout(\n                \"\\\"rpm {rpmArguments} -qa --queryformat '{queryFormat}' | sort -n | tail -n 50 \\\"\".format(\n                    rpmArguments=self._rpmArguments,\n                    queryFormat=\"(%{installtime:date}) Installed rpm: %{name}\\n\"\n                ),\n            )\n        except ProcessExecutionError, e:\n            LOG.exception(e)\n            return \"\"\n\n\nclass Rhel5InstallationLogMonitor(LogMonitor):\n\n    def __init__(self, targetServer):\n        LogMonitor.__init__(\n            self, targetServer,\n            logPath=\"/tmp/anaconda.log\",\n            stopFilePaths=(\n                os.path.join(\"/mnt/sysimage/tmp\", os.path.basename(MONITORING_STOP_FLAG)),\n                MONITORING_STOP_FLAG\n            )\n        )\n\n\nclass Rhel6InstallationLogMonitor(RPMBasedInstallerLogMonitor):\n\n    def __init__(self, targetServer):\n        RPMBasedInstallerLogMonitor.__init__(\n            self, targetServer,\n            logPath=\"/tmp/anaconda.log\",\n            stopFilePaths=(\n                os.path.join(\"/mnt/sysimage/tmp\", os.path.basename(MONITORING_STOP_FLAG)),\n                MONITORING_STOP_FLAG\n            )\n        )\n\n\nclass Rhel7InstallationLogMonitor(LogMonitor):\n\n    def __init__(self, targetServer):\n        LogMonitor.__init__(\n            self, targetServer,\n            logPath=\"/tmp/packaging.log\",\n            stopFilePaths=(\n                os.path.join(\"/mnt/sysimage/tmp\", os.path.basename(MONITORING_STOP_FLAG)),\n                MONITORING_STOP_FLAG,\n            )\n        )\n\n\nclass SlesInstallationLogMonitor(RPMBasedInstallerLogMonitor):\n    def __init__(self, targetServer):\n        RPMBasedInstallerLogMonitor.__init__(\n            self, targetServer,\n            logPath=\"/var/log/YaST2/y2log\",\n            stopFilePaths=(\n                os.path.join(\"/mnt/tmp\", os.path.basename(MONITORING_STOP_FLAG)),\n                MONITORING_STOP_FLAG\n            ),\n            rpmArguments=\"--dbpath /mnt/var/lib/rpm\"\n        )\n\n\nclass UbuntuInstallationLogMonitor(LogMonitor):\n\n    def __init__(self, targetServer):\n        LogMonitor.__init__(self, targetServer, \"/var/log/syslog\")\n\n\nclass Solaris11InstallationMonitor(LogMonitor):\n\n    def __init__(self, targetServer):\n        LogMonitor.__init__(self, targetServer, \"/system/volatile/install_log\")\n        self.installDoneMessage = \"automated installation succeeded\"\n        self.installFailedMessage = \"automated installation failed\"\n        self.installFailedUserMessage = \"The install log reported failure.\"\n        self._installPhaseStartedMessage = \"install phase ... started\"\n        self._installPhaseDoneMessage = \"install phase ... done\"\n\n    def isInstallDone(self):\n        \"\"\" Returns True if the installation has finished. \"\"\"\n        return self.installDoneMessage in \"\\n\".join(self._cachedLastLines).lower()\n\n    def isInstallFailed(self):\n        \"\"\"Return True if the install log contains a failure message.\"\"\"\n        return self.installFailedMessage in \"\\n\".join(self._cachedLastLines).lower()\n\n    def adjustTimeout(self):\n        \"\"\"Sets a larger timeout after the 'Install Phase ... Started' message is detected in the log.\"\"\"\n        if self._installPhaseStartedMessage in \"\\n\".join(self._cachedLastLines).lower():\n            self.timeoutCount = 600\n        if self._installPhaseDoneMessage in \"\\n\".join(self._cachedLastLines).lower():\n            self.timeoutCount = self.defaultTimeoutCount\n\n\nclass Solaris10InstallationMonitor(LogMonitor):\n\n    def __init__(self, targetServer):\n        LogMonitor.__init__(self, targetServer, \"/a/var/sadm/system/logs/install_log\")\n        self.installFailedMessage = \"installation: failed\"\n        self.installFailedUserMessage = \"The install log reported failure.\"\n\n    def isInstallFailed(self):\n        \"\"\"Return True if the install log contains a failure message.\"\"\"\n        return self.installFailedMessage in \"\\n\".join(self._cachedLastLines).lower()\n\n\ndef factorLogMonitor(targetServer):\n    \"\"\" Return a LogMonitor based on the reported OS version\"\"\"\n    osVersion = targetServer.getServerVO().getOsVersion().lower()\n    if platform_util.isSLES(osVersion):\n        return SlesInstallationLogMonitor(targetServer)\n    elif platform_util.isRHELCompatible(osVersion, version=5):\n        return Rhel5InstallationLogMonitor(targetServer)\n    elif platform_util.isRHELCompatible(osVersion, version=6):\n        return Rhel6InstallationLogMonitor(targetServer)\n    elif platform_util.isRHELCompatible(osVersion, version=7):\n        return Rhel7InstallationLogMonitor(targetServer)\n    elif platform_util.isUbuntu(osVersion):\n        return UbuntuInstallationLogMonitor(targetServer)\n    elif platform_util.isSolaris(osVersion, version=11):\n        return Solaris11InstallationMonitor(targetServer)\n    elif platform_util.isSolaris(osVersion, version=10):\n        return Solaris10InstallationMonitor(targetServer)\n    raise NotSupportedError(\"Monitoring installation for %s is not supported\" % osVersion)\n\n\n@HandleShowErrorMessage(\"monitor installation\", LOG)\ndef main():\n    options, remainingArgs = MonitorStepOptionsParser().parse_args()\n\n    targetServer = ThisTargetServer()\n\n    logFile = options.log\n    if not logFile:\n        logMonitor = factorLogMonitor(targetServer)\n    else:\n        logMonitor = LogMonitor(targetServer, logFile)\n    logMonitor.checkDelaySeconds = options.delay\n    logMonitor.timeoutCount = options.count\n\n    return logMonitor.main()\n\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n",
            "description": "Monitors a given log file every DELAY seconds and timeouts after\nCOUNT checks in which the log has not changed.\n\nIf no log file is given it will monitor the installation log for the supported installers:\n- Red Hat, CentOS and OEL\n- SLES\n- Ubuntu\n- Solaris 10\n- Solaris 11 AI\n\nusage: monitor_install_log.py [options]\n\noptions:\n  -h, --help     show this help message and exit\n  --log=LOG      the log file that will be monitored\n  --count=COUNT  the number of times it counts before timing out\n  --delay=DELAY  the delay in seconds between every log check\n\nPrerequisites:\n  - Script needs to be run as part of a build plan.",
            "status": null,
            "name": "Monitor Solaris 10 Installation",
            "state": null,
            "eTag": "2015-06-13T04:48:53.000Z",
            "modified": "2015-06-13T04:48:53.000Z",
            "created": "2015-06-13T04:48:53.000Z",
            "category": "os-deployment-ogfs-scripts",
            "uri": "/rest/os-deployment-ogfs-scripts/650001"
        },
        {
            "codeType": "OGFS",
            "displayCodeType": "OGFS",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "1",
                    "createdBy": "opsware",
                    "createdDate": "2015-06-13T04:48:54.000Z",
                    "usage": "Sleep for a number of seconds before executing the next step in the buildplan.\n\nusage: sleep.py [options]\n\noptions:\n  --seconds           indicates how many seconds we should sleep before executing the next buildplan step\n  --minutes           indicates how many minutes we should sleep before executing the next buildplan step",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-06-13T04:48:54.000Z",
            "version": {
                "versionLabel": "1",
                "createdBy": "opsware",
                "createdDate": "2015-06-13T04:48:54.000Z",
                "usage": "Sleep for a number of seconds before executing the next step in the buildplan.\n\nusage: sleep.py [options]\n\noptions:\n  --seconds           indicates how many seconds we should sleep before executing the next buildplan step\n  --minutes           indicates how many minutes we should sleep before executing the next buildplan step",
                "current": true
            },
            "source": "#!/usr/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n\"\"\"\n    (C) Copyright 2011-2015 Hewlett-Packard Development Company, L.P.\n\n    This python script executes a sleep command for a specified number of seconds\n\"\"\"\n\nimport sys\nimport time\n\nfrom osprov.optparse_ext import OptionParser\nfrom osprov.decorators import HandleShowErrorMessage\nfrom osprov.osbp import logger\nfrom optparse import OptionValueError\n\nlog = logger.getIt(\"Sleep\")\n\nEC_OK = 0\nEC_INVALID_ARGS = 1\n\nDEFAULT_BRAKE_VALUE = 0\n\n\nclass SleepOptionsParser(OptionParser):\n\n    def __init__(self, *args, **kwargs):\n        \"\"\"  init the option parser \"\"\"\n        OptionParser.__init__(self, *args, **kwargs)\n        self.add_option(\"--seconds\", default=DEFAULT_BRAKE_VALUE, type=\"int\",\n                        help=\"Specify how many seconds we should sleep before executing the next step in the build plan.\")\n        self.add_option(\"--minutes\", default=DEFAULT_BRAKE_VALUE, type=\"int\",\n                        help=\"Specify how many minutes we should sleep before executing the next step in the build plan.\")\n\n    def validateArgs(self, opt, args):\n        if not opt.seconds and not opt.minutes:\n            raise OptionValueError(\"Missing required argument: seconds or minutes\")\n        if (opt.seconds == 0 and opt.minutes == 0) or (opt.seconds < 0) or (opt.minutes < 0):\n            raise OptionValueError(\"Invalid arguments or argument values. Seconds or minutes should be integer and \"\n                                   \"have values larger than 0.\")\n\n\n@HandleShowErrorMessage(\"sleep step\", log)\ndef main():\n    \"\"\" build plan script to boot the target system \"\"\"\n    parser = SleepOptionsParser()\n    options, args = parser.parse_args()\n\n    seconds = int(options.seconds)\n    minutes = int(options.minutes)\n\n    secondsToSleep = minutes * 60 + seconds\n\n    print(\"Delaying next step for %i seconds...\" % secondsToSleep)\n    time.sleep(secondsToSleep)\n    return EC_OK\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n",
            "description": "Sleep for a number of seconds before executing the next step in the buildplan.\n\nusage: sleep.py [options]\n\noptions:\n  --seconds           indicates how many seconds we should sleep before executing the next buildplan step\n  --minutes           indicates how many minutes we should sleep before executing the next buildplan step",
            "status": null,
            "name": "Sleep",
            "state": null,
            "eTag": "2015-06-13T04:48:54.000Z",
            "modified": "2015-06-13T04:48:54.000Z",
            "created": "2015-06-13T04:48:54.000Z",
            "category": "os-deployment-ogfs-scripts",
            "uri": "/rest/os-deployment-ogfs-scripts/680001"
        },
        {
            "codeType": "OGFS",
            "displayCodeType": "OGFS",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "1",
                    "createdBy": "opsware",
                    "createdDate": "2015-06-13T04:48:55.000Z",
                    "usage": "Skipping a number of steps based on Custom Attribute\n\nBased on the value provided to the Custom Attribute, the script\nwill take advantage of the Flow Control and preferably skip\na number of steps.\n\nusage: skip_steps_from_ca.py [options]\n\noptions (Linux only):\n  --CA              The value of the custom attribute that will control the flow of the Build Plan.\n                     Ex: --CA='@custom_attribute@'\n                     Valid values : 'yes', 'y', '1', 'no', 'n', '0'\n  --skipSteps       Number of steps that will be skipped if the value of the CA is positive\n\nNote: If the Custom Attribute is not present or has a null string value, this step will not skip any other steps.\nThe build plan will continue as normal.",
                    "current": false
                },
                {
                    "versionLabel": "2",
                    "createdBy": "opsware",
                    "createdDate": "2015-08-04T07:30:32.000Z",
                    "usage": "Skipping a number of steps based on Custom Attribute\n\nBased on the value provided to the Custom Attribute, the script\nwill take advantage of the Flow Control and preferably skip\na number of steps.\n\nusage: skip_steps_from_ca.py [options]\n\noptions (Linux only):\n  --CA              The value of the custom attribute that will control the flow of the Build Plan.\n                     Ex: --CA='@custom_attribute@'\n                     Valid values : 'yes', 'y', '1', 'no', 'n', '0'\n  --skipSteps       Number of steps that will be skipped if the value of the CA is positive\n\nNote: If the Custom Attribute is not present or has a null string value, this step will not skip any other steps.\nThe build plan will continue as normal.",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-08-04T07:30:32.000Z",
            "version": {
                "versionLabel": "2",
                "createdBy": "opsware",
                "createdDate": "2015-08-04T07:30:32.000Z",
                "usage": "Skipping a number of steps based on Custom Attribute\n\nBased on the value provided to the Custom Attribute, the script\nwill take advantage of the Flow Control and preferably skip\na number of steps.\n\nusage: skip_steps_from_ca.py [options]\n\noptions (Linux only):\n  --CA              The value of the custom attribute that will control the flow of the Build Plan.\n                     Ex: --CA='@custom_attribute@'\n                     Valid values : 'yes', 'y', '1', 'no', 'n', '0'\n  --skipSteps       Number of steps that will be skipped if the value of the CA is positive\n\nNote: If the Custom Attribute is not present or has a null string value, this step will not skip any other steps.\nThe build plan will continue as normal.",
                "current": true
            },
            "source": "#!/usr/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# lint_ignore=E501,I0011,C0301\n# Please do not change the two lines above. See PEP 8, PEP 263.\n\"\"\"\n    (C) Copyright 2014-2015 Hewlett-Packard Development Company, L.P.\n\n    Skipping a number of steps based on Custom Attributes\n\n    Based on the value provided tot he Custom Attributes the script\n    will take advantage of the Flow Control and preferably skip\n    a number of steps.\n\"\"\"\n\nimport sys\n\nfrom osprov.osbp import logger\nfrom osprov.decorators import HandleShowErrorMessage\nfrom osprov.optparse_ext import OptionParser\nfrom optparse import OptionValueError\n\nLOG = logger.getIt(\"skip steps based on custom attribute\")\nVALID_VALUES = (['yes', 'y', '1'], ['no', 'n', '0'])\n\n\nclass SkipStepsCAOptionParser(OptionParser):\n    def __init__(self, *args, **kwargs):\n        OptionParser.__init__(self, *args, **kwargs)\n        self.usage = \"Skip steps based on Custom Attribute\"\n\n    def defineOptions(self):\n        self.set_defaults(CA=\"\", skipSteps=0)\n        self.add_option(\"--CA\", dest=\"CA\", type='string',\n                        help=\"Value of the specified CA.\")\n        self.add_option(\"--skipSteps\", dest=\"skipSteps\", type=\"int\", help=\"Number of steps that will be skipped.\")\n\n    def validateArgs(self, opt, args):\n        if opt.CA.lower() == \"\":\n            print \"The mentioned Custom Attribute is not present or it's value is null. Will not skip any step.\"\n            return\n        if opt.CA.lower() not in (VALID_VALUES[0] + VALID_VALUES[1]):\n            raise OptionValueError(\"The provided CA value '%s' is not supported. Please provide one of the following : %s\" % (opt.CA, str(VALID_VALUES)))\n        if opt.skipSteps < 0:\n            raise OptionValueError(\"Invalid arguments or argument values. SkipSteps should be integer and have values larger than 0.\")\n\n\ndef skipNumberOfSteps(CAValue, skipSteps):\n    if (CAValue.lower() in VALID_VALUES[0]):\n        print '''\nBegin Flow Control:\n    Forward to step +%s\nEnd Flow Control''' % (skipSteps + 1)\n\n\n@HandleShowErrorMessage(\"skip steps based on custom attribute\", LOG)\ndef main():\n    parser = SkipStepsCAOptionParser()\n    options, args = parser.parse_args()\n    skipNumberOfSteps(options.CA, options.skipSteps)\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n",
            "description": "Skipping a number of steps based on Custom Attribute\n\nBased on the value provided to the Custom Attribute, the script\nwill take advantage of the Flow Control and preferably skip\na number of steps.\n\nusage: skip_steps_from_ca.py [options]\n\noptions (Linux only):\n  --CA              The value of the custom attribute that will control the flow of the Build Plan.\n                     Ex: --CA='@custom_attribute@'\n                     Valid values : 'yes', 'y', '1', 'no', 'n', '0'\n  --skipSteps       Number of steps that will be skipped if the value of the CA is positive\n\nNote: If the Custom Attribute is not present or has a null string value, this step will not skip any other steps.\nThe build plan will continue as normal.",
            "status": null,
            "name": "Skip steps based on Custom Attribute",
            "state": null,
            "eTag": "2015-08-04T07:30:32.000Z",
            "modified": "2015-08-04T07:30:32.000Z",
            "created": "2015-06-13T04:48:55.000Z",
            "category": "os-deployment-ogfs-scripts",
            "uri": "/rest/os-deployment-ogfs-scripts/690001"
        },
        {
            "codeType": "OGFS",
            "displayCodeType": "OGFS",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "1",
                    "createdBy": "opsware",
                    "createdDate": "2015-06-13T04:48:56.000Z",
                    "usage": "Controls the boot mode of a server and leaving the server in a powered off state.\n\nUsage:\n\tctrlbootmode.py --bootmode {LEGACY | UEFI | UEFI_OPTIMIZED | UEFI_OPTIMIZED_SECURE }\n\nThe --bootmode parameter is mandatory - there is no default bootmode to switch to.\n\nIn detail the boot modes are:\nLEGACY                  switch to \"Legacy BIOS\" boot mode\nUEFI_OPTIMIZED          default UEFI mode w/ optimized boot enabled\nUEFI                    use non optimized boot mode for certain legacy OS (eg. Windows 2008)\nUEFI_OPTIMIZED_SECURE   enable secure boot on top of default\n\nPrerequisites:\n - The server runs a maintenance Windows PE or Linux OS.\n - The server hardware must be HP ProLiant.",
                    "current": false
                },
                {
                    "versionLabel": "2",
                    "createdBy": "opsware",
                    "createdDate": "2015-08-04T07:30:03.000Z",
                    "usage": "Controls the boot mode of a server and leaving the server in a powered off state.\n\nUsage:\n\tctrlbootmode.py --bootmode {LEGACY | UEFI | UEFI_OPTIMIZED | UEFI_OPTIMIZED_SECURE }\n\nThe --bootmode parameter is mandatory - there is no default bootmode to switch to.\n\nIn detail the boot modes are:\nLEGACY                  switch to \"Legacy BIOS\" boot mode\nUEFI_OPTIMIZED          default UEFI mode w/ optimized boot enabled\nUEFI                    use non optimized boot mode for certain legacy OS (eg. Windows 2008)\nUEFI_OPTIMIZED_SECURE   enable secure boot on top of default\n\nPrerequisites:\n - The server runs a maintenance Windows PE or Linux OS.\n - The server hardware must be HP ProLiant.",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-08-04T07:30:03.000Z",
            "version": {
                "versionLabel": "2",
                "createdBy": "opsware",
                "createdDate": "2015-08-04T07:30:03.000Z",
                "usage": "Controls the boot mode of a server and leaving the server in a powered off state.\n\nUsage:\n\tctrlbootmode.py --bootmode {LEGACY | UEFI | UEFI_OPTIMIZED | UEFI_OPTIMIZED_SECURE }\n\nThe --bootmode parameter is mandatory - there is no default bootmode to switch to.\n\nIn detail the boot modes are:\nLEGACY                  switch to \"Legacy BIOS\" boot mode\nUEFI_OPTIMIZED          default UEFI mode w/ optimized boot enabled\nUEFI                    use non optimized boot mode for certain legacy OS (eg. Windows 2008)\nUEFI_OPTIMIZED_SECURE   enable secure boot on top of default\n\nPrerequisites:\n - The server runs a maintenance Windows PE or Linux OS.\n - The server hardware must be HP ProLiant.",
                "current": true
            },
            "source": "#!/usr/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n\"\"\"\n    (C) Copyright 2013-2015 Hewlett-Packard Development Company, L.P.\n\n    This python script controls the boot mode of a ProLiant target server.\n\"\"\"\n\nimport sys\nfrom osprov.optparse_ext import OptionParser, OptionValueError\nfrom osprov.decorators import HandleShowErrorMessage\nfrom osprov.osbp import ThisTargetServer, logger\nfrom pytwist.com.opsware.common import OpswareException, OpswareSystemException\nfrom pytwist.com.opsware.ilo import ServerBootMode\nfrom osprov import ilo\n\nlog = logger.getIt(\"Control Boot Mode\")\n\nEC_OK = 0\nEC_INVALID_ARGS = 1\nEC_UNSUPPORTED_BOOTMODE = 2\nEC_FAILED_SWITCHBOOTMODE = 3\nEC_ERROR_SWITCHBOOTMODE = 4\n\n\nclass CtrlBootModeOptionsParser(OptionParser):\n\n    \"\"\" Custom option parser \"\"\"\n\n    def defineOptions(self):\n        \"\"\" add the options \"\"\"\n        self.prog = \"ctrlbootmode\"\n        self.set_usage(\"%s [options]\" % self.prog)\n        self.add_option(\"-m\", \"--bootmode\", default=None,\n                        help=\"The boot mode to switch to. \"\n                        \"Possible options are: %s\" % ' '.join(ilo.VALID_BOOTMODES))\n\n    def validateArgs(self, opt, args):\n        \"\"\" parameter validation \"\"\"\n        if not opt.bootmode:\n            raise OptionValueError(\"Missing mandatory parameter --bootmode\\n\")\n        if not opt.bootmode in ilo.VALID_BOOTMODES:\n            raise OptionValueError(\"Value for --bootmode parameter is invalid: %s\\n\" % opt.bootmode)\n        if args:\n            raise OptionValueError(\"No other arguments allowed: %s\\n\" % args)\n\n\n@HandleShowErrorMessage(\"control target server boot mode \", log)\ndef main():\n    \"\"\" build plan script to control boot mode of target system \"\"\"\n\n    # parameter handling\n    parser = CtrlBootModeOptionsParser()\n    options, args = parser.parse_args()\n\n    bootmode = options.bootmode.upper()\n    print(\"Boot mode to switch target server to: %s\" % bootmode)\n\n    targetServer = ThisTargetServer()\n    iloServer = ilo.getIlo(targetServer, log=log)\n\n    # first testing target server for supported and current boot mode to\n    # prevent unnecessary switching\n    if not iloServer.isBootModeSupported(iloServer.getBaseBootMode(bootmode)):\n        print(\"Requested boot mode %s not supported on target server\\n\"\n              \"Stopping and leaving boot mode unchanged.\" % bootmode)\n        return EC_UNSUPPORTED_BOOTMODE\n\n    currentbootmode = iloServer.getCurrentBootMode()\n    if currentbootmode == bootmode:\n        print (\"Target server is already in boot mode %s\" % bootmode)\n    else:\n        print (\"Switching target server from current boot mode %s to %s. \"\n               \"This will take some time...\" % (currentbootmode, bootmode))\n        iloServer.switchBootMode(bootmode)\n        # double check...\n        if iloServer.getCurrentBootMode() == bootmode:\n            print (\"Target server successfully switched to boot mode %s. \"\n                   \"Target server is POWERING OFF now.\" % bootmode)\n        else:\n            print (\"Switching to boot mode %s was unsuccessful.\" % bootmode)\n            return EC_FAILED_SWITCHBOOTMODE\n\n    return EC_OK\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n",
            "description": "Controls the boot mode of a server and leaving the server in a powered off state.\n\nUsage:\n\tctrlbootmode.py --bootmode {LEGACY | UEFI | UEFI_OPTIMIZED | UEFI_OPTIMIZED_SECURE }\n\nThe --bootmode parameter is mandatory - there is no default bootmode to switch to.\n\nIn detail the boot modes are:\nLEGACY                  switch to \"Legacy BIOS\" boot mode\nUEFI_OPTIMIZED          default UEFI mode w/ optimized boot enabled\nUEFI                    use non optimized boot mode for certain legacy OS (eg. Windows 2008)\nUEFI_OPTIMIZED_SECURE   enable secure boot on top of default\n\nPrerequisites:\n - The server runs a maintenance Windows PE or Linux OS.\n - The server hardware must be HP ProLiant.",
            "status": null,
            "name": "Control Server Boot Mode",
            "state": null,
            "eTag": "2015-08-04T07:30:03.000Z",
            "modified": "2015-08-04T07:30:03.000Z",
            "created": "2015-06-13T04:48:56.000Z",
            "category": "os-deployment-ogfs-scripts",
            "uri": "/rest/os-deployment-ogfs-scripts/710001"
        },
        {
            "codeType": "OGFS",
            "displayCodeType": "OGFS",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "1",
                    "createdBy": "opsware",
                    "createdDate": "2015-06-13T04:48:56.000Z",
                    "usage": "Place holder script for content version identification",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-06-13T04:48:56.000Z",
            "version": {
                "versionLabel": "1",
                "createdBy": "opsware",
                "createdDate": "2015-06-13T04:48:56.000Z",
                "usage": "Place holder script for content version identification",
                "current": true
            },
            "source": "#65.0.62023.0",
            "description": "Place holder script for content version identification",
            "status": null,
            "name": "Version",
            "state": null,
            "eTag": "2015-06-13T04:48:56.000Z",
            "modified": "2015-06-13T04:48:56.000Z",
            "created": "2015-06-13T04:48:56.000Z",
            "category": "os-deployment-ogfs-scripts",
            "uri": "/rest/os-deployment-ogfs-scripts/720001"
        },
        {
            "codeType": "OGFS",
            "displayCodeType": "OGFS",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "1",
                    "createdBy": "opsware",
                    "createdDate": "2015-06-13T04:48:57.000Z",
                    "usage": "Forwards the build plan's step execution to a previously created checkpoint with the 'Create Checkpoint' step. Does not fail if no checkpoint exists.\n\nusage: continue_from_checkpoint.py [-h] [--name NAME]\n\noptional arguments:\n  -h, --help   show this help message and exit\n  --name NAME  Name of the custom attribute to use. Defaults to\n               'CurrentStepCheckpoint'",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-06-13T04:48:57.000Z",
            "version": {
                "versionLabel": "1",
                "createdBy": "opsware",
                "createdDate": "2015-06-13T04:48:57.000Z",
                "usage": "Forwards the build plan's step execution to a previously created checkpoint with the 'Create Checkpoint' step. Does not fail if no checkpoint exists.\n\nusage: continue_from_checkpoint.py [-h] [--name NAME]\n\noptional arguments:\n  -h, --help   show this help message and exit\n  --name NAME  Name of the custom attribute to use. Defaults to\n               'CurrentStepCheckpoint'",
                "current": true
            },
            "source": "#!/usr/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n\"\"\"\n    (C) Copyright 2014-2015 Hewlett-Packard Development Company, L.P.\n\"\"\"\n\nimport sys\nfrom argparse import ArgumentParser\nfrom types import StringType\n\nfrom osprov.osbp import ThisTargetServer\n\nCURRENT_STEP_CHECKPOINT_CA = \"CurrentStepCheckpoint\"\n\n\ndef printFlowControlForwardInstruction(step):\n        print \"\"\"Begin Flow Control:\n        Forward to step %s\n    End Flow Control\"\"\" % str(step)\n\n\ndef main():\n    argsParser = ArgumentParser()\n    argsParser.add_argument(\"--name\", type=StringType, metavar=\"NAME\",\n                            default=CURRENT_STEP_CHECKPOINT_CA,\n                            help=\"Name of the custom attribute to use. \"\n                            \"Defaults to '%s'\" % CURRENT_STEP_CHECKPOINT_CA)\n    args = argsParser.parse_args()\n\n    gotoStep = ThisTargetServer().getCustomAttribute(args.name)\n    if gotoStep:\n        print \"Continuing from checkpoint '%s' to step %s\" % (args.name, gotoStep)\n        print printFlowControlForwardInstruction(gotoStep)\n    else:\n        print \"No checkpoint to continue from...\"\n    return 0\n\n\nif __name__ == \"__main__\":\n    sys.exit(main())",
            "description": "Forwards the build plan's step execution to a previously created checkpoint with the 'Create Checkpoint' step. Does not fail if no checkpoint exists.\n\nusage: continue_from_checkpoint.py [-h] [--name NAME]\n\noptional arguments:\n  -h, --help   show this help message and exit\n  --name NAME  Name of the custom attribute to use. Defaults to\n               'CurrentStepCheckpoint'",
            "status": null,
            "name": "Continue from Checkpoint",
            "state": null,
            "eTag": "2015-06-13T04:48:57.000Z",
            "modified": "2015-06-13T04:48:57.000Z",
            "created": "2015-06-13T04:48:57.000Z",
            "category": "os-deployment-ogfs-scripts",
            "uri": "/rest/os-deployment-ogfs-scripts/750001"
        },
        {
            "codeType": "OGFS",
            "displayCodeType": "OGFS",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "1",
                    "createdBy": "opsware",
                    "createdDate": "2015-06-13T04:48:58.000Z",
                    "usage": "Inject required settings into the kickstart profile. The install nfs directive\nwill be inserted with the values used at the mount NFS share step. This step\nalso checks for to see if an encrypted password was used, since such a password,\ncan't be used to automatically manage the hypervizor.\n\nUsage:\n\tinject_required_ks_esx.py [--accept-encrypted-password] [--disableWarning]\n\nArguments:\n    accept-encrypted-password - accept the password to be encrypted\n    disableWarning - Do not show warnings of old hpsa_netconfig format\n\nPrerequisites:\n- Target server runs a maintenance Linux OS.\n- The user provided or default ks file must be in /tmp/user.ks.cfg.",
                    "current": false
                },
                {
                    "versionLabel": "2",
                    "createdBy": "opsware",
                    "createdDate": "2015-08-04T07:29:47.000Z",
                    "usage": "Inject required settings into the kickstart profile. The install nfs directive\nwill be inserted with the values used at the mount NFS share step. This step\nalso checks for to see if an encrypted password was used, since such a password,\ncan't be used to automatically manage the hypervizor.\n\nUsage:\n\tinject_required_ks_esx.py [--accept-encrypted-password] [--disableWarning]\n\nArguments:\n    accept-encrypted-password - accept the password to be encrypted\n    disableWarning - Do not show warnings of old hpsa_netconfig format\n\nPrerequisites:\n- Target server runs a maintenance Linux OS.\n- The user provided or default ks file must be in /tmp/user.ks.cfg.",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-08-04T07:29:47.000Z",
            "version": {
                "versionLabel": "2",
                "createdBy": "opsware",
                "createdDate": "2015-08-04T07:29:47.000Z",
                "usage": "Inject required settings into the kickstart profile. The install nfs directive\nwill be inserted with the values used at the mount NFS share step. This step\nalso checks for to see if an encrypted password was used, since such a password,\ncan't be used to automatically manage the hypervizor.\n\nUsage:\n\tinject_required_ks_esx.py [--accept-encrypted-password] [--disableWarning]\n\nArguments:\n    accept-encrypted-password - accept the password to be encrypted\n    disableWarning - Do not show warnings of old hpsa_netconfig format\n\nPrerequisites:\n- Target server runs a maintenance Linux OS.\n- The user provided or default ks file must be in /tmp/user.ks.cfg.",
                "current": true
            },
            "source": "#!/usr/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n\"\"\"\n    (C) Copyright 2013-2015 Hewlett-Packard Development Company, L.P.\n\n    Inject required options and move the required boot files onto the stub partition.\n\"\"\"\nimport os\nimport sys\nimport optparse\nfrom StringIO import StringIO\n\nfrom osprov import helpers\nfrom osprov.osbp import ThisTargetServer\nfrom osprov.errors import ShowErrorMessage\nfrom osprov.osbp.helpers import getMediaURL\nfrom osprov.parsers.netconfig import SmartNetconfig, OLD_SYNTAX_WARNING\nfrom osprov.profile import Kickstart, ProfileError\nfrom osprov.profile.kickstart import Script, Directive\n\nHPSA_NETCONFIG = \"\"\"@hpsa_netconfig@\"\"\"\n\nBASE_KS_FILE = \"tmp/user.ks.cfg\"\n\n\ndef initKickstart(baseFile):\n    \"\"\" Initialize a Kickstart object \"\"\"\n    return Kickstart(open(baseFile, \"r\"))\n\n\ndef removeConflictingOsprov(ksobj):\n    \"\"\" Remove conflicting directives  \"\"\"\n    if hasattr(ksobj, \"install\"):\n        for instance in ksobj.getDirectiveList(\"install\"):\n            print \"Removing %s from the profile\" % instance\n            instance.name = \"#%s\" % instance.name\n\n\ndef injectRequiredOsprov(ksobj, mediaUrl):\n    \"\"\" inject settings required for OS provisioning to work\n            currently it only injects the nfs share. ESX uses different syntax.\n    \"\"\"\n    if not hasattr(ksobj, \"install\"):\n        inst = Directive(\"install\")\n        if mediaUrl.scheme == \"nfs\":\n            inst[1] = \"nfs\"\n            inst[\"server\"] = mediaUrl.netloc\n            inst[\"dir\"] = mediaUrl.path\n        elif mediaUrl.scheme in [\"http\", \"https\"]:\n            if mediaUrl.username:\n                raise ShowErrorMessage(\n                    \"ESXi 4.1 doesn't support installing from a media server that requires authentication.\", 100)\n            inst[1] = \"url\"\n            inst[2] = mediaUrl.canonical()\n        else:\n            raise ShowErrorMessage(\n                \"ERROR: %s is not supported at this time\" % mediaUrl.scheme)\n        ksobj.directives.append(inst)\n\n\ndef hasEncPasswd(ksobj):\n    \"\"\"Check if the root pwd is encrypted \"\"\"\n    try:\n        if ksobj.rootpw[\"iscrypted\"]:\n            pass\n        return True\n    except (KeyError, AttributeError):\n        return False\n\n\ndef injectPost(ksobj, unsupported, agentGW, mid, crypto):\n    \"\"\" Inject code to stall the installer\"\"\"\n    # Don't inject the IP change script  if this is static provisioning\n\n    for script in ksobj.scripts:\n        if script.type == \"post\" and \\\n                \"###  CODE BY HPSA ###\" in [x.strip() for x in script.contents]:\n            return\n\n    agentSrv, opswareCaCrt = crypto\n\n    contents = []\n    contents.append(\"###  CODE BY HPSA ###\")\n    contents.append(\"#### DON'T REMOVE THE ABOVE COMMENT ###\")\n\n    contents.extend((\"\"\"\n\ncat > /tmp/hpsa_agent_mid << EOF\n%(mid)s\nEOF\n\ncat > /tmp/hpsa_agent.srv << EOF\n%(agentSrv)s\nEOF\n\ncat > /tmp/hpsa_ca.crt << EOF\n%(opswareCaCrt)s\nEOF\n\ncd /tmp\ntar xzf /hpsa_agent.tar.gz\ncd usr/hpsa_agent\ncp osprov/esxi_reg.sh /tmp/esxi_reg.sh\nchmod 755 /tmp/esxi_reg.sh\nif which localcli ; then\n    localcli network firewall set -e false\n    localcli network firewall get >> /tmp/hpsa_osprov.out\nfi\n/tmp/esxi_reg.sh \"/tmp/usr/hpsa_agent\" \"%(agentGw)s\"\nRC=$?\nif which localcli ; then\n    localcli network firewall set -e true\n    localcli network firewall get >> /tmp/hpsa_osprov.out\nfi\nexit $RC\n\"\"\" % {'mid': mid, 'agentSrv': agentSrv, 'opswareCaCrt': opswareCaCrt, 'agentGw': agentGW}).split(\"\\n\"))\n\n    contents.append('### END OF HPSA CODE ###')\n\n    post = Script(\"post\")\n    if unsupported:\n        post[\"unsupported\"] = None\n    post[\"interpreter\"] = \"busybox\"\n    post[\"ignorefailure\"] = \"false\"\n\n    post.contents.extend(contents)\n    ksobj.scripts.append(post)\n\n\ndef writeFinalKs(ksobj):\n    \"\"\" Write the kickstart file onto the boot disk \"\"\"\n    ksfile = open(BASE_KS_FILE, \"w\")\n    ksfile.write(str(ksobj))\n    ksfile.close()\n    print \"Kickstart file written to disk\"\n\n\ndef handleOsprov(ksobj, keys):\n    \"\"\" change the profile to suit the environment \"\"\"\n    removeConflictingOsprov(ksobj)\n    injectRequiredOsprov(ksobj, getMediaURL(keys))\n\n\ndef parseArgs(args):\n    \"\"\"Parse the command line arguments\"\"\"\n    parser = optparse.OptionParser(description=__doc__, version='0.0.1', )\n    parser.add_option('--accept-encrypted-password', default=False, dest=\"acceptencrypted\",\n                      help=\"Continue installation even if user has given an encrypted password \",\n                      action=\"store_true\")\n    parser.add_option(\"--disableWarning\", dest=\"disableWarning\", action=\"store_true\",\n                      default=False,\n                      help=\"Do not show warnings of old hpsa_netconfig format\")\n\n    opt, args = parser.parse_args(args)\n    return opt\n\n\ndef injectDevice(ksobj, targetServer):\n    ksobj.network[\"device\"] = targetServer.getMACAddress()\n\n\ndef getProvisioningNIC(netinfo):\n    \"\"\" Searches for and return the provisioning NIC \"\"\"\n    provisioningNics = [nic for nic in netinfo.nics if nic.provisioning]\n    if len(provisioningNics) > 1:\n        print \"Warning: Only one provisioning NIC will be configured from the netconfig\"\n    return provisioningNics[0]\n\n\ndef main():\n\n    opt = parseArgs(sys.argv[1:])\n\n    unsupported = False\n    # FLAG_OVERRIDE #\n    # parse out flags\n    try:\n        targetServer = ThisTargetServer()\n        targetServer.setWorkDir(targetServer.getRemoteRoot())\n        ksobj = initKickstart(BASE_KS_FILE)\n        # exit if unable to retrieve password from ks.cfg\n        try:\n            ksobj.rootpw[1]\n        except (KeyError, AttributeError):\n            print \"Unable to read root password from kick start file. \"\\\n                  \"Please verify kickstart configuration in the build plan\"\n            return 10\n\n        if hasEncPasswd(ksobj) and not opt.acceptencrypted:\n            print \"Can not proceed with installation as the root password is encrypted\"\n            return 11\n        else:\n            # Save the root password for lather use\n            keys = helpers.getDataStore(targetServer)\n            keys.profile.username = \"root\"\n            keys.profile.password = ksobj.rootpw[1]\n            helpers.putDataStore(keys, targetServer)\n        # Extra steps\n        # Below comment is used to generate scripts with additional actions,\n        # don't remove\n        # EXTRA STEPS #\n\n        netconfigParser = SmartNetconfig.readwrite(\n            StringIO(HPSA_NETCONFIG),\n            activeMacAddress=targetServer.getMACAddress(),\n            ipv6default=targetServer.isIPv6Managed()\n        )\n        netinfo = netconfigParser.info()\n        if netinfo.oldSyntax and not opt.disableWarning:\n            newFormat = netconfigParser.format()\n            print OLD_SYNTAX_WARNING + \"\\n%s\" % str(newFormat)\n\n        typosList = netconfigParser.getTyposList()\n        if typosList:\n            print(\"The following keys were not recognized in the netconfig CA and could be typos: %s\" % typosList)\n\n        provisioningNIC = getProvisioningNIC(netinfo)\n\n        if not (provisioningNIC.ipv4Networks or provisioningNIC.ipv6Networks):\n            agwIpPort = targetServer.getRandomAgentGateway()\n            mid = targetServer.getId()\n            agentSrv = targetServer.readFile(\n                os.path.join(targetServer.localServer.CRYPTO_DIR, \"agent.srv\"))\n            opswareCaCrt = targetServer.readFile(\n                os.path.join(targetServer.localServer.CRYPTO_DIR, \"opsware-ca.crt\"))\n            injectPost(ksobj, unsupported, agwIpPort, mid, (agentSrv, opswareCaCrt))\n        injectDevice(ksobj, targetServer)\n        writeFinalKs(ksobj)\n        print \"Successfully injected required settings\"\n    except (IOError, OSError, ProfileError, ShowErrorMessage), why:\n        sys.stderr.write(\"Failed to inject required settings.%s\\n\" % why)\n        return 1\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n",
            "description": "Inject required settings into the kickstart profile. The install nfs directive\nwill be inserted with the values used at the mount NFS share step. This step\nalso checks for to see if an encrypted password was used, since such a password,\ncan't be used to automatically manage the hypervizor.\n\nUsage:\n\tinject_required_ks_esx.py [--accept-encrypted-password] [--disableWarning]\n\nArguments:\n    accept-encrypted-password - accept the password to be encrypted\n    disableWarning - Do not show warnings of old hpsa_netconfig format\n\nPrerequisites:\n- Target server runs a maintenance Linux OS.\n- The user provided or default ks file must be in /tmp/user.ks.cfg.",
            "status": null,
            "name": "Inject Required ESXi 5 Kickstart Settings",
            "state": null,
            "eTag": "2015-08-04T07:29:47.000Z",
            "modified": "2015-08-04T07:29:47.000Z",
            "created": "2015-06-13T04:48:58.000Z",
            "category": "os-deployment-ogfs-scripts",
            "uri": "/rest/os-deployment-ogfs-scripts/770001"
        },
        {
            "codeType": "OGFS",
            "displayCodeType": "OGFS",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "1",
                    "createdBy": "opsware",
                    "createdDate": "2015-06-13T04:48:59.000Z",
                    "usage": "This script installs the Red Hat installer \"build image\" to disk by bundling the\nfollowing OSBP steps with platform specific arguments:\n\n    * Run : Create Stub Partition\n    * Run : Copy Boot Media\n    * Run : Install boot loader for Red Hat Enterprise Linux 5 Server\n    * Run : Copy MID and Crypto\n\t* Run : Copy Installation Profile\n\n Warning: this step repartitions the hard disk.  Refer to each step for details.\n\nUsage:\n\nThis script does not require any command line parameters",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-06-13T04:48:59.000Z",
            "version": {
                "versionLabel": "1",
                "createdBy": "opsware",
                "createdDate": "2015-06-13T04:48:59.000Z",
                "usage": "This script installs the Red Hat installer \"build image\" to disk by bundling the\nfollowing OSBP steps with platform specific arguments:\n\n    * Run : Create Stub Partition\n    * Run : Copy Boot Media\n    * Run : Install boot loader for Red Hat Enterprise Linux 5 Server\n    * Run : Copy MID and Crypto\n\t* Run : Copy Installation Profile\n\n Warning: this step repartitions the hard disk.  Refer to each step for details.\n\nUsage:\n\nThis script does not require any command line parameters",
                "current": true
            },
            "source": "#!/usr/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n\"\"\" (c) Copyright 2009 Hewlett-Packard Development Company, L.P.\n   bundle together all the steps into a single install boot image step\n\"\"\"\n\nimport os\nimport sys\n\nfrom pytwist.com.opsware.common import NotFoundException\nfrom pytwist.com.opsware.osprov import RunScriptPlanStep\nfrom pytwist.com.opsware.osprov import InstallZIPPlanStep\nfrom pytwist.com.opsware.script import ServerScriptRef\nfrom pytwist.com.opsware.script import OGFSScriptRef\n\nfrom librunplan import PlanRunner\nfrom librunplan import PlanOutputHandler\n\nfrom osprov import sa\nfrom osprov.osbp import ThisTargetServer\nfrom osprov.osbp import logger\nfrom osprov.errors import ShowErrorMessage\n\nSteps = (('Linux/Create Stub Partition', None), ('Linux/Copy Boot Media', None), ('Linux/GRuB Boot Loader x86', '/tmp'), ('Deploy Agent', '-d /tmp/opt/opsware/agent/ogfs-agent.zip -u'), ('Linux/Embed files initrd', ' -s /tmp/user.ks.cfg:/ -s /tmp/opt/opsware/agent:/opt/opsware/'), ('Linux/Install bootloader for RedHat Enterprise Linux Server', '--kernel_arguments=\"@kernel_arguments@\"'))\n\n\ndef main(argv=sys.argv, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr):\n    sys.stdin = stdin\n    sys.stderr = stderr\n    sys.stdout = stdout\n    Twist = sa.getTwistServer()\n    Target = ThisTargetServer(twistServer=Twist)\n    runnerOH = PlanOutputHandler(stdout, stderr, logger.getIt(\"Composite step\"))\n    runnerOH.NO_APX_PROGRESS = True  # don't break the papx reporting\n    runnerOH.ADV_STEP_MSG = None  # don't update the main message\n    runnerOH.ADV_STEP_MSG_LONG = \"\\nSub Step: %(action)s '%(name)s'\"\n    runnerOH.ERR_HEADER = \"\\nErrors from sub step %(current)d '%(name)s':\\n\"\n    Runner = PlanRunner(None, targetServer=Target, outputHandler=runnerOH)\n    for scriptPath, parameters in Steps:\n        scriptElems = [x for x in scriptPath.split(\"/\") if x]\n        try:\n            stepRef = Twist.folder.FolderService.getFNode(\n                [\"Opsware\", \"Tools\", \"OS Provisioning\", \"OS Build Plan Steps\"] +\n                scriptElems)\n            if isinstance(stepRef, ServerScriptRef) or isinstance(stepRef, OGFSScriptRef):\n                step = RunScriptPlanStep()\n                step.setScript(stepRef)\n                step.setParameters(parameters)\n            else:\n                step = InstallZIPPlanStep()\n                step.setZip(stepRef)\n                step.setInstallPath(parameters)\n            Runner.doStep(step, stepNo=int(os.environ[\"CURRENT_STEP_NO\"]))\n        except (NotFoundException), why:\n            runnerOH.exception(\"Error : sub step '%s' not found! %s\" %\n                              (scriptPath, why), why)\n            sys.exit(101)\n        except ShowErrorMessage, why:\n            runnerOH.exception(\"Sub Step '%s' failed: %s\" % (scriptPath, why[0]), why)\n            sys.exit(100)\n\nif __name__ == \"__main__\":\n    main()\n",
            "description": "This script installs the Red Hat installer \"build image\" to disk by bundling the\nfollowing OSBP steps with platform specific arguments:\n\n    * Run : Create Stub Partition\n    * Run : Copy Boot Media\n    * Run : Install boot loader for Red Hat Enterprise Linux 5 Server\n    * Run : Copy MID and Crypto\n\t* Run : Copy Installation Profile\n\n Warning: this step repartitions the hard disk.  Refer to each step for details.\n\nUsage:\n\nThis script does not require any command line parameters",
            "status": null,
            "name": "Install And Configure Red Hat Build Image",
            "state": null,
            "eTag": "2015-06-13T04:48:59.000Z",
            "modified": "2015-06-13T04:48:59.000Z",
            "created": "2015-06-13T04:48:59.000Z",
            "category": "os-deployment-ogfs-scripts",
            "uri": "/rest/os-deployment-ogfs-scripts/780001"
        },
        {
            "codeType": "OGFS",
            "displayCodeType": "OGFS",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "1",
                    "createdBy": "opsware",
                    "createdDate": "2015-06-13T04:49:00.000Z",
                    "usage": "This script inject required settings into the kickstart file. It appends code to\nthe %pre section of the kickstart file, to start the agent before the\ninstallation starts. It also injects code into the %post section to prevent the\ninstaller from rebooting after the installation is complete. The lather gives us\na chance to integrate the HP SA agent. It also injects NFS settings if not\nalready there.\n\nUsage:\n\tinject_required_ks.py [--verifyssl]\n\nParameters:\n\tverifyssl: If you are doing HTTPS provisioning, the RHEL version that support\n\t  HTTPS by default validate the issuer of the SSL certificates, and self-signed \n\t  certificates won't work.  The inject required step reverses this behavior.\n\t  It will pass in the --noverifyssl in the kickstart file for a HTTPs URL.\n\t  To prevent this from happening and make the RHEL installer verify SSL \n\t  certificates pass use this paramter.\n\nPrerequisites:\n- Target server runs a maintenance Linux OS.\n- The user provided or default ks file must be in /tmp/user.ks.cfg.",
                    "current": false
                },
                {
                    "versionLabel": "2",
                    "createdBy": "opsware",
                    "createdDate": "2015-08-04T07:30:26.000Z",
                    "usage": "This script inject required settings into the kickstart file. It appends code to\nthe %pre section of the kickstart file, to start the agent before the\ninstallation starts. It also injects code into the %post section to prevent the\ninstaller from rebooting after the installation is complete. The lather gives us\na chance to integrate the HP SA agent. It also injects NFS settings if not\nalready there.\n\nUsage:\n\tinject_required_ks.py [--verifyssl]\n\nParameters:\n\tverifyssl: If you are doing HTTPS provisioning, the RHEL version that support\n\t  HTTPS by default validate the issuer of the SSL certificates, and self-signed \n\t  certificates won't work.  The inject required step reverses this behavior.\n\t  It will pass in the --noverifyssl in the kickstart file for a HTTPs URL.\n\t  To prevent this from happening and make the RHEL installer verify SSL \n\t  certificates pass use this paramter.\n\nPrerequisites:\n- Target server runs a maintenance Linux OS.\n- The user provided or default ks file must be in /tmp/user.ks.cfg.",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-08-04T07:30:26.000Z",
            "version": {
                "versionLabel": "2",
                "createdBy": "opsware",
                "createdDate": "2015-08-04T07:30:26.000Z",
                "usage": "This script inject required settings into the kickstart file. It appends code to\nthe %pre section of the kickstart file, to start the agent before the\ninstallation starts. It also injects code into the %post section to prevent the\ninstaller from rebooting after the installation is complete. The lather gives us\na chance to integrate the HP SA agent. It also injects NFS settings if not\nalready there.\n\nUsage:\n\tinject_required_ks.py [--verifyssl]\n\nParameters:\n\tverifyssl: If you are doing HTTPS provisioning, the RHEL version that support\n\t  HTTPS by default validate the issuer of the SSL certificates, and self-signed \n\t  certificates won't work.  The inject required step reverses this behavior.\n\t  It will pass in the --noverifyssl in the kickstart file for a HTTPs URL.\n\t  To prevent this from happening and make the RHEL installer verify SSL \n\t  certificates pass use this paramter.\n\nPrerequisites:\n- Target server runs a maintenance Linux OS.\n- The user provided or default ks file must be in /tmp/user.ks.cfg.",
                "current": true
            },
            "source": "#!/usr/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n\"\"\"\n    (C) Copyright 2009-2015 Hewlett-Packard Development Company, L.P.\n\n    Inject required options and move the file onto the boot\n    partition.\n\"\"\"\n\nimport sys\nfrom optparse import OptionParser\n\nfrom osprov import helpers\nfrom osprov.errors import ShowErrorMessage\nfrom osprov.osbp.constants import CODE_HEADER, CODE_FOOTER, CODE_WARNING, MONITORING_STOP_FLAG\nfrom osprov.platform_util import isRHELCompatible\nfrom osprov.profile import Kickstart, ProfileError\nfrom osprov.profile.kickstart import Directive, Script\nfrom osprov.osbp import ThisTargetServer, logger\nfrom osprov.osbp.helpers import getMediaURL\n\nLOG = logger.getIt('inject_required')\n\nBASE_KS_FILE = \"tmp/user.ks.cfg\"\nEC_NOT_SUPPORTED = 101\n\n\nclass CustomParser(OptionParser):\n\n    \"\"\" a custom parser \"\"\"\n\n    def __init__(self, *args, **kwargs):\n        OptionParser.__init__(self, *args, **kwargs)\n        self.add_option(\"--verifyssl\", action=\"store_true\", default=False,\n                        help=\"If this flag is set we will instruct the installer to \"\n                        \"validate that the certificates are issued by a trusted CA. \"\n                        \"Useful for HTTPS provisioning\")\n\n\ndef initKickstart(baseFile, platform):\n    \"\"\" Initialize a Kickstart object \"\"\"\n    fileobj = open(baseFile, \"r\")\n    if isRHELCompatible(platform, 7):\n        return Kickstart(fileobj, endtags=True)\n    else:\n        return Kickstart(fileobj, endtags=False)\n\n\ndef injectMediaLocation(ksobj, mediaUrl, verifyssl=False):\n    \"\"\" inject settings required for OS provisioning to work\n            currently it only injects the media share.\n    \"\"\"\n    if mediaUrl.scheme == \"nfs\":\n        nfs = Directive(\"nfs\")\n        nfs[\"server\"] = mediaUrl.netloc\n        nfs[\"dir\"] = mediaUrl.path\n        if mediaUrl.query:\n            nfs[\"opts\"] = mediaUrl.query\n        ksobj.directives.append(nfs)\n    elif mediaUrl.scheme in [\"http\", \"https\"]:\n        url = Directive(\"url\")\n        url[\"url\"] = mediaUrl.canonical()\n        if mediaUrl.scheme == \"https\" and not verifyssl:\n            url[\"noverifyssl\"] = None\n        ksobj.directives.append(url)\n    else:\n        raise ShowErrorMessage(\n            \"ERROR: %s is not supported at this time\" % mediaUrl.scheme)\n\n\ndef removeConflictingOsprov(ksobj):\n    \"\"\" Removes osprov conflicting options from the kickstart \"\"\"\n    # Remove reboot\n    if hasattr(ksobj, \"reboot\"):\n        ksobj.reboot.name = \"# Reboot will be initiated by HPSA\"  # QC 120104\n    # Remove installation path\n    for name in [\"cdrom\", \"nfs\", \"url\", \"harddrive\"]:\n        if hasattr(ksobj, name):\n            for instance in ksobj.getDirectiveList(name):\n                print (\"Removing '%s' from the profile\" % instance)\n                instance.name = \"#%s\" % instance.name\n    # Disable SELinux\n    if not hasattr(ksobj, \"selinux\"):\n        selinux = Directive(\"selinux\")\n        selinux[\"disabled\"] = None\n        ksobj.directives.append(selinux)\n        print \"Disabling SELinux as it's not supported by the SA Agent.\"\n    elif not \"disabled\" in ksobj.selinux:\n        ksobj.selinux.clear()\n        ksobj.selinux[\"disabled\"] = None\n        print \"SELinux configuration setting was found. Disabling SELinux as it's not supported by the SA Agent.\"\n\n\ndef alreadyInjectedPre(ksobj):\n    for script in ksobj.scripts:\n        if script.type == \"pre --erroronfail\" and \\\n                CODE_HEADER.strip() in script.contents:\n            return True\n    return False\n\n\ndef injectPreScript(ksobj, script, options=\"\"):\n    code = CODE_HEADER + script + CODE_FOOTER\n    pre = Script(\"pre %s\" % options)\n    pre.contents.extend(code.split(\"\\n\"))\n    ksobj.scripts.append(pre)\n\n\ndef injectStartOgfsAgentPreScript(ksobj, targetServer):\n    \"\"\" Inject code in the pre hook to start the OGFS agent \"\"\"\n    if alreadyInjectedPre(ksobj):\n        return\n    agwIpPort = targetServer.getRandomAgentGateway()\n    flags = {\"mount\": False, \"async\": True, \"quiet\": True}\n    startCode = \"\"\"\nnetstat -nt | awk '{print $4}' | grep 1002 && reboot\n%s\n\"\"\" % targetServer.localServer.getOgfsAgentStartupScript(agwIpPort, flags=flags)\n    injectPreScript(ksobj, startCode, \"--erroronfail\")\n\n\ndef injectWaitForNMPreScript(ksobj):\n    injectPreScript(ksobj, \"\"\"\n           echo Waiting for NM connectivity to be available\n           for i in 1st 2nd 3rd 4th 5th 6th 7th 8th 9th 10th; do\n               nmcli networking connectivity check | grep full && echo Done && exit 0\n               echo \"Waiting for NM for the ${i} time\"\n               sleep 5\n           done\n           echo Waiting for NM connectivity failed, continuing...\n           \"\"\")\n\n\ndef injectPost(ksobj):\n    \"\"\" Inject code to stall the installer\"\"\"\n    for script in ksobj.scripts:\n        if script.type == \"post\" and \\\n                CODE_HEADER.strip() in script.contents:\n            return\n    scriptCode = \"\"\"\n{header}\n{warning}\necho \"DONE\" > {stopFlag}\n{footer}\n\"\"\".format(\n        header=CODE_HEADER,\n        warning=CODE_WARNING,\n        footer=CODE_FOOTER,\n        stopFlag=MONITORING_STOP_FLAG\n    )\n    post = Script(\"post\")\n    post.contents.extend(scriptCode.split(\"\\n\"))\n    ksobj.scripts.append(post)\n\n\ndef writeFinalKs(ksobj):\n    \"\"\" Write the kickstart file onto the boot disk \"\"\"\n    ksfile = open(BASE_KS_FILE, \"w\")\n    ksfile.write(str(ksobj))\n    ksfile.close()\n    print \"Kickstart file written to disk\"\n\n\ndef main():\n    \"\"\" Do the injection into the kickstart \"\"\"\n    try:\n        args_parser = CustomParser()\n        options, remaining_args = args_parser.parse_args()\n        targetServer = ThisTargetServer()\n        targetServer.setWorkDir(targetServer.getRemoteRoot())\n        keys = helpers.getDataStore(targetServer)\n        keys.platform.full_name = \" \".join(remaining_args)\n        helpers.putDataStore(keys, targetServer)\n        ksobj = initKickstart(BASE_KS_FILE, keys.platform.full_name)\n        removeConflictingOsprov(ksobj)\n        mediaUrl = getMediaURL(keys)\n        rhel7 = isRHELCompatible(keys.platform.full_name, version=7)\n        if mediaUrl.scheme == \"https\":\n            if rhel7:\n                print (\"Warning: Provisioning {platname} from HTTPS media is supported only \" +\n                       \"when using trusted CA signed server certificates. Skipping the certificate \" +\n                       \"validation is not supported by the installer.\").format(platname=keys.platform.full_name)\n            else:\n                print \"Warning: Provisioning from a HTTPS media source is only supported \"\\\n                    \"by Red Hat starting from Enterprise Linux 6. \\n By default checking of \"\\\n                    \"Certificate Authorities is disabled. Use the --verifyssl option to this \"\\\n                    \"step to enable it. You will need to set this option and have a valid \"\\\n                    \"certificate for RHEL 6.0 with HTTPS. All subsequent releases, starting \"\\\n                    \"from RHEL 6.1 support self signed certificates.\"\n        if mediaUrl.username and mediaUrl.scheme in [\"http\", \"https\"]:\n            print \"Red Hat Enterprise Linux does not support authentication for HTTP and HTTPS\"\n            return EC_NOT_SUPPORTED\n        if not rhel7 and targetServer.isIPv6Managed():\n            print \"Provisioning {platname} is not supported over IPv6\".format(platname=keys.platform.full_name)\n            return EC_NOT_SUPPORTED\n        injectMediaLocation(ksobj, mediaUrl, verifyssl=options.verifyssl)\n        if not rhel7:\n            injectStartOgfsAgentPreScript(ksobj, targetServer)\n        else:\n            injectWaitForNMPreScript(ksobj)\n        injectPost(ksobj)\n        writeFinalKs(ksobj)\n        print \"Successfully injected required settings\"\n    except (IOError, OSError, ShowErrorMessage, ProfileError), why:\n        LOG.exception(why)\n        sys.stderr.write(\"Failed to inject required settings.%s\\n\" % why)\n        return 1\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n",
            "description": "This script inject required settings into the kickstart file. It appends code to\nthe %pre section of the kickstart file, to start the agent before the\ninstallation starts. It also injects code into the %post section to prevent the\ninstaller from rebooting after the installation is complete. The lather gives us\na chance to integrate the HP SA agent. It also injects NFS settings if not\nalready there.\n\nUsage:\n\tinject_required_ks.py [--verifyssl]\n\nParameters:\n\tverifyssl: If you are doing HTTPS provisioning, the RHEL version that support\n\t  HTTPS by default validate the issuer of the SSL certificates, and self-signed \n\t  certificates won't work.  The inject required step reverses this behavior.\n\t  It will pass in the --noverifyssl in the kickstart file for a HTTPs URL.\n\t  To prevent this from happening and make the RHEL installer verify SSL \n\t  certificates pass use this paramter.\n\nPrerequisites:\n- Target server runs a maintenance Linux OS.\n- The user provided or default ks file must be in /tmp/user.ks.cfg.",
            "status": null,
            "name": "Inject Required Kickstart Settings",
            "state": null,
            "eTag": "2015-08-04T07:30:26.000Z",
            "modified": "2015-08-04T07:30:26.000Z",
            "created": "2015-06-13T04:49:00.000Z",
            "category": "os-deployment-ogfs-scripts",
            "uri": "/rest/os-deployment-ogfs-scripts/800001"
        },
        {
            "codeType": "OGFS",
            "displayCodeType": "OGFS",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "1",
                    "createdBy": "opsware",
                    "createdDate": "2015-06-13T04:49:00.000Z",
                    "usage": "Replaced step. No longer in use. Please refer to \"User Guide: Provisioning\" for using the new steps",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-06-13T04:49:00.000Z",
            "version": {
                "versionLabel": "1",
                "createdBy": "opsware",
                "createdDate": "2015-06-13T04:49:00.000Z",
                "usage": "Replaced step. No longer in use. Please refer to \"User Guide: Provisioning\" for using the new steps",
                "current": true
            },
            "source": "#!/usr/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n#\n\"\"\"\n    (C) Copyright 2010-2015 Hewlett-Packard Development Company, L.P.\n\n    Deploys the RAID configuration on the target server\n    from a Software Policy\n\"\"\"\nimport sys\nimport os\nfrom osprov.osbp import logger\n\nLOG = logger.getIt(\"deploy raid\")\n\ndef main():\n    \"\"\" Main entry point \"\"\"\n\n    print(\"Warning: Deploy RAID step is replaced. Please refer to 'User Guide: Provisioning' for using the new steps!\")\n    return 1\n\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n",
            "description": "Replaced step. No longer in use. Please refer to \"User Guide: Provisioning\" for using the new steps",
            "status": null,
            "name": "Deploy HP RAID Configuration",
            "state": null,
            "eTag": "2015-06-13T04:49:00.000Z",
            "modified": "2015-06-13T04:49:00.000Z",
            "created": "2015-06-13T04:49:00.000Z",
            "category": "os-deployment-ogfs-scripts",
            "uri": "/rest/os-deployment-ogfs-scripts/810001"
        },
        {
            "codeType": "OGFS",
            "displayCodeType": "OGFS",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "1",
                    "createdBy": "opsware",
                    "createdDate": "2015-06-13T04:49:00.000Z",
                    "usage": "Adds a newly provisioned hypervisor to a virtualization manager.\n\nusage: add_to_virt_manager.py [options]\n\noptions:\n  -m MANAGER, --manager=MANAGER\n                        Virtualization Manager where the server will be added.\n                        If not present the script will decide on one.\n  -p, --pass            If this flag is present together with the \"driver\" option\n                        the  build plan will only print a warning that there is no\n                        V12n manager present in SA, but it will not fail.\n  -c CONTAINER, --container=CONTAINER\n                        The container where this server will be added. If not\n                        specified, the V12N service decides on a default.\n  --driver=DRIVER\n                        Specifies that the target server should be added to\n                        service backed by a VMware vCenter. This is only required if no \"manager\"\n                        is present. If \"manager\" is passed in, this will be ignored and automatically\n                        determined. Valid options are: vmware_vcenter and microsoft_scvmm.\n  --username=USERNAME\n                        Specifies the username to use. Optional.\n  --password=PASSWORD\n                        Specifies the password to use. Optional.",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-06-13T04:49:00.000Z",
            "version": {
                "versionLabel": "1",
                "createdBy": "opsware",
                "createdDate": "2015-06-13T04:49:00.000Z",
                "usage": "Adds a newly provisioned hypervisor to a virtualization manager.\n\nusage: add_to_virt_manager.py [options]\n\noptions:\n  -m MANAGER, --manager=MANAGER\n                        Virtualization Manager where the server will be added.\n                        If not present the script will decide on one.\n  -p, --pass            If this flag is present together with the \"driver\" option\n                        the  build plan will only print a warning that there is no\n                        V12n manager present in SA, but it will not fail.\n  -c CONTAINER, --container=CONTAINER\n                        The container where this server will be added. If not\n                        specified, the V12N service decides on a default.\n  --driver=DRIVER\n                        Specifies that the target server should be added to\n                        service backed by a VMware vCenter. This is only required if no \"manager\"\n                        is present. If \"manager\" is passed in, this will be ignored and automatically\n                        determined. Valid options are: vmware_vcenter and microsoft_scvmm.\n  --username=USERNAME\n                        Specifies the username to use. Optional.\n  --password=PASSWORD\n                        Specifies the password to use. Optional.",
                "current": true
            },
            "source": "#!/usr/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# lint_ignore=E501,I0011\n# Please do not change the two lines above. See PEP 8, PEP 263.\n\"\"\"\n    (C) Copyright 2011-2015 Hewlett-Packard Development Company, L.P.\n\n    OGFS script to integrate the server with V12N services.\n\"\"\"\nimport sys\n\nfrom osprov.optparse_ext import OptionParser, OptionValueError\nfrom osprov.osbp import ThisTargetServer\nfrom osprov import helpers\nfrom osprov.decorators import HandleShowErrorMessage\nfrom osprov.errors import DiscoveryError, ShowErrorMessage\nfrom osprov.osbp import logger\nfrom osprov.util import NullLog\nfrom osprov.util.twist import WaitForWLMJob\nfrom osprov import constants\n\n# pylint: disable=F0401,E0611\nfrom pytwist.com.opsware.v12n.mgmtservice import V12nVIManagerRef\nfrom pytwist.com.opsware.v12n import AddHostSpec, \\\n    V12nInventoryItemReference, \\\n    V12nDriverCodeConstant, \\\n    SSLCertVerificationException\nfrom pytwist.com.opsware.v12n.vmware import VmwareAddHostSpec\nfrom pytwist.com.opsware.custattr import NoSuchFieldException, CustomAttribute\n# pylint: enable=F0401,E0611\n\nLOG = logger.getIt(\"add_to_v12n_manager\")\n\nIP_REPORT_CA = CustomAttribute.OPSWARE_PRIVATE_KEY_PREFIX + constants.IP_REPORT_CA\n\n\nclass CustomParser(OptionParser):\n\n    \"\"\" a custom parser \"\"\"\n\n    @staticmethod\n    def driverOptionCallback(option, opt, value, parser):\n        \"\"\" Callback to handle the driver options \"\"\"\n        if value.lower() == \"vmware_vcenter\":\n            setattr(parser.values, option.dest, V12nDriverCodeConstant.VMWARE_VCENTER)\n        elif value.lower() == \"microsoft_scvmm\":\n            setattr(parser.values, option.dest, V12nDriverCodeConstant.MICROSOFT_SCVMM)\n        else:\n            raise OptionValueError(\"Invalid value for \\\"%s\\\" : %s\" % (opt, value))\n\n    @staticmethod\n    def managerOptionCallback(option, opt, value, parser):\n        \"\"\" Callback to handle converting the manager to Ref \"\"\"\n        del opt\n        setattr(parser.values, option.dest, V12nVIManagerRef(value))\n\n    @staticmethod\n    def containerOptionCallback(option, opt, value, parser):\n        \"\"\" callback to handle the container option \"\"\"\n        if \":\" not in value:\n            raise OptionValueError(\n                \"Invalid syntax for \\\"%s\\\" : %s ( should contain : )\" % (opt, value))\n        locType, locId = value.split(\":\", 1)\n        try:\n            locId = long(locId)\n        except ValueError:\n            raise OptionValueError(\"Invalid Id for \\\"%s\\\" :  %s, should be a number\" % (opt, locId))\n        if not locType.endswith(\"Ref\"):\n            locType += \"Ref\"\n        locClass = \"pytwist.com.opsware.v12n.%s\" % locType\n        locClass = locClass.split(\".\")\n        modName = \".\".join(locClass[:-1])\n        className = locClass[-1]\n        try:\n            __import__(modName)\n            mod = sys.modules[modName]\n            locRef = getattr(mod, className)()\n            locRef.id = locId\n        except ImportError, why:\n            raise OptionValueError(\"Invalid Type for \\\"%s\\\" : %s\" % (opt, why))\n        except AttributeError:\n            raise OptionValueError(\"Invalid Type for \\\"%s\\\" : %s: no such class in %s\" %\n                                  (opt, className, modName))\n        if not isinstance(locRef, V12nInventoryItemReference):\n            raise OptionValueError(\n                \"Invalid Type for \\\"%s\\\" : %s  must implement V12nInventoryItemReference\" % (opt, locType))\n        setattr(parser.values, option.dest, locRef)\n\n    def defineOptions(self):\n        self.add_option(\"-m\", \"--manager\", type=\"long\",\n                        help=\"The ID of the virtualization Manager where the server will be added. \"\n                        \"If not present the script will decide on one, but you \"\n                        \"need to pass it at least the manager type.\", action=\"callback\",\n                        callback=self.managerOptionCallback)\n\n        self.add_option(\"-p\", \"--pass\", dest=\"passit\", action=\"store_true\", default=False,\n                        help=\"If this flag is present together with the \\\"driver\\\" option \"\n                        \"the  build plan will only print a warning that there is no\"\n                        \"Virtualization manager present in SA, but it will not fail.\")\n\n        self.add_option(\"-d\", \"--driver\", type=\"string\",\n                        help=\"Specifies that the target server should be added to \"\n                        \"service backed by a VMware vCenter. This is only required if no \\\"manager\\\"\"\n                        \"is present. If \\\"manager\\\" is passed in, this will be ignored and automatically determined.\"\n                        \"Valid options are: vmware_vcenter and microsoft_scvmm.\", action=\"callback\",\n                        callback=self.driverOptionCallback)\n\n        self.add_option(\"-c\", \"--container\", type=\"string\",\n                        help=\"Specifies the type and Id of the container. This needs to be a valid container for \"\n                        \"the V12n driver being used.\"\n                        \"The argument needs to be given in Type:ID format where Type is the pytwist class of the \"\n                        \"object without the \"\n                        \" \\\"com.opsware.v12n\\\" prefix, so for example to add an ESXi to a specific datacenter you \"\n                        \"would use: vmware.V12nDatacenter:1940001 ( where 1940001 is a valid ID)\",\n                        action=\"callback\", callback=self.containerOptionCallback)\n        self.add_option(\"--username\", type=\"string\", default=None,\n                        help=\"Specifies the username to use. Optional.\")\n        self.add_option(\"--password\", type=\"string\", default=None,\n                        help=\"Specifies the password to use. Optional.\")\n\n    def validateArgs(self, opt, args):\n        \"\"\" Validate arguments \"\"\"\n        if not opt.manager and not opt.driver:\n            raise OptionValueError(\"One of \\\"manager\\\" or \\\"driver\\\" is mandatory.\")\n        if opt.manager:\n            # passit is only effective with a driver\n            opt.passit = False\n            # driver is ignored if manager is present\n            opt.driver = None\n\n\nclass AddToManager(object):\n\n    \"\"\" Add the host to a VI manager \"\"\"\n\n    def __init__(self, targetServer, log=NullLog(), driverType=None):\n        self.targetServer = targetServer\n        self.twistServer = targetServer.twistServer\n        self.log = log\n        self.driverType = driverType\n\n    def getIpAddress(self):\n        \"\"\" Get the IP address to be passed  \"\"\"\n        outOfBandIP = self._getOutOfBandIpAddress()\n        if outOfBandIP:\n            return outOfBandIP\n        return self.targetServer.getServerVO().managementIP\n\n    def _getOutOfBandIpAddress(self):\n        \"\"\" Get the IP address to be passed  \"\"\"\n        self.log.info(\"Looking for reported IP address.\")\n        try:\n            esxiReported = self.targetServer.twistServer.server.ServerService.getCustAttr(\n                self.targetServer.serverRef, IP_REPORT_CA, True)\n            return esxiReported.split(\",\")[0].strip()\n        except NoSuchFieldException:\n            LOG.info(\"'%s'  CA not reported.\", IP_REPORT_CA)\n        return None\n\n    def startAddHost(self, managerRef, username, password, container, sslThumbprint=None):\n        \"\"\" Call the start add host call from the V12n API \"\"\"\n        if sslThumbprint:\n            hostSpec = VmwareAddHostSpec()\n            hostSpec.setSSLThumbPrint(sslThumbprint)\n        else:\n            hostSpec = AddHostSpec()\n        hostSpec.serverRef = self.targetServer.getServerRef()\n        # network address\n        if self.driverType == V12nDriverCodeConstant.MICROSOFT_SCVMM:\n            # SCVMM doesn't support adding by IP (QC #147852) if IPs can't be resolved\n            # back to domains. Since it's required to have the target in the domain\n            # anyway, we know that hostname will bre resolvable, so in stead of adding a configuration\n            # requirement for this step ( configuring reverse DSN ) we just use hostname here\n            hostSpec.hostname = self.targetServer.serverVO.hostName\n        else:\n            # for all others we use IPs, this is important for ESXi where the IP address is not always\n            # available or accurate on the server record.\n            hostSpec.hostname = self.getIpAddress()\n        hostSpec.username = username\n        hostSpec.password = password\n        hostSpec.container = container\n        self.log.debug(\"About to register host to manager (%s) with :\" % managerRef)\n        self.log.debug(\"  hostname: %s\" % hostSpec.hostname)\n        self.log.debug(\"  username: %s\" % hostSpec.username)\n        self.log.debug(\"  password: %s...%s\" % (hostSpec.password[0], hostSpec.password[1]))\n        self.log.debug(\"  container: %s\" % hostSpec.container)\n        if hasattr(hostSpec, \"getSSLThumbPrint\"):\n            self.log.debug(\"  sslThumbprint: %s\" % (hostSpec.getSSLThumbPrint()))\n        return self.twistServer.v12n.V12nVIManagerService.startAddHost(\n            managerRef,\n            hostSpec,\n            300,  # timeout in seconds, should be enough for a blank server\n            \"Initiated by OSBP\",\n            None,\n            None  # no notification and schedule\n        )\n\n    def discoverVIManager(self):\n        \"\"\" Discover a manager ref, that we can use to add  \"\"\"\n        viType = self.driverType\n        driverRef = self.twistServer.v12n.V12nDriverService.findV12nDriverByCode(viType)\n        filterObj = self.twistServer.v12n.V12nDriverService.getRegistrableServers(driverRef)\n        hosts = self.twistServer.server.ServerService.findServerRefs(filterObj)\n        self.log.debug(\"Found following hosts: %s\" % (hosts, ))\n        for serverRef in hosts:\n            managers = self.twistServer.server.ServerService.getHostedManagers(serverRef)\n            self.log.debug(\"Following managers for %s:%s\" % (serverRef, managers))\n            for managerRef in managers:\n                if isinstance(managerRef, V12nVIManagerRef):\n                    # return the first once by convention\n                    return managerRef\n        raise DiscoveryError(\"No suitable managers found\")\n\n    def getDriver(self, managerRef):\n        \"\"\" Return the driver for a manager \"\"\"\n        managerVO = self.twistServer.v12n.V12nVIManagerService.getV12nVIManagerVO(managerRef)\n        driverVO = self.twistServer.v12n.V12nDriverService.getV12nDriverVO(managerVO.driver)\n        self.driverType = driverVO.code\n\n\ndef getUsernameAndPassword(targetServer, options):\n    \"\"\" Return the username and password \"\"\"\n    if options.username and options.password:\n        username = options.username\n        password = options.password\n    else:\n        dstore = helpers.getDataStore(targetServer)\n        if hasattr(dstore.profile, \"username\") and hasattr(dstore.profile, \"password\"):\n            username = dstore.profile.username\n            password = dstore.profile.password\n        else:\n            raise ShowErrorMessage(\"The username and password were not specified.\")\n    return username, password\n\n\n@HandleShowErrorMessage(\"add host\", LOG)\ndef main():\n    \"\"\" Entry point \"\"\"\n    # Parse the arguments\n    args_parser = CustomParser()\n    opt, remaining_args = args_parser.parse_args()\n    if remaining_args:\n        print \"Unneeded arguments (will be ignored): %s\" % \",\".join(remaining_args)\n    targetServer = ThisTargetServer()\n    atm = AddToManager(targetServer, log=LOG, driverType=opt.driver)\n    # Determine the manager\n    if opt.manager:\n        managerRef = opt.manager\n        atm.getDriver(managerRef)\n    else:\n        try:\n            managerRef = atm.discoverVIManager()\n        except DiscoveryError, why:\n            print \"Warning: No virtualization services registered. Hypervisor will not be managed.\"\n            if opt.passit:\n                print \"Since --pass or -p was passed, will report success.\"\n                return 0\n            else:\n                raise why\n    print \"Going to add server to   %s\" % managerRef\n\n    username, password = getUsernameAndPassword(targetServer, opt)\n    LOG.debug(\"Username=%s, password=%s\", username, password)\n\n    jobRef = atm.startAddHost(managerRef, username, password, opt.container)\n    print \"Started job to add host: %s\" % jobRef\n    waitForIt = WaitForWLMJob(jobRef=jobRef, log=LOG, twistServer=targetServer.twistServer)\n    try:\n        waitForIt()\n    except SSLCertVerificationException:\n        # This happens fro ESXi, when we first try to add it we get the thumbprint\n        # WLM doesn't persist the sslThumbprint on the Exception, so we need to\n        # get it from the job result\n        print \"Retrieved SSL Thumbprint. Trying again\"\n        sslThumbprint = waitForIt.jobResult.sslThumbprint\n        jobRef = atm.startAddHost(managerRef, username, password, opt.container, sslThumbprint)\n        print \"Started job to add host: %s\" % jobRef\n        waitForIt = WaitForWLMJob(\n            jobRef=jobRef, log=LOG, twistServer=targetServer.twistServer)\n        waitForIt()\n\n    print \"Successfully added virtualization host\"\n\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n",
            "description": "Adds a newly provisioned hypervisor to a virtualization manager.\n\nusage: add_to_virt_manager.py [options]\n\noptions:\n  -m MANAGER, --manager=MANAGER\n                        Virtualization Manager where the server will be added.\n                        If not present the script will decide on one.\n  -p, --pass            If this flag is present together with the \"driver\" option\n                        the  build plan will only print a warning that there is no\n                        V12n manager present in SA, but it will not fail.\n  -c CONTAINER, --container=CONTAINER\n                        The container where this server will be added. If not\n                        specified, the V12N service decides on a default.\n  --driver=DRIVER\n                        Specifies that the target server should be added to\n                        service backed by a VMware vCenter. This is only required if no \"manager\"\n                        is present. If \"manager\" is passed in, this will be ignored and automatically\n                        determined. Valid options are: vmware_vcenter and microsoft_scvmm.\n  --username=USERNAME\n                        Specifies the username to use. Optional.\n  --password=PASSWORD\n                        Specifies the password to use. Optional.",
            "status": null,
            "name": "Add to Virtualization Manager",
            "state": null,
            "eTag": "2015-06-13T04:49:00.000Z",
            "modified": "2015-06-13T04:49:00.000Z",
            "created": "2015-06-13T04:49:00.000Z",
            "category": "os-deployment-ogfs-scripts",
            "uri": "/rest/os-deployment-ogfs-scripts/820001"
        },
        {
            "codeType": "OGFS",
            "displayCodeType": "OGFS",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "1",
                    "createdBy": "opsware",
                    "createdDate": "2015-06-13T04:49:01.000Z",
                    "usage": "Clears the checkpoint created by the 'Create Checkpoint' step. Does not fail if no checkpoint exists.\n\nusage: clear_checkpoint.py [-h] [--name NAME]\n\noptional arguments:\n  -h, --help   show this help message and exit\n  --name NAME  Name of the custom attribute to use. Defaults to 'CurrentStepCheckpoint'\n               Will print a warning if the custom attribute is not found",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-06-13T04:49:01.000Z",
            "version": {
                "versionLabel": "1",
                "createdBy": "opsware",
                "createdDate": "2015-06-13T04:49:01.000Z",
                "usage": "Clears the checkpoint created by the 'Create Checkpoint' step. Does not fail if no checkpoint exists.\n\nusage: clear_checkpoint.py [-h] [--name NAME]\n\noptional arguments:\n  -h, --help   show this help message and exit\n  --name NAME  Name of the custom attribute to use. Defaults to 'CurrentStepCheckpoint'\n               Will print a warning if the custom attribute is not found",
                "current": true
            },
            "source": "#!/usr/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n\"\"\"\n    (C) Copyright 2014-2015 Hewlett-Packard Development Company, L.P.\n\"\"\"\n\nimport sys\nfrom argparse import ArgumentParser\nfrom types import StringType\n\nfrom osprov.osbp import ThisTargetServer\n\nCURRENT_STEP_CHECKPOINT_CA = \"CurrentStepCheckpoint\"\n\n\ndef main():\n\n    argsParser = ArgumentParser()\n    argsParser.add_argument(\"--name\", type=StringType, metavar=\"NAME\",\n                            default=CURRENT_STEP_CHECKPOINT_CA,\n                            help=\"Name of the custom attribute to use. \"\n                            \"Defaults to '%s'\" % CURRENT_STEP_CHECKPOINT_CA)\n    args = argsParser.parse_args()\n\n    checkpointName = ThisTargetServer().getCustomAttribute(args.name)\n    if checkpointName:\n        ThisTargetServer().removeCustomAttribute(args.name)\n        print \"Cleared checkpoint '%s'\" % args.name\n    else:\n        print \"Warning: checkpoint '%s' does not exist\" % args.name\n\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n",
            "description": "Clears the checkpoint created by the 'Create Checkpoint' step. Does not fail if no checkpoint exists.\n\nusage: clear_checkpoint.py [-h] [--name NAME]\n\noptional arguments:\n  -h, --help   show this help message and exit\n  --name NAME  Name of the custom attribute to use. Defaults to 'CurrentStepCheckpoint'\n               Will print a warning if the custom attribute is not found",
            "status": null,
            "name": "Clear Checkpoint",
            "state": null,
            "eTag": "2015-06-13T04:49:01.000Z",
            "modified": "2015-06-13T04:49:01.000Z",
            "created": "2015-06-13T04:49:01.000Z",
            "category": "os-deployment-ogfs-scripts",
            "uri": "/rest/os-deployment-ogfs-scripts/840001"
        },
        {
            "codeType": "OGFS",
            "displayCodeType": "OGFS",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "1",
                    "createdBy": "opsware",
                    "createdDate": "2015-06-13T04:49:03.000Z",
                    "usage": "Injects settings for personalization into a Kickstart installation profile.\nPersonalization settings include network settings.\n\nUsage: inject_ks_personalization_settings.py [OPTIONS]\n\nOptions:\n--require-netconfig=[true,false]\n\tSpecify whether a netconfig is mandatory or not.\n\tOptional argument, defaults to false.\n\n--disableWarning\n    Do not show warnings of old hpsa_netconfig format\n    Optional argument, defaults to false.\n\nPrerequisites:\n- Target server runs a maintenance Linux OS.",
                    "current": false
                },
                {
                    "versionLabel": "2",
                    "createdBy": "opsware",
                    "createdDate": "2015-08-04T07:30:29.000Z",
                    "usage": "Injects settings for personalization into a Kickstart installation profile.\nPersonalization settings include network settings.\n\nUsage: inject_ks_personalization_settings.py [OPTIONS]\n\nOptions:\n--require-netconfig=[true,false]\n\tSpecify whether a netconfig is mandatory or not.\n\tOptional argument, defaults to false.\n\n--disableWarning\n    Do not show warnings of old hpsa_netconfig format\n    Optional argument, defaults to false.\n\nPrerequisites:\n- Target server runs a maintenance Linux OS.",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-08-04T07:30:29.000Z",
            "version": {
                "versionLabel": "2",
                "createdBy": "opsware",
                "createdDate": "2015-08-04T07:30:29.000Z",
                "usage": "Injects settings for personalization into a Kickstart installation profile.\nPersonalization settings include network settings.\n\nUsage: inject_ks_personalization_settings.py [OPTIONS]\n\nOptions:\n--require-netconfig=[true,false]\n\tSpecify whether a netconfig is mandatory or not.\n\tOptional argument, defaults to false.\n\n--disableWarning\n    Do not show warnings of old hpsa_netconfig format\n    Optional argument, defaults to false.\n\nPrerequisites:\n- Target server runs a maintenance Linux OS.",
                "current": true
            },
            "source": "#!/usr/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# lint_ignore=E501,I0011,C0301\n# Please do not change the two lines above. See PEP 8, PEP 263.\n\"\"\"\n    (C) Copyright 2010-2015 Hewlett-Packard Development Company, L.P.\n\n    This program will inject personalized settings into the kickstart\n    file.\n\"\"\"\n\nimport os\nimport sys\nfrom cStringIO import StringIO\n\nfrom osprov import helpers\nfrom osprov.errors import ShowErrorMessage\nfrom osprov.optparse_ext import OptionParser, OptionValueError\nfrom osprov.osbp import ThisTargetServer, logger\nfrom osprov.osbp.constants import CODE_HEADER, CODE_WARNING, CODE_FOOTER\nfrom osprov.osbp.helpers import getMediaURL\nfrom osprov.platform_util import isRHELCompatible, isRHEL7CompatibleMedia\nfrom osprov.profile import Kickstart\nfrom osprov.profile.kickstart import Directive\nfrom osprov.profile.kickstart import Script\nfrom osprov.parsers.netconfig import SmartNetconfig, OLD_SYNTAX_WARNING\nfrom osprov.networking import validation\n\nEC_NO_ERR = 0\nEC_NO_CA = 20\nEC_EXCEPTION = 100\nEC_NOT_SUPPORTED = 101\n\nKS_PATH = \"tmp/user.ks.cfg\"\n\nLOG = logger.getIt('inject_ks_pers')\n\n# replaced at build time\nTARGET_OS = \"esxi5\"\n\n\ndef removeNetworkDirective(ks):\n    if hasattr(ks, \"network\"):\n        print \"Removing existing network personalization from the kickstart\"\n        ks.directives.remove(ks.network)\n\ndef injectSysctlSettings(isIPv6Managed):\n    sysctl = open(\"tmp/sysctl.conf\", \"w\")\n    if not isIPv6Managed:\n        sysctl.write(\"net.ipv6.conf.all.disable_ipv6=1\")\n    sysctl.close()\n\n\ndef injectPersonalization(ks, netinfo, provisioningNIC, provisioningRoute, isIPv6Managed, isRHEL7=False):\n    \"\"\" Inject static networking configuration into the kickstart profile. \"\"\"\n    removeNetworkDirective(ks)\n\n    static_dir = Directive(\"network\")\n    static_dir[\"device\"] = provisioningNIC.macAddress\n    print \"Going to provision using interface with MAC address %s\" % provisioningNIC.macAddress\n\n    # ESXi doesn't support ipv6, noipv6 and noipv4 boot parameters\n    isESXi = \"esxi\" in TARGET_OS\n\n    if isIPv6Managed:\n        if isESXi:\n            if provisioningNIC.ipv6Networks:\n                print \"Configuring boot protocol to: static\"\n                static_dir[\"bootproto\"] = \"static\"\n            elif provisioningNIC.ipv6Autoconfig:\n                # esxi does not know of auto as a bootproto option\n                # if bootproto is not set the ESXi installer defaults to DHCP and also will print a warning\n                # Setting it dhcp from the start it's convenient\n                print \"Configuring boot protocol to: dhcp\"\n                static_dir[\"bootproto\"] = \"dhcp\"\n            else:\n                print \"Can not complete network personalization. \" \\\n                      \"Auto configuration is turned off for IPv6 and there is no static address defined\"\n                sys.exit(36)\n        else:\n            if provisioningNIC.ipv6Autoconfig:\n                print \"Configuring IPv6 to: auto\"\n                static_dir[\"ipv6\"] = \"auto\"\n            elif provisioningNIC.ipv6Networks:\n                if isRHEL7:\n                    return\n                print \"Configuring boot protocol to: static\"\n                static_dir[\"bootproto\"] = \"static\"\n            else:\n                print \"Can not complete network personalization. \" \\\n                      \"Auto configuration is turned off for IPv6 and there is no static address defined\"\n                sys.exit(37)\n            print \"Disabling IPv4\"\n            static_dir[\"noipv4\"] = None\n\n        for ipv6Network in provisioningNIC.ipv6Networks:\n            print \"Configuring IPv6 network: %s\" % ipv6Network\n            static_dir[\"ip\" if isESXi else \"ipv6\"] = ipv6Network.ip\n            static_dir[\"netmask\"] = ipv6Network.prefixlen\n            break  # we only set the first IP if any\n        if provisioningNIC.ipv4Networks:\n            print \"Found IPv6-based service OS, ignoring IPv4 network personalization\"\n    else:\n        # IPv4\n        if provisioningNIC.ipv4Networks:\n            print \"Configuring boot protocol to: static\"\n            static_dir[\"bootproto\"] = \"static\"\n        elif provisioningNIC.dhcpv4:\n            print \"Configuring boot protocol to: dhcp\"\n            static_dir[\"bootproto\"] = \"dhcp\"\n        else:\n            print \"Can not complete network personalization. \" \\\n                  \"DHCP is turned off for IPv4 and there is no static address defined\"\n            sys.exit(38)\n        if not isESXi:\n            print \"Disabling IPv6\"\n            static_dir[\"noipv6\"] = None\n\n        for ipv4Network in provisioningNIC.ipv4Networks:\n            print \"Configuring IPv4 network: %s\" % ipv4Network\n            static_dir[\"ip\"] = ipv4Network.ip\n            static_dir[\"netmask\"] = ipv4Network.netmask\n            break  # we only set the first IP if any\n        if provisioningNIC.ipv6Networks:\n            print \"Found IPv4-based service OS, ignoring IPv6 network personalization\"\n\n    if provisioningRoute:\n        gw = str(provisioningRoute.gateway)\n        print \"Will use default gateway: %s\" % gw\n        #if isinstance(provisioningRoute.gateway, ipaddr.IPv6Address) and isRHEL7:\n        #    gw = \"[%s]\" % provisioningRoute.gateway\n        static_dir[\"gateway\"] = gw\n\n    # use the stack-aware DNS server, if any\n    for dnsServer in provisioningNIC.ipv6DnsServers if isIPv6Managed else provisioningNIC.ipv4DnsServers:\n        print \"Will use name server: %s\" % dnsServer\n        static_dir[\"nameserver\"] = dnsServer\n        break\n\n    if netinfo.fqdn:\n        print \"Setting FQDN to: %s\" % netinfo.fqdn\n        static_dir[\"hostname\"] = netinfo.fqdn\n    ks.directives.append(static_dir)\n\n\ndef injectVlanID(provisioningNIC, ksObj):\n    \"\"\" Inject the VLAN ID in the installation profile \"\"\"\n    if provisioningNIC.vlan_id is None:\n        return\n    if \"esxi5\" in TARGET_OS.lower():\n        print \"Configuring VLAN ID %s\" % provisioningNIC.vlan_id\n        ksObj.network[\"vlanid\"] = provisioningNIC.vlan_id\n    elif \"esxi\" in TARGET_OS.lower():\n        print \"Warning: Not injecting vlan id. This version of ESXi does not support it.\"\n\n\ndef injectVmwareESXi41Workaround(ks, netinfo, provisioningNIC, provisioningRoute):\n    \"\"\" VMware insists on having a DHCP server in all cases.\n            We must work around that.\n\n            This workaround only applies the static IP during installation, so the\n            installer can access the NFS share. The network settings are also needed\n            in the network directive. Should be called after injectStatic!\n    \"\"\"\n    # collect the info on a dictionary format expected by weasel\n    nic = {\n        \"bootProto\": \"static\",\n        \"ip\": str(provisioningNIC.ipv4Networks[0].ip),\n        \"netmask\": str(provisioningNIC.ipv4Networks[0].netmask),\n        \"vlanID\": 0,\n        \"hostname\": \"localhost\",\n        \"nameserver1\": \"\",\n        \"nameserver2\": \"\",\n        \"device\": None\n    }\n    if provisioningNIC.dnsServers:\n        nic[\"nameserver1\"] = str(provisioningNIC.dnsServers[0])\n    if netinfo.fqdn:\n        nic[\"hostname\"] = netinfo.fqdn\n    if provisioningRoute:\n        nic[\"gateway\"] = str(provisioningRoute.gateway)\n    # create a pre script to apply the static networking\n    pre = Script(\"pre\")\n    pre[\"interpreter\"] = \"python\"\n    pre[\"unsupported\"] = None\n    pre.contents.append(CODE_HEADER)\n    pre.contents.append(CODE_WARNING)\n    # use the public API of the vmware installer (weasel) library\n    pre.contents.append(\"from weasel import networking\")\n    pre.contents.append(\"nic = %s\" % nic)\n    pre.contents.append(\n        \"nic[\\\"device\\\"] = networking.findPhysicalNicByMacAddress('%s')\"\n        % provisioningNIC.macAddress)\n    pre.contents.append(\"networking.connect(nicChoices = nic)\")\n    pre.contents.append(\"networking.enactHostWideUserchoices(nic)\")\n    pre.contents.append(CODE_FOOTER)\n    # inject this pre script\n    ks.scripts.append(pre)\n    # qc 122451 , prevent hostname warning\n    # in order for this to work, it must be called after inject static\n    if \"hostname\" not in ks.network:\n        ks.network[\"hostname\"] = \"localhost\"\n\n\ndef injectRhelWorkaround(ks, provisioningNIC):\n    \"\"\" Rhel <7 does not allow --device=MAC, work around that\"\"\"\n    script = Script(\"pre\")\n    script.contents.append(CODE_HEADER)\n    script.contents.append(CODE_WARNING)\n    # figure out who has  this mac belongs\n    script.contents.append(\"DEV=`ifconfig -a | grep -i 'HWaddr %s' | cut -d' ' -f1`\"\n                           % provisioningNIC.macAddress)\n    script.contents.append(\"if [ -z \\\"$DEV\\\" ] ; then DEV='%s' ; fi\" % provisioningNIC.macAddress)\n    # path the kickstart file\n    script.contents.append(\"sed -i /user.ks.cfg -e \\\"s/--device=%s/--device=$DEV/\\\"\"\n                           % provisioningNIC.macAddress)\n    script.contents.append(CODE_FOOTER)\n    ks.scripts.append(script)\n\n\ndef writeKsFile(ksFile, ks):\n    \"\"\" Write the ks file to disk  \"\"\"\n    ksf = open(ksFile, \"w+\")\n    ksf.write(str(ks))\n    ksf.close()\n\n\ndef getOptions():\n    \"\"\"Returns the command-line options.\"\"\"\n    optparser = OptionParser()\n    optparser.add_option(\"--require-netconfig\", default=\"false\")\n    optparser.add_option(\"--disableWarning\", dest=\"disableWarning\", action=\"store_true\",\n                         default=False,\n                         help=\"Do not show warnings of old hpsa_netconfig format\")\n    (options, args) = optparser.parse_args()\n    del args\n    if not options.require_netconfig.lower() in (\"true\", \"false\"):\n        raise OptionValueError(\n            \"Invalid value for --require-netconfig: %s.\\nShould be 'true' or 'false'.\")\n    options.require_netconfig = options.require_netconfig.lower() == \"true\"\n    return options\n\n\ndef validateNetconfig(provisioningNIC, provisioningRoutes):\n    \"\"\" Perform some additional validation on the netconfig \"\"\"\n    if (\"esxi5\" in TARGET_OS.lower() and\n            (provisioningNIC.ipv4Networks or provisioningNIC.ipv6Networks) and\n            not provisioningRoutes):\n        raise ShowErrorMessage(\"Default gateway is missing from the hpsa_netconfig custom attribute. It is mandatory for this version of ESXi.\")\n\n\ndef main():\n    \"\"\" Configure the Kickstart profile according to the hpsa_netconfig custom attribute\"\"\"\n    try:\n        targetServer = ThisTargetServer()\n        targetServer.setWorkDir(targetServer.getRemoteRoot())\n        keys = helpers.getDataStore(targetServer)\n        options = getOptions()\n\n        if not HPSA_NETCONFIG and options.require_netconfig:\n            print \"Network configuration (hpsa_netconfig) for this server was not found, even though \"\n            print \"it is required by the value true of the custom attribute require_netconfig. \"\n            print \"Check the hpsa_netconfig custom attribute and verify the target server \"\n            print \"has been configured for static networking.\"\n            return 1\n\n        isIPv6Managed = targetServer.isIPv6Managed()\n\n        if \"esxi4\" in TARGET_OS.lower() and isIPv6Managed:\n            print(\"Provisioning on IPv6 not supported for ESXi 4.1.\")\n            return 1\n\n        if keys.platform.full_name:\n            isRhel7 = isRHELCompatible(keys.platform.full_name, 7)\n        else:\n            # platform key not set for ESXi\n            isRhel7 = False\n\n        netconfigParser = SmartNetconfig.readwrite(\n            StringIO(HPSA_NETCONFIG),\n            activeMacAddress=targetServer.getMACAddress(),\n            ipv6default=isIPv6Managed,\n            log=LOG\n        )\n\n        netinfo = netconfigParser.info()\n        if netinfo.oldSyntax and not options.disableWarning:\n            newFormat = netconfigParser.format()\n            print OLD_SYNTAX_WARNING + \"\\n%s\" % str(newFormat)\n\n        typosList = netconfigParser.getTyposList()\n        if typosList:\n            print(\"The following keys were not recognized in the hpsa_netconfig custom attribute and could be typos: %s\" % typosList)\n\n        provisioningNIC = netinfo.getProvisioningNIC()\n\n        mediaUrl = getMediaURL(keys)\n        if (isRhel7 and mediaUrl.scheme == \"nfs\" and\n                isIPv6Managed and provisioningNIC.ipv6Networks and not provisioningNIC.ipv6Autoconfig and\n                isRHEL7CompatibleMedia(\"0\", targetServer, mediaUrl.scheme, \"/\" + mediaUrl.fragment if mediaUrl.fragment else \"/mnt/media\")):\n            print \"Provisioning {platname} over IPv6 on NFS \".format(platname=keys.platform.full_name.replace(\" 7 \", \" 7.0 \")) + \\\n                  \"with only a static network configuration is not supported.\\n\" + \\\n                  \"Enable IPv6 autoconfig or use HTTP/HTTPS for the media.\"\n            return EC_NOT_SUPPORTED\n\n        validation.validateProvisioningNIC(provisioningNIC, targetServer)\n\n        provisioningRoutes = [iproute for iproute in (netinfo.ipv6Routes if isIPv6Managed else netinfo.ipv4Routes)\n                              if iproute.nic == provisioningNIC]\n        provisioningRoute = provisioningRoutes[0] if provisioningRoutes else None\n\n        validateNetconfig(provisioningNIC, provisioningRoutes)\n\n        ksObj = Kickstart(open(KS_PATH), endtags=isRhel7)\n        injectPersonalization(ksObj, netinfo, provisioningNIC, provisioningRoute, isIPv6Managed, isRhel7)\n\n        injectVlanID(provisioningNIC, ksObj)\n\n        if not isRhel7 and \"rhel\" in TARGET_OS.lower():\n            injectRhelWorkaround(ksObj, provisioningNIC)\n        elif \"esxi4\" in TARGET_OS.lower() and provisioningNIC.ipv4Networks:\n            injectVmwareESXi41Workaround(ksObj, netinfo, provisioningNIC, provisioningRoute)\n        writeKsFile(KS_PATH, ksObj)\n        if isRhel7:\n            injectSysctlSettings(isIPv6Managed)\n    except (OSError, IOError, ShowErrorMessage, OptionValueError), why:\n        LOG.exception(why)\n        print \"Failed to inject personalization settings:\\n%s\" % why\n        return EC_EXCEPTION\n\n\nHPSA_NETCONFIG = \"\"\"@hpsa_netconfig@\"\"\"\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n",
            "description": "Injects settings for personalization into a Kickstart installation profile.\nPersonalization settings include network settings.\n\nUsage: inject_ks_personalization_settings.py [OPTIONS]\n\nOptions:\n--require-netconfig=[true,false]\n\tSpecify whether a netconfig is mandatory or not.\n\tOptional argument, defaults to false.\n\n--disableWarning\n    Do not show warnings of old hpsa_netconfig format\n    Optional argument, defaults to false.\n\nPrerequisites:\n- Target server runs a maintenance Linux OS.",
            "status": null,
            "name": "Inject Kickstart Personalization Settings for ESXi 5",
            "state": null,
            "eTag": "2015-08-04T07:30:29.000Z",
            "modified": "2015-08-04T07:30:29.000Z",
            "created": "2015-06-13T04:49:03.000Z",
            "category": "os-deployment-ogfs-scripts",
            "uri": "/rest/os-deployment-ogfs-scripts/890001"
        },
        {
            "codeType": "OGFS",
            "displayCodeType": "OGFS",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "1",
                    "createdBy": "opsware",
                    "createdDate": "2015-06-13T04:49:04.000Z",
                    "usage": "usage: Deletes an iLO user using the hponcfg utility.\n\noptions:\n  -h, --help            show this help message and exit\n  --username=USERNAME   Required. username of the iLO user to delete.\n  --fail-nouser\t        fail if the user to be deleted is not found.\n\nExample: --username=admin\n  Will delete an iLO user identified by admin.\n\nPrerequisites:\n  - Script needs to be run as part of a build plan.\n  - Target server runs a maintenance Linux or Windows PE OS for the hponcfg utility to be available.",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-06-13T04:49:04.000Z",
            "version": {
                "versionLabel": "1",
                "createdBy": "opsware",
                "createdDate": "2015-06-13T04:49:04.000Z",
                "usage": "usage: Deletes an iLO user using the hponcfg utility.\n\noptions:\n  -h, --help            show this help message and exit\n  --username=USERNAME   Required. username of the iLO user to delete.\n  --fail-nouser\t        fail if the user to be deleted is not found.\n\nExample: --username=admin\n  Will delete an iLO user identified by admin.\n\nPrerequisites:\n  - Script needs to be run as part of a build plan.\n  - Target server runs a maintenance Linux or Windows PE OS for the hponcfg utility to be available.",
                "current": true
            },
            "source": "#!/usr/bin/python\n\"\"\"\n    (C) Copyright 2012-2015 Hewlett-Packard Development Company, L.P.\n\"\"\"\n\nimport sys\nfrom optparse import OptionValueError\nfrom time import sleep\n\nsys.path.append(\"/opsw/apx/runtime/script/osprov.run_os_build_plan_papx/\")\nsys.path.append(\"/opt/opsware/pylibs2/\")\n\nfrom osprov.errors import ProcessExecutionError, ShowErrorMessage\nfrom osprov.optparse_ext import OptionParser\nfrom osprov.osbp import logger, ThisTargetServer\nfrom osprov.profile.ribcl import RibclProfile\nfrom osprov.wrappers.hponcfg import HpOnCfg\nfrom osprov.decorators import HandleShowErrorMessage\n\nlog = logger.getIt(\"Delete iLO User\")\n\nUSER_NOT_FOUND_STATUS_CODES = (\"0x000A\", \"0xA\")\n\nRETRIES_ON_FAILURE = 5\nSECONDS_BETWEEN_RETRIES = 5\n\n\nclass DeleteIloUserOptionParser(OptionParser):\n\n    def __init__(self, *args, **kwargs):\n        OptionParser.__init__(self, *args, **kwargs)\n        self.usage = \"Deletes an iLO user using the hponcfg utility.\"\n\n    def defineOptions(self):\n        self.add_option(\"--username\",\n                        help=\"Username of iLO user to delete\")\n        self.add_option(\"--fail-nouser\", default=False, action=\"store_true\",\n                        help=\"Fail if the specified user does not exist\")\n\n    def validateArgs(self, opt, args):\n        if not opt.username:\n            raise OptionValueError(\"Missing required argument: username\")\n\n\n@HandleShowErrorMessage(\"Delete iLO User\", log)\ndef main():\n    parser = DeleteIloUserOptionParser()\n    options, remaining_args = parser.parse_args()\n\n    targetServer = ThisTargetServer()\n    hpOnCfg = HpOnCfg(targetServer, log=log)\n\n    ribcl = hpOnCfg.getCurrentConfig()\n\n    if ribcl.iLOUserExists(options.username):\n        ribclProfile = RibclProfile()\n        user = RibclProfile.User(options.username)\n        ribclProfile.addCommand(RibclProfile.DeleteUserCommand(user))\n        try:\n            hpOnCfg.set(ribclProfile)\n            # Check to see if the user was really deleted, wait and retry if not\n            for i in xrange(RETRIES_ON_FAILURE):\n                ribcl = hpOnCfg.getCurrentConfig()\n                if not ribcl.iLOUserExists(options.username):\n                    break\n                print \"Warning: iLO User was not deleted, retry %d of 5\" % (i + 1)\n                try:\n                    hpOnCfg.set(ribclProfile)\n                except ProcessExecutionError, why:\n                    # Check if hponcfg failed because user was not found, in this case it's\n                    # what we want\n                    log.exception(why)\n                    if reduce(lambda x, y: x or y, [code in why.stderr for code in USER_NOT_FOUND_STATUS_CODES]):\n                        break\n                sleep(SECONDS_BETWEEN_RETRIES)\n            else:\n                raise ShowErrorMessage(\n                    \"Error: iLO User '%s' could not be deleted, there may be a problem with the iLO\" % options.username)\n        except ProcessExecutionError, why:\n            log.exception(why)\n            print \"Failed to delete the iLO user using hponcfg\"\n            print \"Standard output of hponcfg command:\"\n            print why.stdout\n            print \"Standard error of hponcfg command:\"\n            print why.stderr\n            return why.exitCode\n    else:\n        if not options.fail_nouser:\n            print \"Warning: iLO User '%s' does not exist\" % options.username\n        else:\n            raise ShowErrorMessage(\n                \"Error: iLO User '%s' does not exist and --fail-nouser is set\" % options.username)\n\n    return 0\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n",
            "description": "usage: Deletes an iLO user using the hponcfg utility.\n\noptions:\n  -h, --help            show this help message and exit\n  --username=USERNAME   Required. username of the iLO user to delete.\n  --fail-nouser\t        fail if the user to be deleted is not found.\n\nExample: --username=admin\n  Will delete an iLO user identified by admin.\n\nPrerequisites:\n  - Script needs to be run as part of a build plan.\n  - Target server runs a maintenance Linux or Windows PE OS for the hponcfg utility to be available.",
            "status": null,
            "name": "Delete iLO User",
            "state": null,
            "eTag": "2015-06-13T04:49:04.000Z",
            "modified": "2015-06-13T04:49:04.000Z",
            "created": "2015-06-13T04:49:04.000Z",
            "category": "os-deployment-ogfs-scripts",
            "uri": "/rest/os-deployment-ogfs-scripts/900001"
        },
        {
            "codeType": "OGFS",
            "displayCodeType": "OGFS",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "1",
                    "createdBy": "opsware",
                    "createdDate": "2015-06-13T04:49:04.000Z",
                    "usage": "Injects settings for personalization into a Kickstart installation profile.\nPersonalization settings include network settings.\n\nUsage: inject_ks_personalization_settings.py [OPTIONS]\n\nOptions:\n--require-netconfig=[true,false]\n\tSpecify whether a netconfig is mandatory or not.\n\tOptional argument, defaults to false.\n\n--disableWarning\n    Do not show warnings of old hpsa_netconfig format\n    Optional argument, defaults to false.\n\nPrerequisites:\n- Target server runs a maintenance Linux OS.",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-06-13T04:49:04.000Z",
            "version": {
                "versionLabel": "1",
                "createdBy": "opsware",
                "createdDate": "2015-06-13T04:49:04.000Z",
                "usage": "Injects settings for personalization into a Kickstart installation profile.\nPersonalization settings include network settings.\n\nUsage: inject_ks_personalization_settings.py [OPTIONS]\n\nOptions:\n--require-netconfig=[true,false]\n\tSpecify whether a netconfig is mandatory or not.\n\tOptional argument, defaults to false.\n\n--disableWarning\n    Do not show warnings of old hpsa_netconfig format\n    Optional argument, defaults to false.\n\nPrerequisites:\n- Target server runs a maintenance Linux OS.",
                "current": true
            },
            "source": "#!/usr/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# lint_ignore=E501,I0011,C0301\n# Please do not change the two lines above. See PEP 8, PEP 263.\n\"\"\"\n    (C) Copyright 2010-2015 Hewlett-Packard Development Company, L.P.\n\n    This program will inject personalized settings into the kickstart\n    file.\n\"\"\"\n\nimport os\nimport sys\nfrom cStringIO import StringIO\n\nfrom osprov import helpers\nfrom osprov.errors import ShowErrorMessage\nfrom osprov.optparse_ext import OptionParser, OptionValueError\nfrom osprov.osbp import ThisTargetServer, logger\nfrom osprov.osbp.constants import CODE_HEADER, CODE_WARNING, CODE_FOOTER\nfrom osprov.osbp.helpers import getMediaURL\nfrom osprov.platform_util import isRHELCompatible, isRHEL7CompatibleMedia\nfrom osprov.profile import Kickstart\nfrom osprov.profile.kickstart import Directive\nfrom osprov.profile.kickstart import Script\nfrom osprov.parsers.netconfig import SmartNetconfig, OLD_SYNTAX_WARNING\nfrom osprov.networking import validation\n\nEC_NO_ERR = 0\nEC_NO_CA = 20\nEC_EXCEPTION = 100\nEC_NOT_SUPPORTED = 101\n\nKS_PATH = \"tmp/user.ks.cfg\"\n\nLOG = logger.getIt('inject_ks_pers')\n\n# replaced at build time\nTARGET_OS = \"esxi4\"\n\n\ndef removeNetworkDirective(ks):\n    if hasattr(ks, \"network\"):\n        print \"Removing existing network personalization from the kickstart\"\n        ks.directives.remove(ks.network)\n\ndef injectSysctlSettings(isIPv6Managed):\n    sysctl = open(\"tmp/sysctl.conf\", \"w\")\n    if not isIPv6Managed:\n        sysctl.write(\"net.ipv6.conf.all.disable_ipv6=1\")\n    sysctl.close()\n\n\ndef injectPersonalization(ks, netinfo, provisioningNIC, provisioningRoute, isIPv6Managed, isRHEL7=False):\n    \"\"\" Inject static networking configuration into the kickstart profile. \"\"\"\n    removeNetworkDirective(ks)\n\n    static_dir = Directive(\"network\")\n    static_dir[\"device\"] = provisioningNIC.macAddress\n    print \"Going to provision using interface with MAC address %s\" % provisioningNIC.macAddress\n\n    # ESXi doesn't support ipv6, noipv6 and noipv4 boot parameters\n    isESXi = \"esxi\" in TARGET_OS\n\n    if isIPv6Managed:\n        if isESXi:\n            if provisioningNIC.ipv6Networks:\n                print \"Configuring boot protocol to: static\"\n                static_dir[\"bootproto\"] = \"static\"\n            elif provisioningNIC.ipv6Autoconfig:\n                # esxi does not know of auto as a bootproto option\n                # if bootproto is not set the ESXi installer defaults to DHCP and also will print a warning\n                # Setting it dhcp from the start it's convenient\n                print \"Configuring boot protocol to: dhcp\"\n                static_dir[\"bootproto\"] = \"dhcp\"\n            else:\n                print \"Can not complete network personalization. \" \\\n                      \"Auto configuration is turned off for IPv6 and there is no static address defined\"\n                sys.exit(36)\n        else:\n            if provisioningNIC.ipv6Autoconfig:\n                print \"Configuring IPv6 to: auto\"\n                static_dir[\"ipv6\"] = \"auto\"\n            elif provisioningNIC.ipv6Networks:\n                if isRHEL7:\n                    return\n                print \"Configuring boot protocol to: static\"\n                static_dir[\"bootproto\"] = \"static\"\n            else:\n                print \"Can not complete network personalization. \" \\\n                      \"Auto configuration is turned off for IPv6 and there is no static address defined\"\n                sys.exit(37)\n            print \"Disabling IPv4\"\n            static_dir[\"noipv4\"] = None\n\n        for ipv6Network in provisioningNIC.ipv6Networks:\n            print \"Configuring IPv6 network: %s\" % ipv6Network\n            static_dir[\"ip\" if isESXi else \"ipv6\"] = ipv6Network.ip\n            static_dir[\"netmask\"] = ipv6Network.prefixlen\n            break  # we only set the first IP if any\n        if provisioningNIC.ipv4Networks:\n            print \"Found IPv6-based service OS, ignoring IPv4 network personalization\"\n    else:\n        # IPv4\n        if provisioningNIC.ipv4Networks:\n            print \"Configuring boot protocol to: static\"\n            static_dir[\"bootproto\"] = \"static\"\n        elif provisioningNIC.dhcpv4:\n            print \"Configuring boot protocol to: dhcp\"\n            static_dir[\"bootproto\"] = \"dhcp\"\n        else:\n            print \"Can not complete network personalization. \" \\\n                  \"DHCP is turned off for IPv4 and there is no static address defined\"\n            sys.exit(38)\n        if not isESXi:\n            print \"Disabling IPv6\"\n            static_dir[\"noipv6\"] = None\n\n        for ipv4Network in provisioningNIC.ipv4Networks:\n            print \"Configuring IPv4 network: %s\" % ipv4Network\n            static_dir[\"ip\"] = ipv4Network.ip\n            static_dir[\"netmask\"] = ipv4Network.netmask\n            break  # we only set the first IP if any\n        if provisioningNIC.ipv6Networks:\n            print \"Found IPv4-based service OS, ignoring IPv6 network personalization\"\n\n    if provisioningRoute:\n        gw = str(provisioningRoute.gateway)\n        print \"Will use default gateway: %s\" % gw\n        #if isinstance(provisioningRoute.gateway, ipaddr.IPv6Address) and isRHEL7:\n        #    gw = \"[%s]\" % provisioningRoute.gateway\n        static_dir[\"gateway\"] = gw\n\n    # use the stack-aware DNS server, if any\n    for dnsServer in provisioningNIC.ipv6DnsServers if isIPv6Managed else provisioningNIC.ipv4DnsServers:\n        print \"Will use name server: %s\" % dnsServer\n        static_dir[\"nameserver\"] = dnsServer\n        break\n\n    if netinfo.fqdn:\n        print \"Setting FQDN to: %s\" % netinfo.fqdn\n        static_dir[\"hostname\"] = netinfo.fqdn\n    ks.directives.append(static_dir)\n\n\ndef injectVlanID(provisioningNIC, ksObj):\n    \"\"\" Inject the VLAN ID in the installation profile \"\"\"\n    if provisioningNIC.vlan_id is None:\n        return\n    if \"esxi5\" in TARGET_OS.lower():\n        print \"Configuring VLAN ID %s\" % provisioningNIC.vlan_id\n        ksObj.network[\"vlanid\"] = provisioningNIC.vlan_id\n    elif \"esxi\" in TARGET_OS.lower():\n        print \"Warning: Not injecting vlan id. This version of ESXi does not support it.\"\n\n\ndef injectVmwareESXi41Workaround(ks, netinfo, provisioningNIC, provisioningRoute):\n    \"\"\" VMware insists on having a DHCP server in all cases.\n            We must work around that.\n\n            This workaround only applies the static IP during installation, so the\n            installer can access the NFS share. The network settings are also needed\n            in the network directive. Should be called after injectStatic!\n    \"\"\"\n    # collect the info on a dictionary format expected by weasel\n    nic = {\n        \"bootProto\": \"static\",\n        \"ip\": str(provisioningNIC.ipv4Networks[0].ip),\n        \"netmask\": str(provisioningNIC.ipv4Networks[0].netmask),\n        \"vlanID\": 0,\n        \"hostname\": \"localhost\",\n        \"nameserver1\": \"\",\n        \"nameserver2\": \"\",\n        \"device\": None\n    }\n    if provisioningNIC.dnsServers:\n        nic[\"nameserver1\"] = str(provisioningNIC.dnsServers[0])\n    if netinfo.fqdn:\n        nic[\"hostname\"] = netinfo.fqdn\n    if provisioningRoute:\n        nic[\"gateway\"] = str(provisioningRoute.gateway)\n    # create a pre script to apply the static networking\n    pre = Script(\"pre\")\n    pre[\"interpreter\"] = \"python\"\n    pre[\"unsupported\"] = None\n    pre.contents.append(CODE_HEADER)\n    pre.contents.append(CODE_WARNING)\n    # use the public API of the vmware installer (weasel) library\n    pre.contents.append(\"from weasel import networking\")\n    pre.contents.append(\"nic = %s\" % nic)\n    pre.contents.append(\n        \"nic[\\\"device\\\"] = networking.findPhysicalNicByMacAddress('%s')\"\n        % provisioningNIC.macAddress)\n    pre.contents.append(\"networking.connect(nicChoices = nic)\")\n    pre.contents.append(\"networking.enactHostWideUserchoices(nic)\")\n    pre.contents.append(CODE_FOOTER)\n    # inject this pre script\n    ks.scripts.append(pre)\n    # qc 122451 , prevent hostname warning\n    # in order for this to work, it must be called after inject static\n    if \"hostname\" not in ks.network:\n        ks.network[\"hostname\"] = \"localhost\"\n\n\ndef injectRhelWorkaround(ks, provisioningNIC):\n    \"\"\" Rhel <7 does not allow --device=MAC, work around that\"\"\"\n    script = Script(\"pre\")\n    script.contents.append(CODE_HEADER)\n    script.contents.append(CODE_WARNING)\n    # figure out who has  this mac belongs\n    script.contents.append(\"DEV=`ifconfig -a | grep -i 'HWaddr %s' | cut -d' ' -f1`\"\n                           % provisioningNIC.macAddress)\n    script.contents.append(\"if [ -z \\\"$DEV\\\" ] ; then DEV='%s' ; fi\" % provisioningNIC.macAddress)\n    # path the kickstart file\n    script.contents.append(\"sed -i /user.ks.cfg -e \\\"s/--device=%s/--device=$DEV/\\\"\"\n                           % provisioningNIC.macAddress)\n    script.contents.append(CODE_FOOTER)\n    ks.scripts.append(script)\n\n\ndef writeKsFile(ksFile, ks):\n    \"\"\" Write the ks file to disk  \"\"\"\n    ksf = open(ksFile, \"w+\")\n    ksf.write(str(ks))\n    ksf.close()\n\n\ndef getOptions():\n    \"\"\"Returns the command-line options.\"\"\"\n    optparser = OptionParser()\n    optparser.add_option(\"--require-netconfig\", default=\"false\")\n    optparser.add_option(\"--disableWarning\", dest=\"disableWarning\", action=\"store_true\",\n                         default=False,\n                         help=\"Do not show warnings of old hpsa_netconfig format\")\n    (options, args) = optparser.parse_args()\n    del args\n    if not options.require_netconfig.lower() in (\"true\", \"false\"):\n        raise OptionValueError(\n            \"Invalid value for --require-netconfig: %s.\\nShould be 'true' or 'false'.\")\n    options.require_netconfig = options.require_netconfig.lower() == \"true\"\n    return options\n\n\ndef validateNetconfig(provisioningNIC, provisioningRoutes):\n    \"\"\" Perform some additional validation on the netconfig \"\"\"\n    if (\"esxi5\" in TARGET_OS.lower() and\n            (provisioningNIC.ipv4Networks or provisioningNIC.ipv6Networks) and\n            not provisioningRoutes):\n        raise ShowErrorMessage(\"Default gateway is missing from the hpsa_netconfig custom attribute. It is mandatory for this version of ESXi.\")\n\n\ndef main():\n    \"\"\" Configure the Kickstart profile according to the hpsa_netconfig custom attribute\"\"\"\n    try:\n        targetServer = ThisTargetServer()\n        targetServer.setWorkDir(targetServer.getRemoteRoot())\n        keys = helpers.getDataStore(targetServer)\n        options = getOptions()\n\n        if not HPSA_NETCONFIG and options.require_netconfig:\n            print \"Network configuration (hpsa_netconfig) for this server was not found, even though \"\n            print \"it is required by the value true of the custom attribute require_netconfig. \"\n            print \"Check the hpsa_netconfig custom attribute and verify the target server \"\n            print \"has been configured for static networking.\"\n            return 1\n\n        isIPv6Managed = targetServer.isIPv6Managed()\n\n        if \"esxi4\" in TARGET_OS.lower() and isIPv6Managed:\n            print(\"Provisioning on IPv6 not supported for ESXi 4.1.\")\n            return 1\n\n        if keys.platform.full_name:\n            isRhel7 = isRHELCompatible(keys.platform.full_name, 7)\n        else:\n            # platform key not set for ESXi\n            isRhel7 = False\n\n        netconfigParser = SmartNetconfig.readwrite(\n            StringIO(HPSA_NETCONFIG),\n            activeMacAddress=targetServer.getMACAddress(),\n            ipv6default=isIPv6Managed,\n            log=LOG\n        )\n\n        netinfo = netconfigParser.info()\n        if netinfo.oldSyntax and not options.disableWarning:\n            newFormat = netconfigParser.format()\n            print OLD_SYNTAX_WARNING + \"\\n%s\" % str(newFormat)\n\n        typosList = netconfigParser.getTyposList()\n        if typosList:\n            print(\"The following keys were not recognized in the hpsa_netconfig custom attribute and could be typos: %s\" % typosList)\n\n        provisioningNIC = netinfo.getProvisioningNIC()\n\n        mediaUrl = getMediaURL(keys)\n        if (isRhel7 and mediaUrl.scheme == \"nfs\" and\n                isIPv6Managed and provisioningNIC.ipv6Networks and not provisioningNIC.ipv6Autoconfig and\n                isRHEL7CompatibleMedia(\"0\", targetServer, mediaUrl.scheme, \"/\" + mediaUrl.fragment if mediaUrl.fragment else \"/mnt/media\")):\n            print \"Provisioning {platname} over IPv6 on NFS \".format(platname=keys.platform.full_name.replace(\" 7 \", \" 7.0 \")) + \\\n                  \"with only a static network configuration is not supported.\\n\" + \\\n                  \"Enable IPv6 autoconfig or use HTTP/HTTPS for the media.\"\n            return EC_NOT_SUPPORTED\n\n        validation.validateProvisioningNIC(provisioningNIC, targetServer)\n\n        provisioningRoutes = [iproute for iproute in (netinfo.ipv6Routes if isIPv6Managed else netinfo.ipv4Routes)\n                              if iproute.nic == provisioningNIC]\n        provisioningRoute = provisioningRoutes[0] if provisioningRoutes else None\n\n        validateNetconfig(provisioningNIC, provisioningRoutes)\n\n        ksObj = Kickstart(open(KS_PATH), endtags=isRhel7)\n        injectPersonalization(ksObj, netinfo, provisioningNIC, provisioningRoute, isIPv6Managed, isRhel7)\n\n        injectVlanID(provisioningNIC, ksObj)\n\n        if not isRhel7 and \"rhel\" in TARGET_OS.lower():\n            injectRhelWorkaround(ksObj, provisioningNIC)\n        elif \"esxi4\" in TARGET_OS.lower() and provisioningNIC.ipv4Networks:\n            injectVmwareESXi41Workaround(ksObj, netinfo, provisioningNIC, provisioningRoute)\n        writeKsFile(KS_PATH, ksObj)\n        if isRhel7:\n            injectSysctlSettings(isIPv6Managed)\n    except (OSError, IOError, ShowErrorMessage, OptionValueError), why:\n        LOG.exception(why)\n        print \"Failed to inject personalization settings:\\n%s\" % why\n        return EC_EXCEPTION\n\n\nHPSA_NETCONFIG = \"\"\"@hpsa_netconfig@\"\"\"\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n",
            "description": "Injects settings for personalization into a Kickstart installation profile.\nPersonalization settings include network settings.\n\nUsage: inject_ks_personalization_settings.py [OPTIONS]\n\nOptions:\n--require-netconfig=[true,false]\n\tSpecify whether a netconfig is mandatory or not.\n\tOptional argument, defaults to false.\n\n--disableWarning\n    Do not show warnings of old hpsa_netconfig format\n    Optional argument, defaults to false.\n\nPrerequisites:\n- Target server runs a maintenance Linux OS.",
            "status": null,
            "name": "Inject Kickstart Personalization Settings for ESXi",
            "state": null,
            "eTag": "2015-06-13T04:49:04.000Z",
            "modified": "2015-06-13T04:49:04.000Z",
            "created": "2015-06-13T04:49:04.000Z",
            "category": "os-deployment-ogfs-scripts",
            "uri": "/rest/os-deployment-ogfs-scripts/910001"
        },
        {
            "codeType": "OGFS",
            "displayCodeType": "OGFS",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "1",
                    "createdBy": "opsware",
                    "createdDate": "2015-06-13T04:49:06.000Z",
                    "usage": "This step main purpose is to detect when a previous ended job of the same build plan failed\nat one of the steps and start the new run from that step that failed.\n\nIt can be considered as an example of how to create/use a flow control script.",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-06-13T04:49:06.000Z",
            "version": {
                "versionLabel": "1",
                "createdBy": "opsware",
                "createdDate": "2015-06-13T04:49:06.000Z",
                "usage": "This step main purpose is to detect when a previous ended job of the same build plan failed\nat one of the steps and start the new run from that step that failed.\n\nIt can be considered as an example of how to create/use a flow control script.",
                "current": true
            },
            "source": "#!/usr/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n\"\"\"\n    (C) Copyright 2014-2015 Hewlett-Packard Development Company, L.P.\n\"\"\"\n\nimport os\nimport sys\nfrom osprov.osbp import ThisTargetServer, logger\nfrom pytwist.com.opsware.search import Filter\n\nlog = logger.getIt(\"Flow Control\")\n\n\ndef getLastFailedStep(serverID, buildPlanID):\n    targetServer = ThisTargetServer()\n    twistServer = targetServer.twistServer\n    previousJobsFilter = Filter()\n    previousJobsFilter.setObjectType(\"job\")\n    previousJobsFilter.setExpression('job_device_id = \"%d\"' % serverID)\n    jobRefs = list(twistServer.search.SearchService.findObjRefs(previousJobsFilter))\n    if len(jobRefs):\n        jobInfoVOs = [vo for vo in twistServer.job.JobService.getJobInfoVOs(jobRefs) if vo.endDate]\n        if not len(jobInfoVOs):\n            print(\"No previous ended jobs found for this server\")\n            return None\n        else:\n            log.debug(\"Found previous ended jobs: %s\" % str(jobInfoVOs))\n        # sort VOs by endDate\n        jobInfoVOs.sort(lambda x, y: cmp(x.endDate, y.endDate))\n        lastJobRef = max(jobInfoVOs, key=lambda x:x.endDate).ref\n        lastJobID = lastJobRef.id\n        log.debug(\"Found last ended job ID: %d\\n\" % lastJobID)\n        lastJobResult = twistServer.job.JobService.getResult(lastJobRef)\n        for result in lastJobResult.elemResultInfo:\n            if serverID == result.element.id:\n                if result.output.exitCode == 0:\n                    print(\"Last ended job for this server was successful\")\n                    return None\n                else:\n                    log.debug(\"Last job failed with exit code %d\" % result.output.exitCode)\n                if buildPlanID != lastJobResult.jobInfo.OSBuildPlanRef.id:\n                    print(\"Last ended job for this server was not a run of this BuildPlan\")\n                    return None\n                else:\n                    log.debug(\"Last ended job for this server was a run of this Build Plan\")\n                failedStep = int(result.doneSteps) + 1\n                log.debug(\"Found last failed step: %d\\n\" % failedStep)\n                print(\"Found that the last ended job on the server was %d, had run the same Build Plan and failed at step %d\"\n                      % (lastJobID, failedStep))\n                return failedStep\n            else:\n                log.debug(\"Result element (%s) not specific to this serverID, looking in to other elements\"\n                          % str(result))\n    else:\n        print(\"No previous jobs found for this server\")\n    return None\n\n\ndef printFlowControlForwartInstruction(step):\n        print \"\"\"Begin Flow Control:\n        Forward to step %s\n    End Flow Control\"\"\" % str(step)\n\n\ndef main():\n    serverID = long(os.environ[\"TARGET_SERVER_ID\"])\n    buildPlanID = long(os.environ[\"BUILD_PLAN_ID\"])\n    currentStep = long(os.environ[\"CURRENT_STEP_NO\"])\n    log.debug(\"TARGET_SERVER_ID: %d\\nBUILD_PLAN_ID: %d\\nCURRENT_STEP_NO: %d\\n\" % (serverID, buildPlanID, currentStep))\n    lastFailedStep = getLastFailedStep(serverID, buildPlanID)\n    if lastFailedStep:\n        if lastFailedStep > currentStep:\n            print\n            log.debug(\"Printing FlowControl Instruction to jump to last fail point, step %d\" % lastFailedStep)\n            printFlowControlForwartInstruction(lastFailedStep)\n        else:\n            if lastFailedStep == currentStep:\n                print(\"Last failed Build Plan step is the step we are executing now\")\n            else:\n                print(\"Last failed Build Plan step was already executed on current run\")\n            print(\"The Build Plan execution will continue normal flow\")\n    else:\n        log.debug(\"Previous ended and failed job for this server and this Build Plan was not found\")\n        print(\"The Build Plan execution will continue normal flow\")\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n",
            "description": "This step main purpose is to detect when a previous ended job of the same build plan failed\nat one of the steps and start the new run from that step that failed.\n\nIt can be considered as an example of how to create/use a flow control script.",
            "status": null,
            "name": "Continue with previous job run failed step",
            "state": null,
            "eTag": "2015-06-13T04:49:06.000Z",
            "modified": "2015-06-13T04:49:06.000Z",
            "created": "2015-06-13T04:49:06.000Z",
            "category": "os-deployment-ogfs-scripts",
            "uri": "/rest/os-deployment-ogfs-scripts/940001"
        },
        {
            "codeType": "OGFS",
            "displayCodeType": "OGFS",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "1",
                    "createdBy": "opsware",
                    "createdDate": "2015-06-13T04:49:06.000Z",
                    "usage": "This is a SAMPLE Step simulating a difficult operation that might fail.\nYou can specify the failure chance as the first parameter (50% by default).",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-06-13T04:49:06.000Z",
            "version": {
                "versionLabel": "1",
                "createdBy": "opsware",
                "createdDate": "2015-06-13T04:49:06.000Z",
                "usage": "This is a SAMPLE Step simulating a difficult operation that might fail.\nYou can specify the failure chance as the first parameter (50% by default).",
                "current": true
            },
            "source": "#!/usr/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n\"\"\"\n    (C) Copyright 2014-2015 Hewlett-Packard Development Company, L.P.\n\"\"\"\n\nimport sys\nfrom random import randrange\n\n\ndef main():\n    failPercent = 50\n    if len(sys.argv) > 1:\n        failPercent = int(sys.argv[1])\n    randomNo = randrange(100)\n    if randomNo < failPercent:\n        print \"Chance decided this step should fail!\"\n        return 1\n    else:\n        print \"Chance decided this step should pass!\"\n        return 0\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n",
            "description": "This is a SAMPLE Step simulating a difficult operation that might fail.\nYou can specify the failure chance as the first parameter (50% by default).",
            "status": null,
            "name": "Random Fail",
            "state": null,
            "eTag": "2015-06-13T04:49:06.000Z",
            "modified": "2015-06-13T04:49:06.000Z",
            "created": "2015-06-13T04:49:06.000Z",
            "category": "os-deployment-ogfs-scripts",
            "uri": "/rest/os-deployment-ogfs-scripts/950001"
        },
        {
            "codeType": "OGFS",
            "displayCodeType": "OGFS",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "1",
                    "createdBy": "opsware",
                    "createdDate": "2015-06-13T04:49:06.000Z",
                    "usage": "The step is deprecated and will be removed in a subsequent version.\n\nThis script removes HP SA software model elements from the target server's record in the SA model repository.  \nThis is necessary when installing a different OS onto an existing server.  This includes the following data items, if present:\n\n * the server's attachment to a specific OS Profile\n * Software Policy attachments\n * Custom Attributes (locally defined on the server record itself)\n\nThis script may also be used to assign the target server to a new OS Profile.\n\nUsage:\n\nreset_os_and_policy_info.py [--assign_os_profile \"OS Profile Name\"] [--preserve_attrs=attr1,attr2,attr3] [--ignore_sysconfig]\n\nAll parameters are optional.  The default behavior with no parameters is:\n\n * Assign the server to the \"Not Assigned\" OS Profile corresponding to the server's current platform\n * Detach all attached Software Policies\n * Remove all locally defined custom attributes, except those listed in the \"bm.reprovision_attributes_to_preserve\" sysconfig setting\n\nPrerequisites:\n - If provided, OS Profile must be a valid name or ID.",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-06-13T04:49:06.000Z",
            "version": {
                "versionLabel": "1",
                "createdBy": "opsware",
                "createdDate": "2015-06-13T04:49:06.000Z",
                "usage": "The step is deprecated and will be removed in a subsequent version.\n\nThis script removes HP SA software model elements from the target server's record in the SA model repository.  \nThis is necessary when installing a different OS onto an existing server.  This includes the following data items, if present:\n\n * the server's attachment to a specific OS Profile\n * Software Policy attachments\n * Custom Attributes (locally defined on the server record itself)\n\nThis script may also be used to assign the target server to a new OS Profile.\n\nUsage:\n\nreset_os_and_policy_info.py [--assign_os_profile \"OS Profile Name\"] [--preserve_attrs=attr1,attr2,attr3] [--ignore_sysconfig]\n\nAll parameters are optional.  The default behavior with no parameters is:\n\n * Assign the server to the \"Not Assigned\" OS Profile corresponding to the server's current platform\n * Detach all attached Software Policies\n * Remove all locally defined custom attributes, except those listed in the \"bm.reprovision_attributes_to_preserve\" sysconfig setting\n\nPrerequisites:\n - If provided, OS Profile must be a valid name or ID.",
                "current": true
            },
            "source": "#!/usr/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n#\n\"\"\"\n    (C) Copyright 2010-2015 Hewlett-Packard Development Company, L.P.\n\n    Wrapper around spin.Device.clearRoles(), which handles removing\n    stale attachments in the model to OS Profile, Policies, etc\n\n    Optionally assigns the target server to a new OS Profile. If OS Profile\n    is not provided, default to the \"Not Assigned\" node for the server's current\n    platform\n\"\"\"\nfrom optparse import OptionParser\nimport sys\n\n# pylint: disable=F0401,E0611\nfrom pytwist.com.opsware.custattr import NoSuchFieldException\nfrom pytwist.com.opsware.server import ServerRef\nfrom pytwist.com.opsware.custattr import CustomAttribute\n# pylint: enable=F0401,E0611\nfrom opsware_common import errors\n\nfrom osprov import sa\nfrom osprov.ogfs import ogsh_spin\nfrom osprov.errors import ShowErrorMessage\nfrom osprov.util import twist\nfrom osprov.osbp import ThisTargetServer\nfrom osprov.osbp import datastore\n\n\nclass ResetInfo(object):\n\n    def __init__(self, spin, twistServer, serverRef):\n        self.spin = spin\n        self.twistServer = twistServer\n        self.serverRef = serverRef\n\n    def doReset(self, ignore_sysconfig=False, preserve_attrs=\"\", assign_os_profile=None):\n        self.spin.Device.clearRoles(id=self.serverRef.getId())\n        attrsToPreserve = []\n        if not ignore_sysconfig:\n            roleClass = self.spin.RoleClass.getByPath(path=[\"ServiceLevel\", \"Opsware\", \"buildmgr\"])\n            try:\n                reprovAttrNames = roleClass.getChildren(child_class=\"AppConfigWad\")[0].getDictValue(\n                    key=\"bm.reprovision_attributes_to_preserve\")\n                attrsToPreserve.extend(reprovAttrNames.split())\n            except errors.OpswareError, error:\n                # invalidParameterName is fine. There are none defined\n                if error.error_name != \"spin.invalidParameterName\":\n                    raise\n\n        if preserve_attrs:\n            attrsToPreserve.extend(preserve_attrs.split(\",\"))\n        # Keep the datastore intact\n        attrsToPreserve.append(datastore.CA_NAME)\n\n        preserveDict = {}\n        for attrName in attrsToPreserve:\n            try:\n                preserveDict[attrName] = self.twistServer.server.ServerService.getCustAttr(\n                    self.serverRef, attrName, False)\n            except NoSuchFieldException:\n                pass\n\n        willDelete = self.twistServer.server.ServerService.getCustAttrs(\n            self.serverRef, None, False)\n        if willDelete:\n            print \"Custom attributes that will be deleted:\"\n            for key, value in willDelete.items():\n                if not (preserveDict.has_key(key) or key.startswith(CustomAttribute.OPSWARE_PRIVATE_KEY_PREFIX)):\n                    print \"    %s=%s\" % (key, value)\n\n        self.twistServer.server.ServerService.clearCustAttrs(self.serverRef)\n        if preserveDict:\n            print \"Preserving the following custom attributes: %s\" % \", \".join([\n                x for x in preserveDict.keys() if not x.startswith(CustomAttribute.OPSWARE_PRIVATE_KEY_PREFIX)])\n            self.twistServer.server.ServerService.setCustAttrs(self.serverRef, preserveDict)\n\n        if assign_os_profile:\n            profileVO = twist.getOSIP(self.twistServer, assign_os_profile)\n            self.spin.Device.applyTemplateByRCs(\n                id=self.serverRef.getId(), rc_ids=[profileVO.getRef().getId()],\n                mode=\"override\", allow_platform_change=1)\n\n\ndef main():\n    TARGET = ThisTargetServer()\n    parser = OptionParser(description=__doc__, version=\"0.0.1\",\n                          usage='%prog [--assign_os_profile \"OS Installation Profile Name\"] [--preserve_attrs=attr1,attr2,attr3] [--ignore_sysconfig]')\n    parser.add_option(\"-a\", \"--preserve_attrs\", dest=\"preserve_attrs\", metavar=\"ATTR1,ATTR2\",\n                      help=\"Comma delimited list of custom attribute names to preserve\")\n    parser.add_option(\n        \"-o\", \"--assign_os_profile\", dest=\"assign_os_profile\", metavar=\"OS Profile Name\",\n        help=\"Name or ID of an OS Profile to which the target server should be assigned\")\n    parser.add_option(\"-i\", \"--ignore_sysconfig\", action=\"store_true\",\n                      dest=\"ignore_sysconfig\", default=False,\n                      help=\"By default we preserve the list of custom attribute names stored in SA system configuration setting \\\"bm.reprovision_attributes_to_preserve\\\". Specify this option to ignore these settings and remove all custom attributes not explicitly preserved.\")\n    try:\n        opt, args = parser.parse_args(sys.argv[1:])\n        mid = TARGET.getId()\n        spin = ogsh_spin.getSpin()\n        reset = ResetInfo(spin, sa.getTwistServer(), ServerRef(mid))\n        reset.doReset(opt.ignore_sysconfig, opt.preserve_attrs,\n                      opt.assign_os_profile)\n    except ShowErrorMessage, ex:\n        sys.stderr.write(ex.args[0] + \"\\n\")\n        return ex.args[1]\n    except errors.OpswareError, opswError:\n        sys.stderr.write(\"Error: %s - %s (%s)\\n\" % (opswError.error_name,\n                                                    opswError.params, opswError.faultCode))\n        return opswError.faultCode\n\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n",
            "description": "The step is deprecated and will be removed in a subsequent version.\n\nThis script removes HP SA software model elements from the target server's record in the SA model repository.  \nThis is necessary when installing a different OS onto an existing server.  This includes the following data items, if present:\n\n * the server's attachment to a specific OS Profile\n * Software Policy attachments\n * Custom Attributes (locally defined on the server record itself)\n\nThis script may also be used to assign the target server to a new OS Profile.\n\nUsage:\n\nreset_os_and_policy_info.py [--assign_os_profile \"OS Profile Name\"] [--preserve_attrs=attr1,attr2,attr3] [--ignore_sysconfig]\n\nAll parameters are optional.  The default behavior with no parameters is:\n\n * Assign the server to the \"Not Assigned\" OS Profile corresponding to the server's current platform\n * Detach all attached Software Policies\n * Remove all locally defined custom attributes, except those listed in the \"bm.reprovision_attributes_to_preserve\" sysconfig setting\n\nPrerequisites:\n - If provided, OS Profile must be a valid name or ID.",
            "status": null,
            "name": "Reset OS and Policy Info",
            "state": null,
            "eTag": "2015-06-13T04:49:06.000Z",
            "modified": "2015-06-13T04:49:06.000Z",
            "created": "2015-06-13T04:49:06.000Z",
            "category": "os-deployment-ogfs-scripts",
            "uri": "/rest/os-deployment-ogfs-scripts/960001"
        },
        {
            "codeType": "OGFS",
            "displayCodeType": "OGFS",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "1",
                    "createdBy": "opsware",
                    "createdDate": "2015-06-13T04:49:08.000Z",
                    "usage": "Integrates the HP SA agent. The agent will install and register at the first OS\nboot. No parameters are necessary.\n\nPrerequisites:\n- Target server runs a Suse, RHEL, Ubuntu or Solaris 10 OS installer.\n- The install is complete.\n- The installed system is mounted on /mnt for Suse, /mnt/sysimage for RHEL, /target for Ubuntu and /a for Solaris 10.",
                    "current": false
                },
                {
                    "versionLabel": "2",
                    "createdBy": "opsware",
                    "createdDate": "2015-08-04T07:30:14.000Z",
                    "usage": "Integrates the HP SA agent. The agent will install and register at the first OS\nboot. No parameters are necessary.\n\nPrerequisites:\n- Target server runs a Suse, RHEL, Ubuntu or Solaris 10 OS installer.\n- The install is complete.\n- The installed system is mounted on /mnt for Suse, /mnt/sysimage for RHEL, /target for Ubuntu and /a for Solaris 10.",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-08-04T07:30:14.000Z",
            "version": {
                "versionLabel": "2",
                "createdBy": "opsware",
                "createdDate": "2015-08-04T07:30:14.000Z",
                "usage": "Integrates the HP SA agent. The agent will install and register at the first OS\nboot. No parameters are necessary.\n\nPrerequisites:\n- Target server runs a Suse, RHEL, Ubuntu or Solaris 10 OS installer.\n- The install is complete.\n- The installed system is mounted on /mnt for Suse, /mnt/sysimage for RHEL, /target for Ubuntu and /a for Solaris 10.",
                "current": true
            },
            "source": "#!/usr/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n\"\"\"\n    (C) Copyright 2014-2015 Hewlett-Packard Development Company, L.P.\n\n    Integrate The HP SA agent into the final OS.\n\"\"\"\n\nimport os\nimport sys\nimport random\n\nfrom osprov import helpers\nfrom osprov.errors import InvalidArgumentsError\nfrom osprov.networking.utils import isIPv6Address\nfrom osprov.osbp import logger\nfrom osprov.osbp import ThisTargetServer\nfrom osprov.platform_util import isRHELCompatible, isSLES\nfrom osprov.util import process\nfrom osprov.decorators import HandleShowErrorMessage\n\nfrom librunplan import PlanRunner\nfrom librunplan import PlanOutputHandler\n\nfrom pytwist.com.opsware.osprov import RunScriptPlanStep\n\nLOG = logger.getIt(\"integrate_hpsa_agent\")\n\n\ndef rootPartition(platform):\n    \"\"\" Get the root partition  \"\"\"\n    if \"suse\" in platform.lower():\n        # for suse AutoYast\n        return \"mnt\"\n    elif \"ubuntu\" in platform.lower():\n        # for ubuntu\n        return \"target\"\n    elif \"5.10-X86\" in platform:\n        # for solaris 10\n        return \"a\"\n    else:\n        # for RHEL kickstart\n        return \"mnt/sysimage\"\n\n\ndef copyMidAndCrypto(root):\n    \"\"\" Copy the mid and crypto to the root partition \"\"\"\n    midDir = \"etc/opt/opsware/agent\"\n    cryptoDir = \"var/opt/opsware/crypto/\"\n    # ensure directories\n    for directory in [midDir, cryptoDir]:\n        process.runIt(\"rosh -l root mkdir -p  /%s\" %\n                     (os.path.join(root, directory)),\n                      quiet=True, quieterr=True, log=LOG)\n    # copy the crypto\n    src = \"/\" + os.path.join(cryptoDir, \"agent\")\n    dst = \"/\" + os.path.join(root, cryptoDir)\n    process.runIt(\"rosh -l root cp  -R '%s' '%s'\" % (src, dst),\n                  quiet=True, quieterr=True, log=LOG)\n    # copy mid\n    src = \"/\" + os.path.join(midDir, \"mid\")\n    dst = \"/\" + os.path.join(root, midDir)\n    process.runIt(\"rosh -l root cp  '%s' '%s'\" % (src, dst),\n                  quiet=True, quieterr=True, log=LOG)\n    return open(os.path.join(midDir, \"mid\")).read().strip()\n\n\ndef scheduleAgentInstallSystemD(platformName, agentGws):\n    root = rootPartition(platformName)\n    installer = \"/tmp/hpsa_agent_installer\"\n    installer_script = \"tmp/hpsa_agent_installer.sh\"\n\n    with open(os.path.join(root, installer_script), \"w\") as installer_script_file:\n        installer_script_file.write(getAgentInstallScript(installer, agentGws))\n    os.chmod(os.path.join(root, installer_script), 0550)\n\n    serviceName = \"hpsa_agent_installer.service\"\n    serviceFile = os.path.join(root, \"etc/systemd/system/\", serviceName)\n    with open(serviceFile, \"w\") as service:\n        service.write(getSystemdService(installer_script))\n    # enable the service\n    os.symlink(\"../%s\" % serviceName, os.path.join(root, \"etc/systemd/system/multi-user.target.wants/\", serviceName))\n\n\ndef getSystemdService(installer_script):\n    return \"\"\"[Unit]\nDescription=One-time HPSA agent install\nAfter=syslog.target network.target\n\n[Service]\nType=oneshot\nExecStart=/{installer_script} start\nKillMode=none\n\n[Install]\nWantedBy=multi-user.target\n\"\"\".format(installer_script=installer_script)\n\n\ndef scheduleAgentInstall(platformName, agentGws,\n                         initFileName=\"etc/init.d/hpsa_agent_installer\"):\n    \"\"\" Schedules an agent install job to run at boot \"\"\"\n    root = rootPartition(platformName)\n    rc_path = \"etc/rc.d/rc%d.d\"\n    install_path = \"/tmp/hpsa_agent_installer\"\n    if \"5.10-X86\" in platformName or \"ubuntu\" in platformName.lower():\n        rc_path = \"etc/rc%d.d\"\n        install_path = \"/hpsa_agent_installer\"\n\n    with open(os.path.join(root, initFileName), \"w\") as initFile:\n        initFile.write(getAgentInstallScript(install_path, agentGws))\n    os.chmod(os.path.join(root, initFileName), 0550)\n\n    agent = \"S40hpsa_agent_installer\"\n    for level in [2, 3, 5]:\n        if not os.path.exists(os.path.join(root, rc_path % level)):\n            continue\n        rc_link = os.path.join(root, rc_path % level, agent)\n        # just assume that if they are there we already created them in an earlier run\n        if not os.path.islink(rc_link):\n            os.symlink(os.path.join(os.sep, initFileName), rc_link)\n\n\ndef integrateAgentIsDone(root,\n                         flagFileName=\"var/tmp/doneIntegrateAgent\"):\n    \"\"\" For Suse Write the flag file to continue AutoYaST process\"\"\"\n    with open(os.path.join(root, flagFileName), \"w\") as flagFile:\n        flagFile.write(\"Done\")\n\n\ndef getAgentInstallScript(installerName, agentGws):\n    \"\"\" Does the file generation and writing \"\"\"\n    return INIT_FILE_TEMPLATE.format(\n        scriptName=\"hpsa_agent_installer\",\n        logFile=\"/var/log/opsware/agent/install.log\",\n        installerName=installerName,\n        agentgws=\" \".join([\"%s:%s\" % (ip, port) for ip, port in agentGws]),\n        agentgws_formatted=\",\".join([(\"[%s]:%s\" if isIPv6Address(ip) else \"%s:%s\") % (ip, port) for ip, port in agentGws])\n    )\n\n\ndef downloadAgent(target, root):\n    \"\"\" Download the agent using the deploy step  \"\"\"\n    destDir = os.path.join(root, \"tmp\")\n    if not os.path.exists(destDir):\n        os.makedirs(destDir)\n    destFile = os.path.join(destDir, \"hpsa_agent_installer\")\n    args = \"-n opsware-agent -d %s \" % destFile\n    runnerOH = PlanOutputHandler(sys.stdout, sys.stderr, LOG)\n    runnerOH.NO_APX_PROGRESS = True  # don't break the papx reporting\n    runnerOH.ADV_STEP_MSG = None  # don't update the main message\n    runnerOH.ADV_STEP_MSG_LONG = \"\\nSub Step: %(action)s '%(name)s'\"\n    runnerOH.ERR_HEADER = \"\\nErrors from sub step %(current)d '%(name)s':\\n\"\n    runner = PlanRunner(None, targetServer=target, outputHandler=runnerOH)\n    scriptPath = \"Deploy Agent\"\n    scriptElems = [x for x in scriptPath.split(\"/\") if x]\n    stepRef = target.twistServer.folder.FolderService.getFNode(\n        [\"Opsware\", \"Tools\", \"OS Provisioning\", \"OS Build Plan Steps\"] +\n        scriptElems)\n    step = RunScriptPlanStep()\n    step.setScript(stepRef)\n    step.setParameters(args)\n    runner.doStep(step, stepNo=int(os.environ[\"CURRENT_STEP_NO\"]))\n    return destFile\n\n\ndef getAgentInstallerPath(root):\n    \"\"\" Return an existing agent installer \"\"\"\n    for installer in [\"tmp/hpsa_agent_installer\", \"hpsa_agent_installer\"]:\n        installerPath = os.path.join(root, installer)\n        if os.path.isfile(installerPath):\n            LOG.debug(\"Found agent installer at: \" + installerPath)\n            return installerPath\n    return None\n\n\ndef chooseAgentGateways(agentGws, ipv6Managed):\n    \"\"\" Choose two random gateways, but take stack into account \"\"\"\n    if not agentGws:\n        raise InvalidArgumentsError(\"No agent gateways\")\n    LOG.debug(\"Available agent gateways: %s\" % agentGws)\n\n    ipv6Gws = []\n    ipv4Gws = []\n    for agentGwIP, agentGwPort in agentGws:\n        if isIPv6Address(agentGwIP):\n            ipv6Gws.append((agentGwIP, agentGwPort))\n        else:\n            ipv4Gws.append((agentGwIP, agentGwPort))\n\n    result = []\n    if ipv6Gws:\n        result.append(random.choice(ipv6Gws))\n    if ipv4Gws:\n        result.append(random.choice(ipv4Gws))\n    if not ipv6Managed:\n        result.reverse()\n    return result\n\n\n@HandleShowErrorMessage(\"integrate the HP SA agent\", LOG)\ndef main():\n    if len(sys.argv) > 1:\n        print \"Arguments are no longer required and will be ignored\"\n    try:\n        targetServer = ThisTargetServer()\n        targetServer.setWorkDir(targetServer.getRemoteRoot())\n        keys = helpers.getDataStore(targetServer)\n\n        platform = keys.platform.full_name\n        if not platform:\n            platform = targetServer.getServerVO(cached=False).getOsVersion()\n        print (\"Integrating the HP SA agent for \" + platform)\n\n        root = rootPartition(platform)\n\n        # newer OS build plans have a \"Deploy Agent\" step\n        # this is for backwards compatibility\n        if not getAgentInstallerPath(root):\n            downloadAgent(targetServer, root)\n\n        copyMidAndCrypto(root)\n        agentGws = chooseAgentGateways(targetServer.getAgentGWs(stackAware=False), targetServer.isIPv6Managed(()))\n        print \"Using agent gateway(s): %s\" % agentGws\n        if isRHELCompatible(platform, 7) or isSLES(platform, 12):\n            scheduleAgentInstallSystemD(platform, agentGws)\n        else:\n            scheduleAgentInstall(platform, agentGws)\n        print \"Successfully integrated the HP SA agent.\"\n        print \"The agent will be installed on the first OS boot.\"\n\n        if \"suse\" in platform.lower():\n            integrateAgentIsDone(root)\n    except (IOError, OSError), why:\n        LOG.exception(why)\n        sys.stderr.write(\"%s\\n\" % why)\n        sys.stdout.write(\"Failed to integrate HP SA Agent.\\n\")\n        return 1\n\n\nINIT_FILE_TEMPLATE = \"\"\"#!/bin/sh\n#\n# /etc/init.d/%(scriptName)s\n#\n#\n### BEGIN INIT INFO\n# Provides:          hpsa_agent_installer\n# Required-Start:    $syslog $remote_fs $network $local_fs\n# Should-Start:      $time $portmap\n# Required-Stop:     $syslog $remote_fs\n# Should-Stop:       $time $portmap\n# Default-Start:     3 5\n# Default-Stop:      0 1 2 6\n# Short-Description: HP SA Installer script.\n# Description: Just to install the HP SA Agent on first boot\n#\n# X-UnitedLinux-Default-Enabled: yes\n### END INIT INFO\nHPSA_INSTALL_LOG={logFile}\nmkdir -p ` dirname $HPSA_INSTALL_LOG`\n\necho \"Installing HPSA Agent\"\necho \"Logging in $HPSA_INSTALL_LOG\"\n\n# Redirect messages to the log\nexec >> $HPSA_INSTALL_LOG\nexec 2>> $HPSA_INSTALL_LOG\n\nHPSA_BIN={installerName}\ncase \"$1\" in\n    start)\n        ##  Protect against NFS services that might use the agent port\n        # Observed in newer RHELs ( 5.7 and 6.1 )\n        LOCKEDFILE=\"/etc/init.d/nfslock\"\n        LOCKED_STOPPED=1\n        if [ -f $LOCKEDFILE ] ; then\n            $LOCKEDFILE stop\n            LOCKED_STOPPED=0\n        fi\n        # Make sure it's executable\n        chmod +x $HPSA_BIN\n\n        echo \"Using HPSA agent gateways: {agentgws}\"\n\n        echo \"START NETWORK DIAGNOSTIC INFO\"\n        ifconfig -a\n        netstat -rn\n\n        python -c \"import sys; sys.exit(0)\"\n        if [ $? -eq 0 ]; then\n            for i in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 ; do\n                connected=1\n                for agw in {agentgws}; do\n                    echo \"Trying to connect to $agw\"\n                    echo $agw | python -c \"import sys, socket; ip, port = sys.stdin.readline().rsplit(':',1); s=socket.socket(socket.AF_INET6*int(':' in ip) or socket.AF_INET, socket.SOCK_STREAM); s.settimeout(10); s.connect((ip, int(port)));\"\n                    if [ $? -eq 0 ] ; then echo \"Successfully connected to $agw\"; connected=0; break; fi\n                    sleep $i\n                done\n                if [ $connected -eq 0 ]; then break; fi\n            done\n        else\n            echo \"python not available, skipping network diagnostics\"\n        fi\n\n        echo \"END NETWORK DIAGNOSTIC INFO\"\n\n        # Run the installer\n        $HPSA_BIN -s --settime --force_full_hw_reg --force_sw_reg \\\\\n            --logfile $HPSA_INSTALL_LOG    \\\\\n            --opsw_gw_addr \"{agentgws_formatted}\"\n        RC=$?\n        if [ $LOCKED_STOPPED = 0 ] ; then\n            $LOCKEDFILE start\n        fi\n        if [ $RC -eq 0 ] ; then\n            echo \"Agent Installation successful\"\n            # self destruct\n            rm -f /etc/rc.d/rc*/*hpsa_agent_installer\n            rm -f $0\n            rm -f /etc/init.d/hpsa_agent_installer\n            rm $HPSA_BIN\n            if [ -d \"/etc/systemd/system\" ] || [ -d \"/run/systemd/system\" ] || [ -d \"/usr/lib/systemd/system\" ] || [ -d \"/lib/systemd/system\" ] ; then\n                echo \"Disabling hpsa_agent_installer.service\"\n                rm -f /etc/systemd/system/multi-user.target.wants/hpsa_agent_installer.service\n            fi\n            exit 0\n        else\n            #  The installer also logs here, so no extra message is needed\n            exit 1\n        fi\n        ;;\n    stop)\n        echo Call to \"$1\" not implemented\n        exit 3\n        ;;\n    try-restart)\n        echo Call to \"$1\" not implemented\n        exit 3\n        ;;\n    restart)\n        echo Call to \"$1\" not implemented\n        ;;\n    force-reload)\n        echo Call to \"$1\" not implemented\n        exit 3\n        ;;\n    reload)\n        echo Call to \"$1\" not implemented\n        exit 3\n        ;;\n    status)\n        echo Call to \"$1\" not implemented\n        exit 3\n        ;;\nesac\n\"\"\"\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n",
            "description": "Integrates the HP SA agent. The agent will install and register at the first OS\nboot. No parameters are necessary.\n\nPrerequisites:\n- Target server runs a Suse, RHEL, Ubuntu or Solaris 10 OS installer.\n- The install is complete.\n- The installed system is mounted on /mnt for Suse, /mnt/sysimage for RHEL, /target for Ubuntu and /a for Solaris 10.",
            "status": null,
            "name": "Integrate Linux HP SA Agent",
            "state": null,
            "eTag": "2015-08-04T07:30:14.000Z",
            "modified": "2015-08-04T07:30:14.000Z",
            "created": "2015-06-13T04:49:08.000Z",
            "category": "os-deployment-ogfs-scripts",
            "uri": "/rest/os-deployment-ogfs-scripts/990001"
        },
        {
            "codeType": "OGFS",
            "displayCodeType": "OGFS",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "1",
                    "createdBy": "opsware",
                    "createdDate": "2015-06-13T04:49:08.000Z",
                    "usage": "Validates key job settings are set and fails the OS Build Plan if any are incorrect. These include the target server's WinPE version and the following custom attributes: ComputerName, ProductKey, SystemDrive, SystemDiskNumber.\n\nUsage:\n\nvalidate_job_settings.py [--sig WINPE64] [--productkey] [--domain]\n\nThe script by default checks for WINPE32 on the target server. Use \"--sig WINPE64\" for 64 bit builds.  \nBy default, the ProductKey custom attribute is not required or validated, but passing \"--productkey\" enables this validation.\nPassing --domain will validate for custom attributes used for adding the provisioned server to a domain \n(DomainName, DomainUser, DomainPassword). This is off by default.",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-06-13T04:49:08.000Z",
            "version": {
                "versionLabel": "1",
                "createdBy": "opsware",
                "createdDate": "2015-06-13T04:49:08.000Z",
                "usage": "Validates key job settings are set and fails the OS Build Plan if any are incorrect. These include the target server's WinPE version and the following custom attributes: ComputerName, ProductKey, SystemDrive, SystemDiskNumber.\n\nUsage:\n\nvalidate_job_settings.py [--sig WINPE64] [--productkey] [--domain]\n\nThe script by default checks for WINPE32 on the target server. Use \"--sig WINPE64\" for 64 bit builds.  \nBy default, the ProductKey custom attribute is not required or validated, but passing \"--productkey\" enables this validation.\nPassing --domain will validate for custom attributes used for adding the provisioned server to a domain \n(DomainName, DomainUser, DomainPassword). This is off by default.",
                "current": true
            },
            "source": "#!/usr/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n#\n\"\"\"\n    (C) Copyright 2010-2015 Hewlett-Packard Development Company, L.P.\n\n    Validates essential job conditions and fails the build plan if they\n    are incorrect\n\"\"\"\nimport optparse\nimport re\nimport sys\n\nfrom osprov.osbp import ThisTargetServer\nfrom osprov.osbp.TargetServer import WinPETargetServer\nfrom osprov.profile import unattend\nfrom osprov.errors import ShowErrorMessage\n\n\nEC_USAGE = 1\nEC_EXCEPTION = 2\nEC_TARGET_SERVER = 5\nEC_CUST_ATTR = 6\n\n\nclass JobSettingValidator(object):\n\n    \"\"\" Implement job validation \"\"\"\n    NETBIOS_INVALID_CHARS = ' \\\\*+=|:;\"?<>,'\n\n    def __init__(self, twistServer, targetServer,\n                 sig=\"WINPE32\",\n                 checkProductKey=False,\n                 checkDomain=False):\n        self.twistServer = twistServer\n        self.targetServer = targetServer\n        self.serverRef = targetServer.serverRef\n        self.sig = sig\n        self.checkProductKey = checkProductKey\n        self.checkDomain = checkDomain\n\n    def _attr(self, val):\n        \"\"\" Identity function, usefull in unit tests \"\"\"\n        return val\n\n    def validateJobSettings(self, out=sys.stdout, err=sys.stderr):\n        \"\"\" Start all validators \"\"\"\n        exceptions = []\n        for func in (self.validateWinPE, self.validateComputerName,\n                     self.validateProductKey, self.validateSystemDrive,\n                     self.validateSystemDiskNumber, self.validateDomain):\n            try:\n                func()\n            except ShowErrorMessage, sem:\n                exceptions.append(sem)\n\n        if exceptions:\n            for exception in exceptions[1:]:\n                err.write(exception.args[0] + \"\\n\")\n            raise exceptions[0]\n\n        out.write(\"All job settings validated OK\\n\")\n\n    def validateWinPE(self):\n        if self.sig == \"WINPE32\":\n            if not (isinstance(self.targetServer, WinPETargetServer) and\n                    not self.targetServer.is64bit()):\n                raise ShowErrorMessage(\"Server must be running %s, but it is not.\" %\n                                       self.sig, EC_TARGET_SERVER)\n        elif self.sig == \"WINPE64\":\n            if not (isinstance(self.targetServer, WinPETargetServer) and\n                    self.targetServer.is64bit()):\n                raise ShowErrorMessage(\"Server must be running %s, but it is not.\" %\n                                       self.sig, EC_TARGET_SERVER)\n        else:\n            ShowErrorMessage(\"Invalid signature to check against: %s. Valid options \"\n                             \"are WINPE64 or WINPE32\" % self.sig)\n\n    def validateDomain(self):\n        \"\"\" Validate the domain specific CAs \"\"\"\n        if not self.checkDomain:\n            return\n        if not self._attr(\"\"\"@DomainName@\"\"\"):\n            raise ShowErrorMessage(\n                \"The domain name needs to be set using the DomainName custom attribute.\")\n        if not self._attr(\"\"\"@DomainUser@\"\"\"):\n            raise ShowErrorMessage(\n                \"The domain user needs to be set using the DomainUser custom attribute.\")\n        if not self._attr(\"\"\"@DomainPassword@\"\"\"):\n            raise ShowErrorMessage(\n                \"The domain password needs to be set using the DomainPassword custom attribute.\")\n\n    def validateComputerName(self):\n        # We are using the info here:\n        # http://support.microsoft.com/kb/188997\n        caValue = self._attr(\"\"\"@ComputerName@\"\"\")\n        if not caValue:\n            return\n        if len(caValue) > 15:\n            raise ShowErrorMessage(\n                \"ComputerName custom attribute must not exceed 14 characters.\" +\n                \" '%s' is not a valid Windows computer name\" % caValue, EC_CUST_ATTR)\n        invalidAndPresent = [x for x in self.NETBIOS_INVALID_CHARS if x in caValue]\n        if invalidAndPresent:\n            raise ShowErrorMessage(\n                \"ComputerName custom attribute contains invalid characters. \" +\n                \" \".join(invalidAndPresent), EC_CUST_ATTR)\n\n    def validateProductKey(self):\n        if not self.checkProductKey:\n            return\n        caValue = self._attr(\"\"\"@ProductKey@\"\"\")\n        if not caValue:\n            raise ShowErrorMessage(\n                \"Please provide a ProductKey to proceed with installation.\",\n                EC_CUST_ATTR)\n        unattend.validateProductKey(caValue)\n\n    def validateSystemDrive(self):\n        caValue = self._attr(\"\"\"@SystemDrive@\"\"\")\n        if not caValue:\n            return\n        if not re.match(\"^[C-WYZ]$\", caValue):\n            message = \"SystemDrive custom attribute must be a single valid uppercase drive letter.\"\n            if caValue in \"ABX\":\n                message = \"SystemDrive custom attribute may not be A, B or X.\"\n            elif re.match(\"^[A-Z]:$\", caValue, re.I):\n                message = \"SystemDrive should not include a trailing colon.\"\n            raise ShowErrorMessage(message, EC_CUST_ATTR)\n\n    def validateSystemDiskNumber(self):\n        caValue = self._attr(\"\"\"@SystemDiskNumber@\"\"\")\n        if not caValue:\n            return\n        if not re.match(\"^\\d+$\", caValue):\n            raise ShowErrorMessage(\n                \"SystemDiskNumber custom attribute must be a number.\", EC_CUST_ATTR)\n\n\ndef parseArgs(args):\n    # setup and return parsed arguments\n    parser = optparse.OptionParser(\n        description=__doc__,\n        version=\"1.1.0\",\n        usage=\"%prog [-s WINPE64] [-p]\"\n    )\n    parser.set_defaults(sig=\"WINPE32\", productkey=False)\n    parser.add_option(\"-s\", \"--sig\", dest=\"sig\", metavar=\"WINPE64\",\n                      help=\"Signature to check for. Either WINPE32 or WINPE64\")\n    parser.add_option(\"-p\", \"--productkey\", dest=\"productkey\", action=\"store_true\",\n                      help=\"This flag controls whether a ProductKey custom attribute is checked.\")\n    parser.add_option(\"-d\", \"--domain\", action=\"store_true\", default=False,\n                      help=\"This flag controls whether the Domain specific custom attributes are set\")\n    return parser.parse_args(args)\n\n\ndef main():\n    opt, args = parseArgs(sys.argv[1:])\n\n    targetServer = ThisTargetServer()\n    validator = JobSettingValidator(targetServer.twistServer, targetServer,\n                                    sig=opt.sig,\n                                    checkProductKey=opt.productkey,\n                                    checkDomain=opt.domain\n                                    )\n    try:\n        validator.validateJobSettings()\n    except ShowErrorMessage, why:\n        sys.stderr.write(\"%s\\n\" % why)\n        return why.exitCode\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n",
            "description": "Validates key job settings are set and fails the OS Build Plan if any are incorrect. These include the target server's WinPE version and the following custom attributes: ComputerName, ProductKey, SystemDrive, SystemDiskNumber.\n\nUsage:\n\nvalidate_job_settings.py [--sig WINPE64] [--productkey] [--domain]\n\nThe script by default checks for WINPE32 on the target server. Use \"--sig WINPE64\" for 64 bit builds.  \nBy default, the ProductKey custom attribute is not required or validated, but passing \"--productkey\" enables this validation.\nPassing --domain will validate for custom attributes used for adding the provisioned server to a domain \n(DomainName, DomainUser, DomainPassword). This is off by default.",
            "status": null,
            "name": "Validate Job Settings",
            "state": null,
            "eTag": "2015-06-13T04:49:08.000Z",
            "modified": "2015-06-13T04:49:08.000Z",
            "created": "2015-06-13T04:49:08.000Z",
            "category": "os-deployment-ogfs-scripts",
            "uri": "/rest/os-deployment-ogfs-scripts/1000001"
        },
        {
            "codeType": "OGFS",
            "displayCodeType": "OGFS",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "1",
                    "createdBy": "opsware",
                    "createdDate": "2015-06-13T04:49:09.000Z",
                    "usage": "Decommissions a server that is agent managed but preserves the server's custom attributes from the DEFAULT namespace.\nIf the server is not agent managed it will exit without failing.\n\nNote that using this step on a server in lifecycle MANAGED and state MAINTENANCE is not recommended\nsince this will reset the crypto, making it impossible to execute subsequent steps that use the ogfs-agent\nwithout requiring a reboot.\n\nFor details about server decommissioning, please consult the Server Automation provided documentation.",
                    "current": false
                },
                {
                    "versionLabel": "2",
                    "createdBy": "opsware",
                    "createdDate": "2015-08-04T07:29:59.000Z",
                    "usage": "Decommissions a server that is agent managed but preserves the server's custom attributes from the DEFAULT namespace.\nIf the server is not agent managed it will exit without failing.\n\nNote that using this step on a server in lifecycle MANAGED and state MAINTENANCE is not recommended\nsince this will reset the crypto, making it impossible to execute subsequent steps that use the ogfs-agent\nwithout requiring a reboot.\n\nFor details about server decommissioning, please consult the Server Automation provided documentation.",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-08-04T07:29:59.000Z",
            "version": {
                "versionLabel": "2",
                "createdBy": "opsware",
                "createdDate": "2015-08-04T07:29:59.000Z",
                "usage": "Decommissions a server that is agent managed but preserves the server's custom attributes from the DEFAULT namespace.\nIf the server is not agent managed it will exit without failing.\n\nNote that using this step on a server in lifecycle MANAGED and state MAINTENANCE is not recommended\nsince this will reset the crypto, making it impossible to execute subsequent steps that use the ogfs-agent\nwithout requiring a reboot.\n\nFor details about server decommissioning, please consult the Server Automation provided documentation.",
                "current": true
            },
            "source": "#!/usr/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n#\n\"\"\"\n    (C) Copyright 2013-2015 Hewlett-Packard Development Company, L.P.\n\n    Decommissions a server that is agent managed.\n\"\"\"\nimport sys\n\nfrom osprov.decorators import HandleShowErrorMessage\nfrom osprov.ogfs import ogsh_spin\nfrom osprov.osbp import logger, thisServerID\nfrom osprov.server.sa import SAServer\n\nLOG = logger.getIt(\"Decommission Server\")\n\n\n@HandleShowErrorMessage(\"decommission server\", LOG)\ndef main():\n    serverId = thisServerID()\n    targetServer = SAServer(server=serverId)\n    if targetServer.isAgentless():\n        print(\"The target server is not agent managed, skipping decommissioning\")\n        return 0\n    else:\n        spin = ogsh_spin.getSpin()\n        spin.Device.reprovision(id=serverId, check_state=0, keep_custom_attributes=1, keep_fields=[\"reporting\"])\n        targetServer.twistServer.shared.TwistConsoleService.forceCacheConsistency()\n    return 0\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n",
            "description": "Decommissions a server that is agent managed but preserves the server's custom attributes from the DEFAULT namespace.\nIf the server is not agent managed it will exit without failing.\n\nNote that using this step on a server in lifecycle MANAGED and state MAINTENANCE is not recommended\nsince this will reset the crypto, making it impossible to execute subsequent steps that use the ogfs-agent\nwithout requiring a reboot.\n\nFor details about server decommissioning, please consult the Server Automation provided documentation.",
            "status": null,
            "name": "Decommission Server",
            "state": null,
            "eTag": "2015-08-04T07:29:59.000Z",
            "modified": "2015-08-04T07:29:59.000Z",
            "created": "2015-06-13T04:49:08.000Z",
            "category": "os-deployment-ogfs-scripts",
            "uri": "/rest/os-deployment-ogfs-scripts/1010001"
        },
        {
            "codeType": "OGFS",
            "displayCodeType": "OGFS",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "1",
                    "createdBy": "opsware",
                    "createdDate": "2015-06-13T04:49:09.000Z",
                    "usage": "Adds an iLO user with the specified username, password and privileges using the hponcfg utility.\n\nusage: Adds an iLO user using the hponcfg utility.\n\noptions:\n  -h, --help            show this help message and exit\n  --username=USERNAME   Required. Username of the new iLO user\n  --password=PASSWORD   Required. Password of the new iLO user\n  --privilege=PRIVILEGE\n                        Privilege to be given to the new iLO user. Can be\n                        specified more than once. Possible values:  ADMIN\n                        REMOTE_CONS RESET_SERVER VIRTUAL_MEDIA CONFIG_ILO\n\nexample: --username=admin --password=ChangeMe123! --privilege=ADMIN --privilege=CONFIG_ILO \n\tWill add an iLO user admin with ADMIN and CONFIG_ILO privileges.\n\nSupported characters in USERNAME and PASSWORD:\n  - All uppercase and lowercase letters\n  - All numeric characters\n  - The symbols !#$()*+,-./:;=?@[]^_{|}~\n\nPrerequisites:\n - Script needs to be run as part of a build plan.\n - Target server runs a maintenance Windows PE or Linux OS.",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-06-13T04:49:09.000Z",
            "version": {
                "versionLabel": "1",
                "createdBy": "opsware",
                "createdDate": "2015-06-13T04:49:09.000Z",
                "usage": "Adds an iLO user with the specified username, password and privileges using the hponcfg utility.\n\nusage: Adds an iLO user using the hponcfg utility.\n\noptions:\n  -h, --help            show this help message and exit\n  --username=USERNAME   Required. Username of the new iLO user\n  --password=PASSWORD   Required. Password of the new iLO user\n  --privilege=PRIVILEGE\n                        Privilege to be given to the new iLO user. Can be\n                        specified more than once. Possible values:  ADMIN\n                        REMOTE_CONS RESET_SERVER VIRTUAL_MEDIA CONFIG_ILO\n\nexample: --username=admin --password=ChangeMe123! --privilege=ADMIN --privilege=CONFIG_ILO \n\tWill add an iLO user admin with ADMIN and CONFIG_ILO privileges.\n\nSupported characters in USERNAME and PASSWORD:\n  - All uppercase and lowercase letters\n  - All numeric characters\n  - The symbols !#$()*+,-./:;=?@[]^_{|}~\n\nPrerequisites:\n - Script needs to be run as part of a build plan.\n - Target server runs a maintenance Windows PE or Linux OS.",
                "current": true
            },
            "source": "#!/usr/bin/python\n\"\"\"\n    (C) Copyright 2012-2015 Hewlett-Packard Development Company, L.P.\n\"\"\"\n\nimport sys\nfrom optparse import OptionValueError\nfrom time import sleep\n\nsys.path.append(\"/opsw/apx/runtime/script/osprov.run_os_build_plan_papx/\")\nsys.path.append(\"/opt/opsware/pylibs2/\")\n\nfrom osprov.errors import ProcessExecutionError, ShowErrorMessage\nfrom osprov.optparse_ext import OptionParser\nfrom osprov.osbp import logger, ThisTargetServer\nfrom osprov.profile.ribcl import RibclProfile\nfrom osprov.wrappers.hponcfg import HpOnCfg\n\nlog = logger.getIt(\"Add iLO User\")\n\nUSER_EXISTS_STATUS_CODES = (\"0x0007\", \"0x7\")\n\nRETRIES_ON_FAILURE = 5\nSECONDS_BETWEEN_RETRIES = 5\n\n\nclass AddIloUserOptionParser(OptionParser):\n\n    def __init__(self, *args, **kwargs):\n        OptionParser.__init__(self, *args, **kwargs)\n        self.usage = \"Adds an iLO user using the hponcfg utility.\"\n\n    def defineOptions(self):\n        self.add_option(\"--username\",\n                        help=\"Username of the new iLO user\")\n        self.add_option(\"--password\",\n                        help=\"Password of the new iLO user\")\n        self.add_option(\"--privilege\",\n                        default=[],\n                        choices=RibclProfile.User.SUPPORTED_PRIVILEGES,\n                        action=\"append\",\n                        help=\"Privilege to be given to the new iLO user. Can be specified more than once. \"\n                        \"Possible values:\\n %s\" % \" \".join(\n                            RibclProfile.User.SUPPORTED_PRIVILEGES)\n                        )\n\n    def validateArgs(self, opt, args):\n        if not opt.username:\n            raise OptionValueError(\"Missing required argument: username\")\n        if not opt.password:\n            raise OptionValueError(\"Missing required argument: password\")\n\n\ndef main():\n    parser = AddIloUserOptionParser()\n    options, remaining_args = parser.parse_args()\n\n    targetServer = ThisTargetServer()\n    hpOnCfg = HpOnCfg(targetServer, log=log)\n\n    ribclProfile = RibclProfile()\n    user = RibclProfile.User(options.username, options.password)\n    for privilege in options.privilege:\n        user.addPrivilege(privilege)\n    ribclProfile.addCommand(RibclProfile.AddUserCommand(user))\n\n    try:\n        hpOnCfg.set(ribclProfile)\n        # Check to see if the user was really added, wait and retry if not\n        for i in xrange(RETRIES_ON_FAILURE):\n            ribcl = hpOnCfg.getCurrentConfig()\n            if ribcl.iLOUserExists(options.username):\n                break\n            print \"Warning: iLO User was not added, retry %d of 5\" % (i + 1)\n            try:\n                hpOnCfg.set(ribclProfile)\n            except ProcessExecutionError, why:\n                # Check if hponcfg failed because user was added, in this case it's what we want\n                log.exception(why)\n                if reduce(lambda x, y: x or y, [code in why.stderr for code in USER_EXISTS_STATUS_CODES]):\n                    break\n            sleep(SECONDS_BETWEEN_RETRIES)\n        else:\n            raise ShowErrorMessage(\n                \"Error: iLO User '%s' could not be added, there may be a problem with the iLO\" % options.username)\n    except ProcessExecutionError, why:\n        log.exception(why)\n        print \"Failed to add the iLO user using hponcfg\"\n        print \"Standard output of hponcfg command:\"\n        print why.stdout\n        print \"Standard error of hponcfg command:\"\n        print why.stderr\n        return why.exitCode\n    return 0\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n",
            "description": "Adds an iLO user with the specified username, password and privileges using the hponcfg utility.\n\nusage: Adds an iLO user using the hponcfg utility.\n\noptions:\n  -h, --help            show this help message and exit\n  --username=USERNAME   Required. Username of the new iLO user\n  --password=PASSWORD   Required. Password of the new iLO user\n  --privilege=PRIVILEGE\n                        Privilege to be given to the new iLO user. Can be\n                        specified more than once. Possible values:  ADMIN\n                        REMOTE_CONS RESET_SERVER VIRTUAL_MEDIA CONFIG_ILO\n\nexample: --username=admin --password=ChangeMe123! --privilege=ADMIN --privilege=CONFIG_ILO \n\tWill add an iLO user admin with ADMIN and CONFIG_ILO privileges.\n\nSupported characters in USERNAME and PASSWORD:\n  - All uppercase and lowercase letters\n  - All numeric characters\n  - The symbols !#$()*+,-./:;=?@[]^_{|}~\n\nPrerequisites:\n - Script needs to be run as part of a build plan.\n - Target server runs a maintenance Windows PE or Linux OS.",
            "status": null,
            "name": "Add iLO User",
            "state": null,
            "eTag": "2015-06-13T04:49:09.000Z",
            "modified": "2015-06-13T04:49:09.000Z",
            "created": "2015-06-13T04:49:09.000Z",
            "category": "os-deployment-ogfs-scripts",
            "uri": "/rest/os-deployment-ogfs-scripts/1020001"
        },
        {
            "codeType": "OGFS",
            "displayCodeType": "OGFS",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "1",
                    "createdBy": "opsware",
                    "createdDate": "2015-06-13T04:49:11.000Z",
                    "usage": "Injects the following settings for personalization into a preseed installation profile:\n- Network settings using passed with the hpsa_netconfig custom attribute.\n\nUsage: inject_ps_personalization_settings.py [options]\n\nOptions:\n  -h, --help            show this help message and exit\n  --require-netconfig=['true', 'false']\n                        Specify whether a network configuration is mandatory or not. Defaults to 'false'.\n  --disableWarning\n                        Do not show warnings of old hpsa_netconfig format\n\nPrerequisites:\n- Target server runs a maintenance Linux OS.\n- A preseed configuration file has to be provided in order to inject the static network configuration.",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-06-13T04:49:11.000Z",
            "version": {
                "versionLabel": "1",
                "createdBy": "opsware",
                "createdDate": "2015-06-13T04:49:11.000Z",
                "usage": "Injects the following settings for personalization into a preseed installation profile:\n- Network settings using passed with the hpsa_netconfig custom attribute.\n\nUsage: inject_ps_personalization_settings.py [options]\n\nOptions:\n  -h, --help            show this help message and exit\n  --require-netconfig=['true', 'false']\n                        Specify whether a network configuration is mandatory or not. Defaults to 'false'.\n  --disableWarning\n                        Do not show warnings of old hpsa_netconfig format\n\nPrerequisites:\n- Target server runs a maintenance Linux OS.\n- A preseed configuration file has to be provided in order to inject the static network configuration.",
                "current": true
            },
            "source": "#!/usr/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# lint_ignore=E501,I0011,C0301\n# Please do not change the two lines above. See PEP 8, PEP 263.\n\"\"\"\n    (C) Copyright 2013-2015 Hewlett-Packard Development Company, L.P.\n\n    This program will inject personalized settings into the preseed\n    file.\n\"\"\"\n\nimport sys\nfrom osprov.decorators import HandleShowErrorMessage\nfrom cStringIO import StringIO\n\nfrom osprov.optparse_ext import OptionParser, OptionValueError\nfrom osprov.profile.preseed import Preseed\nfrom osprov.osbp import logger\nfrom osprov.osbp import ThisTargetServer\nfrom osprov.parsers.netconfig import SmartNetconfig, OLD_SYNTAX_WARNING\nfrom osprov.networking import validation\n\nEC_EXCEPTION = 100\nPS_PATH = \"tmp/preseed.cfg\"\n\nLOG = logger.getIt('inject_ps_pers')\n\nHPSA_NETCONFIG = \"\"\"@hpsa_netconfig@\"\"\"\n\n\ndef writePsFile(psFile, ps):\n    \"\"\" Write the ks file to disk  \"\"\"\n    psf = open(psFile, \"w+\")\n    psf.write(str(ps))\n    psf.close()\n\n\ndef getOptions():\n    \"\"\"Returns the command-line options.\"\"\"\n    optparser = OptionParser()\n    optparser.add_option(\"--require-netconfig\", default=\"false\")\n    optparser.add_option(\"--disableWarning\", dest=\"disableWarning\", action=\"store_true\",\n                        default=False,\n                        help=\"Do not show warnings of old hpsa_netconfig format\")\n    (options, args) = optparser.parse_args()\n    del args\n    if not options.require_netconfig.lower() in (\"true\", \"false\"):\n        raise OptionValueError(\n            \"Invalid value for --require-netconfig: %s.\\nShould be 'true' or 'false'.\")\n    options.require_netconfig = options.require_netconfig.lower() == \"true\"\n    return options\n\n\ndef setNetworkSettings(profile, netinfo, isIpv6managed):\n    \"\"\" Configure the network settings  \"\"\"\n    provisioningNIC = netinfo.getProvisioningNIC()\n    print \"Going to provision using interface with MAC address %s\" % provisioningNIC.macAddress\n    # https://bugs.launchpad.net/ubuntu/+source/netcfg/+bug/56679\n    # we pass in BOOTIF on the kernel command line of the installer so this will be correct\n    profile[\"d-i\", \"netcfg/choose_interface\"] = (\"select\", \"auto\")\n\n    def config_static(network):\n        print \"Configuring boot protocol to: static\"\n        profile[\"d-i\", \"netcfg/disable_autoconfig\"] = (\"boolean\", \"true\")\n        # adding these so that the preconfiguration file will work on systems both with and\n        # without a dhcp server\n        profile[\"d-i\", \"netcfg/dhcp_failed\"] = (\"note\", \"\")\n        profile[\"d-i\", \"netcfg/dhcp_options\"] = (\"select\", \"Configure network manually\")\n        profile[\"d-i\", \"netcfg/confirm_static\"] = (\"boolean\", \"true\")\n        profile[\"d-i\", \"netcfg/get_ipaddress\"] = (\"string\", str(network.ip))\n        if network.netmask:\n            profile[\"d-i\", \"netcfg/get_netmask\"] = (\"string\", str(network.netmask))\n\n    # A static configuration will always have priority if static network info is defined\n    if isIpv6managed:\n        if provisioningNIC.ipv6Autoconfig:\n            print \"Configuring boot protocol to: dhcp\"\n        elif provisioningNIC.ipv6Networks:\n            print \"Configuring IPv6 network: %s\" % provisioningNIC.ipv6Networks[0]\n            config_static(provisioningNIC.ipv6Networks[0])\n        else:\n            print \"Can not complete network personalization. \" \\\n                  \"Auto configuration is turned off for IPv6 and there is no static address defined\"\n            sys.exit(37)\n        if provisioningNIC.ipv6DnsServers:\n            print \"Will use name server: %s\" % provisioningNIC.ipv6DnsServers[0]\n            profile[\"d-i\", \"netcfg/get_nameservers\"] = (\"string\", str(provisioningNIC.ipv6DnsServers[0]))\n        defaultRoutes = [x for x in netinfo.ipv6Routes if x.nic == provisioningNIC]\n        if provisioningNIC.ipv4Networks:\n            print \"Found IPv6-based service OS, ignoring IPv4 network personalization\"\n    else:\n        if provisioningNIC.ipv4Networks:\n            print \"Configuring IPv4 network: %s\" % provisioningNIC.ipv4Networks[0]\n            config_static(provisioningNIC.ipv4Networks[0])\n        elif provisioningNIC.dhcpv4:\n            print \"Configuring boot protocol to: dhcp\"\n        else:\n            print \"Can not complete network personalization. \" \\\n                  \"DHCP is turned off for IPv4 and there is no static address defined\"\n            sys.exit(38)\n        if provisioningNIC.ipv4DnsServers:\n            print \"Will use name server: %s\" % provisioningNIC.ipv4DnsServers[0]\n            profile[\"d-i\", \"netcfg/get_nameservers\"] = (\"string\", str(provisioningNIC.ipv4DnsServers[0]))\n        defaultRoutes = [x for x in netinfo.ipv4Routes if x.nic == provisioningNIC]\n        if provisioningNIC.ipv6Networks:\n            print \"Found IPv4-based service OS, ignoring IPv6 network personalization\"\n\n    if defaultRoutes:\n        profile[\"d-i\", \"netcfg/get_gateway\"] = (\"string\", str(defaultRoutes[0].gateway))\n    else:\n        # need to add a blank gateway to avoid stopping the installer\n        profile[\"d-i\", \"netcfg/get_gateway\"] = (\"string\", \"\")\n\n    if netinfo.hostname:\n        print \"Configuring hostname to: %s.\" % netinfo.hostname\n        profile[\"d-i\", \"netcfg/get_hostname\"] = (\"string\", netinfo.hostname)\n    if netinfo.domainName:\n        print \"Configuring domain name to: %s.\" % netinfo.domainName\n        profile[\"d-i\", \"netcfg/get_domain\"] = (\"string\", netinfo.domainName)\n\n\n@HandleShowErrorMessage(\"Inject Preseed Personalization Settings\", LOG)\ndef main():\n    \"\"\" Script main entry \"\"\"\n    try:\n        targetServer = ThisTargetServer()\n        options = getOptions()\n\n        if not HPSA_NETCONFIG and options.require_netconfig:\n            print \"Network configuration (hpsa_netconfig) for this server was not found, even though \"\n            print \"it is required by the value true of the CA require_netconfig. \"\n            print \"Check the hpsa_netconfig custom attribute and verify the target server \"\n            print \"has been configured for static networking.\"\n            return 1\n\n        netconfigParser = SmartNetconfig.readwrite(\n            StringIO(HPSA_NETCONFIG),\n            activeMacAddress=targetServer.getMACAddress(),\n            ipv6default=targetServer.isIPv6Managed(),\n            log=LOG\n        )\n        netinfo = netconfigParser.info()\n        if netinfo.oldSyntax and not options.disableWarning:\n            newFormat = netconfigParser.format()\n            print OLD_SYNTAX_WARNING + \"\\n%s\" % str(newFormat)\n\n        typosList = netconfigParser.getTyposList()\n        if typosList:\n            print(\"The following keys were not recognized in the netconfig CA and could be typos: %s\" % typosList)\n\n        validation.validateProvisioningNIC(netinfo.getProvisioningNIC(), targetServer)\n        psObj = Preseed(open(targetServer.pathToOGFS(PS_PATH)))\n        setNetworkSettings(psObj, netinfo, targetServer.isIPv6Managed())\n        writePsFile(targetServer.pathToOGFS(PS_PATH), psObj)\n        LOG.debug(\"The preseed after injecting personalization: \\n %s\", str(psObj))\n    except (OSError, IOError), why:\n        print \"Failed to inject personalization settings:\\n%s\" % why\n        return EC_EXCEPTION\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n",
            "description": "Injects the following settings for personalization into a preseed installation profile:\n- Network settings using passed with the hpsa_netconfig custom attribute.\n\nUsage: inject_ps_personalization_settings.py [options]\n\nOptions:\n  -h, --help            show this help message and exit\n  --require-netconfig=['true', 'false']\n                        Specify whether a network configuration is mandatory or not. Defaults to 'false'.\n  --disableWarning\n                        Do not show warnings of old hpsa_netconfig format\n\nPrerequisites:\n- Target server runs a maintenance Linux OS.\n- A preseed configuration file has to be provided in order to inject the static network configuration.",
            "status": null,
            "name": "Inject Preseed Personalization Settings",
            "state": null,
            "eTag": "2015-06-13T04:49:11.000Z",
            "modified": "2015-06-13T04:49:11.000Z",
            "created": "2015-06-13T04:49:11.000Z",
            "category": "os-deployment-ogfs-scripts",
            "uri": "/rest/os-deployment-ogfs-scripts/1070001"
        },
        {
            "codeType": "OGFS",
            "displayCodeType": "OGFS",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "1",
                    "createdBy": "opsware",
                    "createdDate": "2015-06-13T04:49:12.000Z",
                    "usage": "Waits for the ESXi installer to complete\n\nusage: wait_for_esxi.py [options]\n\noptions:\n  -h, --help            show this help message and exit\n  --atLeast=MINUTES     the number of minutes to wait before actively checking\n                        for the agent; default value: 1 minute(s)\n  --atMost=MINUTES      the maximum number of minutes to wait for the agent to\n                        come back online; default value: 20 minute(s)",
                    "current": false
                },
                {
                    "versionLabel": "2",
                    "createdBy": "opsware",
                    "createdDate": "2015-08-04T07:29:57.000Z",
                    "usage": "Waits for the ESXi installer to complete\n\nusage: wait_for_esxi.py [options]\n\noptions:\n  -h, --help            show this help message and exit\n  --atLeast=MINUTES     the number of minutes to wait before actively checking\n                        for the agent; default value: 1 minute(s)\n  --atMost=MINUTES      the maximum number of minutes to wait for the agent to\n                        come back online; default value: 20 minute(s)",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-08-04T07:29:57.000Z",
            "version": {
                "versionLabel": "2",
                "createdBy": "opsware",
                "createdDate": "2015-08-04T07:29:57.000Z",
                "usage": "Waits for the ESXi installer to complete\n\nusage: wait_for_esxi.py [options]\n\noptions:\n  -h, --help            show this help message and exit\n  --atLeast=MINUTES     the number of minutes to wait before actively checking\n                        for the agent; default value: 1 minute(s)\n  --atMost=MINUTES      the maximum number of minutes to wait for the agent to\n                        come back online; default value: 20 minute(s)",
                "current": true
            },
            "source": "#!/usr/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# lint_ignore=E501,I0011,C0301\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n\"\"\"\n    (C) Copyright 2013-2015 Hewlett-Packard Development Company, L.P.\n\n    Detects when the ESXi installation is complete.\n\"\"\"\n\nimport sys\nimport time\nfrom optparse import OptionParser\nfrom cStringIO import StringIO\n\nfrom osprov.osbp import ThisTargetServer, logger\nfrom osprov.errors import InvalidArgumentsError\n\nfrom osprov.parsers.netconfig import SmartNetconfig\nfrom osprov.util.twist import ServerServiceInt\nfrom osprov.server.sa import Lifecycle\nfrom osprov.decorators import HandleShowErrorMessage\nfrom osprov import constants\n\nfrom pytwist.com.opsware.common import ServerConnectionFailedException\nfrom pytwist.com.opsware.custattr import NoSuchFieldException, CustomAttribute\n\nLOG = logger.getIt(\"wait_for_esxi\")\n\nEC_NOT_ONLINE = 10\nIP_REPORT_CA = CustomAttribute.OPSWARE_PRIVATE_KEY_PREFIX + constants.IP_REPORT_CA\n\n\nclass CustomParser(OptionParser):\n\n    \"\"\" a custom parser \"\"\"\n\n    def __init__(self, *args, **kwargs):\n        OptionParser.__init__(self, *args, **kwargs)\n        self.add_option(\"--atLeast\",\n                        default=5, type=\"int\", metavar=\"MINUTES\",\n                        help=\"the number of minutes to wait before actively checking \\\n                    for the agent; default value: %default minute(s)\")\n        self.add_option(\"--atMost\",\n                        default=30, type=\"int\", metavar=\"MINUTES\",\n                        help=\"the maximum number of minutes to wait for the agent to \\\n                    come back online; default value: %default minute(s)\")\n\n\ndef validate_wait_time(wait):\n    \"\"\" Validate wait time \"\"\"\n    # just greater than one\n    # this could be a type and specialized optparser check\n    if wait < 1:\n        raise InvalidArgumentsError(\" %d cannot be less than 1 (minute).\" % wait)\n\n\ndef validate_args(options):\n    \"\"\" Validate incoming arguments \"\"\"\n    try:\n        validate_wait_time(options.atLeast)\n    except InvalidArgumentsError, why:\n        raise InvalidArgumentsError(\"atLeast \" + str(why))\n\n    try:\n        validate_wait_time(options.atMost)\n    except InvalidArgumentsError, why:\n        raise InvalidArgumentsError(\"atMost \" + str(why))\n\n    if options.atLeast > options.atMost:\n        raise InvalidArgumentsError(\"atLeast cannot be greater than atMost\")\n\n\ndef getIpAddresses(targetServer, isIPv6Managed):\n    \"\"\" Get the ESXi installer IP addresses as strings. \"\"\"\n    # Consider the static information to always be more accurate\n    parser = SmartNetconfig.readonly(\n        StringIO(\"\"\"@hpsa_netconfig@\"\"\"),\n        activeMacAddress=targetServer.getMACAddress(),\n        ipv6default=isIPv6Managed,\n        log=LOG\n    )\n    provisioningNics = [x for x in parser.info().nics if x.provisioning]\n    if (provisioningNics and provisioningNics[0] and\n       (provisioningNics[0].ipv4Networks or provisioningNics[0].ipv6Networks)):\n            return [str(ipNetwork.ip) for ipNetwork in\n                    (provisioningNics[0].ipv6Networks if isIPv6Managed else provisioningNics[0].ipv4Networks)]\n    else:\n        LOG.info(\"No hpsa_netconfig custom attr. Looking for the SA reported IP address.\")\n    try:\n        reportedIpAddresses = targetServer.twistServer.server.ServerService.getCustAttr(\n            targetServer.serverRef, IP_REPORT_CA, True)\n        reportedIpAddresses = [ip.strip() for ip in reportedIpAddresses.split(\",\")]\n        return reportedIpAddresses\n    except NoSuchFieldException:\n        LOG.info(\"'%s' CA not reported yet.\", IP_REPORT_CA)\n    return []\n\n\n@HandleShowErrorMessage(\"wait for ESXi\", LOG)\ndef main():\n    \"\"\" Main entry point \"\"\"\n    LOG.debug(\"Starting to wait for the ESXi installer\")\n    args_parser = CustomParser()\n    options, remaining_args = args_parser.parse_args(sys.argv[1:])\n    del remaining_args\n    try:\n        validate_args(options)\n    except InvalidArgumentsError, why:\n        args_parser.error(why)\n\n    minWait = options.atLeast * 60\n    maxWait = time.time() + (options.atMost * 60)\n    time.sleep(minWait)\n\n    targetServer = ThisTargetServer()\n    error = None\n\n    ipAddresses = []\n    ipAddress = None\n    while True:\n        if ipAddresses:\n            for ipAddress in ipAddresses:\n                LOG.info(\"Trying to connect to %s:%s\", ipAddress, 443)\n                try:\n                    ServerServiceInt(targetServer.twistServer, log=LOG)\\\n                        .checkServerListeningSSL(targetServer.serverRef, ipAddress, 443)\n                    error = None\n                    break\n                except ServerConnectionFailedException, why:\n                    LOG.exception(why)\n                    error = \"Cannot connect to %s on port %s. The ESXi installer probably failed.\" % (\n                        ipAddress, 443)\n            if not error:\n                print \"Successfully connected to %s on port %s\" % (ipAddress, 443)\n                break\n        else:\n            LOG.info(\"No IP address reported yet, waiting some more...\")\n            error = \"The IP address was not reported. The ESXi installer probably failed.\"\n        if time.time() > maxWait:\n            LOG.error(\"Timeout reached\")\n            break\n        LOG.debug(\"Going to sleep. Last error: %s\", error)\n        time.sleep(10)\n        ipAddresses = getIpAddresses(targetServer, targetServer.isIPv6Managed())\n\n    serverVO = targetServer.getServerVO(targetServer.serverRef)\n\n    if error:\n        serverVO.setOsVersion(\"unknown\")\n        targetServer.updateVO(serverVO)\n        # Print the last error\n        print error\n        return 2\n    elif ipAddress:\n        # Set server's os version and lifecycle\n        serverVO.setOsVersion(\"VMware ESXi\")\n        serverVO.agentVersion = None\n        targetServer.updateVO(serverVO)\n        targetServer.updateState(lifecycle=Lifecycle.UNMANAGED)\n        targetServer.writeCustomAttribute(IP_REPORT_CA, str(ipAddress))\n        print \"The ESXi installer finished successfully\"\n\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n",
            "description": "Waits for the ESXi installer to complete\n\nusage: wait_for_esxi.py [options]\n\noptions:\n  -h, --help            show this help message and exit\n  --atLeast=MINUTES     the number of minutes to wait before actively checking\n                        for the agent; default value: 1 minute(s)\n  --atMost=MINUTES      the maximum number of minutes to wait for the agent to\n                        come back online; default value: 20 minute(s)",
            "status": null,
            "name": "Wait for ESXi installation",
            "state": null,
            "eTag": "2015-08-04T07:29:57.000Z",
            "modified": "2015-08-04T07:29:57.000Z",
            "created": "2015-06-13T04:49:12.000Z",
            "category": "os-deployment-ogfs-scripts",
            "uri": "/rest/os-deployment-ogfs-scripts/1080001"
        },
        {
            "codeType": "OGFS",
            "displayCodeType": "OGFS",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "1",
                    "createdBy": "opsware",
                    "createdDate": "2015-06-13T04:49:13.000Z",
                    "usage": "Usage: Prints iLO configuration infomation using hponcfg utility.\n\nOptions:\n  -h, --help          Show this help message and exit\n  --print=mgmtIP      Prints iLo management IP address\n  --print=config      Prints iLo management configuration information\n  --print=mgmtPortIP  Prints iLo management port\n\nPrerequisites:\n  - Script needs to be run as part of a build plan.\n  - Target server runs a maintenance Linux or Windows PE OS for the hponcfg utility to be available.",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-06-13T04:49:13.000Z",
            "version": {
                "versionLabel": "1",
                "createdBy": "opsware",
                "createdDate": "2015-06-13T04:49:13.000Z",
                "usage": "Usage: Prints iLO configuration infomation using hponcfg utility.\n\nOptions:\n  -h, --help          Show this help message and exit\n  --print=mgmtIP      Prints iLo management IP address\n  --print=config      Prints iLo management configuration information\n  --print=mgmtPortIP  Prints iLo management port\n\nPrerequisites:\n  - Script needs to be run as part of a build plan.\n  - Target server runs a maintenance Linux or Windows PE OS for the hponcfg utility to be available.",
                "current": true
            },
            "source": "#!/usr/bin/python\n\"\"\"\n    (C) Copyright 2012-2015 Hewlett-Packard Development Company, L.P.\n\"\"\"\n\nimport sys\n\nsys.path.append(\"/opsw/apx/runtime/script/osprov.run_os_build_plan_papx/\")\nsys.path.append(\"/opt/opsware/pylibs2/\")\n\nfrom osprov import ipaddr\nfrom osprov.osbp import logger, ThisTargetServer\nfrom osprov.errors import ShowErrorMessage\nfrom osprov.optparse_ext import OptionParser\nfrom osprov.wrappers.hponcfg import HpOnCfg, GetConfigOperation\nfrom osprov.decorators import HandleShowErrorMessage\n\n\nlog = logger.getIt(\"Print iLO Configuration\")\n\n\nclass PrintILOConfigOptionParser(OptionParser):\n\n    def __init__(self, *args, **kwargs):\n        OptionParser.__init__(self, *args, **kwargs)\n        self.usage = \"Prints iLo configuration information.\"\n\n    def defineOptions(self):\n        self.add_option(\"--print\",\n                        default=\"config\",\n                        choices=[\"mgmtIP\", \"mgmtPortIP\", \"config\"],\n                        action=\"store\", dest=\"print_option\",\n                        help=\"Prints iLO configuration information. \"\n                             \"Possible values: mgmtIP, mgmtPortIP or config\\n\"\n                             \"mgmtIP      print all management IPs of the iLO\\n\"\n                             \"mgmtPortIP  print port and all management IPs of the iLO\\n\"\n                             \"config      print iLo configuration\\n\"\n                        )\n\n\ndef getPreferredILOAddresses(iloIPs, targetServer):\n    if len(iloIPs):\n        if targetServer.isIPv6Managed():\n            iloIPs = sorted(iloIPs, key=lambda x: isinstance(x, ipaddr.IPv4Address))\n        else:\n            iloIPs = sorted(iloIPs, key=lambda x: isinstance(x, ipaddr.IPv6Address))\n        return \" \".join([str(x) for x in iloIPs])\n    else:\n        raise ShowErrorMessage(\"Cannot determine any iLO IP addresses\")\n\n\ndef getPreferredILOPort(port):\n    if not port:\n        port = 443\n        log.warn(\"Cannot determine port, defaulting to 443\")\n    return port\n\n\n@HandleShowErrorMessage(\"Print iLO Configuration\", log)\ndef main():\n    targetServer = ThisTargetServer()\n    parser = PrintILOConfigOptionParser()\n    options, remaining_args = parser.parse_args()\n    del remaining_args\n\n    hpOnCfg = HpOnCfg(targetServer, log=log)\n    if options.print_option == \"mgmtIP\":\n        print getPreferredILOAddresses(hpOnCfg.getIloAddresses(), targetServer)\n    elif options.print_option == \"mgmtPortIP\":\n        print \"%s %s\" % (getPreferredILOPort(hpOnCfg.getIloPort()), getPreferredILOAddresses(hpOnCfg.getIloAddresses(), targetServer))\n    else:\n        operation = GetConfigOperation(hpOnCfg)\n        result = operation.run()\n        print result\n\n    return 0\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n",
            "description": "Usage: Prints iLO configuration infomation using hponcfg utility.\n\nOptions:\n  -h, --help          Show this help message and exit\n  --print=mgmtIP      Prints iLo management IP address\n  --print=config      Prints iLo management configuration information\n  --print=mgmtPortIP  Prints iLo management port\n\nPrerequisites:\n  - Script needs to be run as part of a build plan.\n  - Target server runs a maintenance Linux or Windows PE OS for the hponcfg utility to be available.",
            "status": null,
            "name": "Print iLO Configuration",
            "state": null,
            "eTag": "2015-06-13T04:49:13.000Z",
            "modified": "2015-06-13T04:49:13.000Z",
            "created": "2015-06-13T04:49:12.000Z",
            "category": "os-deployment-ogfs-scripts",
            "uri": "/rest/os-deployment-ogfs-scripts/1100001"
        },
        {
            "codeType": "OGFS",
            "displayCodeType": "OGFS",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "1",
                    "createdBy": "opsware",
                    "createdDate": "2015-06-13T04:49:13.000Z",
                    "usage": "\nExecutes the sysprep process on the Windows machine. The VM is rebooted several times for the\noperation to complete.\n\nThis operation requires that the target Virtual Machine is in MAINTENANCE mode.\n\nThe following steps are then executed:\n * An agent startup script containing the \"sysprep /oobe /shutdown\" command is deployed\n * Power off the VM\n * Disconnect NICs (to disable communication with the SA core until sysprep process is complete)\n * Power on the VM (agent script containing the sysprep command will be executed)\n * Wait for the VM to shut down (signaling that the sysprep operation is complete)\n * Power on the VM (so that the Windows Machine is reconfigured from the unattend.xml file)",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-06-13T04:49:13.000Z",
            "version": {
                "versionLabel": "1",
                "createdBy": "opsware",
                "createdDate": "2015-06-13T04:49:13.000Z",
                "usage": "\nExecutes the sysprep process on the Windows machine. The VM is rebooted several times for the\noperation to complete.\n\nThis operation requires that the target Virtual Machine is in MAINTENANCE mode.\n\nThe following steps are then executed:\n * An agent startup script containing the \"sysprep /oobe /shutdown\" command is deployed\n * Power off the VM\n * Disconnect NICs (to disable communication with the SA core until sysprep process is complete)\n * Power on the VM (agent script containing the sysprep command will be executed)\n * Wait for the VM to shut down (signaling that the sysprep operation is complete)\n * Power on the VM (so that the Windows Machine is reconfigured from the unattend.xml file)",
                "current": true
            },
            "source": "#!/usr/bin/python\n\"\"\"\n    (C) Copyright 2014-2015 Hewlett-Packard Development Company, L.P.\n\"\"\"\nimport sys\nimport datetime\n\nfrom osprov import helpers\nfrom osprov.decorators import HandleShowErrorMessage\nfrom osprov.errors import ShowErrorMessage\nfrom osprov.osbp import logger, ThisTargetServer\nfrom osprov.util.twist import InternalService\nfrom osprov.v12n import guest_customization\n\nfrom pytwist.com.opsware.search import Filter\n\n\nLOG = logger.getIt(\"Execute Sysprep (Windows)\")\n\n\nclass V12nVirtualServerServiceInt(InternalService):\n    _path = 'com/opsware/v12n/internal/V12nVirtualServerServiceInt'\n\n\n@HandleShowErrorMessage(\"Execute Sysprep (Windows)\", LOG)\ndef main():\n    target_server = ThisTargetServer()\n\n    ts = target_server.twistServer\n    server_ref = target_server.getServerRef()\n\n    v12n_server_ref = get_v12n_server_ref(ts, server_ref)\n\n    osbp_job_vo = get_current_osbp_job_vo(ts, server_ref)\n    timeout_in_seconds = compute_remaining_timeout_in_seconds(osbp_job_vo)\n\n    print \"Do cleanup of registry network settings\"\n    registry_cleanup_of_network_settings(target_server)\n\n    print \"Injecting sysprep script\"\n    inject_sysprep_command_as_agent_startup_script(target_server)\n\n    print \"Rebooting machine to complete the sysprep process\"\n    reboot_server_and_complete_sysprep(ts, v12n_server_ref, timeout_in_seconds)\n\n    print \"Sysprep process completed\"\n\n\ndef registry_cleanup_of_network_settings(target_server):\n    system_drive = helpers.getSystemDrive(\"@SystemDrive:C@\")\n    runner = target_server.rosh()\n    # loads the registry hive from cloned machine\n    runner.runIt(\"reg.exe LOAD HKLM\\\\CLONE {SystemDrive}:\\\\Windows\\\\System32\\\\config\\\\SYSTEM\".format(SystemDrive=system_drive), checkExitCode=(0, 1))\n    # following keys are used to store the IPv6 IP addresses (10) and gateway info (16)\n    runner.runIt(\"reg.exe DELETE HKLM\\\\CLONE\\\\ControlSet001\\\\Control\\\\nsi\\\\{eb004a01-9b1a-11d4-9123-0050047759bc}\\\\10 /f\", checkExitCode=(0, 1))\n    runner.runIt(\"reg.exe DELETE HKLM\\\\CLONE\\\\ControlSet001\\\\Control\\\\nsi\\\\{eb004a01-9b1a-11d4-9123-0050047759bc}\\\\16 /f\", checkExitCode=(0, 1))\n    runner.runIt(\"reg.exe DELETE HKLM\\\\CLONE\\\\ControlSet002\\\\Control\\\\nsi\\\\{eb004a01-9b1a-11d4-9123-0050047759bc}\\\\10 /f\", checkExitCode=(0, 1))\n    runner.runIt(\"reg.exe DELETE HKLM\\\\CLONE\\\\ControlSet002\\\\Control\\\\nsi\\\\{eb004a01-9b1a-11d4-9123-0050047759bc}\\\\16 /f\", checkExitCode=(0, 1))\n    runner.runIt(\"reg.exe UNLOAD HKLM\\\\CLONE\", checkExitCode=(0, 1))\n\ndef inject_sysprep_command_as_agent_startup_script(target_server):\n    script_lines = []\n    system_drive = helpers.getSystemDrive(\"@SystemDrive:C@\")\n\n    # Runs sysprep on unattend.xml provided in previous build step.\n    # This sysprep will handle all aspects of guest customization.\n    # Note that as no unattend path is mentioned, the default path is used.\n    # The sysprep will ultimately shutdown the VM as a signal that guest\n    # customization completed successfully.\n\n    # replace placeholder in template with system drive\n    script_lines.append(\n        \"exit_code = os.system( '%s:/Windows/system32/sysprep/sysprep.exe /generalize /oobe /shutdown' )\" % system_drive)\n\n    LOG.debug(\"Injecting sysprep command as an agent startup script\")\n    guest_customization.inject_guest_customization_script(target_server, script_lines)\n    LOG.debug(\"Injection of the sysprep command completed\")\n\n\n\ndef reboot_server_and_complete_sysprep(ts, v12n_server_ref, timeout_in_seconds):\n    service = V12nVirtualServerServiceInt(ts, log=LOG)\n    service.rebootVirtualServerAndCompleteSysprep(v12n_server_ref, timeout_in_seconds)\n\n\ndef get_v12n_server_ref(ts, server_ref):\n    filter = Filter()\n    filter.expression = 'device_id = %s' % server_ref.getId()\n\n    v12n_server_refs = ts.v12n.V12nVirtualServerService.findV12nVirtualServerRefs(filter)\n    if len(v12n_server_refs) != 1:\n        raise ShowErrorMessage(\"Cannot find the Virtual Machine identifier for the server %s. Result was: %s\" % (server_ref, v12n_server_refs))\n\n    return v12n_server_refs[0]\n\n\ndef compute_remaining_timeout_in_seconds(osbp_job_vo):\n\n    overall = extract_timeout_in_seconds(osbp_job_vo, 14400)\n    elapsed = compute_elapsed_time_in_seconds(osbp_job_vo)\n\n    remaining = overall - elapsed\n    if remaining <= 0:\n        raise ShowErrorMessage(\"Sysprep was not started. Timeout exceeded.\\nOverall timeout(s): %s. Elapsed(s): %s\" % (overall, elapsed))\n\n    return remaining\n\n\ndef extract_timeout_in_seconds(job_vo, default_value):\n    return job_vo.args.timeOut or default_value\n\n\ndef compute_elapsed_time_in_seconds(job_vo):\n    now = datetime.datetime.now()\n    elapsed_time = now - datetime.datetime.fromtimestamp(job_vo.startDate)\n    return int(elapsed_time.total_seconds())\n\n\ndef get_current_osbp_job_vo(ts, server_ref):\n    filter = Filter()\n    filter.expression = '(job_device_id = %s) & (job_type = \"os_build_plan.execute\") & (job_status = \"ACTIVE\")' % server_ref.id\n\n    job_refs = ts.job.JobService.findJobRefs(filter)\n    if len(job_refs) != 1:\n        raise ShowErrorMessage(\"Failed to uniquely identify the current OSBP job. Make sure no other OSBP job is executed \"\n                               \"against the server: %s. The following job refs were found: %s\" % (server_ref, job_refs))\n\n    job_ref = job_refs[0]\n    return ts.job.JobService.getJobInfoVO(job_ref)\n\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n\n",
            "description": "\nExecutes the sysprep process on the Windows machine. The VM is rebooted several times for the\noperation to complete.\n\nThis operation requires that the target Virtual Machine is in MAINTENANCE mode.\n\nThe following steps are then executed:\n * An agent startup script containing the \"sysprep /oobe /shutdown\" command is deployed\n * Power off the VM\n * Disconnect NICs (to disable communication with the SA core until sysprep process is complete)\n * Power on the VM (agent script containing the sysprep command will be executed)\n * Wait for the VM to shut down (signaling that the sysprep operation is complete)\n * Power on the VM (so that the Windows Machine is reconfigured from the unattend.xml file)",
            "status": null,
            "name": "Execute Sysprep (Windows)",
            "state": null,
            "eTag": "2015-06-13T04:49:13.000Z",
            "modified": "2015-06-13T04:49:13.000Z",
            "created": "2015-06-13T04:49:13.000Z",
            "category": "os-deployment-ogfs-scripts",
            "uri": "/rest/os-deployment-ogfs-scripts/1110001"
        },
        {
            "codeType": "OGFS",
            "displayCodeType": "OGFS",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "1",
                    "createdBy": "opsware",
                    "createdDate": "2015-06-13T04:49:14.000Z",
                    "usage": "Integrates the HP SA agent. The agent will install and register at the first OS\nboot. No parameters are necessary.\n\nPrerequisites:\n- Target server runs a Suse, RHEL, Ubuntu or Solaris 10 OS installer.\n- The install is complete.\n- The installed system is mounted on /mnt for Suse, /mnt/sysimage for RHEL, /target for Ubuntu and /a for Solaris 10.",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-06-13T04:49:14.000Z",
            "version": {
                "versionLabel": "1",
                "createdBy": "opsware",
                "createdDate": "2015-06-13T04:49:14.000Z",
                "usage": "Integrates the HP SA agent. The agent will install and register at the first OS\nboot. No parameters are necessary.\n\nPrerequisites:\n- Target server runs a Suse, RHEL, Ubuntu or Solaris 10 OS installer.\n- The install is complete.\n- The installed system is mounted on /mnt for Suse, /mnt/sysimage for RHEL, /target for Ubuntu and /a for Solaris 10.",
                "current": true
            },
            "source": "#!/usr/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n\"\"\"\n    (C) Copyright 2014-2015 Hewlett-Packard Development Company, L.P.\n\n    Integrate The HP SA agent into the final OS.\n\"\"\"\n\nimport os\nimport sys\nimport random\n\nfrom osprov import helpers\nfrom osprov.errors import InvalidArgumentsError\nfrom osprov.networking.utils import isIPv6Address\nfrom osprov.osbp import logger\nfrom osprov.osbp import ThisTargetServer\nfrom osprov.platform_util import isRHELCompatible, isSLES\nfrom osprov.util import process\nfrom osprov.decorators import HandleShowErrorMessage\n\nfrom librunplan import PlanRunner\nfrom librunplan import PlanOutputHandler\n\nfrom pytwist.com.opsware.osprov import RunScriptPlanStep\n\nLOG = logger.getIt(\"integrate_hpsa_agent\")\n\n\ndef rootPartition(platform):\n    \"\"\" Get the root partition  \"\"\"\n    if \"suse\" in platform.lower():\n        # for suse AutoYast\n        return \"mnt\"\n    elif \"ubuntu\" in platform.lower():\n        # for ubuntu\n        return \"target\"\n    elif \"5.10-X86\" in platform:\n        # for solaris 10\n        return \"a\"\n    else:\n        # for RHEL kickstart\n        return \"mnt/sysimage\"\n\n\ndef copyMidAndCrypto(root):\n    \"\"\" Copy the mid and crypto to the root partition \"\"\"\n    midDir = \"etc/opt/opsware/agent\"\n    cryptoDir = \"var/opt/opsware/crypto/\"\n    # ensure directories\n    for directory in [midDir, cryptoDir]:\n        process.runIt(\"rosh -l root mkdir -p  /%s\" %\n                     (os.path.join(root, directory)),\n                      quiet=True, quieterr=True, log=LOG)\n    # copy the crypto\n    src = \"/\" + os.path.join(cryptoDir, \"agent\")\n    dst = \"/\" + os.path.join(root, cryptoDir)\n    process.runIt(\"rosh -l root cp  -R '%s' '%s'\" % (src, dst),\n                  quiet=True, quieterr=True, log=LOG)\n    # copy mid\n    src = \"/\" + os.path.join(midDir, \"mid\")\n    dst = \"/\" + os.path.join(root, midDir)\n    process.runIt(\"rosh -l root cp  '%s' '%s'\" % (src, dst),\n                  quiet=True, quieterr=True, log=LOG)\n    return open(os.path.join(midDir, \"mid\")).read().strip()\n\n\ndef scheduleAgentInstallSystemD(platformName, agentGws):\n    root = rootPartition(platformName)\n    installer = \"/tmp/hpsa_agent_installer\"\n    installer_script = \"tmp/hpsa_agent_installer.sh\"\n\n    with open(os.path.join(root, installer_script), \"w\") as installer_script_file:\n        installer_script_file.write(getAgentInstallScript(installer, agentGws))\n    os.chmod(os.path.join(root, installer_script), 0550)\n\n    serviceName = \"hpsa_agent_installer.service\"\n    serviceFile = os.path.join(root, \"etc/systemd/system/\", serviceName)\n    with open(serviceFile, \"w\") as service:\n        service.write(getSystemdService(installer_script))\n    # enable the service\n    os.symlink(\"../%s\" % serviceName, os.path.join(root, \"etc/systemd/system/multi-user.target.wants/\", serviceName))\n\n\ndef getSystemdService(installer_script):\n    return \"\"\"[Unit]\nDescription=One-time HPSA agent install\nAfter=syslog.target network.target\n\n[Service]\nType=oneshot\nExecStart=/{installer_script} start\nKillMode=none\n\n[Install]\nWantedBy=multi-user.target\n\"\"\".format(installer_script=installer_script)\n\n\ndef scheduleAgentInstall(platformName, agentGws,\n                         initFileName=\"etc/init.d/hpsa_agent_installer\"):\n    \"\"\" Schedules an agent install job to run at boot \"\"\"\n    root = rootPartition(platformName)\n    rc_path = \"etc/rc.d/rc%d.d\"\n    install_path = \"/tmp/hpsa_agent_installer\"\n    if \"5.10-X86\" in platformName or \"ubuntu\" in platformName.lower():\n        rc_path = \"etc/rc%d.d\"\n        install_path = \"/hpsa_agent_installer\"\n\n    with open(os.path.join(root, initFileName), \"w\") as initFile:\n        initFile.write(getAgentInstallScript(install_path, agentGws))\n    os.chmod(os.path.join(root, initFileName), 0550)\n\n    agent = \"S40hpsa_agent_installer\"\n    for level in [2, 3, 5]:\n        if not os.path.exists(os.path.join(root, rc_path % level)):\n            continue\n        rc_link = os.path.join(root, rc_path % level, agent)\n        # just assume that if they are there we already created them in an earlier run\n        if not os.path.islink(rc_link):\n            os.symlink(os.path.join(os.sep, initFileName), rc_link)\n\n\ndef integrateAgentIsDone(root,\n                         flagFileName=\"var/tmp/doneIntegrateAgent\"):\n    \"\"\" For Suse Write the flag file to continue AutoYaST process\"\"\"\n    with open(os.path.join(root, flagFileName), \"w\") as flagFile:\n        flagFile.write(\"Done\")\n\n\ndef getAgentInstallScript(installerName, agentGws):\n    \"\"\" Does the file generation and writing \"\"\"\n    return INIT_FILE_TEMPLATE.format(\n        scriptName=\"hpsa_agent_installer\",\n        logFile=\"/var/log/opsware/agent/install.log\",\n        installerName=installerName,\n        agentgws=\" \".join([\"%s:%s\" % (ip, port) for ip, port in agentGws]),\n        agentgws_formatted=\",\".join([(\"[%s]:%s\" if isIPv6Address(ip) else \"%s:%s\") % (ip, port) for ip, port in agentGws])\n    )\n\n\ndef downloadAgent(target, root):\n    \"\"\" Download the agent using the deploy step  \"\"\"\n    destDir = os.path.join(root, \"tmp\")\n    if not os.path.exists(destDir):\n        os.makedirs(destDir)\n    destFile = os.path.join(destDir, \"hpsa_agent_installer\")\n    args = \"-n opsware-agent -d %s \" % destFile\n    runnerOH = PlanOutputHandler(sys.stdout, sys.stderr, LOG)\n    runnerOH.NO_APX_PROGRESS = True  # don't break the papx reporting\n    runnerOH.ADV_STEP_MSG = None  # don't update the main message\n    runnerOH.ADV_STEP_MSG_LONG = \"\\nSub Step: %(action)s '%(name)s'\"\n    runnerOH.ERR_HEADER = \"\\nErrors from sub step %(current)d '%(name)s':\\n\"\n    runner = PlanRunner(None, targetServer=target, outputHandler=runnerOH)\n    scriptPath = \"Deploy Agent\"\n    scriptElems = [x for x in scriptPath.split(\"/\") if x]\n    stepRef = target.twistServer.folder.FolderService.getFNode(\n        [\"Opsware\", \"Tools\", \"OS Provisioning\", \"OS Build Plan Steps\"] +\n        scriptElems)\n    step = RunScriptPlanStep()\n    step.setScript(stepRef)\n    step.setParameters(args)\n    runner.doStep(step, stepNo=int(os.environ[\"CURRENT_STEP_NO\"]))\n    return destFile\n\n\ndef getAgentInstallerPath(root):\n    \"\"\" Return an existing agent installer \"\"\"\n    for installer in [\"tmp/hpsa_agent_installer\", \"hpsa_agent_installer\"]:\n        installerPath = os.path.join(root, installer)\n        if os.path.isfile(installerPath):\n            LOG.debug(\"Found agent installer at: \" + installerPath)\n            return installerPath\n    return None\n\n\ndef chooseAgentGateways(agentGws, ipv6Managed):\n    \"\"\" Choose two random gateways, but take stack into account \"\"\"\n    if not agentGws:\n        raise InvalidArgumentsError(\"No agent gateways\")\n    LOG.debug(\"Available agent gateways: %s\" % agentGws)\n\n    ipv6Gws = []\n    ipv4Gws = []\n    for agentGwIP, agentGwPort in agentGws:\n        if isIPv6Address(agentGwIP):\n            ipv6Gws.append((agentGwIP, agentGwPort))\n        else:\n            ipv4Gws.append((agentGwIP, agentGwPort))\n\n    result = []\n    if ipv6Gws:\n        result.append(random.choice(ipv6Gws))\n    if ipv4Gws:\n        result.append(random.choice(ipv4Gws))\n    if not ipv6Managed:\n        result.reverse()\n    return result\n\n\n@HandleShowErrorMessage(\"integrate the HP SA agent\", LOG)\ndef main():\n    if len(sys.argv) > 1:\n        print \"Arguments are no longer required and will be ignored\"\n    try:\n        targetServer = ThisTargetServer()\n        targetServer.setWorkDir(targetServer.getRemoteRoot())\n        keys = helpers.getDataStore(targetServer)\n\n        platform = keys.platform.full_name\n        if not platform:\n            platform = targetServer.getServerVO(cached=False).getOsVersion()\n        print (\"Integrating the HP SA agent for \" + platform)\n\n        root = rootPartition(platform)\n\n        # newer OS build plans have a \"Deploy Agent\" step\n        # this is for backwards compatibility\n        if not getAgentInstallerPath(root):\n            downloadAgent(targetServer, root)\n\n        copyMidAndCrypto(root)\n        agentGws = chooseAgentGateways(targetServer.getAgentGWs(stackAware=False), targetServer.isIPv6Managed(()))\n        print \"Using agent gateway(s): %s\" % agentGws\n        if isRHELCompatible(platform, 7) or isSLES(platform, 12):\n            scheduleAgentInstallSystemD(platform, agentGws)\n        else:\n            scheduleAgentInstall(platform, agentGws)\n        print \"Successfully integrated the HP SA agent.\"\n        print \"The agent will be installed on the first OS boot.\"\n\n        if \"suse\" in platform.lower():\n            integrateAgentIsDone(root)\n    except (IOError, OSError), why:\n        LOG.exception(why)\n        sys.stderr.write(\"%s\\n\" % why)\n        sys.stdout.write(\"Failed to integrate HP SA Agent.\\n\")\n        return 1\n\n\nINIT_FILE_TEMPLATE = \"\"\"#!/bin/sh\n#\n# /etc/init.d/%(scriptName)s\n#\n#\n### BEGIN INIT INFO\n# Provides:          hpsa_agent_installer\n# Required-Start:    $syslog $remote_fs $network $local_fs\n# Should-Start:      $time $portmap\n# Required-Stop:     $syslog $remote_fs\n# Should-Stop:       $time $portmap\n# Default-Start:     3 5\n# Default-Stop:      0 1 2 6\n# Short-Description: HP SA Installer script.\n# Description: Just to install the HP SA Agent on first boot\n#\n# X-UnitedLinux-Default-Enabled: yes\n### END INIT INFO\nHPSA_INSTALL_LOG={logFile}\nmkdir -p ` dirname $HPSA_INSTALL_LOG`\n\necho \"Installing HPSA Agent\"\necho \"Logging in $HPSA_INSTALL_LOG\"\n\n# Redirect messages to the log\nexec >> $HPSA_INSTALL_LOG\nexec 2>> $HPSA_INSTALL_LOG\n\nHPSA_BIN={installerName}\ncase \"$1\" in\n    start)\n        ##  Protect against NFS services that might use the agent port\n        # Observed in newer RHELs ( 5.7 and 6.1 )\n        LOCKEDFILE=\"/etc/init.d/nfslock\"\n        LOCKED_STOPPED=1\n        if [ -f $LOCKEDFILE ] ; then\n            $LOCKEDFILE stop\n            LOCKED_STOPPED=0\n        fi\n        # Make sure it's executable\n        chmod +x $HPSA_BIN\n\n        echo \"Using HPSA agent gateways: {agentgws}\"\n\n        echo \"START NETWORK DIAGNOSTIC INFO\"\n        ifconfig -a\n        netstat -rn\n\n        python -c \"import sys; sys.exit(0)\"\n        if [ $? -eq 0 ]; then\n            for i in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 ; do\n                connected=1\n                for agw in {agentgws}; do\n                    echo \"Trying to connect to $agw\"\n                    echo $agw | python -c \"import sys, socket; ip, port = sys.stdin.readline().rsplit(':',1); s=socket.socket(socket.AF_INET6*int(':' in ip) or socket.AF_INET, socket.SOCK_STREAM); s.settimeout(10); s.connect((ip, int(port)));\"\n                    if [ $? -eq 0 ] ; then echo \"Successfully connected to $agw\"; connected=0; break; fi\n                    sleep $i\n                done\n                if [ $connected -eq 0 ]; then break; fi\n            done\n        else\n            echo \"python not available, skipping network diagnostics\"\n        fi\n\n        echo \"END NETWORK DIAGNOSTIC INFO\"\n\n        # Run the installer\n        $HPSA_BIN -s --settime --force_full_hw_reg --force_sw_reg \\\\\n            --logfile $HPSA_INSTALL_LOG    \\\\\n            --opsw_gw_addr \"{agentgws_formatted}\"\n        RC=$?\n        if [ $LOCKED_STOPPED = 0 ] ; then\n            $LOCKEDFILE start\n        fi\n        if [ $RC -eq 0 ] ; then\n            echo \"Agent Installation successful\"\n            # self destruct\n            rm -f /etc/rc.d/rc*/*hpsa_agent_installer\n            rm -f $0\n            rm -f /etc/init.d/hpsa_agent_installer\n            rm $HPSA_BIN\n            if [ -d \"/etc/systemd/system\" ] || [ -d \"/run/systemd/system\" ] || [ -d \"/usr/lib/systemd/system\" ] || [ -d \"/lib/systemd/system\" ] ; then\n                echo \"Disabling hpsa_agent_installer.service\"\n                rm -f /etc/systemd/system/multi-user.target.wants/hpsa_agent_installer.service\n            fi\n            exit 0\n        else\n            #  The installer also logs here, so no extra message is needed\n            exit 1\n        fi\n        ;;\n    stop)\n        echo Call to \"$1\" not implemented\n        exit 3\n        ;;\n    try-restart)\n        echo Call to \"$1\" not implemented\n        exit 3\n        ;;\n    restart)\n        echo Call to \"$1\" not implemented\n        ;;\n    force-reload)\n        echo Call to \"$1\" not implemented\n        exit 3\n        ;;\n    reload)\n        echo Call to \"$1\" not implemented\n        exit 3\n        ;;\n    status)\n        echo Call to \"$1\" not implemented\n        exit 3\n        ;;\nesac\n\"\"\"\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n",
            "description": "Integrates the HP SA agent. The agent will install and register at the first OS\nboot. No parameters are necessary.\n\nPrerequisites:\n- Target server runs a Suse, RHEL, Ubuntu or Solaris 10 OS installer.\n- The install is complete.\n- The installed system is mounted on /mnt for Suse, /mnt/sysimage for RHEL, /target for Ubuntu and /a for Solaris 10.",
            "status": null,
            "name": "Integrate HP SA Agent for Solaris 10",
            "state": null,
            "eTag": "2015-06-13T04:49:14.000Z",
            "modified": "2015-06-13T04:49:14.000Z",
            "created": "2015-06-13T04:49:14.000Z",
            "category": "os-deployment-ogfs-scripts",
            "uri": "/rest/os-deployment-ogfs-scripts/1130001"
        },
        {
            "codeType": "OGFS",
            "displayCodeType": "OGFS",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "1",
                    "createdBy": "opsware",
                    "createdDate": "2015-06-13T04:49:17.000Z",
                    "usage": "Monitors a given log file every DELAY seconds and timeouts after\nCOUNT checks in which the log has not changed.\n\nIf no log file is given it will monitor the installation log for the supported installers:\n- Red Hat, CentOS and OEL\n- SLES\n- Ubuntu\n- Solaris 10\n- Solaris 11 AI\n\nusage: monitor_install_log.py [options]\n\noptions:\n  -h, --help     show this help message and exit\n  --log=LOG      the log file that will be monitored\n  --count=COUNT  the number of times it counts before timing out\n  --delay=DELAY  the delay in seconds between every log check\n\nPrerequisites:\n  - Script needs to be run as part of a build plan.",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-06-13T04:49:17.000Z",
            "version": {
                "versionLabel": "1",
                "createdBy": "opsware",
                "createdDate": "2015-06-13T04:49:17.000Z",
                "usage": "Monitors a given log file every DELAY seconds and timeouts after\nCOUNT checks in which the log has not changed.\n\nIf no log file is given it will monitor the installation log for the supported installers:\n- Red Hat, CentOS and OEL\n- SLES\n- Ubuntu\n- Solaris 10\n- Solaris 11 AI\n\nusage: monitor_install_log.py [options]\n\noptions:\n  -h, --help     show this help message and exit\n  --log=LOG      the log file that will be monitored\n  --count=COUNT  the number of times it counts before timing out\n  --delay=DELAY  the delay in seconds between every log check\n\nPrerequisites:\n  - Script needs to be run as part of a build plan.",
                "current": true
            },
            "source": "#!/usr/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n#\n\"\"\"\n    (C) Copyright 2014-2015 Hewlett-Packard Development Company, L.P.\n\n    Monitors a given log file every DELAY seconds and timeouts after\n    COUNT checks in which the log has not changed.\n\n    If no log file is given it will monitor the installation log for the supported installers:\n    - Red Hat, CentOS and OEL\n    - SLES\n    - Ubuntu\n    - Solaris 10\n    - Solaris 11 AI\n\"\"\"\n\nimport os\nimport sys\nimport time\nfrom optparse import OptionError\nfrom StringIO import StringIO\n\nfrom librunplan import PlanOutputHandler\n\nfrom osprov import platform_util\nfrom osprov.decorators import HandleShowErrorMessage\nfrom osprov.errors import ShowErrorMessage, TimeoutError, NotSupportedError, ProcessExecutionError\nfrom osprov.optparse_ext import OptionParser\nfrom osprov.osbp import ThisTargetServer, logger\nfrom osprov.osbp.constants import MONITORING_STOP_FLAG\n\n# waits CHECK_DELAY * TIMEOUT_COUNT, 10 minutes by default\n\nCHECK_DELAY = 6  # seconds\nTIMEOUT_COUNT = 100\n\nLOG = logger.getIt(\"Monitor Installation\")\n\n\nclass MonitorStepOptionsParser(OptionParser):\n\n    \"\"\" An options' parser for this step. \"\"\"\n\n    def defineOptions(self):\n        self.add_option(\"--log\", help=\"the log file that will be monitored\")\n        self.add_option(\"--count\", default=TIMEOUT_COUNT, type=int,\n                        help=\"the number of times it counts before timing out\")\n        self.add_option(\"--delay\", default=CHECK_DELAY, type=float,\n                        help=\"the delay in seconds between every log check\")\n\n    def validateArgs(self, opt, args):\n        if opt.count and opt.count < 0:\n            raise OptionError(\"not a positive number\", \"count\")\n        if opt.delay and opt.delay < 0:\n            raise OptionError(\"not a positive number\", \"delay\")\n\n\nclass LogMonitor (object):\n\n    \"\"\" Monitors logs until one of the stop files is encountered or times out. \"\"\"\n\n    def __init__(self, targetServer, logPath, stopFilePaths=(MONITORING_STOP_FLAG,), output=PlanOutputHandler()):\n        self.targetServer = targetServer\n        self.output = output\n        self.logPath = self.targetServer.pathToOGFS(logPath)\n        self.stopFilePaths = [self.targetServer.pathToOGFS(path) for path in stopFilePaths]\n        self.lastLine = None\n        self.checkDelaySeconds = 6\n        self.defaultTimeoutCount = 100\n        self.timeoutCount = self.defaultTimeoutCount\n        self.numberOfReportedLines = 50\n        self._cachedLastLines = []\n        self.installFailedUserMessage = \"\"\n\n    def waitForLogFile(self):\n        \"\"\"Waits self.checkDelay * self.timeoutCount for self.logPath to appear.\"\"\"\n        failedCheckCount = 0\n        while failedCheckCount < self.timeoutCount:\n            if os.path.exists(self.logPath):\n                return\n            else:\n                failedCheckCount += 1\n            time.sleep(self.checkDelaySeconds)\n        else:\n            raise ShowErrorMessage(\"The install log %s did not appear.\" % self.logPath)\n\n    def _generateLog(self):\n        raise NotImplementedError(\"abstract\")\n\n    def _openLog(self, canGenerate=True):\n        \"\"\" Returns a file object to self.logPath. \"\"\"\n        return open(self.logPath, \"rb\")\n\n    def getLastLines(self, count, canGenerate=True):\n        \"\"\"Returns the last lineNo lines of supplied file object.\"\"\"\n        try:\n            self._cachedLastLines = self._openLog(canGenerate=canGenerate).readlines()[-count:]\n            return self._cachedLastLines\n        except IOError, error:\n            LOG.error(\"Failed to read the log file\")\n            LOG.exception(error)\n            self._cachedLastLines = []\n            return []\n\n    def getLatestLines(self):\n        \"\"\" Returns the latest lines from the log file.\"\"\"\n        lastLines = self.getLastLines(self.numberOfReportedLines)\n        if not lastLines:\n            return []\n        if self.lastLine is None:\n            self.lastLine = lastLines[-1]\n            return lastLines\n        else:\n            curLastLine = lastLines[-1]\n            if curLastLine == self.lastLine:\n                return []\n            else:\n                self.lastLine = curLastLine\n                return lastLines\n\n    def isInstallDone(self):\n        \"\"\" Returns True if the installation has finished. \"\"\"\n        for path in self.stopFilePaths:\n            if os.path.exists(path):\n                return True\n        else:\n            return False\n\n    def isInstallFailed(self):\n        \"\"\"\n        Returns True if the installation is known to have failed.\n        To be implemented by subclasses if needed.\n        \"\"\"\n\n        return False\n\n    def adjustTimeout(self):\n        \"\"\"Hook for dynamically adjusting the timeout. Gets called at each iteration. \"\"\"\n\n        pass\n\n    def main(self):\n        \"\"\" Main monitoring function \"\"\"\n        print(\"Monitoring %s log file\" % self.logPath)\n\n        print(\"Waiting for %s to appear\" % self.logPath)\n        self.waitForLogFile()\n        print(\"Found the log file\")\n\n        failedCheckCount = 0\n        while failedCheckCount < self.timeoutCount and not self.isInstallDone() and not self.isInstallFailed():\n            lastLines = self.getLatestLines()\n            if lastLines:\n                failedCheckCount = 0\n                self.output.replaceMessages(\"Monitoring Installation\", \"\".join(lastLines))\n            else:\n                failedCheckCount += 1\n            self.adjustTimeout()\n            time.sleep(self.checkDelaySeconds)\n        else:\n            print(\"Here are the last %d lines of the log:\" % self.numberOfReportedLines)\n            print(\"\".join(self.getLastLines(self.numberOfReportedLines, canGenerate=False)))\n            if self.isInstallDone():\n                print(\"Installation completed.\")\n                return 0\n            elif self.isInstallFailed():\n                raise ShowErrorMessage(\n                    \"The installation failed: %s\" % self.installFailedUserMessage)\n            else:\n                raise TimeoutError(\"Monitoring the log file timed out.\")\n\n\nclass RPMBasedInstallerLogMonitor(LogMonitor):\n\n    def __init__(self, targetServer, logPath, stopFilePaths=(MONITORING_STOP_FLAG,), output=PlanOutputHandler(), rpmArguments=\"\"):\n        LogMonitor.__init__(self, targetServer, logPath, stopFilePaths, output)\n        self._rpmArguments = rpmArguments\n\n    def _openLog(self, canGenerate=True):\n        if canGenerate:\n            generatedLog = self._generateLog()\n            if generatedLog.strip():\n                return StringIO(generatedLog)\n        return open(self.logPath, \"rb\")\n\n    def _generateLog(self):\n        try:\n            return self.targetServer.rosh().getStdout(\n                \"\\\"rpm {rpmArguments} -qa --queryformat '{queryFormat}' | sort -n | tail -n 50 \\\"\".format(\n                    rpmArguments=self._rpmArguments,\n                    queryFormat=\"(%{installtime:date}) Installed rpm: %{name}\\n\"\n                ),\n            )\n        except ProcessExecutionError, e:\n            LOG.exception(e)\n            return \"\"\n\n\nclass Rhel5InstallationLogMonitor(LogMonitor):\n\n    def __init__(self, targetServer):\n        LogMonitor.__init__(\n            self, targetServer,\n            logPath=\"/tmp/anaconda.log\",\n            stopFilePaths=(\n                os.path.join(\"/mnt/sysimage/tmp\", os.path.basename(MONITORING_STOP_FLAG)),\n                MONITORING_STOP_FLAG\n            )\n        )\n\n\nclass Rhel6InstallationLogMonitor(RPMBasedInstallerLogMonitor):\n\n    def __init__(self, targetServer):\n        RPMBasedInstallerLogMonitor.__init__(\n            self, targetServer,\n            logPath=\"/tmp/anaconda.log\",\n            stopFilePaths=(\n                os.path.join(\"/mnt/sysimage/tmp\", os.path.basename(MONITORING_STOP_FLAG)),\n                MONITORING_STOP_FLAG\n            )\n        )\n\n\nclass Rhel7InstallationLogMonitor(LogMonitor):\n\n    def __init__(self, targetServer):\n        LogMonitor.__init__(\n            self, targetServer,\n            logPath=\"/tmp/packaging.log\",\n            stopFilePaths=(\n                os.path.join(\"/mnt/sysimage/tmp\", os.path.basename(MONITORING_STOP_FLAG)),\n                MONITORING_STOP_FLAG,\n            )\n        )\n\n\nclass SlesInstallationLogMonitor(RPMBasedInstallerLogMonitor):\n    def __init__(self, targetServer):\n        RPMBasedInstallerLogMonitor.__init__(\n            self, targetServer,\n            logPath=\"/var/log/YaST2/y2log\",\n            stopFilePaths=(\n                os.path.join(\"/mnt/tmp\", os.path.basename(MONITORING_STOP_FLAG)),\n                MONITORING_STOP_FLAG\n            ),\n            rpmArguments=\"--dbpath /mnt/var/lib/rpm\"\n        )\n\n\nclass UbuntuInstallationLogMonitor(LogMonitor):\n\n    def __init__(self, targetServer):\n        LogMonitor.__init__(self, targetServer, \"/var/log/syslog\")\n\n\nclass Solaris11InstallationMonitor(LogMonitor):\n\n    def __init__(self, targetServer):\n        LogMonitor.__init__(self, targetServer, \"/system/volatile/install_log\")\n        self.installDoneMessage = \"automated installation succeeded\"\n        self.installFailedMessage = \"automated installation failed\"\n        self.installFailedUserMessage = \"The install log reported failure.\"\n        self._installPhaseStartedMessage = \"install phase ... started\"\n        self._installPhaseDoneMessage = \"install phase ... done\"\n\n    def isInstallDone(self):\n        \"\"\" Returns True if the installation has finished. \"\"\"\n        return self.installDoneMessage in \"\\n\".join(self._cachedLastLines).lower()\n\n    def isInstallFailed(self):\n        \"\"\"Return True if the install log contains a failure message.\"\"\"\n        return self.installFailedMessage in \"\\n\".join(self._cachedLastLines).lower()\n\n    def adjustTimeout(self):\n        \"\"\"Sets a larger timeout after the 'Install Phase ... Started' message is detected in the log.\"\"\"\n        if self._installPhaseStartedMessage in \"\\n\".join(self._cachedLastLines).lower():\n            self.timeoutCount = 600\n        if self._installPhaseDoneMessage in \"\\n\".join(self._cachedLastLines).lower():\n            self.timeoutCount = self.defaultTimeoutCount\n\n\nclass Solaris10InstallationMonitor(LogMonitor):\n\n    def __init__(self, targetServer):\n        LogMonitor.__init__(self, targetServer, \"/a/var/sadm/system/logs/install_log\")\n        self.installFailedMessage = \"installation: failed\"\n        self.installFailedUserMessage = \"The install log reported failure.\"\n\n    def isInstallFailed(self):\n        \"\"\"Return True if the install log contains a failure message.\"\"\"\n        return self.installFailedMessage in \"\\n\".join(self._cachedLastLines).lower()\n\n\ndef factorLogMonitor(targetServer):\n    \"\"\" Return a LogMonitor based on the reported OS version\"\"\"\n    osVersion = targetServer.getServerVO().getOsVersion().lower()\n    if platform_util.isSLES(osVersion):\n        return SlesInstallationLogMonitor(targetServer)\n    elif platform_util.isRHELCompatible(osVersion, version=5):\n        return Rhel5InstallationLogMonitor(targetServer)\n    elif platform_util.isRHELCompatible(osVersion, version=6):\n        return Rhel6InstallationLogMonitor(targetServer)\n    elif platform_util.isRHELCompatible(osVersion, version=7):\n        return Rhel7InstallationLogMonitor(targetServer)\n    elif platform_util.isUbuntu(osVersion):\n        return UbuntuInstallationLogMonitor(targetServer)\n    elif platform_util.isSolaris(osVersion, version=11):\n        return Solaris11InstallationMonitor(targetServer)\n    elif platform_util.isSolaris(osVersion, version=10):\n        return Solaris10InstallationMonitor(targetServer)\n    raise NotSupportedError(\"Monitoring installation for %s is not supported\" % osVersion)\n\n\n@HandleShowErrorMessage(\"monitor installation\", LOG)\ndef main():\n    options, remainingArgs = MonitorStepOptionsParser().parse_args()\n\n    targetServer = ThisTargetServer()\n\n    logFile = options.log\n    if not logFile:\n        logMonitor = factorLogMonitor(targetServer)\n    else:\n        logMonitor = LogMonitor(targetServer, logFile)\n    logMonitor.checkDelaySeconds = options.delay\n    logMonitor.timeoutCount = options.count\n\n    return logMonitor.main()\n\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n",
            "description": "Monitors a given log file every DELAY seconds and timeouts after\nCOUNT checks in which the log has not changed.\n\nIf no log file is given it will monitor the installation log for the supported installers:\n- Red Hat, CentOS and OEL\n- SLES\n- Ubuntu\n- Solaris 10\n- Solaris 11 AI\n\nusage: monitor_install_log.py [options]\n\noptions:\n  -h, --help     show this help message and exit\n  --log=LOG      the log file that will be monitored\n  --count=COUNT  the number of times it counts before timing out\n  --delay=DELAY  the delay in seconds between every log check\n\nPrerequisites:\n  - Script needs to be run as part of a build plan.",
            "status": null,
            "name": "Monitor Solaris 11 Installation",
            "state": null,
            "eTag": "2015-06-13T04:49:17.000Z",
            "modified": "2015-06-13T04:49:17.000Z",
            "created": "2015-06-13T04:49:17.000Z",
            "category": "os-deployment-ogfs-scripts",
            "uri": "/rest/os-deployment-ogfs-scripts/1210001"
        },
        {
            "codeType": "OGFS",
            "displayCodeType": "OGFS",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "1",
                    "createdBy": "opsware",
                    "createdDate": "2015-06-13T04:49:18.000Z",
                    "usage": "This script is intended to be used with an UEFI-capable ProLiant server\nconfigured to boot in legacy BIOS mode running Gaius WinPE in UEFI mode, with\nintent to install a Windows OS. This script will setup a local harddrive,\ndeploy a WinPE ServiceOS, reboot the server and wait for the SA agent\nto be started. The server will come up in Legacy BIOS mode and the Windows\nOS installation will continue.\n\nUsage: install_and_boot_into_local_winpe.py [options]\n\nOptions:\n-h, --help : show this help message and exit\n--waitAtLeast : The number of minutes to wait before actively checking for the agent\n--waitAtMost : The maximum number of minutes to wait for the agent to come back online\n--withVID : HP ProLiant Gen8 VID handling\n--systemDiskNumber : system disk number where Windows is installed (default disk number is '0')\n--systemDrive : system drive letter where WinPE will be copied\n--winpeVersion : WinPE version which will be downloaded (default value is 'any')\n--force : Force WinPE local install and boot (This option works correctly only if the server is in Legacy BIOS mode)\n--disableWarning : Do not show warnings of old hpsa_netconfig format\n\nPrerequisites:\n- Target server runs a maintenance Gaius Windows PE OS.\n- Must be part of a build plan.",
                    "current": false
                },
                {
                    "versionLabel": "2",
                    "createdBy": "opsware",
                    "createdDate": "2015-08-04T07:30:32.000Z",
                    "usage": "This script is intended to be used with an UEFI-capable ProLiant server\nconfigured to boot in legacy BIOS mode running Gaius WinPE in UEFI mode, with\nintent to install a Windows OS. This script will setup a local harddrive,\ndeploy a WinPE ServiceOS, reboot the server and wait for the SA agent\nto be started. The server will come up in Legacy BIOS mode and the Windows\nOS installation will continue.\n\nUsage: install_and_boot_into_local_winpe.py [options]\n\nOptions:\n-h, --help : show this help message and exit\n--waitAtLeast : The number of minutes to wait before actively checking for the agent\n--waitAtMost : The maximum number of minutes to wait for the agent to come back online\n--withVID : HP ProLiant Gen8 VID handling\n--systemDiskNumber : system disk number where Windows is installed (default disk number is '0')\n--systemDrive : system drive letter where WinPE will be copied\n--winpeVersion : WinPE version which will be downloaded (default value is 'any')\n--force : Force WinPE local install and boot (This option works correctly only if the server is in Legacy BIOS mode)\n--disableWarning : Do not show warnings of old hpsa_netconfig format\n\nPrerequisites:\n- Target server runs a maintenance Gaius Windows PE OS.\n- Must be part of a build plan.",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-08-04T07:30:32.000Z",
            "version": {
                "versionLabel": "2",
                "createdBy": "opsware",
                "createdDate": "2015-08-04T07:30:32.000Z",
                "usage": "This script is intended to be used with an UEFI-capable ProLiant server\nconfigured to boot in legacy BIOS mode running Gaius WinPE in UEFI mode, with\nintent to install a Windows OS. This script will setup a local harddrive,\ndeploy a WinPE ServiceOS, reboot the server and wait for the SA agent\nto be started. The server will come up in Legacy BIOS mode and the Windows\nOS installation will continue.\n\nUsage: install_and_boot_into_local_winpe.py [options]\n\nOptions:\n-h, --help : show this help message and exit\n--waitAtLeast : The number of minutes to wait before actively checking for the agent\n--waitAtMost : The maximum number of minutes to wait for the agent to come back online\n--withVID : HP ProLiant Gen8 VID handling\n--systemDiskNumber : system disk number where Windows is installed (default disk number is '0')\n--systemDrive : system drive letter where WinPE will be copied\n--winpeVersion : WinPE version which will be downloaded (default value is 'any')\n--force : Force WinPE local install and boot (This option works correctly only if the server is in Legacy BIOS mode)\n--disableWarning : Do not show warnings of old hpsa_netconfig format\n\nPrerequisites:\n- Target server runs a maintenance Gaius Windows PE OS.\n- Must be part of a build plan.",
                "current": true
            },
            "source": "#!/usr/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n\"\"\"\n    (C) Copyright 2009-2015 Hewlett-Packard Development Company, L.P.\n\n    Inject required options and move the file onto the boot partition.\n\"\"\"\n\nimport sys\nimport os\nfrom osprov import ilo\nfrom osprov.osbp import logger, ThisTargetServer\nfrom osprov.optparse_ext import OptionParser\nfrom osprov.errors import SetupError, ShowErrorMessage, NotFoundError\nfrom osprov.util import winpe\nfrom librunplan import PlanRunner, PlanOutputHandler\nfrom pytwist.com.opsware.ilo import ServerBootMode\nfrom pytwist import twistserver\nfrom pytwist.com.opsware.script import ServerScriptRef, OGFSScriptRef\nfrom pytwist.com.opsware.osprov import RunScriptPlanStep, InstallCMLPlanStep\nfrom pytwist.com.opsware.common import NotFoundException\nfrom optparse import OptionError\n\nLOG = logger.getIt(\"Install and boot into local WinPE\")\n\n\nclass ConfigureWindowsPreinstallationEnvironmentOptionsParser(OptionParser):\n    \"\"\" An option parser for this step. \"\"\"\n\n    def defineOptions(self):\n        self.add_option(\"--waitAtLeast\", type=\"int\", default=3,\n                        help=\"The number of minutes to wait before actively checking for the agent\")\n        self.add_option(\"--waitAtMost\", type=\"int\", default=20,\n                        help=\"The maximum number of minutes to wait for the agent to come back online\")\n        self.add_option(\"--withVID\", action=\"store_true\", default=False,\n                        help=\"HP ProLiant Gen8 VID handling\")\n        self.add_option(\"--systemDiskNumber\", type=\"int\", default=0,\n                        help=\"System disk number where Windows is installed (default disk number is '0').\")\n        self.add_option(\"--systemDrive\", type=\"string\", default=\"C\",\n                        help=\"System drive letter where WinPE will be copied\")\n        self.add_option(\"--winpeVersion\", type=\"string\", default=winpe.ANY_WINPE,\n                        help=\"WinPE version which will be downloaded (default value is 'any').\")\n        self.add_option(\"--force\", action=\"store_true\", default=False,\n                        help=\"Force WinPE local install and boot.\")\n        self.add_option(\"--disableWarning\", dest=\"disableWarning\", action=\"store_true\",\n                        default=False,\n                        help=\"Do not show warnings of old hpsa_netconfig format\")\n\n    def validateArgs(self, opt, args):\n        if opt.withVID:\n            opt.withVID = \"--withVID\"\n        else:\n            opt.withVID = \"\"\n\n        winpeVersions = map(str.strip, opt.winpeVersion.split(\",\"))\n        for ver in winpeVersions:\n            if ver not in winpe.WINPE_VERSION_TO_ISO.keys():\n                raise OptionError(\"Invalid WinPE version was requested: %s. Supported WinPE options: %s\" % (ver, str(winpe.WINPE_VERSION_TO_ISO.keys()).strip(\"[]\")), \"winpeVersion\")\n\n\ndef getSteps(atLeast=3, atMost=20, withVid='', sysDiskNr=0, sysDrive=\"C\", winpeVer=\"any\", disableWarning=False, targetServer=None):\n    yield ('OS Provisioning/OS Build Plan Steps/Prepare Disks on HP ProLiant Gen8', '%s' % withVid)\n    # Defect 190385\n    # After the run of the above step we need to update the sysDiskNr value from CA\n    newSysDiskNr = targetServer.getCustomAttribute('SystemDiskNumber')\n    if newSysDiskNr and newSysDiskNr != str(sysDiskNr):\n        LOG.debug(\"Updating the SystemDiskNumber value for the next SubSteps to: %s\" % str(newSysDiskNr))\n        sysDiskNr = newSysDiskNr\n    yield ('OS Provisioning/OS Build Plan Steps/Windows/Templates/Configure Windows Partitioning Scheme for Legacy',\n              'X:\\\\Windows\\\\Temp\\\\diskpart_legacy.txt')\n    yield ('OS Provisioning/OS Build Plan Steps/Windows/Templates/Configure Windows Partitioning Scheme for Uefi',\n              'X:\\\\Windows\\\\Temp\\\\diskpart_uefi.txt')\n    yield ('OS Provisioning/OS Build Plan Steps/Windows/Partition Disk for Windows',\n              '--systemDiskNumber=%s' % (str(sysDiskNr)))\n    yield ('OS Provisioning/OS Build Plan Steps/Windows/Deploy WinPE on Localdisk',\n              '--systemDiskNumber=%s --systemDrive=%s --winpeVersion=%s %s' % (\n                  str(sysDiskNr), str(sysDrive), str(winpeVer), (\"--disableWarning\" if disableWarning else \"\")))\n    yield ('OS Provisioning/OS Build Plan Steps/Reboot', '')\n    yield ('OS Provisioning/OS Build Plan Steps/Wait for HP SA Agent',\n              '--maintenance --atLeast=%s --atMost=%s' % (str(atLeast), str(atMost)))\n    return\n\n\ndef correctBootMode(targetServer):\n    \"\"\"\n    Determine if the current boot mode is right or not.\n    When a Gen9 machine is booted in Gaius it will use UEFI mode even if BIOS is set to LEGACY mode.\n    That's NOT a correct boot mode and we have to do 'Local Deploy of WinPE'\n    Other cases are right\n    \"\"\"\n    currentBootMode = targetServer.rosh().getStdout(\n        [\"\\\"Program Files\\\\Opsware\\\\agent\\\\pylibs\\\\\\osprov\\scripts\\\\bootmode.cmd\\\"\", \"--getBootedMode\"])\n\n    if ServerBootMode.UEFI in currentBootMode:\n        try:\n            iloServer = ilo.getIlo(targetServer, log=LOG)\n            baseBootMode = iloServer.getBaseBootMode(iloServer.getCurrentBootMode())\n            if baseBootMode == ServerBootMode.LEGACY:\n                return False\n        except SetupError as why:\n            LOG.exception(why)\n            raise\n    return True\n\n\ndef runSteps(steps, targetServer, twist):\n    runnerOH = PlanOutputHandler(sys.stdout, sys.stderr, logger.getIt(\"Composite step\"))\n    runnerOH.NO_APX_PROGRESS = True  # don't break the papx reporting\n    runnerOH.ADV_STEP_MSG = None  # don't update the main message\n    runnerOH.ADV_STEP_MSG_LONG = \"\\nSub Step: %(action)s '%(name)s'\"\n    runnerOH.ERR_HEADER = \"\\nErrors from sub step %(current)d '%(name)s':\\n\"\n    runner = PlanRunner(None, targetServer=targetServer, outputHandler=runnerOH)\n    for scriptPath, parameters in steps:\n        scriptElems = [x for x in scriptPath.split(\"/\") if x]\n        try:\n            stepRef = twist.folder.FolderService.getFNode([\"Opsware\", \"Tools\"] +\n                                                          scriptElems)\n            step = None\n            if isinstance(stepRef, ServerScriptRef) or isinstance(stepRef, OGFSScriptRef):\n                step = RunScriptPlanStep()\n                step.setScript(stepRef)\n                step.setParameters(parameters)\n            elif \"CMLRef\" in str(stepRef):\n                step = InstallCMLPlanStep()\n                step.setCmlRef(stepRef)\n                step.setLocationOnServer(parameters)\n                step.setDownload(True)\n                step.setOverwrite(True)\n            runner.doStep(step, stepNo=int(os.environ[\"CURRENT_STEP_NO\"]))\n        except NotFoundException as why:\n            runnerOH.exception(\"Error : sub step '%s' not found! %s\" % (scriptPath, why), why)\n            sys.exit(1)\n        except ShowErrorMessage as why:\n            runnerOH.exception(\"Sub Step '%s' failed: %s\" % (scriptPath, why[0]), why)\n            sys.exit(1)\n\n\ndef main():\n    # get and parse arguments\n    opt, remainingArgs = ConfigureWindowsPreinstallationEnvironmentOptionsParser().parse_args()\n    winpeVersions = map(str.strip, opt.winpeVersion.split(\",\"))\n\n    targetServer = ThisTargetServer()\n    twist = twistserver.TwistServer()\n\n    correctWinPE, isoName = winpe.haveValidWinPE(targetServer, winpeVersions, log=LOG)\n\n    # in case the machine current boot mode is Legacy -or- real & current boot mode is UEFI \n    # this script will exit and build plan will continue with next steps\n    if not opt.force:\n        if correctBootMode(targetServer) and correctWinPE:\n            sys.exit(0)\n\n    if not isoName:\n        raise NotFoundError(\"Cannot continue Build Plan since we don't have any ISO defined for WinPE %s\" % str(winpeVersions).strip('[]'))\n\n    steps = getSteps(atLeast=opt.waitAtLeast, atMost=opt.waitAtMost, withVid=opt.withVID,\n                     sysDiskNr=opt.systemDiskNumber, sysDrive=opt.systemDrive, winpeVer=opt.winpeVersion,\n                     disableWarning=opt.disableWarning, targetServer=targetServer)\n    runSteps(steps, targetServer, twist)\n\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n",
            "description": "This script is intended to be used with an UEFI-capable ProLiant server\nconfigured to boot in legacy BIOS mode running Gaius WinPE in UEFI mode, with\nintent to install a Windows OS. This script will setup a local harddrive,\ndeploy a WinPE ServiceOS, reboot the server and wait for the SA agent\nto be started. The server will come up in Legacy BIOS mode and the Windows\nOS installation will continue.\n\nUsage: install_and_boot_into_local_winpe.py [options]\n\nOptions:\n-h, --help : show this help message and exit\n--waitAtLeast : The number of minutes to wait before actively checking for the agent\n--waitAtMost : The maximum number of minutes to wait for the agent to come back online\n--withVID : HP ProLiant Gen8 VID handling\n--systemDiskNumber : system disk number where Windows is installed (default disk number is '0')\n--systemDrive : system drive letter where WinPE will be copied\n--winpeVersion : WinPE version which will be downloaded (default value is 'any')\n--force : Force WinPE local install and boot (This option works correctly only if the server is in Legacy BIOS mode)\n--disableWarning : Do not show warnings of old hpsa_netconfig format\n\nPrerequisites:\n- Target server runs a maintenance Gaius Windows PE OS.\n- Must be part of a build plan.",
            "status": null,
            "name": "Install and boot into local WinPE",
            "state": null,
            "eTag": "2015-08-04T07:30:32.000Z",
            "modified": "2015-08-04T07:30:32.000Z",
            "created": "2015-06-13T04:49:18.000Z",
            "category": "os-deployment-ogfs-scripts",
            "uri": "/rest/os-deployment-ogfs-scripts/1230001"
        },
        {
            "codeType": "OGFS",
            "displayCodeType": "OGFS",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "1",
                    "createdBy": "opsware",
                    "createdDate": "2015-06-13T04:49:19.000Z",
                    "usage": "Converts one or more files from one encoding to another. \nNote that conversion is done in-place, that is, the original file is overwritten with the new one.\n\nUsage:\n\nThe script should be called in the following way: \n\t[--from=ENCODING] --to=ENCODING [FILE(S)]\n\nWhere: \n --from=ENCODING\tthe file is in the character ENCODING (defaults to UTF8)\n --to=ENCODING\t\tthe file will be converted to the character ENCODING (e.g.: ISO-8859-1)\n\nIf no FILE is specified the script will attempt to identify the path of Unattend.txt.\n\nThe arguments should be given in the following format: --argument='value'.\n\nExample: --to='ISO-8859-1'\n  will attempt to convert the file(s), to the ISO-8859-1 character encoding. This is useful when it contains non-ASCII characters.\n\nWarning:\n  When used as an build plan step to change the character encoding of an OS installation profile this script must be the last one to \n  process the profile. Note that the conversion script must not be used on the Windows 2008 or later Unattended Setup file, Unattend.xml, \n  which supports UTF8.",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-06-13T04:49:19.000Z",
            "version": {
                "versionLabel": "1",
                "createdBy": "opsware",
                "createdDate": "2015-06-13T04:49:19.000Z",
                "usage": "Converts one or more files from one encoding to another. \nNote that conversion is done in-place, that is, the original file is overwritten with the new one.\n\nUsage:\n\nThe script should be called in the following way: \n\t[--from=ENCODING] --to=ENCODING [FILE(S)]\n\nWhere: \n --from=ENCODING\tthe file is in the character ENCODING (defaults to UTF8)\n --to=ENCODING\t\tthe file will be converted to the character ENCODING (e.g.: ISO-8859-1)\n\nIf no FILE is specified the script will attempt to identify the path of Unattend.txt.\n\nThe arguments should be given in the following format: --argument='value'.\n\nExample: --to='ISO-8859-1'\n  will attempt to convert the file(s), to the ISO-8859-1 character encoding. This is useful when it contains non-ASCII characters.\n\nWarning:\n  When used as an build plan step to change the character encoding of an OS installation profile this script must be the last one to \n  process the profile. Note that the conversion script must not be used on the Windows 2008 or later Unattended Setup file, Unattend.xml, \n  which supports UTF8.",
                "current": true
            },
            "source": "#!/usr/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n#\n# Also note that a Python version greater than 2.3 is needed\n\"\"\"\n    (C) Copyright 2010-2015 Hewlett-Packard Development Company, L.P.\n\n    This python script converts one or more files from one character encoding to another.\n\"\"\"\n\nimport os\nimport sys\nfrom optparse import OptionParser\nfrom StringIO import StringIO\n\nfrom osprov.osbp import ThisTargetServer\nfrom osprov.errors import ShowErrorMessage\n\nEC_NO_FILE = 1\nEC_NO_PROFILE = 2\nEC_NO_TARGET_ENCODING = 3\nEC_OGFS = 4\n\n\ndef parseArgs():\n    \"Parses the arguments in sys.arg\"\n\n    parser = OptionParser()\n\n    parser.add_option(\"--from\", default=\"utf8\", help=\"from encoding\")\n    parser.add_option(\"--to\", help=\"to encoding\")\n\n    return parser.parse_args()\n\n\ndef convert(from_enc, to_enc, filepath):\n    \"Converts from the character encoding from_enc to to_enc the file at filepath\"\n\n    infile = open(filepath, \"r\")\n    buf = StringIO()\n\n    try:\n        buf.write(infile.read().decode(from_enc).encode(to_enc))\n    except UnicodeDecodeError, ude:\n        sys.stderr.write(\"%s\\n\" % ude)\n        sys.stderr.write(\"Cannot decode file %s using the %s character encoding\\n\" %\n                         (filepath, from_enc))\n        raise\n    except UnicodeEncodeError, uee:\n        sys.stderr.write(\"%s\\n\" % uee)\n        sys.stderr.write(\n            \"Cannot encode file %s using the %s character encoding\\n\" % (filepath, to_enc))\n        raise\n\n    infile.close()\n\n    output = open(filepath, \"w\")\n    output.write(buf.getvalue())\n    output.close()\n\n\ndef locate_os_profile():\n    \"Attempts to locate the OS installation profile\"\n\n    win_profiles = [\"Unattend.txt\"]\n    win_temp = \"X/Windows/Temp\"\n\n    profiles = [os.path.join(win_temp, wp) for wp in win_profiles]\n\n    for p in profiles:\n        if os.path.isfile(p):\n            return p\n\n    return \"\"\n\n\ndef main():\n\n    opt, files = parseArgs()\n\n    try:\n        targetServer = ThisTargetServer()\n        targetserver = targetServer.setWorkDir(targetServer.getRemoteRoot())\n    except ShowErrorMessage, why:\n        sys.stderr.write(str(why))\n        return EC_OGFS\n    if not opt.to:\n        sys.stderr.write(\"The --to='ENCODING' argument is missing\\n\")\n        return EC_NO_TARGET_ENCODING\n\n    if not files:\n        profile = locate_os_profile()\n        if not profile:\n            print \"Unable to locate an OS installation profile and no other files were specified as arguments.\"\n            return EC_NO_PROFILE\n        files = [profile]\n\n    for each in files:\n        if not os.path.isfile(each):\n            sys.stderr.write(\"No such file: %s\\n\" % os.getcwd() + file)\n            return EC_NO_FILE\n        convert(opt.__dict__[\"from\"], opt.to, file)\n\n    return 0\n\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n",
            "description": "Converts one or more files from one encoding to another. \nNote that conversion is done in-place, that is, the original file is overwritten with the new one.\n\nUsage:\n\nThe script should be called in the following way: \n\t[--from=ENCODING] --to=ENCODING [FILE(S)]\n\nWhere: \n --from=ENCODING\tthe file is in the character ENCODING (defaults to UTF8)\n --to=ENCODING\t\tthe file will be converted to the character ENCODING (e.g.: ISO-8859-1)\n\nIf no FILE is specified the script will attempt to identify the path of Unattend.txt.\n\nThe arguments should be given in the following format: --argument='value'.\n\nExample: --to='ISO-8859-1'\n  will attempt to convert the file(s), to the ISO-8859-1 character encoding. This is useful when it contains non-ASCII characters.\n\nWarning:\n  When used as an build plan step to change the character encoding of an OS installation profile this script must be the last one to \n  process the profile. Note that the conversion script must not be used on the Windows 2008 or later Unattended Setup file, Unattend.xml, \n  which supports UTF8.",
            "status": null,
            "name": "Convert Character Encoding",
            "state": null,
            "eTag": "2015-06-13T04:49:19.000Z",
            "modified": "2015-06-13T04:49:19.000Z",
            "created": "2015-06-13T04:49:19.000Z",
            "category": "os-deployment-ogfs-scripts",
            "uri": "/rest/os-deployment-ogfs-scripts/1250001"
        },
        {
            "codeType": "OGFS",
            "displayCodeType": "OGFS",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "1",
                    "createdBy": "opsware",
                    "createdDate": "2015-06-13T04:49:20.000Z",
                    "usage": "Checks that the target server has a functioning iLO service, and prints the iLO version.\nIf the server doesn't have iLO capability ( not manufactured by HP ), the step will\nfail instantly. If the server does have iLO capability but the service is not yet \nregistered in SA, it will wait for it.\n\nusage: Check For iLO Service [options]\n\noptions:\n  -h, --help            show this help message and exit\n  -t MINUTES, --atMost=MINUTES\n                        Wait at most this many minutes before timing out.\n                        Default 10 minutes.\n\nPrerequisites:\n- Script needs to run as part of a build plan.",
                    "current": false
                },
                {
                    "versionLabel": "2",
                    "createdBy": "opsware",
                    "createdDate": "2015-08-04T07:30:30.000Z",
                    "usage": "Checks that the target server has a functioning iLO service, and prints the iLO version.\nIf the server doesn't have iLO capability ( not manufactured by HP ), the step will\nfail instantly. If the server does have iLO capability but the service is not yet \nregistered in SA, it will wait for it.\n\nusage: Check For iLO Service [options]\n\noptions:\n  -h, --help            show this help message and exit\n  -t MINUTES, --atMost=MINUTES\n                        Wait at most this many minutes before timing out.\n                        Default 10 minutes.\n\nPrerequisites:\n- Script needs to run as part of a build plan.",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-08-04T07:30:30.000Z",
            "version": {
                "versionLabel": "2",
                "createdBy": "opsware",
                "createdDate": "2015-08-04T07:30:30.000Z",
                "usage": "Checks that the target server has a functioning iLO service, and prints the iLO version.\nIf the server doesn't have iLO capability ( not manufactured by HP ), the step will\nfail instantly. If the server does have iLO capability but the service is not yet \nregistered in SA, it will wait for it.\n\nusage: Check For iLO Service [options]\n\noptions:\n  -h, --help            show this help message and exit\n  -t MINUTES, --atMost=MINUTES\n                        Wait at most this many minutes before timing out.\n                        Default 10 minutes.\n\nPrerequisites:\n- Script needs to run as part of a build plan.",
                "current": true
            },
            "source": "#!/usr/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n\"\"\"\n    (C) Copyright 2012-2015 Hewlett-Packard Development Company, L.P.\n\n    Check and wait for the iLO Service\n\"\"\"\nimport sys\n\nfrom osprov import ilo\nfrom osprov.errors import TimeoutError, SetupError, NotSupportedError\nfrom osprov.osbp import ThisTargetServer\nfrom osprov.osbp import logger\nfrom osprov.patterns.scanner import TimeoutScanner, StopScan\nfrom osprov.optparse_ext import OptionParser, OptionValueError\nfrom osprov.decorators import HandleShowErrorMessage\n\nLOG = logger.getIt(\"check iLO Service\")\n\n\nclass CheckForILOServiceOptparser(OptionParser):\n\n    \"\"\" Custom option parser \"\"\"\n\n    def defineOptions(self):\n        self.prog = \"Check For iLO Service\"\n        self.set_usage(\"%s [options]\" % self.prog)\n        self.add_option(\"-t\", \"--atMost\", type=\"int\", default=\"10\", metavar=\"MINUTES\",\n                        help=\"Wait at most this many minutes before timing out. Default %default.\"\n                        )\n\n    def validateArgs(self, opt, args):\n        if opt.atMost < 1:\n            raise OptionValueError(\"MINUTES should be more than 1.\")\n\n\nclass CheckForILOServiceScanner(TimeoutScanner):\n\n    \"\"\" Custom scanner for the iLO service \"\"\"\n\n    def __init__(self, targetServer, *args, **kwargs):\n        super(CheckForILOServiceScanner, self).__init__(*args, **kwargs)\n        self.targetServer = targetServer\n\n    def shortcut(self):\n        if self.targetServer.serverVO.manufacturer:\n            if self.targetServer.serverVO.manufacturer.strip().lower() not in (\n                \"hp\",\n                \"hewlett-packard\",\n                \"hewlett-packard company\",\n                \"hewlett-packard inc.\",\n                \"hewlett packard\",\n                \"hewlett packard company\",\n                \"hewlett packard inc.\",\n                \"unknown manufacturer\"\n            ):\n                raise NotSupportedError(\"Server model %s, manufacturer %s does not support iLO\" % (\n                    self.targetServer.serverVO.model,\n                    self.targetServer.serverVO.manufacturer,\n                ))\n        self.scan()\n\n    def scan(self):\n        self.log.debug(\"Scanning for iLO\")\n        try:\n            iloServ = ilo.getIlo(self.targetServer, log=self.log)\n            self.log.debug(\"Found iLO %s\" % iloServ)\n            print \"Service active, version %s.\" % iloServ.version()\n            raise StopScan()\n        except SetupError, why:\n            self.log.exception(why)\n\n\n@HandleShowErrorMessage(\"check iLO service\", LOG)\ndef main():\n    \"\"\" Main entry point \"\"\"\n    opt, args = CheckForILOServiceOptparser().parse_args()\n    if args:\n        print \"Warning, unneeded arguments will be ignored: %s\" % (\" \".join(args))\n    scanner = CheckForILOServiceScanner(\n        targetServer=ThisTargetServer(),\n        timeoutMin=opt.atMost,\n        waitUpfrontMin=1,\n        log=LOG\n    )\n    try:\n        scanner()\n    except TimeoutError, why:\n        LOG.exception(why)\n        print \"Error: The iLO service did not  become available after %d minutes.\" % opt.atMost\n        print \"This Build Plan requires the iLO service and can't continue without it.\"\n        return 10\n\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n",
            "description": "Checks that the target server has a functioning iLO service, and prints the iLO version.\nIf the server doesn't have iLO capability ( not manufactured by HP ), the step will\nfail instantly. If the server does have iLO capability but the service is not yet \nregistered in SA, it will wait for it.\n\nusage: Check For iLO Service [options]\n\noptions:\n  -h, --help            show this help message and exit\n  -t MINUTES, --atMost=MINUTES\n                        Wait at most this many minutes before timing out.\n                        Default 10 minutes.\n\nPrerequisites:\n- Script needs to run as part of a build plan.",
            "status": null,
            "name": "Check iLO Service",
            "state": null,
            "eTag": "2015-08-04T07:30:30.000Z",
            "modified": "2015-08-04T07:30:30.000Z",
            "created": "2015-06-13T04:49:20.000Z",
            "category": "os-deployment-ogfs-scripts",
            "uri": "/rest/os-deployment-ogfs-scripts/1260001"
        },
        {
            "codeType": "OGFS",
            "displayCodeType": "OGFS",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "1",
                    "createdBy": "opsware",
                    "createdDate": "2015-06-13T04:49:22.000Z",
                    "usage": "Injects settings for personalization into a Kickstart installation profile.\nPersonalization settings include network settings.\n\nUsage: inject_ks_personalization_settings.py [OPTIONS]\n\nOptions:\n--require-netconfig=[true,false]\n\tSpecify whether a netconfig is mandatory or not.\n\tOptional argument, defaults to false.\n\n--disableWarning\n    Do not show warnings of old hpsa_netconfig format\n    Optional argument, defaults to false.\n\nPrerequisites:\n- Target server runs a maintenance Linux OS.",
                    "current": false
                },
                {
                    "versionLabel": "2",
                    "createdBy": "opsware",
                    "createdDate": "2015-08-04T07:29:46.000Z",
                    "usage": "Injects settings for personalization into a Kickstart installation profile.\nPersonalization settings include network settings.\n\nUsage: inject_ks_personalization_settings.py [OPTIONS]\n\nOptions:\n--require-netconfig=[true,false]\n\tSpecify whether a netconfig is mandatory or not.\n\tOptional argument, defaults to false.\n\n--disableWarning\n    Do not show warnings of old hpsa_netconfig format\n    Optional argument, defaults to false.\n\nPrerequisites:\n- Target server runs a maintenance Linux OS.",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-08-04T07:29:46.000Z",
            "version": {
                "versionLabel": "2",
                "createdBy": "opsware",
                "createdDate": "2015-08-04T07:29:46.000Z",
                "usage": "Injects settings for personalization into a Kickstart installation profile.\nPersonalization settings include network settings.\n\nUsage: inject_ks_personalization_settings.py [OPTIONS]\n\nOptions:\n--require-netconfig=[true,false]\n\tSpecify whether a netconfig is mandatory or not.\n\tOptional argument, defaults to false.\n\n--disableWarning\n    Do not show warnings of old hpsa_netconfig format\n    Optional argument, defaults to false.\n\nPrerequisites:\n- Target server runs a maintenance Linux OS.",
                "current": true
            },
            "source": "#!/usr/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# lint_ignore=E501,I0011,C0301\n# Please do not change the two lines above. See PEP 8, PEP 263.\n\"\"\"\n    (C) Copyright 2010-2015 Hewlett-Packard Development Company, L.P.\n\n    This program will inject personalized settings into the kickstart\n    file.\n\"\"\"\n\nimport os\nimport sys\nfrom cStringIO import StringIO\n\nfrom osprov import helpers\nfrom osprov.errors import ShowErrorMessage\nfrom osprov.optparse_ext import OptionParser, OptionValueError\nfrom osprov.osbp import ThisTargetServer, logger\nfrom osprov.osbp.constants import CODE_HEADER, CODE_WARNING, CODE_FOOTER\nfrom osprov.osbp.helpers import getMediaURL\nfrom osprov.platform_util import isRHELCompatible, isRHEL7CompatibleMedia\nfrom osprov.profile import Kickstart\nfrom osprov.profile.kickstart import Directive\nfrom osprov.profile.kickstart import Script\nfrom osprov.parsers.netconfig import SmartNetconfig, OLD_SYNTAX_WARNING\nfrom osprov.networking import validation\n\nEC_NO_ERR = 0\nEC_NO_CA = 20\nEC_EXCEPTION = 100\nEC_NOT_SUPPORTED = 101\n\nKS_PATH = \"tmp/user.ks.cfg\"\n\nLOG = logger.getIt('inject_ks_pers')\n\n# replaced at build time\nTARGET_OS = \"rhel\"\n\n\ndef removeNetworkDirective(ks):\n    if hasattr(ks, \"network\"):\n        print \"Removing existing network personalization from the kickstart\"\n        ks.directives.remove(ks.network)\n\ndef injectSysctlSettings(isIPv6Managed):\n    sysctl = open(\"tmp/sysctl.conf\", \"w\")\n    if not isIPv6Managed:\n        sysctl.write(\"net.ipv6.conf.all.disable_ipv6=1\")\n    sysctl.close()\n\n\ndef injectPersonalization(ks, netinfo, provisioningNIC, provisioningRoute, isIPv6Managed, isRHEL7=False):\n    \"\"\" Inject static networking configuration into the kickstart profile. \"\"\"\n    removeNetworkDirective(ks)\n\n    static_dir = Directive(\"network\")\n    static_dir[\"device\"] = provisioningNIC.macAddress\n    print \"Going to provision using interface with MAC address %s\" % provisioningNIC.macAddress\n\n    # ESXi doesn't support ipv6, noipv6 and noipv4 boot parameters\n    isESXi = \"esxi\" in TARGET_OS\n\n    if isIPv6Managed:\n        if isESXi:\n            if provisioningNIC.ipv6Networks:\n                print \"Configuring boot protocol to: static\"\n                static_dir[\"bootproto\"] = \"static\"\n            elif provisioningNIC.ipv6Autoconfig:\n                # esxi does not know of auto as a bootproto option\n                # if bootproto is not set the ESXi installer defaults to DHCP and also will print a warning\n                # Setting it dhcp from the start it's convenient\n                print \"Configuring boot protocol to: dhcp\"\n                static_dir[\"bootproto\"] = \"dhcp\"\n            else:\n                print \"Can not complete network personalization. \" \\\n                      \"Auto configuration is turned off for IPv6 and there is no static address defined\"\n                sys.exit(36)\n        else:\n            if provisioningNIC.ipv6Autoconfig:\n                print \"Configuring IPv6 to: auto\"\n                static_dir[\"ipv6\"] = \"auto\"\n            elif provisioningNIC.ipv6Networks:\n                if isRHEL7:\n                    return\n                print \"Configuring boot protocol to: static\"\n                static_dir[\"bootproto\"] = \"static\"\n            else:\n                print \"Can not complete network personalization. \" \\\n                      \"Auto configuration is turned off for IPv6 and there is no static address defined\"\n                sys.exit(37)\n            print \"Disabling IPv4\"\n            static_dir[\"noipv4\"] = None\n\n        for ipv6Network in provisioningNIC.ipv6Networks:\n            print \"Configuring IPv6 network: %s\" % ipv6Network\n            static_dir[\"ip\" if isESXi else \"ipv6\"] = ipv6Network.ip\n            static_dir[\"netmask\"] = ipv6Network.prefixlen\n            break  # we only set the first IP if any\n        if provisioningNIC.ipv4Networks:\n            print \"Found IPv6-based service OS, ignoring IPv4 network personalization\"\n    else:\n        # IPv4\n        if provisioningNIC.ipv4Networks:\n            print \"Configuring boot protocol to: static\"\n            static_dir[\"bootproto\"] = \"static\"\n        elif provisioningNIC.dhcpv4:\n            print \"Configuring boot protocol to: dhcp\"\n            static_dir[\"bootproto\"] = \"dhcp\"\n        else:\n            print \"Can not complete network personalization. \" \\\n                  \"DHCP is turned off for IPv4 and there is no static address defined\"\n            sys.exit(38)\n        if not isESXi:\n            print \"Disabling IPv6\"\n            static_dir[\"noipv6\"] = None\n\n        for ipv4Network in provisioningNIC.ipv4Networks:\n            print \"Configuring IPv4 network: %s\" % ipv4Network\n            static_dir[\"ip\"] = ipv4Network.ip\n            static_dir[\"netmask\"] = ipv4Network.netmask\n            break  # we only set the first IP if any\n        if provisioningNIC.ipv6Networks:\n            print \"Found IPv4-based service OS, ignoring IPv6 network personalization\"\n\n    if provisioningRoute:\n        gw = str(provisioningRoute.gateway)\n        print \"Will use default gateway: %s\" % gw\n        #if isinstance(provisioningRoute.gateway, ipaddr.IPv6Address) and isRHEL7:\n        #    gw = \"[%s]\" % provisioningRoute.gateway\n        static_dir[\"gateway\"] = gw\n\n    # use the stack-aware DNS server, if any\n    for dnsServer in provisioningNIC.ipv6DnsServers if isIPv6Managed else provisioningNIC.ipv4DnsServers:\n        print \"Will use name server: %s\" % dnsServer\n        static_dir[\"nameserver\"] = dnsServer\n        break\n\n    if netinfo.fqdn:\n        print \"Setting FQDN to: %s\" % netinfo.fqdn\n        static_dir[\"hostname\"] = netinfo.fqdn\n    ks.directives.append(static_dir)\n\n\ndef injectVlanID(provisioningNIC, ksObj):\n    \"\"\" Inject the VLAN ID in the installation profile \"\"\"\n    if provisioningNIC.vlan_id is None:\n        return\n    if \"esxi5\" in TARGET_OS.lower():\n        print \"Configuring VLAN ID %s\" % provisioningNIC.vlan_id\n        ksObj.network[\"vlanid\"] = provisioningNIC.vlan_id\n    elif \"esxi\" in TARGET_OS.lower():\n        print \"Warning: Not injecting vlan id. This version of ESXi does not support it.\"\n\n\ndef injectVmwareESXi41Workaround(ks, netinfo, provisioningNIC, provisioningRoute):\n    \"\"\" VMware insists on having a DHCP server in all cases.\n            We must work around that.\n\n            This workaround only applies the static IP during installation, so the\n            installer can access the NFS share. The network settings are also needed\n            in the network directive. Should be called after injectStatic!\n    \"\"\"\n    # collect the info on a dictionary format expected by weasel\n    nic = {\n        \"bootProto\": \"static\",\n        \"ip\": str(provisioningNIC.ipv4Networks[0].ip),\n        \"netmask\": str(provisioningNIC.ipv4Networks[0].netmask),\n        \"vlanID\": 0,\n        \"hostname\": \"localhost\",\n        \"nameserver1\": \"\",\n        \"nameserver2\": \"\",\n        \"device\": None\n    }\n    if provisioningNIC.dnsServers:\n        nic[\"nameserver1\"] = str(provisioningNIC.dnsServers[0])\n    if netinfo.fqdn:\n        nic[\"hostname\"] = netinfo.fqdn\n    if provisioningRoute:\n        nic[\"gateway\"] = str(provisioningRoute.gateway)\n    # create a pre script to apply the static networking\n    pre = Script(\"pre\")\n    pre[\"interpreter\"] = \"python\"\n    pre[\"unsupported\"] = None\n    pre.contents.append(CODE_HEADER)\n    pre.contents.append(CODE_WARNING)\n    # use the public API of the vmware installer (weasel) library\n    pre.contents.append(\"from weasel import networking\")\n    pre.contents.append(\"nic = %s\" % nic)\n    pre.contents.append(\n        \"nic[\\\"device\\\"] = networking.findPhysicalNicByMacAddress('%s')\"\n        % provisioningNIC.macAddress)\n    pre.contents.append(\"networking.connect(nicChoices = nic)\")\n    pre.contents.append(\"networking.enactHostWideUserchoices(nic)\")\n    pre.contents.append(CODE_FOOTER)\n    # inject this pre script\n    ks.scripts.append(pre)\n    # qc 122451 , prevent hostname warning\n    # in order for this to work, it must be called after inject static\n    if \"hostname\" not in ks.network:\n        ks.network[\"hostname\"] = \"localhost\"\n\n\ndef injectRhelWorkaround(ks, provisioningNIC):\n    \"\"\" Rhel <7 does not allow --device=MAC, work around that\"\"\"\n    script = Script(\"pre\")\n    script.contents.append(CODE_HEADER)\n    script.contents.append(CODE_WARNING)\n    # figure out who has  this mac belongs\n    script.contents.append(\"DEV=`ifconfig -a | grep -i 'HWaddr %s' | cut -d' ' -f1`\"\n                           % provisioningNIC.macAddress)\n    script.contents.append(\"if [ -z \\\"$DEV\\\" ] ; then DEV='%s' ; fi\" % provisioningNIC.macAddress)\n    # path the kickstart file\n    script.contents.append(\"sed -i /user.ks.cfg -e \\\"s/--device=%s/--device=$DEV/\\\"\"\n                           % provisioningNIC.macAddress)\n    script.contents.append(CODE_FOOTER)\n    ks.scripts.append(script)\n\n\ndef writeKsFile(ksFile, ks):\n    \"\"\" Write the ks file to disk  \"\"\"\n    ksf = open(ksFile, \"w+\")\n    ksf.write(str(ks))\n    ksf.close()\n\n\ndef getOptions():\n    \"\"\"Returns the command-line options.\"\"\"\n    optparser = OptionParser()\n    optparser.add_option(\"--require-netconfig\", default=\"false\")\n    optparser.add_option(\"--disableWarning\", dest=\"disableWarning\", action=\"store_true\",\n                         default=False,\n                         help=\"Do not show warnings of old hpsa_netconfig format\")\n    (options, args) = optparser.parse_args()\n    del args\n    if not options.require_netconfig.lower() in (\"true\", \"false\"):\n        raise OptionValueError(\n            \"Invalid value for --require-netconfig: %s.\\nShould be 'true' or 'false'.\")\n    options.require_netconfig = options.require_netconfig.lower() == \"true\"\n    return options\n\n\ndef validateNetconfig(provisioningNIC, provisioningRoutes):\n    \"\"\" Perform some additional validation on the netconfig \"\"\"\n    if (\"esxi5\" in TARGET_OS.lower() and\n            (provisioningNIC.ipv4Networks or provisioningNIC.ipv6Networks) and\n            not provisioningRoutes):\n        raise ShowErrorMessage(\"Default gateway is missing from the hpsa_netconfig custom attribute. It is mandatory for this version of ESXi.\")\n\n\ndef main():\n    \"\"\" Configure the Kickstart profile according to the hpsa_netconfig custom attribute\"\"\"\n    try:\n        targetServer = ThisTargetServer()\n        targetServer.setWorkDir(targetServer.getRemoteRoot())\n        keys = helpers.getDataStore(targetServer)\n        options = getOptions()\n\n        if not HPSA_NETCONFIG and options.require_netconfig:\n            print \"Network configuration (hpsa_netconfig) for this server was not found, even though \"\n            print \"it is required by the value true of the custom attribute require_netconfig. \"\n            print \"Check the hpsa_netconfig custom attribute and verify the target server \"\n            print \"has been configured for static networking.\"\n            return 1\n\n        isIPv6Managed = targetServer.isIPv6Managed()\n\n        if \"esxi4\" in TARGET_OS.lower() and isIPv6Managed:\n            print(\"Provisioning on IPv6 not supported for ESXi 4.1.\")\n            return 1\n\n        if keys.platform.full_name:\n            isRhel7 = isRHELCompatible(keys.platform.full_name, 7)\n        else:\n            # platform key not set for ESXi\n            isRhel7 = False\n\n        netconfigParser = SmartNetconfig.readwrite(\n            StringIO(HPSA_NETCONFIG),\n            activeMacAddress=targetServer.getMACAddress(),\n            ipv6default=isIPv6Managed,\n            log=LOG\n        )\n\n        netinfo = netconfigParser.info()\n        if netinfo.oldSyntax and not options.disableWarning:\n            newFormat = netconfigParser.format()\n            print OLD_SYNTAX_WARNING + \"\\n%s\" % str(newFormat)\n\n        typosList = netconfigParser.getTyposList()\n        if typosList:\n            print(\"The following keys were not recognized in the hpsa_netconfig custom attribute and could be typos: %s\" % typosList)\n\n        provisioningNIC = netinfo.getProvisioningNIC()\n\n        mediaUrl = getMediaURL(keys)\n        if (isRhel7 and mediaUrl.scheme == \"nfs\" and\n                isIPv6Managed and provisioningNIC.ipv6Networks and not provisioningNIC.ipv6Autoconfig and\n                isRHEL7CompatibleMedia(\"0\", targetServer, mediaUrl.scheme, \"/\" + mediaUrl.fragment if mediaUrl.fragment else \"/mnt/media\")):\n            print \"Provisioning {platname} over IPv6 on NFS \".format(platname=keys.platform.full_name.replace(\" 7 \", \" 7.0 \")) + \\\n                  \"with only a static network configuration is not supported.\\n\" + \\\n                  \"Enable IPv6 autoconfig or use HTTP/HTTPS for the media.\"\n            return EC_NOT_SUPPORTED\n\n        validation.validateProvisioningNIC(provisioningNIC, targetServer)\n\n        provisioningRoutes = [iproute for iproute in (netinfo.ipv6Routes if isIPv6Managed else netinfo.ipv4Routes)\n                              if iproute.nic == provisioningNIC]\n        provisioningRoute = provisioningRoutes[0] if provisioningRoutes else None\n\n        validateNetconfig(provisioningNIC, provisioningRoutes)\n\n        ksObj = Kickstart(open(KS_PATH), endtags=isRhel7)\n        injectPersonalization(ksObj, netinfo, provisioningNIC, provisioningRoute, isIPv6Managed, isRhel7)\n\n        injectVlanID(provisioningNIC, ksObj)\n\n        if not isRhel7 and \"rhel\" in TARGET_OS.lower():\n            injectRhelWorkaround(ksObj, provisioningNIC)\n        elif \"esxi4\" in TARGET_OS.lower() and provisioningNIC.ipv4Networks:\n            injectVmwareESXi41Workaround(ksObj, netinfo, provisioningNIC, provisioningRoute)\n        writeKsFile(KS_PATH, ksObj)\n        if isRhel7:\n            injectSysctlSettings(isIPv6Managed)\n    except (OSError, IOError, ShowErrorMessage, OptionValueError), why:\n        LOG.exception(why)\n        print \"Failed to inject personalization settings:\\n%s\" % why\n        return EC_EXCEPTION\n\n\nHPSA_NETCONFIG = \"\"\"@hpsa_netconfig@\"\"\"\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n",
            "description": "Injects settings for personalization into a Kickstart installation profile.\nPersonalization settings include network settings.\n\nUsage: inject_ks_personalization_settings.py [OPTIONS]\n\nOptions:\n--require-netconfig=[true,false]\n\tSpecify whether a netconfig is mandatory or not.\n\tOptional argument, defaults to false.\n\n--disableWarning\n    Do not show warnings of old hpsa_netconfig format\n    Optional argument, defaults to false.\n\nPrerequisites:\n- Target server runs a maintenance Linux OS.",
            "status": null,
            "name": "Inject Kickstart Personalization Settings",
            "state": null,
            "eTag": "2015-08-04T07:29:46.000Z",
            "modified": "2015-08-04T07:29:46.000Z",
            "created": "2015-06-13T04:49:22.000Z",
            "category": "os-deployment-ogfs-scripts",
            "uri": "/rest/os-deployment-ogfs-scripts/1310001"
        },
        {
            "codeType": "OGFS",
            "displayCodeType": "OGFS",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "1",
                    "createdBy": "opsware",
                    "createdDate": "2015-06-13T04:49:22.000Z",
                    "usage": "Cleans up files which refer to MAC of source VM",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-06-13T04:49:22.000Z",
            "version": {
                "versionLabel": "1",
                "createdBy": "opsware",
                "createdDate": "2015-06-13T04:49:22.000Z",
                "usage": "Cleans up files which refer to MAC of source VM",
                "current": true
            },
            "source": "#!/usr/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n#\n\"\"\"\n    (C) Copyright 2012-2015 Hewlett-Packard Development Company, L.P.\n\n    Copies a Guest Customization script onto the VM, which will run once, after the next reboot.\n\"\"\"\n\nimport os\nimport sys\nimport glob\n\nfrom osprov.osbp import ThisTargetServer, logger\nfrom osprov import constants\n\nLOG = logger.getIt(\"cleanup_old_macs\")\n\n\ndef main():\n    TARGET = ThisTargetServer()\n    MOUNTED_ROOT_DIR = TARGET.pathToOGFS(constants.OGFS_SYSTEM_ROOT)\n\n    # clean up files with old MAC addresses while still in maintenance mode\n    net_rules_paths = ['/etc/udev/rules.d/30-net_persistent_names.rules',\n                       '/etc/udev/rules.d/70-persistent-net.rules']\n    for net_rules_path in net_rules_paths:\n        net_rules_path = MOUNTED_ROOT_DIR + net_rules_path\n        if os.path.exists(net_rules_path):\n            os.unlink(net_rules_path)\n            LOG.debug(\"Cleaning up file with old MAC address: \" + net_rules_path)\n\n    #Remove any legacy versions of ifcfg files\n    old_file_names_path = MOUNTED_ROOT_DIR + '/etc/sysconfig/network/ifcfg-eth-id*'\n    filenames = glob.glob(old_file_names_path);\n    for filename in filenames:\n        LOG.debug(\"Removing legacy ifcfg files with mac address:\" + filename)\n        os.unlink(filename)\n\nif __name__ == \"__main__\":\n    main()\n",
            "description": "Cleans up files which refer to MAC of source VM",
            "status": null,
            "name": "Clean up old MAC Addresses (SuSE Linux Enterprise Server)",
            "state": null,
            "eTag": "2015-06-13T04:49:22.000Z",
            "modified": "2015-06-13T04:49:22.000Z",
            "created": "2015-06-13T04:49:22.000Z",
            "category": "os-deployment-ogfs-scripts",
            "uri": "/rest/os-deployment-ogfs-scripts/1320001"
        },
        {
            "codeType": "OGFS",
            "displayCodeType": "OGFS",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "1",
                    "createdBy": "opsware",
                    "createdDate": "2015-06-13T04:49:23.000Z",
                    "usage": "This script reboots a target server running an ogfs-agent. \n\nIt also clears any previous boot configuration for the target server. \nIn case network booting was configured it will clear the configuration \non all of the target server's interfaces.\n\nIn case an iLO  manager is registered for the server, the reboot also happens\nif the connection to the agent cannot be made.\n\n\nPrerequisites:\n - Target server runs a Linux or Windows OS or a maintenance Linux or Windows PE OS.",
                    "current": false
                },
                {
                    "versionLabel": "2",
                    "createdBy": "opsware",
                    "createdDate": "2015-08-04T07:29:42.000Z",
                    "usage": "This script reboots a target server running an ogfs-agent. \n\nIt also clears any previous boot configuration for the target server. \nIn case network booting was configured it will clear the configuration \non all of the target server's interfaces.\n\nIn case an iLO  manager is registered for the server, the reboot also happens\nif the connection to the agent cannot be made.\n\n\nPrerequisites:\n - Target server runs a Linux or Windows OS or a maintenance Linux or Windows PE OS.",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-08-04T07:29:42.000Z",
            "version": {
                "versionLabel": "2",
                "createdBy": "opsware",
                "createdDate": "2015-08-04T07:29:42.000Z",
                "usage": "This script reboots a target server running an ogfs-agent. \n\nIt also clears any previous boot configuration for the target server. \nIn case network booting was configured it will clear the configuration \non all of the target server's interfaces.\n\nIn case an iLO  manager is registered for the server, the reboot also happens\nif the connection to the agent cannot be made.\n\n\nPrerequisites:\n - Target server runs a Linux or Windows OS or a maintenance Linux or Windows PE OS.",
                "current": true
            },
            "source": "#!/usr/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n\"\"\"\n    (C) Copyright 2009-2015 Hewlett-Packard Development Company, L.P.\n\n    Initiate a reboot\n\"\"\"\n\nimport sys\nimport os\nimport time\n\nfrom osprov.osbp import ThisTargetServer, logger\nfrom osprov.errors import ShowErrorMessage, NotFoundError\nfrom osprov import boot\nfrom osprov import helpers\nfrom osprov.scripts import bootmode\n\n# pylint: disable=F0401,E0611\nfrom pytwist import twistserver\nfrom pytwist.com.opsware.search import Filter\n# pylint: enable=F0401,E0611\n\nLOG = logger.getIt(\"reboot_agent\")\n\n\ndef main(argv=sys.argv, stdin=sys.stdin,\n         stdout=sys.stdout, stderr=sys.stderr):\n    \"\"\" Reboot the target server\"\"\"\n    sys.stdin = stdin\n    sys.stdout = stdout\n    sys.stderr = stderr\n\n    targetServer = ThisTargetServer()\n\n    keys = helpers.getDataStore(targetServer)\n    if keys.boot.controller:\n        bootController = keys.boot.controller(targetServer, LOG)\n    else:\n        bootController = boot.NetworkBootController(targetServer, LOG)\n\n    try:\n        bootController.clearBoot()\n    except NotFoundError, why:\n        sys.stderr.write(\"Could not clear the boot configuration.\\n\\\n                          This is safe for deployments that do not have\\\n                          OS Provisioning components installed.\\n\\\n                          Reason: %s\\n\" % str(why))\n\n    if (bootmode.getCurrentBootMode(targetServer) == \"LEGACY\"):\n       try:\n           bootController.setOneTimeBootOption(boot.OTB.HDD)\n       except boot.OTBNotSupportedError as why:\n           pass\n    else:\n        print('Server in UEFI boot mode. One Time Boot option was not set to \"Local Disk\"')\n\n    try:\n        print \"Initiating reboot now...\"\n        targetServer.reboot()\n    except (IOError, OSError, ShowErrorMessage), why:\n        LOG.exception(why)\n        sys.stderr.write(\"Failure while initiating reboot: %s\\n\" % why)\n        sys.exit(1)\n\nif __name__ == \"__main__\":\n    main()\n",
            "description": "This script reboots a target server running an ogfs-agent. \n\nIt also clears any previous boot configuration for the target server. \nIn case network booting was configured it will clear the configuration \non all of the target server's interfaces.\n\nIn case an iLO  manager is registered for the server, the reboot also happens\nif the connection to the agent cannot be made.\n\n\nPrerequisites:\n - Target server runs a Linux or Windows OS or a maintenance Linux or Windows PE OS.",
            "status": null,
            "name": "Reboot",
            "state": null,
            "eTag": "2015-08-04T07:29:42.000Z",
            "modified": "2015-08-04T07:29:42.000Z",
            "created": "2015-06-13T04:49:23.000Z",
            "category": "os-deployment-ogfs-scripts",
            "uri": "/rest/os-deployment-ogfs-scripts/1330001"
        },
        {
            "codeType": "OGFS",
            "displayCodeType": "OGFS",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "1",
                    "createdBy": "opsware",
                    "createdDate": "2015-06-13T04:49:24.000Z",
                    "usage": "This script will perform token replacement using ScriptWeaver @AttrName@ style syntax in the target file. Values are obtained from SA custom attribute data on the target server. The placeholder tokens must be surrounded with @ signs.\n\nUsage:\n\nparameterize_text_file.py PATH_TO_FILE [PATH_TO_FILE_2...]\n\nwhere PATH_TO_FILE is the OGFS path or absolute path on the target server to any writable file you would like to perform replacement on.\n\nNOTE that this script is NOT required for ServerScripts and OGFSScripts that are used in OS Build Plans.  The text of any script in an OS Build Plan will automatically be parameterized. Also, the parameters passed to any script used in an OS Build Plan are automatically paramaterized.  This script is only needed when processing other arbitrary files.\n\nAlso note that as of SA 9.0, default values may be provided in the parameterization tokens use @AttrName:Default Value@ syntax separating the custom attribute name from the default value with a colon.\n\nFor example:\n\n@BackupDay:Sunday@ will be replaced with the value of the BackupDay custom attribute. If there is no BackupDay custom attribute, Sunday will be used.\n\nPrerequisites:\n - Target file must be writable.",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-06-13T04:49:24.000Z",
            "version": {
                "versionLabel": "1",
                "createdBy": "opsware",
                "createdDate": "2015-06-13T04:49:24.000Z",
                "usage": "This script will perform token replacement using ScriptWeaver @AttrName@ style syntax in the target file. Values are obtained from SA custom attribute data on the target server. The placeholder tokens must be surrounded with @ signs.\n\nUsage:\n\nparameterize_text_file.py PATH_TO_FILE [PATH_TO_FILE_2...]\n\nwhere PATH_TO_FILE is the OGFS path or absolute path on the target server to any writable file you would like to perform replacement on.\n\nNOTE that this script is NOT required for ServerScripts and OGFSScripts that are used in OS Build Plans.  The text of any script in an OS Build Plan will automatically be parameterized. Also, the parameters passed to any script used in an OS Build Plan are automatically paramaterized.  This script is only needed when processing other arbitrary files.\n\nAlso note that as of SA 9.0, default values may be provided in the parameterization tokens use @AttrName:Default Value@ syntax separating the custom attribute name from the default value with a colon.\n\nFor example:\n\n@BackupDay:Sunday@ will be replaced with the value of the BackupDay custom attribute. If there is no BackupDay custom attribute, Sunday will be used.\n\nPrerequisites:\n - Target file must be writable.",
                "current": true
            },
            "source": "#!/usr/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n#\n\"\"\"\n    (C) Copyright 2011-2015 Hewlett-Packard Development Company, L.P.\n\n    Replaces ScriptWeaver @tokens@ with data from the HP SA model in text files\n\"\"\"\nimport sys\n\nfrom osprov.osbp import ThisTargetServer, scriptweaver\nfrom osprov.osbp import logger\nfrom osprov import helpers\nfrom pytwist.com.opsware.osprov import OSBuildPlanRef\n\nLOG = logger.getIt(\"Parametrize\")\n\ntargetServer = ThisTargetServer()\nkeys = helpers.getDataStore(targetServer, LOG)\n\nfor filePath in sys.argv[1:]:\n    print \"Parameterizing\", filePath\n    filePath = targetServer.pathToOGFS(filePath)\n    inFile = open(filePath)\n    fileData = inFile.read()\n    inFile.close()\n    scriptData = scriptweaver.Translator(\n        serverVO=targetServer.getServerVO(),\n        planRef=OSBuildPlanRef(keys.papx.buildplan_id),\n        twistServer=targetServer.twistServer\n    ).sub(fileData)\n    outFile = open(filePath, \"w\")\n    outFile.write(scriptData)\n    outFile.close()\n",
            "description": "This script will perform token replacement using ScriptWeaver @AttrName@ style syntax in the target file. Values are obtained from SA custom attribute data on the target server. The placeholder tokens must be surrounded with @ signs.\n\nUsage:\n\nparameterize_text_file.py PATH_TO_FILE [PATH_TO_FILE_2...]\n\nwhere PATH_TO_FILE is the OGFS path or absolute path on the target server to any writable file you would like to perform replacement on.\n\nNOTE that this script is NOT required for ServerScripts and OGFSScripts that are used in OS Build Plans.  The text of any script in an OS Build Plan will automatically be parameterized. Also, the parameters passed to any script used in an OS Build Plan are automatically paramaterized.  This script is only needed when processing other arbitrary files.\n\nAlso note that as of SA 9.0, default values may be provided in the parameterization tokens use @AttrName:Default Value@ syntax separating the custom attribute name from the default value with a colon.\n\nFor example:\n\n@BackupDay:Sunday@ will be replaced with the value of the BackupDay custom attribute. If there is no BackupDay custom attribute, Sunday will be used.\n\nPrerequisites:\n - Target file must be writable.",
            "status": null,
            "name": "Parameterize Text File",
            "state": null,
            "eTag": "2015-06-13T04:49:24.000Z",
            "modified": "2015-06-13T04:49:24.000Z",
            "created": "2015-06-13T04:49:23.000Z",
            "category": "os-deployment-ogfs-scripts",
            "uri": "/rest/os-deployment-ogfs-scripts/1350001"
        },
        {
            "codeType": "OGFS",
            "displayCodeType": "OGFS",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "1",
                    "createdBy": "opsware",
                    "createdDate": "2015-06-13T04:49:24.000Z",
                    "usage": "Monitors a given log file every DELAY seconds and timeouts after\nCOUNT checks in which the log has not changed.\n\nIf no log file is given it will monitor the installation log for the supported installers:\n- Red Hat, CentOS and OEL\n- SLES\n- Ubuntu\n- Solaris 10\n- Solaris 11 AI\n\nusage: monitor_install_log.py [options]\n\noptions:\n  -h, --help     show this help message and exit\n  --log=LOG      the log file that will be monitored\n  --count=COUNT  the number of times it counts before timing out\n  --delay=DELAY  the delay in seconds between every log check\n\nPrerequisites:\n  - Script needs to be run as part of a build plan.",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-06-13T04:49:24.000Z",
            "version": {
                "versionLabel": "1",
                "createdBy": "opsware",
                "createdDate": "2015-06-13T04:49:24.000Z",
                "usage": "Monitors a given log file every DELAY seconds and timeouts after\nCOUNT checks in which the log has not changed.\n\nIf no log file is given it will monitor the installation log for the supported installers:\n- Red Hat, CentOS and OEL\n- SLES\n- Ubuntu\n- Solaris 10\n- Solaris 11 AI\n\nusage: monitor_install_log.py [options]\n\noptions:\n  -h, --help     show this help message and exit\n  --log=LOG      the log file that will be monitored\n  --count=COUNT  the number of times it counts before timing out\n  --delay=DELAY  the delay in seconds between every log check\n\nPrerequisites:\n  - Script needs to be run as part of a build plan.",
                "current": true
            },
            "source": "#!/usr/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n#\n\"\"\"\n    (C) Copyright 2014-2015 Hewlett-Packard Development Company, L.P.\n\n    Monitors a given log file every DELAY seconds and timeouts after\n    COUNT checks in which the log has not changed.\n\n    If no log file is given it will monitor the installation log for the supported installers:\n    - Red Hat, CentOS and OEL\n    - SLES\n    - Ubuntu\n    - Solaris 10\n    - Solaris 11 AI\n\"\"\"\n\nimport os\nimport sys\nimport time\nfrom optparse import OptionError\nfrom StringIO import StringIO\n\nfrom librunplan import PlanOutputHandler\n\nfrom osprov import platform_util\nfrom osprov.decorators import HandleShowErrorMessage\nfrom osprov.errors import ShowErrorMessage, TimeoutError, NotSupportedError, ProcessExecutionError\nfrom osprov.optparse_ext import OptionParser\nfrom osprov.osbp import ThisTargetServer, logger\nfrom osprov.osbp.constants import MONITORING_STOP_FLAG\n\n# waits CHECK_DELAY * TIMEOUT_COUNT, 10 minutes by default\n\nCHECK_DELAY = 6  # seconds\nTIMEOUT_COUNT = 100\n\nLOG = logger.getIt(\"Monitor Installation\")\n\n\nclass MonitorStepOptionsParser(OptionParser):\n\n    \"\"\" An options' parser for this step. \"\"\"\n\n    def defineOptions(self):\n        self.add_option(\"--log\", help=\"the log file that will be monitored\")\n        self.add_option(\"--count\", default=TIMEOUT_COUNT, type=int,\n                        help=\"the number of times it counts before timing out\")\n        self.add_option(\"--delay\", default=CHECK_DELAY, type=float,\n                        help=\"the delay in seconds between every log check\")\n\n    def validateArgs(self, opt, args):\n        if opt.count and opt.count < 0:\n            raise OptionError(\"not a positive number\", \"count\")\n        if opt.delay and opt.delay < 0:\n            raise OptionError(\"not a positive number\", \"delay\")\n\n\nclass LogMonitor (object):\n\n    \"\"\" Monitors logs until one of the stop files is encountered or times out. \"\"\"\n\n    def __init__(self, targetServer, logPath, stopFilePaths=(MONITORING_STOP_FLAG,), output=PlanOutputHandler()):\n        self.targetServer = targetServer\n        self.output = output\n        self.logPath = self.targetServer.pathToOGFS(logPath)\n        self.stopFilePaths = [self.targetServer.pathToOGFS(path) for path in stopFilePaths]\n        self.lastLine = None\n        self.checkDelaySeconds = 6\n        self.defaultTimeoutCount = 100\n        self.timeoutCount = self.defaultTimeoutCount\n        self.numberOfReportedLines = 50\n        self._cachedLastLines = []\n        self.installFailedUserMessage = \"\"\n\n    def waitForLogFile(self):\n        \"\"\"Waits self.checkDelay * self.timeoutCount for self.logPath to appear.\"\"\"\n        failedCheckCount = 0\n        while failedCheckCount < self.timeoutCount:\n            if os.path.exists(self.logPath):\n                return\n            else:\n                failedCheckCount += 1\n            time.sleep(self.checkDelaySeconds)\n        else:\n            raise ShowErrorMessage(\"The install log %s did not appear.\" % self.logPath)\n\n    def _generateLog(self):\n        raise NotImplementedError(\"abstract\")\n\n    def _openLog(self, canGenerate=True):\n        \"\"\" Returns a file object to self.logPath. \"\"\"\n        return open(self.logPath, \"rb\")\n\n    def getLastLines(self, count, canGenerate=True):\n        \"\"\"Returns the last lineNo lines of supplied file object.\"\"\"\n        try:\n            self._cachedLastLines = self._openLog(canGenerate=canGenerate).readlines()[-count:]\n            return self._cachedLastLines\n        except IOError, error:\n            LOG.error(\"Failed to read the log file\")\n            LOG.exception(error)\n            self._cachedLastLines = []\n            return []\n\n    def getLatestLines(self):\n        \"\"\" Returns the latest lines from the log file.\"\"\"\n        lastLines = self.getLastLines(self.numberOfReportedLines)\n        if not lastLines:\n            return []\n        if self.lastLine is None:\n            self.lastLine = lastLines[-1]\n            return lastLines\n        else:\n            curLastLine = lastLines[-1]\n            if curLastLine == self.lastLine:\n                return []\n            else:\n                self.lastLine = curLastLine\n                return lastLines\n\n    def isInstallDone(self):\n        \"\"\" Returns True if the installation has finished. \"\"\"\n        for path in self.stopFilePaths:\n            if os.path.exists(path):\n                return True\n        else:\n            return False\n\n    def isInstallFailed(self):\n        \"\"\"\n        Returns True if the installation is known to have failed.\n        To be implemented by subclasses if needed.\n        \"\"\"\n\n        return False\n\n    def adjustTimeout(self):\n        \"\"\"Hook for dynamically adjusting the timeout. Gets called at each iteration. \"\"\"\n\n        pass\n\n    def main(self):\n        \"\"\" Main monitoring function \"\"\"\n        print(\"Monitoring %s log file\" % self.logPath)\n\n        print(\"Waiting for %s to appear\" % self.logPath)\n        self.waitForLogFile()\n        print(\"Found the log file\")\n\n        failedCheckCount = 0\n        while failedCheckCount < self.timeoutCount and not self.isInstallDone() and not self.isInstallFailed():\n            lastLines = self.getLatestLines()\n            if lastLines:\n                failedCheckCount = 0\n                self.output.replaceMessages(\"Monitoring Installation\", \"\".join(lastLines))\n            else:\n                failedCheckCount += 1\n            self.adjustTimeout()\n            time.sleep(self.checkDelaySeconds)\n        else:\n            print(\"Here are the last %d lines of the log:\" % self.numberOfReportedLines)\n            print(\"\".join(self.getLastLines(self.numberOfReportedLines, canGenerate=False)))\n            if self.isInstallDone():\n                print(\"Installation completed.\")\n                return 0\n            elif self.isInstallFailed():\n                raise ShowErrorMessage(\n                    \"The installation failed: %s\" % self.installFailedUserMessage)\n            else:\n                raise TimeoutError(\"Monitoring the log file timed out.\")\n\n\nclass RPMBasedInstallerLogMonitor(LogMonitor):\n\n    def __init__(self, targetServer, logPath, stopFilePaths=(MONITORING_STOP_FLAG,), output=PlanOutputHandler(), rpmArguments=\"\"):\n        LogMonitor.__init__(self, targetServer, logPath, stopFilePaths, output)\n        self._rpmArguments = rpmArguments\n\n    def _openLog(self, canGenerate=True):\n        if canGenerate:\n            generatedLog = self._generateLog()\n            if generatedLog.strip():\n                return StringIO(generatedLog)\n        return open(self.logPath, \"rb\")\n\n    def _generateLog(self):\n        try:\n            return self.targetServer.rosh().getStdout(\n                \"\\\"rpm {rpmArguments} -qa --queryformat '{queryFormat}' | sort -n | tail -n 50 \\\"\".format(\n                    rpmArguments=self._rpmArguments,\n                    queryFormat=\"(%{installtime:date}) Installed rpm: %{name}\\n\"\n                ),\n            )\n        except ProcessExecutionError, e:\n            LOG.exception(e)\n            return \"\"\n\n\nclass Rhel5InstallationLogMonitor(LogMonitor):\n\n    def __init__(self, targetServer):\n        LogMonitor.__init__(\n            self, targetServer,\n            logPath=\"/tmp/anaconda.log\",\n            stopFilePaths=(\n                os.path.join(\"/mnt/sysimage/tmp\", os.path.basename(MONITORING_STOP_FLAG)),\n                MONITORING_STOP_FLAG\n            )\n        )\n\n\nclass Rhel6InstallationLogMonitor(RPMBasedInstallerLogMonitor):\n\n    def __init__(self, targetServer):\n        RPMBasedInstallerLogMonitor.__init__(\n            self, targetServer,\n            logPath=\"/tmp/anaconda.log\",\n            stopFilePaths=(\n                os.path.join(\"/mnt/sysimage/tmp\", os.path.basename(MONITORING_STOP_FLAG)),\n                MONITORING_STOP_FLAG\n            )\n        )\n\n\nclass Rhel7InstallationLogMonitor(LogMonitor):\n\n    def __init__(self, targetServer):\n        LogMonitor.__init__(\n            self, targetServer,\n            logPath=\"/tmp/packaging.log\",\n            stopFilePaths=(\n                os.path.join(\"/mnt/sysimage/tmp\", os.path.basename(MONITORING_STOP_FLAG)),\n                MONITORING_STOP_FLAG,\n            )\n        )\n\n\nclass SlesInstallationLogMonitor(RPMBasedInstallerLogMonitor):\n    def __init__(self, targetServer):\n        RPMBasedInstallerLogMonitor.__init__(\n            self, targetServer,\n            logPath=\"/var/log/YaST2/y2log\",\n            stopFilePaths=(\n                os.path.join(\"/mnt/tmp\", os.path.basename(MONITORING_STOP_FLAG)),\n                MONITORING_STOP_FLAG\n            ),\n            rpmArguments=\"--dbpath /mnt/var/lib/rpm\"\n        )\n\n\nclass UbuntuInstallationLogMonitor(LogMonitor):\n\n    def __init__(self, targetServer):\n        LogMonitor.__init__(self, targetServer, \"/var/log/syslog\")\n\n\nclass Solaris11InstallationMonitor(LogMonitor):\n\n    def __init__(self, targetServer):\n        LogMonitor.__init__(self, targetServer, \"/system/volatile/install_log\")\n        self.installDoneMessage = \"automated installation succeeded\"\n        self.installFailedMessage = \"automated installation failed\"\n        self.installFailedUserMessage = \"The install log reported failure.\"\n        self._installPhaseStartedMessage = \"install phase ... started\"\n        self._installPhaseDoneMessage = \"install phase ... done\"\n\n    def isInstallDone(self):\n        \"\"\" Returns True if the installation has finished. \"\"\"\n        return self.installDoneMessage in \"\\n\".join(self._cachedLastLines).lower()\n\n    def isInstallFailed(self):\n        \"\"\"Return True if the install log contains a failure message.\"\"\"\n        return self.installFailedMessage in \"\\n\".join(self._cachedLastLines).lower()\n\n    def adjustTimeout(self):\n        \"\"\"Sets a larger timeout after the 'Install Phase ... Started' message is detected in the log.\"\"\"\n        if self._installPhaseStartedMessage in \"\\n\".join(self._cachedLastLines).lower():\n            self.timeoutCount = 600\n        if self._installPhaseDoneMessage in \"\\n\".join(self._cachedLastLines).lower():\n            self.timeoutCount = self.defaultTimeoutCount\n\n\nclass Solaris10InstallationMonitor(LogMonitor):\n\n    def __init__(self, targetServer):\n        LogMonitor.__init__(self, targetServer, \"/a/var/sadm/system/logs/install_log\")\n        self.installFailedMessage = \"installation: failed\"\n        self.installFailedUserMessage = \"The install log reported failure.\"\n\n    def isInstallFailed(self):\n        \"\"\"Return True if the install log contains a failure message.\"\"\"\n        return self.installFailedMessage in \"\\n\".join(self._cachedLastLines).lower()\n\n\ndef factorLogMonitor(targetServer):\n    \"\"\" Return a LogMonitor based on the reported OS version\"\"\"\n    osVersion = targetServer.getServerVO().getOsVersion().lower()\n    if platform_util.isSLES(osVersion):\n        return SlesInstallationLogMonitor(targetServer)\n    elif platform_util.isRHELCompatible(osVersion, version=5):\n        return Rhel5InstallationLogMonitor(targetServer)\n    elif platform_util.isRHELCompatible(osVersion, version=6):\n        return Rhel6InstallationLogMonitor(targetServer)\n    elif platform_util.isRHELCompatible(osVersion, version=7):\n        return Rhel7InstallationLogMonitor(targetServer)\n    elif platform_util.isUbuntu(osVersion):\n        return UbuntuInstallationLogMonitor(targetServer)\n    elif platform_util.isSolaris(osVersion, version=11):\n        return Solaris11InstallationMonitor(targetServer)\n    elif platform_util.isSolaris(osVersion, version=10):\n        return Solaris10InstallationMonitor(targetServer)\n    raise NotSupportedError(\"Monitoring installation for %s is not supported\" % osVersion)\n\n\n@HandleShowErrorMessage(\"monitor installation\", LOG)\ndef main():\n    options, remainingArgs = MonitorStepOptionsParser().parse_args()\n\n    targetServer = ThisTargetServer()\n\n    logFile = options.log\n    if not logFile:\n        logMonitor = factorLogMonitor(targetServer)\n    else:\n        logMonitor = LogMonitor(targetServer, logFile)\n    logMonitor.checkDelaySeconds = options.delay\n    logMonitor.timeoutCount = options.count\n\n    return logMonitor.main()\n\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n",
            "description": "Monitors a given log file every DELAY seconds and timeouts after\nCOUNT checks in which the log has not changed.\n\nIf no log file is given it will monitor the installation log for the supported installers:\n- Red Hat, CentOS and OEL\n- SLES\n- Ubuntu\n- Solaris 10\n- Solaris 11 AI\n\nusage: monitor_install_log.py [options]\n\noptions:\n  -h, --help     show this help message and exit\n  --log=LOG      the log file that will be monitored\n  --count=COUNT  the number of times it counts before timing out\n  --delay=DELAY  the delay in seconds between every log check\n\nPrerequisites:\n  - Script needs to be run as part of a build plan.",
            "status": null,
            "name": "Monitor Ubuntu Installation",
            "state": null,
            "eTag": "2015-06-13T04:49:24.000Z",
            "modified": "2015-06-13T04:49:24.000Z",
            "created": "2015-06-13T04:49:24.000Z",
            "category": "os-deployment-ogfs-scripts",
            "uri": "/rest/os-deployment-ogfs-scripts/1360001"
        },
        {
            "codeType": "OGFS",
            "displayCodeType": "OGFS",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "175",
                    "createdBy": "opsware",
                    "createdDate": "2015-08-04T07:29:44.000Z",
                    "usage": "Validates the custom attributes defined in the parameter field and fails the OS Build Plan if any custom attribute does not have a value associated with it.\n\nRequired Parameters:  \n--custAttrNames \"custAttrName1 custAttrName2 custAttrName3 ... custAttrNameN\"   The parameter list is a space-separated list of custom attribute names contained inside double quotes.\nMinimum of one custom attribute name is needed.\n\nCustom Attributes:  None",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-08-04T07:29:44.000Z",
            "version": {
                "versionLabel": "175",
                "createdBy": "opsware",
                "createdDate": "2015-08-04T07:29:44.000Z",
                "usage": "Validates the custom attributes defined in the parameter field and fails the OS Build Plan if any custom attribute does not have a value associated with it.\n\nRequired Parameters:  \n--custAttrNames \"custAttrName1 custAttrName2 custAttrName3 ... custAttrNameN\"   The parameter list is a space-separated list of custom attribute names contained inside double quotes.\nMinimum of one custom attribute name is needed.\n\nCustom Attributes:  None",
                "current": true
            },
            "source": "#!/usr/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n# (C) Copyright 2013-2015 Hewlett-Packard Development Company, L.P.\n#\n\"\"\"\nValidates the custom attributes and fails the build plan if any of the custom attributes\ndoesn't have a value associated with it.\n\"\"\"\nimport optparse\nimport sys\n\nfrom osprov.osbp.scriptweaver import Translator\nfrom osprov.osbp import ThisTargetServer\nfrom osprov.errors import ShowErrorMessage\nfrom osprov       import helpers\nfrom pytwist.com.opsware.osprov import OSBuildPlanRef\n\n#pylint: disable=F0401,E0611\nfrom pytwist.com.opsware.custattr import NoSuchFieldException\n#pylint: enable=F0401,E0611\n\nEC_USAGE = 1\nEC_EXCEPTION = 2\nEC_TARGET_SERVER = 5\nEC_CUST_ATTR = 6\n\nHELP_MESSAGE = \"\"\"\\nSee the online help for more information about defining and using custom attributes and for\\ninformation about commonly used custom attributes.\"\"\"\n\n# This class is used to validate that the custom attributes, whose names were passed in using the \"--custAttrNames\" parameter,\n# contain a value (e.g. are not empty).\nclass CustomAttributeValidator(object):\n\n\tCA_Failed = False\n\n\tdef __init__(self, twistServer, targetServer, buildPlanRef):\n\t\tself.twistServer = twistServer\n\t\tself.targetServer = targetServer\n\t\tself.serverRef = targetServer.serverRef\n\t\tself.buildPlanRef = buildPlanRef\n\n\t# Validate the custom attribute specified by \"caName\".\n\tdef validateCA(self, caName):\n\t\t# Get the value of the custom attribute whose name is contained in the variable \"caName\".\n\t\tcaValue = Translator(self.targetServer.getServerVO(), self.buildPlanRef).sub(\"@\" + caName + \"@\")\n\n\t\t# If the custom attribute \"--custAttrNames \"WimFileName\"\"  and the value is not set, then it's an error.\n\t\tif caName.strip() == \"WimFileName\" and (not caValue or len(caValue.strip()) == 0):\n\t\t\tErrorMessage=\"\"\"\\nThe 'WimFileName' custom attribute is not set. This custom attribute is required for this \\nbuild plan and specifies the file name for the WIM image you are creating or installing. \\nThe captured Windows image (WIM image) will always be located in the Images folder on your \\nMedia Server unless you modify the parameters to the Windows Image Capture and Windows \\nImage Install OS Build Plan steps to use another folder.\"\"\"\n\t\t\tsys.stderr.write(\"%s\\n\" % ErrorMessage)\n\t\t\tself.CA_Failed = True\n\t\t# If the custom attribute \"--custAttrNames \"HBA_Config\"\"  and the value is not set, then it's an error.\n\t\telif caName.strip() == \"HBA_Config\" and (not caValue or len(caValue.strip()) == 0):\n\t\t\tErrorMessage=\"\"\"\\nThe 'HBA_Config' custom attribute is not set. This custom attribute is required for this build \\nplan and contains the configuration information for the HBA being configured. See \"Configure \\nthe boot device on a Fibre Channel HBA\" in the online help for more details.\"\"\"\n\t\t\tsys.stderr.write(\"%s\\n\" % ErrorMessage)\n\t\t\tself.CA_Failed = True\n\t\t# If the custom attribute \"--custAttrNames \"ProductKey_*\"\"  and the value is not set, then it's an error.\n\t\telif (\"ProductKey\" in caName.strip()) and (not caValue or len(caValue.strip()) == 0):\n\t\t\tErrorMessage=\"\"\"\\nThe '\"\"\" + caName + \"\"\"' custom attribute is not set. This custom attribute is \\nrequired for this build plan and represents the product key required to install Windows, \\nset by entering product keys from the Settings page of your appliance. If you intend to \\ninstall Windows without a product key, you can remove this step from your build plan.\"\"\"\n\t\t\tsys.stderr.write(\"%s\\n\" % ErrorMessage)\n\t\t\tself.CA_Failed = True\n\t\t# If the  custom attribute is not set, then it's an error. \n\t\telif (not caValue or len(caValue.strip()) == 0):\n\t\t\tErrorMessage=\"\"\"\\nThe '\"\"\" + caName + \"\"\"' custom attribute is required for this build plan and is not set. \\nThis step validates the custom attributes defined in the parameter field and fails the \\nOS Build Plan if any custom attribute does not have a value associated with it. \\n\\nSee the author of this build plan for information about this custom attribute.\"\"\"\n\t\t\tsys.stderr.write(\"%s\\n\" % ErrorMessage)\n\t\t\tself.CA_Failed = True\n\n\n\t# Validate the custom attributes whose names appear in the string \"caNames\".\n\tdef validateCAs(self, caNames):\n\t\t# If the  custom attribute Invalid, then it's an error.\n\t\tif not caNames or len(caNames.strip()) == 0:\n\t\t\tErrorMessage=\"\"\"\\nNo parameters specified. Specify a list of space separated custom attribute names using the\\n--custAttrNames parameter.\"\"\"\n\t\t\traise ShowErrorMessage(ErrorMessage, EC_CUST_ATTR)\n\n\t\t# Parse the space-separated list of custom attribute names and put them into an array.\n\t\tnameArray = caNames.split()\n\n\t\t# Validate each custom attribute contained in the array.\n\t\tfor caName in nameArray:\n\t\t\tself.validateCA(caName)\n\t\t\t\n\t\tif self.CA_Failed == True:\n\t\t\tsys.stderr.write(\"%s\\n\" % HELP_MESSAGE)\n\t\t\tsys.exit(EC_CUST_ATTR)\n\t\t\t\n\n# This method parses the parameters to this script.\ndef parseArgs(args):\n\n\t# If the  custom attribute Invalid, then it's an error.\n\tif len(args) >= 1 and (\"--custAttrNames\" not in args):\n        ErrorMessage=\"\"\"\\nInvalid parameters specified. Specify a list of space separated custom attribute names using \\nthe --custAttrNames parameter for this step.\"\"\"\n\t\tsys.stderr.write(\"%s\\n\" % ErrorMessage)\n\t\tsys.stderr.write(\"%s\\n\" % HELP_MESSAGE)\n\t\tsys.exit(EC_USAGE)\n\t# If no custom attribute specified, then it's an error.\n\telif len(args) < 2 and (\"--custAttrNames\" in args):\n\t\tErrorMessage=\"\"\"\\nNo custom attribute specified. Specify a list of space separated custom attribute names \\nusing the --custAttrNames parameter for this step.\"\"\"\n\t\tsys.stderr.write(\"%s\\n\" % ErrorMessage)\n\t\tsys.stderr.write(\"%s\\n\" % HELP_MESSAGE)\n\t\tsys.exit(EC_USAGE)\n\n\t# setup and return parsed arguments\n\tparser = optparse.OptionParser(\n\t\tdescription=__doc__,\n\t\tversion=\"1.1.0\",\n\t\tusage=\"%prog [--custAttrNames \\\"<space separated list of custom attribute names>\\\"]\"\n\t)\n\n\tparser.add_option(\"-c\", \"--custAttrNames\", dest=\"custAttrNames\", metavar=\"\",\n\t\thelp=\"This flag controls whether a custom attribute is valid.\")\n   \n\treturn parser.parse_args(args)\n\ndef main():\n\n\topt, args = parseArgs(sys.argv[1:])\n\t\n\ttargetServer = ThisTargetServer()\n\n\tkeys = helpers.getDataStore(targetServer)\n\n\tvalidator = CustomAttributeValidator(targetServer.twistServer, targetServer, OSBuildPlanRef(keys.papx.buildplan_id))\n\t\n\ttry:\n\t\t# Validate the custom attributes.\n\t\tvalidator.validateCAs(opt.custAttrNames)\n\texcept ShowErrorMessage, why:\n\t\tsys.stderr.write(\"%s\\n\" % why)\n\t\tsys.stderr.write(\"%s\\n\" % HELP_MESSAGE)\n\t\treturn why.exitCode\n\nif __name__ == \"__main__\":\n\tsys.exit(main())\n",
            "description": "Validates the custom attributes defined in the parameter field and fails the OS Build Plan if any custom attribute does not have a value associated with it.\n\nRequired Parameters:  \n--custAttrNames \"custAttrName1 custAttrName2 custAttrName3 ... custAttrNameN\"   The parameter list is a space-separated list of custom attribute names contained inside double quotes.\nMinimum of one custom attribute name is needed.\n\nCustom Attributes:  None",
            "status": null,
            "name": "Validate Custom Attributes",
            "state": null,
            "eTag": "2015-08-04T07:29:44.000Z",
            "modified": "2015-08-04T07:29:44.000Z",
            "created": "2015-08-04T07:29:43.000Z",
            "category": "os-deployment-ogfs-scripts",
            "uri": "/rest/os-deployment-ogfs-scripts/1460001"
        },
        {
            "codeType": "OGFS",
            "displayCodeType": "OGFS",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "38",
                    "createdBy": "opsware",
                    "createdDate": "2015-08-04T07:29:46.000Z",
                    "usage": "On servers configured in UEFI boot mode, this script will force the server into the Intelligent Provisioning Linux Service OS after the ESXi installation has completed, where it will add an ESXi boot option to the UEFI boot menu.  The disk partition with the \"ESXi\" label is assumed to be the EFI System Partition and will be used when creating the ESXi boot option.\n\nThis step is skipped if the server is not configured in UEFI boot mode.\n\nOptions:\n  --atLeast=MINUTES  The number of minutes to wait before setting a one-time boot to Intelligent Provisioning.  Since a one-time boot cannot be set while a server is going through POST (Power On Self Test), this option can be used to give the server time to complete POST after it has rebooted. Default is 1 minutes.After the wait time,script will retry to set one-time boot after every 30 seconds till it succeeds.Script will throw an error if one-time boot is not set after 20 retrials.\n  --atMost=MINUTES  The number of minutes to wait for this script to complete after it has configured the server to one-time boot into Intelligent Provisioning. Default is 45 minutes.\n  --bootOptionName=NAME  The name of the boot option that you want added to the UEFI boot menu. Default is \"ESXi\".\n  --efiSystemPartitionLabel=PARTITION_LABEL  The label assigned by the ESXi installer to the EFI System Partition. This option should only be used if the ESXi installer assigns a different label to the EFI System Partition. Default is \"ESXi\". ",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-08-04T07:29:46.000Z",
            "version": {
                "versionLabel": "38",
                "createdBy": "opsware",
                "createdDate": "2015-08-04T07:29:46.000Z",
                "usage": "On servers configured in UEFI boot mode, this script will force the server into the Intelligent Provisioning Linux Service OS after the ESXi installation has completed, where it will add an ESXi boot option to the UEFI boot menu.  The disk partition with the \"ESXi\" label is assumed to be the EFI System Partition and will be used when creating the ESXi boot option.\n\nThis step is skipped if the server is not configured in UEFI boot mode.\n\nOptions:\n  --atLeast=MINUTES  The number of minutes to wait before setting a one-time boot to Intelligent Provisioning.  Since a one-time boot cannot be set while a server is going through POST (Power On Self Test), this option can be used to give the server time to complete POST after it has rebooted. Default is 1 minutes.After the wait time,script will retry to set one-time boot after every 30 seconds till it succeeds.Script will throw an error if one-time boot is not set after 20 retrials.\n  --atMost=MINUTES  The number of minutes to wait for this script to complete after it has configured the server to one-time boot into Intelligent Provisioning. Default is 45 minutes.\n  --bootOptionName=NAME  The name of the boot option that you want added to the UEFI boot menu. Default is \"ESXi\".\n  --efiSystemPartitionLabel=PARTITION_LABEL  The label assigned by the ESXi installer to the EFI System Partition. This option should only be used if the ESXi installer assigns a different label to the EFI System Partition. Default is \"ESXi\". ",
                "current": true
            },
            "source": "#!/usr/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n#\n\"\"\"\n(C) Copyright 2014-2015 Hewlett-Packard Development Company, L.P.\n\"\"\"\n\nimport sys\nimport re\nimport datetime\nimport time\nfrom optparse import OptionParser\nfrom osprov import boot\nfrom osprov import ilo\nfrom osprov.osbp import ThisTargetServer, logger\nfrom osprov.util.twist import toByteList, toPyString\nfrom pytwist.com.opsware.common import OpswareException, OpswareSystemException\n\nDEBUG=@Debug:0@\n\nILO_PERMANENT_NAMESPACE = \"PERM\"\nILO_TEMPORARY_NAMESPACE = \"TMP\"\nSMARTSTART_SSSTK = \"SMARTSTART_SSSTK\"\nICSP_SMARTSTART_SSSTK_PARAMS = \"ICSP_SMARTSTART_SSSTK_PARAMS\"\nICSP_SMARTSTART_SSSTK_OUTPUT = \"ICSP_SMARTSTART_SSSTK_OUTPUT\"\nICSP_SMARTSTART_SSSTK_STATUS = \"ICSP_SMARTSTART_SSSTK_STATUS\"\n\nWAIT_AT_LEAST = 1\nWAIT_AT_MOST = 45\n\nEC_SUCCESS = 0\nEC_FAILED = 1\n\nlog = logger.getIt(\"Add ESXi Boot Option To UEFI Boot Order On Next Reboot\")\n\n###############################################################################\n###############################################################################\n##\n## Begin SMARTSTART_SSSTK Intelligent Provisioning startup script\n##\n###############################################################################\n###############################################################################\n\n# This is a Python here document containing the script that we are going to\n# place in the SMARTSTART_SSSTK blob.  The SMARTSTART_SSSTK blob is a special\n# blob which Intelligent Provisioning reads when it starts up and executes the\n# script contained inside the blob.\nsmartstartSsstkScript = \"\"\"\\\n#!/bin/bash\n\n# This is a BASH here document containing the Python script that runs inside IP.\nPYTHON_SCRIPT=$(cat <<EOF\n#!/usr/bin/python\nimport sys\nimport re\nimport subprocess\nimport os.path\nfrom subprocess import Popen, PIPE, STDOUT\nfrom optparse import OptionParser\n\n# Parses the command line arguments.\ndef parseArgs(args):\n    parser = OptionParser()\n    parser.add_option(\"--bootOptionName\",\n            default = \"ESXi\",\n            dest = \"bootOptionName\",\n            help = \"The name of the ESXi boot option to add to the UEFI boot menu.\")\n    parser.add_option(\"--efiSystemPartitionLabel\",\n            default = \"ESXi\",\n            dest = \"efiSystemPartitionLabel\",\n            help = \"The label assigned to the EFI System Partition by the ESXi installer.\")\n    options, args = parser.parse_args(args)\n    if args:\n        parser.error(\"Additional positional arguments are not supported\")\n    return options, args\n\n# Converts the specified list to a string that is delimited by the specified\n# delimiter character (default = ' ').\ndef listToString(list, delimeter=' '):\n\n    str = delimeter.join(list)\n\n    return str\n\n# Executes the specified command, which must be a list contaning the \n# executable name and its arguments.\ndef executeCommand(cmdArgs):\n\n    cmdAsString = listToString(cmdArgs)\n\n    print \"Executing => \", cmdAsString\n\n    p = subprocess.Popen(cmdArgs, stdout=subprocess.PIPE, stderr=STDOUT)\n\n    output = p.communicate()[0].strip()\n\n    retCode = p.poll()\n\n    p.stdout.close()\n\n    return retCode, output\n\n# Returns the device name of the disk partition that has the specified\n# disk label assigned to it.\ndef getDeviceWithESXiLabel(efiSystemPartitionLabel):\n\n    byLabelPath = \"/dev/disk/by-label/\" + efiSystemPartitionLabel\n\n    # Check if there's a disk with the \"ESXi\" label.\n    if (os.path.exists(byLabelPath)):\n        print \"'%s' exists\" % byLabelPath\n\n        if (os.path.islink(byLabelPath)):\n            print \"'%s' is a symlink\" % byLabelPath\n        else:\n            print \"'%s' is not a symlink\" % byLabelPath\n            raise Exception(\"'%s' is not a symlink\" % byLabelPath)\n    else:\n        print \"'%s' not found\" % byLabelPath\n        raise Exception(\"'%s' not found\" % byLabelPath)\n\n    deviceName = os.path.realpath(byLabelPath)\n\n    print \"'%s' label maps to device '%s'\" % (byLabelPath,deviceName)\n\n    devicePattern = re.compile(r\"^([\\S]+)([\\d]+)\\s*$\")\n\n    disk = None\n    partition = None\n\n    result = devicePattern.search(deviceName)\n\n    if result:\n        disk = result.group(1)\n        partition = result.group(2)\n\n    print \"The ESXi EFI System Partition is on disk '%s' partition '%s'\" % (disk,partition)\n\n    return disk, partition\n\n# Shows the disk labels on the target.(for troubleshooting)\ndef showDiskLabels():\n\n    cmdArgs = [\"ls\", \"-l\", \"/dev/disk/by-label\"]\n\n    retCode, output = executeCommand(cmdArgs)\n\n    if (retCode == 0):\n        print \"Found the following disk labels:\"\n        print output\n    else:\n        print \"Failed to get the disk labels\"\n        raise Exception(\"An error occurred while executing '%s' : %s\" % (listToString(cmdArgs), output))\n\n# Shows the disk partitions on the target.(for troubleshooting)\ndef showDiskPartitions():\n\n    cmdArgs = [\"cat\", \"/proc/partitions\"]\n\n    retCode, output = executeCommand(cmdArgs)\n\n    if (retCode == 0):\n        print \"Found the following disk partitions:\"\n        print output\n    else:\n        print \"Failed to get the disk partitions\"\n        raise Exception(\"An error occurred while executing '%s' : %s\" % (listToString(cmdArgs), output))\n\n# Adds the specified boot option name to the UEFI boot menu, which points\n# to the ESXi boot loader on the disk partition that has the specified\n# partition label assigned to it.\ndef addUefiBootOptionForESXi( efiSystemPartitionLabel, bootOptionName):\n\n    disk, partition = getDeviceWithESXiLabel(efiSystemPartitionLabel)\n\n    cmdArgs = [\"efibootmgr\", \"--create\", \"--disk\", disk, \"--part\", partition, \"--label\", bootOptionName, \"--loader\", \"\\\\EFI\\\\BOOT\\\\BOOTx64.EFI\"]\n\n    retCode, output = executeCommand(cmdArgs)\n\n    if (retCode == 0):\n        print \"Successfully added boot option '%s'\" % bootOptionName\n    else:\n        print \"Failed to add boot option '%s'\" % bootOptionName\n        raise Exception(\"An error occurred while executing '%s' : %s\" % (listToString(cmdArgs), output))\n\n# Main Routine\ndef main():\n\n    options, remaining_args = parseArgs(sys.argv[1:])\n\n    retCode = 0\n\n    try:\n        # Show the available disk partitions.\n        showDiskPartitions()\n\n        # Show the available disk partition labels.\n        showDiskLabels()\n\n        # Add the ESXi boot option in the UEFI boot menu.\n        addUefiBootOptionForESXi( options.efiSystemPartitionLabel, options.bootOptionName)\n    except (Exception), why:\n        retCode = 1\n        sys.stderr.write(\"An error executing SMARTSTART_SSSTK script:\\\\n%s\\\\n\" % str(why))\n\n    return retCode\n\nif __name__ == \"__main__\":\n    sys.exit(main())\nEOF\n)\n\nLOG_FILE=/tmp/icsp_ssstk_output.log\n\n# Returns 0 if the specified blob exists in the specified namespace\nblobExists() {\n\n    local NAMESPACE=$1\n    local BLOB_NAME=$2\n\n    local RET_CODE=0\n\n    local MAX_TRIES=5\n\n    local COUNT=0\n\n    echo \"Checking if blob ${BLOB_NAME} exists in namespace ${NAMESPACE}\" 1>&2\n\n    while [ ${COUNT} -lt ${MAX_TRIES} ]\n    do\n        # List the blobs in the specified namespace and check if the specified\n        # blob is present.\n        hpblob -l ${NAMESPACE} | grep \"^${BLOB_NAME}\\$\" > /dev/null\n\n        local CMD_RET_CODE=(${PIPESTATUS[*]})\n\n        # Did the \"hpblob\" command succeed?\n        if [ ${CMD_RET_CODE[0]} -eq 0 ]\n        then\n            # Did the \"grep\" find the blob name in the output of \"hpblob\"?\n            if [ ${CMD_RET_CODE[1]} -eq 0 ]\n            then\n                echo \"Blob ${BLOB_NAME} exists in namespace ${NAMESPACE}\" 1>&2\n            else\n                echo \"Blob ${BLOB_NAME} does not exist in namespace ${NAMESPACE}\" 1>&2\n                RET_CODE=1\n            fi\n\n            break\n        else\n            COUNT=$((COUNT+1))\n\n            sleep 5\n        fi\n    done\n\n    if [ ${COUNT} -eq ${MAX_TRIES} ]\n    then\n        echo \"Failed to list blobs in ${NAMESPACE}\" 1>&2\n        RET_CODE=1\n    fi\n\n    return ${RET_CODE}\n}\n\n# Deletes the specified blob from the specified namespace.\ndeleteBlob() {\n\n    local NAMESPACE=$1\n    local BLOB_NAME=$2\n\n    local RET_CODE=0\n    local MAX_TRIES=5\n    local COUNT=0\n\n    echo \"Deleting blob ${BLOB_NAME} from namespace ${NAMESPACE}\" 1>&2\n\n    while [ ${COUNT} -lt ${MAX_TRIES} ]\n    do\n        hpblob -d ${NAMESPACE} -k ${BLOB_NAME}\n\n        if [ $? -eq 0 ]\n        then\n            echo \"Successfully deleted blob ${BLOB_NAME}\" 1>&2\n            break\n        else\n            COUNT=$((COUNT+1))\n\n            sleep 5\n        fi\n    done\n\n    if [ ${COUNT} -eq ${MAX_TRIES} ]\n    then\n        echo \"Failed to delete blob ${BLOB_NAME}\" 1>&2\n        RET_CODE=1\n    fi\n\n    return ${RET_CODE}\n}\n\n# Reads the specified blob from the specified namespace.\nreadBlob() {\n\n    local NAMESPACE=$1\n    local BLOB_NAME=$2\n\n    local RET_CODE=0\n\n    local MAX_TRIES=5\n\n    local COUNT=0\n\n    if blobExists ${NAMESPACE} ${BLOB_NAME}\n    then\n        DATA_FILE=$(mktemp /tmp/ssstk_params_XXXXXX)\n\n        if [ $? -eq 0 ]\n        then\n            echo \"Reading blob ${BLOB_NAME} from namespace ${NAMESPACE}\" 1>&2\n\n            while [ ${COUNT} -lt ${MAX_TRIES} ]\n            do\n                BLOB_DATA=$(hpblob -r ${NAMESPACE} -k ${BLOB_NAME} -f ${DATA_FILE})\n\n                if [ $? -eq 0 ]\n                then\n                    echo \"Successfully read blob ${BLOB_NAME}\" 1>&2\n                    break\n                else\n                    COUNT=$((COUNT+1))\n\n                    sleep 5\n                fi\n            done\n\n            if [ ${COUNT} -eq ${MAX_TRIES} ]\n            then\n                echo \"Failed to read blob ${BLOB_NAME}\" 1>&2\n                RET_CODE=1\n            fi\n\n            cat \"${DATA_FILE}\"\n\n            rm -f ${DATA_FILE}\n        else\n            echo \"readBlob() could not create temporary file\" 1>&2\n            RET_CODE=1\n        fi\n    else\n        echo \"Not attempting to read blob ${BLOB_NAME} from ${NAMESPACE}, since it does not exist\" 1>&2\n    fi\n\n    return ${RET_CODE}\n}\n\n# Writes the data contained in the specified data file to the specified blob\n# in the specified namespace.\nwriteBlob() {\n\n    local NAMESPACE=$1\n    local BLOB_NAME=$2\n    local DATA_FILE=$3\n\n    local RET_CODE=0\n\n    local MAX_TRIES=5\n\n    local COUNT=0\n\n    echo \"Writing blob ${BLOB_NAME} to namespace ${NAMESPACE}\" 1>&2\n\n    while [ ${COUNT} -lt ${MAX_TRIES} ]\n    do\n        hpblob -w ${NAMESPACE} -k ${BLOB_NAME} -f ${DATA_FILE}\n\n        if [ $? -eq 0 ]\n        then\n            echo \"Successfully wrote blob ${BLOB_NAME}\" 1>&2\n            break\n        else\n            COUNT=$((COUNT+1))\n\n            sleep 5\n        fi\n    done\n\n    if [ ${COUNT} -eq ${MAX_TRIES} ]\n    then\n        echo \"Failed to write blob ${BLOB_NAME}\" 1>&2\n        RET_CODE=1\n    fi\n\n    return ${RET_CODE}\n}\n\n# Deletes the SMARTSTART_SSSTK blob.\ndeleteSstkBlob() {\n    deleteBlob \"-p\" \"SMARTSTART_SSSTK\"\n\n    local RET_CODE=$?\n\n    return ${RET_CODE}\n}\n\n# Writes the log file produced by this script (e.g. SMARTSTART_SSSTK) to\n# the ICSP_SMARTSTART_SSSTK_OUTPUT blob.\nwriteIcspSsstkOutputBlob() {\n    writeBlob \"-t\" \"ICSP_SMARTSTART_SSSTK_OUTPUT\" ${LOG_FILE}\n\n    local RET_CODE=$?\n\n    return ${RET_CODE}\n}\n\n# Writes the exit status of this script (e.g. SMARTSTART_SSSTK) to the\n# ICSP_SMARTSTART_SSSTK_STATUS blob.\nwriteIcspSsstkStatusBlob() {\n    local STATUS=$1\n\n    local STATUS_FILE=\"/tmp/icsp_ssstk_status\"\n\n    echo -n ${STATUS} > ${STATUS_FILE}\n\n    writeBlob \"-t\" \"ICSP_SMARTSTART_SSSTK_STATUS\" ${STATUS_FILE}\n\n    local RET_CODE=$?\n\n    return ${RET_CODE}\n}\n\n# Reads the parameters from the ICSP_SMARTSTART_SSSTK_PARAMS blob.\nreadIcspSsstkParamsBlob() {\n    SSSTK_PARAMS=$(readBlob -t \"ICSP_SMARTSTART_SSSTK_PARAMS\")\n\n    local RET_CODE=$?\n\n    echo \"ICSP_SMARTSTART_SSSTK_PARAMS = ${SSSTK_PARAMS}\" 1>&2\n\n    echo ${SSSTK_PARAMS}\n\n    return ${RET_CODE}\n}\n\nmainRoutine() {\n\n    local RET_CODE=0\n\n    echo \"DATE: $(date)\"\n\n    # Delete the SMARTSTART_SSSTK blob so it doesn't get executed\n    # by Intelligent Provisioning when the next Build Plan is run.\n    deleteSstkBlob\n\n    if [ $? -eq 0 ]\n    then\n        # Write our Python script that creates the ESXi boot option\n        # to a Python file.\n        echo \"${PYTHON_SCRIPT}\" > /tmp/boot_option.py\n\n        # Read any parameters from the ICSP_SMARTSTART_SSSTK_PARAMS\n        # blob that are to be passed to our Python script.\n        local PARAMS=$(readIcspSsstkParamsBlob)\n\n        RET_CODE=$?\n\n        if [ ${RET_CODE} -eq 0 ]\n        then\n            CMD=\"python /tmp/boot_option.py ${PARAMS}\"\n\n            echo \"Executing command => ${CMD}\"\n\n            eval ${CMD} 2>&1\n\n            RET_CODE=$?\n\n            echo \"/tmp/boot_option.py returned ${RET_CODE} exit code\"\n        else\n            echo \"An error occurred getting script parameters from blob\" 1>&2\n            RET_CODE=1\n        fi\n    else\n        RET_CODE=1\n    fi\n\n    return ${RET_CODE}\n}\n\n# Disable Intelligent Provisioning's script trace (e.g. \"bash -x\"), so that\n# the script trace doesn't show up in our log file.\nset +o xtrace\n\n# Run the script that sets the ESXi custom boot option and capture its\n# output to a log file.\nmainRoutine 2>&1 | tee ${LOG_FILE}\n\nretCode=${PIPESTATUS[0]}\n\n# Write the output of the script to the ICSP_SMARTSTART_SSSTK_OUTPUT blob.\nwriteIcspSsstkOutputBlob\n\n# Write the exit code of the script to the ICSP_SMARTSTART_SSSTK_STATUS blob.\nwriteIcspSsstkStatusBlob $retCode\n\n# If we successfully created the ESXi boot option in the UEFI Boot Menu, then\n# reboot the server so that it boots from our newly created ESXi boot option.\nif [ ${retCode} -eq 0 ]\nthen\n    echo \"Rebooting server ...\"\n# This validation checks for /sbin/reboot and creates a softlink from /bin/reboot if it's not there.\n    reboot=\"/sbin/reboot\"\n    if test ! -e $reboot\n    then\n        ln -s /bin/reboot /sbin/reboot\n    fi\n    /sbin/reboot\nfi\n\"\"\"\n\n###############################################################################\n###############################################################################\n##\n## End SMARTSTART_SSSTK Intelligent Provisioning startup script\n##\n###############################################################################\n###############################################################################\n\n# Parses the command line arguments\ndef parseArgs(args):\n    parser = OptionParser()\n    parser.add_option(\"--atLeast\",\n            type=\"int\", metavar=\"MINUTES\", default=WAIT_AT_LEAST,\n            dest = \"atLeast\",\n            help=\"the number of minutes to wait before configuring the server \\\n            to do a one-time boot to Intelligent Provisioning: %default minute(s)\")\n    parser.add_option(\"--atMost\",\n            type=\"int\", metavar=\"MINUTES\", default=WAIT_AT_MOST,\n            dest = \"atMost\",\n            help=\"the maximum number of minutes to wait for the script that \\\n            sets the ESXi boot option from within Intelligent Provisioning \\\n            to complete; default value: %default minute(s)\")\n    parser.add_option(\"--bootOptionName\",\n            default = \"ESXi\",\n            dest = \"bootOptionName\",\n            help = \"The name of the ESXi boot option to add to the UEFI boot menu.\")\n    parser.add_option(\"--efiSystemPartitionLabel\",\n            default = \"ESXi\",\n            dest = \"efiSystemPartitionLabel\",\n            help = \"The label assigned to the EFI System Partition by the ESXi installer.\")\n    options, args = parser.parse_args(args)\n    if args:\n        parser.error(\"Additional positional arguments are not supported\")\n\n    return options, args\n\n# Writes an debug message to stdout.\ndef writeDebugMessage(msg):\n\n    # Write the message to stdout so that it shows up in the job output.\n    if (DEBUG):\n        print msg\n\n# Writes an info message to stdout.\ndef writeInfoMessage(msg):\n\n    # Write the message to stdout so that it shows up in the job output.\n    print msg\n\n# Writes an error message to stderr.\ndef writeErrorMessage(msg):\n\n    # Write the message to stderr so that it shows up in the job output.\n    sys.stderr.write(msg)\n\n# Returns \"True\" if the server is in UEFI mode; \"False\" otherwise.\ndef isServerInUefiMode(iloMgmtProc):\n\n    currentBootMode = iloMgmtProc.getCurrentBootMode()\n\n    uefiPattern = re.compile(r\".*UEFI.*\")\n\n    result = uefiPattern.search(currentBootMode)\n\n    if result:\n        uefiMode = True\n    else:\n        uefiMode = False\n\n    return uefiMode\n\n# Writes a blob to the specified namespace.\ndef writeBlob( iloMgmtProc, iloNameSpace, blobName, blobData):\n\n    writeDebugMessage(\"Writing blob %s to namespace %s\" % (blobName, iloNameSpace))\n\n    iloMgmtProc.ims.writeBlobStore( iloMgmtProc.iloManagerRef, iloNameSpace, blobName, toByteList(blobData))\n\n# Reads a blob from the specified namespace.\ndef readBlob( iloMgmtProc, iloNameSpace, blobName):\n\n    writeDebugMessage(\"Reading blob %s from namespace %s\" % (blobName, iloNameSpace))\n\n    blobData = toPyString(iloMgmtProc.ims.readBlobStore( iloMgmtProc.iloManagerRef, iloNameSpace, blobName))\n\n    return blobData\n\n# Deletes a blob from the specified namespace.\ndef deleteBlob( iloMgmtProc, iloNameSpace, blobName):\n\n    writeDebugMessage(\"Deleting blob %s from namespace %s\" % (blobName, iloNameSpace))\n\n    try:\n        iloMgmtProc.ims.deleteBlobStore( iloMgmtProc.iloManagerRef, iloNameSpace, blobName)\n    except (OpswareException, OpswareSystemException):\n        writeDebugMessage(\"Failed to delete blob %s.  Blob may not exist.\" % blobName)\n\n# Sets a one-time boot to the specified boot device.\ndef setOneTimeBoot( iloMgmtProc, bootDevice):\n\n    writeInfoMessage(\"Setting one-time boot to %s\" % bootDevice)\n    retrial=1\n    MaxRetrials = 20\n    while True:\n                try:\n                     writeDebugMessage(\"Trying to set OTB, Retry Index = %s.\" % retrial)\n                     iloMgmtProc.setOneTimeBootOption(bootDevice)\n                except (OpswareException, OpswareSystemException, Exception), why:\n                     time.sleep(30)\n                     retrial = retrial + 1\n                     if(retrial < MaxRetrials):\n                        continue\n                     else:\n                        writeInfoMessage(\"Faild to set One Time Boot Flag.(Retry Count = %d)\" % retrial)\n                        writeInfoMessage(why.message)\n                        raise\n                break\n    writeInfoMessage(\"Successfully set One Time Boot\")\n \n# Configures the server to do a one-time boot to Intelligent Provisioning.\ndef setOneTimeBootToIntelligentProvisioning(iloMgmtProc):\n\n    writeDebugMessage(\"Setting one-time boot to Intelligent Provisioning\")\n\n    setOneTimeBoot( iloMgmtProc, \"EMB-TOOLKIT-LX\")\n\n# Waits for the script contained inside the SMARTSTART_SSSTK blob to finish\n# executing.  The script will return its exit code inside the\n# ICSP_SMARTSTART_SSSTK_STATUS blob and its output inside the\n# ICSP_SMARTSTART_SSSTK_OUTPUT blob.\ndef waitForScriptToComplete( iloMgmtProc, timeout):\n\n    writeDebugMessage(\"Waiting for Intelligent Provisioning to launch and startup script to complete\")\n\n    lastIloError = None\n\n    currentTime = time.time()\n    expirationTime = currentTime + timeout\n\n    # Wait until our SMARTSTART_SSSTK script that's running on Intelligent Provisioning\n    # completes and writes its exit status to the ICSP_SMARTSTART_SSSTK_STATUS blob, or\n    # until we reach our timeout.  Any exceptions from \"readBlob()\" are propagated up\n    # the call stack.\n    while (time.time() < expirationTime):\n        blobData = readBlob( iloMgmtProc, ILO_TEMPORARY_NAMESPACE, ICSP_SMARTSTART_SSSTK_STATUS)\n\n        # The readBlob() function returns \"None\" (e.g. null) when there is no such blob.\n        # Our ICSP_SMARTSTART_SSSTK_STATUS blob won't exist until our SMARTSTART_SSSTK\n        # script that's running on Intelligent Provisioning completes.\n        if (blobData is None):\n            time.sleep(30)\n            continue\n\n        return blobData\n\n    raise Exception(\"Timed out after %s seconds waiting for Intelligent Provisioning script to complete\" % timeout)\n\n# Writes our startup script to the SMARTSTART_SSSTK blob so that it is executed\n# by Intelligent Provisioning when it boots.\ndef writeSsstkScriptAndParamsToBlobStore( iloMgmtProc, options):\n\n    params = \"\"\n\n    # Propagate the \"--bootOptionName\" option, if specified, to our startup script.\n    if (options.bootOptionName is not None):\n        params += \" \\\"--bootOptionName=\" + options.bootOptionName + \"\\\"\"\n\n    # Propagate the \"--efiSystemPartitionLabel\" option, if specified, to our startup script.\n    if (options.efiSystemPartitionLabel is not None):\n        params += \" \\\"--efiSystemPartitionLabel=\" + options.efiSystemPartitionLabel + \"\\\"\"\n\n    # Write the parameters that we're going to pass to our startup script to the\n    # ICSP_SMARTSTART_SSSTK_PARAMS blob.\n    writeBlob( iloMgmtProc, ILO_TEMPORARY_NAMESPACE, ICSP_SMARTSTART_SSSTK_PARAMS, params)\n\n    # Write our startup script to the SMARTSTART_SSSTK blob so that it is executed by\n    # Intelligent Provisioning when it boots.\n    writeBlob( iloMgmtProc, ILO_PERMANENT_NAMESPACE, SMARTSTART_SSSTK, smartstartSsstkScript)\n\n# Main Routine\ndef main():\n\n    options, remaining_args = parseArgs(sys.argv[1:])\n\n    targetServer = ThisTargetServer()\n\n    iloMgmtProc = ilo.getIlo(targetServer, log=log)\n\n    uefiBootMode = False\n\n    try:\n        uefiBootMode = isServerInUefiMode(iloMgmtProc)\n    except (Exception), why:\n        writeErrorMessage(\"Error determining boot mode:\\n%s\\n\" % str(why))\n        return EC_FAILED\n\n    if (uefiBootMode):\n        writeDebugMessage(\"Boot Mode is UEFI\")\n\n        writeDebugMessage(\"Waiting %d minutes before configuring server to one-time boot to Intelligent Provisioning\" % options.atLeast)\n\n        # The assumption is that the target server has been rebooted in the previous\n        # build plan step, so we'll wait for a little while to allow the server to\n        # complete POST and boot the ESXi installer from the stub partition.  Once\n        # the server is past POST, it is safe to set the one-time boot to Intelligent\n        # Provisioning.\n        time.sleep(options.atLeast * 60)\n\n        try:\n            # Clean up old blobs from prior runs.\n            deleteBlob( iloMgmtProc, ILO_TEMPORARY_NAMESPACE, ICSP_SMARTSTART_SSSTK_OUTPUT);\n            deleteBlob( iloMgmtProc, ILO_TEMPORARY_NAMESPACE, ICSP_SMARTSTART_SSSTK_STATUS);\n            deleteBlob( iloMgmtProc, ILO_TEMPORARY_NAMESPACE, ICSP_SMARTSTART_SSSTK_PARAMS);\n\n            writeSsstkScriptAndParamsToBlobStore( iloMgmtProc, options)\n\n            setOneTimeBootToIntelligentProvisioning(iloMgmtProc)\n\n            retCode = waitForScriptToComplete( iloMgmtProc, options.atMost * 60)\n\n            writeDebugMessage(\"Script Exit Code: %s\" % retCode)\n\n            scriptOutput = readBlob( iloMgmtProc, ILO_TEMPORARY_NAMESPACE, ICSP_SMARTSTART_SSSTK_OUTPUT)\n\n            writeDebugMessage(\"Script Output:\\n\\n%s\" % scriptOutput)\n \n            if (int(retCode) == 0):\n                writeInfoMessage(\"Successfully set ESXi Boot Option\")\n            else:\n                raise Exception(\"Intelligent Provisioning script failed\")\n\n        except (OpswareException, OpswareSystemException, Exception), why:\n            writeErrorMessage(\"Could not set ESXi Boot Option:\\n%s\\n\" % str(why))\n            return EC_FAILED\n        finally:\n            # The SMARTSTART_SSSTK blob is typically deleted from the script contained\n            # inside it, which Intelligent Provisioning will run when it boots.  However,\n            # if there was an error anywhere along the way, the SMARTSTART_SSSTK blob\n            # may not have been deleted, which may be problematic for the next build plan\n            # that is run.  So, let's try to delete it here, whether it exists or not.\n            deleteBlob( iloMgmtProc, ILO_PERMANENT_NAMESPACE, SMARTSTART_SSSTK);\n            deleteBlob( iloMgmtProc, ILO_TEMPORARY_NAMESPACE, ICSP_SMARTSTART_SSSTK_PARAMS);\n    else:\n        writeInfoMessage(\"Boot Mode is not UEFI.  Skipping this step.\")\n\n    return EC_SUCCESS\n\nif __name__ == \"__main__\":\n    sys.exit(main())",
            "description": "On servers configured in UEFI boot mode, this script will force the server into the Intelligent Provisioning Linux Service OS after the ESXi installation has completed, where it will add an ESXi boot option to the UEFI boot menu.  The disk partition with the \"ESXi\" label is assumed to be the EFI System Partition and will be used when creating the ESXi boot option.\n\nThis step is skipped if the server is not configured in UEFI boot mode.\n\nOptions:\n  --atLeast=MINUTES  The number of minutes to wait before setting a one-time boot to Intelligent Provisioning.  Since a one-time boot cannot be set while a server is going through POST (Power On Self Test), this option can be used to give the server time to complete POST after it has rebooted. Default is 1 minutes.After the wait time,script will retry to set one-time boot after every 30 seconds till it succeeds.Script will throw an error if one-time boot is not set after 20 retrials.\n  --atMost=MINUTES  The number of minutes to wait for this script to complete after it has configured the server to one-time boot into Intelligent Provisioning. Default is 45 minutes.\n  --bootOptionName=NAME  The name of the boot option that you want added to the UEFI boot menu. Default is \"ESXi\".\n  --efiSystemPartitionLabel=PARTITION_LABEL  The label assigned by the ESXi installer to the EFI System Partition. This option should only be used if the ESXi installer assigns a different label to the EFI System Partition. Default is \"ESXi\". ",
            "status": null,
            "name": "Add ESXi Boot Option To UEFI Boot Order",
            "state": null,
            "eTag": "2015-08-04T07:29:46.000Z",
            "modified": "2015-08-04T07:29:46.000Z",
            "created": "2015-08-04T07:29:46.000Z",
            "category": "os-deployment-ogfs-scripts",
            "uri": "/rest/os-deployment-ogfs-scripts/1480001"
        },
        {
            "codeType": "OGFS",
            "displayCodeType": "OGFS",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "32",
                    "createdBy": "opsware",
                    "createdDate": "2015-08-04T07:29:47.000Z",
                    "usage": "Verifies that the target server has an iLO4 management processor or newer.  If the target server has iLO, iLO2, iLO3, or no iLO at all, the script will return an error.\n\nusage: Verify server has iLO4 or newer\n\noptions:\n  -h, --help            show this help message and exit\n  -t MINUTES, --atMost=MINUTES\n                        Wait at most this many minutes before timing out.\n                        Default 10 minutes.\n\nPrerequisites:\n- Target server must have an iLO4 management processor or newer\n",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-08-04T07:29:47.000Z",
            "version": {
                "versionLabel": "32",
                "createdBy": "opsware",
                "createdDate": "2015-08-04T07:29:47.000Z",
                "usage": "Verifies that the target server has an iLO4 management processor or newer.  If the target server has iLO, iLO2, iLO3, or no iLO at all, the script will return an error.\n\nusage: Verify server has iLO4 or newer\n\noptions:\n  -h, --help            show this help message and exit\n  -t MINUTES, --atMost=MINUTES\n                        Wait at most this many minutes before timing out.\n                        Default 10 minutes.\n\nPrerequisites:\n- Target server must have an iLO4 management processor or newer\n",
                "current": true
            },
            "source": "#!/usr/bin/python \n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*- \n# ex: set tabstop=4 : \n# Please do not change the two lines above. See PEP 8, PEP 263. \n\"\"\" (C) Copyright 2014-2015 Hewlett-Packard Development Company, L.P.\n\nCheck and verify iLO service exists and iLO is atleast version 4 or above\n\"\"\"\nimport sys\n\nfrom osprov          import ilo\nfrom osprov.errors   import TimeoutError, SetupError, NotSupportedError\nfrom osprov.osbp     import ThisTargetServer\nfrom osprov.osbp     import logger\nfrom osprov.patterns.scanner import TimeoutScanner, StopScan\nfrom osprov.optparse_ext     import OptionParser, OptionValueError\nfrom osprov.decorators       import HandleShowErrorMessage\n\nLOG = logger.getIt(\"check iLO4 or above\")\n\nclass CheckForILOServiceOptparser(OptionParser):\n\t\"\"\" Custom option parser \"\"\"\n\n\tdef defineOptions(self):\n\t\tself.prog  =  \"Check For iLO Service and validate iLO4 or above\"\n\t\tself.set_usage(\"%s [options]\" % self.prog)\n\t\tself.add_option(\"-t\", \"--atMost\", type = \"int\", default = \"10\", metavar=\"MINUTES\",\n\t\t\thelp = \"Wait at most this many minutes before timing out. Default %default.\"\n\t\t)\n\n\tdef validateArgs(self, opt, args):\n\t\tif opt.atMost < 1:\n\t\t\traise OptionValueError(\"MINUTES should be more than 1.\")\n\nclass CheckForILOServiceScanner(TimeoutScanner):\n\t\"\"\" Custom scanner for the iLO service \"\"\"\n\n\tdef __init__(self, targetServer, *args, **kwargs):\n\t\tsuper(CheckForILOServiceScanner, self).__init__(*args, **kwargs)\n\t\tself.targetServer = targetServer\n\n\tdef shortcut(self):\n\t\tif self.targetServer.serverVO.manufacturer:\n\t\t\tif self.targetServer.serverVO.manufacturer.strip().lower() not in (\n\t\t\t\t\t\"hp\" ,\n\t\t\t\t\t\"hewlett-packard\",\n\t\t\t\t\t\"hewlett-packard company\",\n\t\t\t\t\t\"hewlett-packard inc.\",\n\t\t\t\t\t\"hewlett packard\",\n\t\t\t\t\t\"hewlett packard company\",\n\t\t\t\t\t\"hewlett packard inc.\",\n\t\t\t\t):\n\t\t\t\traise NotSupportedError(\"Server model %s, manufacturer %s does not support iLO\" % (\n\t\t\t\t\tself.targetServer.serverVO.model,\n\t\t\t\t\tself.targetServer.serverVO.manufacturer,\n\t\t\t\t))\n\t\tself.scan()\n\n\tdef scan(self):\n\t\tself.log.debug(\"Scanning for iLO\")\n\t\ttry:\n\t\t\tiloServ = ilo.getIlo(self.targetServer, log = self.log)\n\t\t\tself.log.debug(\"Found iLO %s\" % iloServ)\n\t\t\tprint \"Service active, version %s.\" % iloServ.version()\n\t\t\tif iloServ.version().lower() not in (\n\t\t\t\t\t\"ilo4\", \"ilo4_rest\"\n\t\t\t\t):\n\t\t\t\traise NotSupportedError(\"iLO version %s is not supported. iLO 4 or above required.\\nServer model %s\" % (\n\t\t\t\t\tiloServ.version(),\n\t\t\t\t\tself.targetServer.serverVO.model,\n\t\t\t\t))\n\t\t\traise StopScan()\n\t\texcept SetupError, why:\n\t\t\tself.log.exception(why)\n\n\n@HandleShowErrorMessage(\"check iLO service and version\", LOG)\ndef main():\n\t\"\"\" Main entry point \"\"\"\n\topt, args = CheckForILOServiceOptparser().parse_args()\n\tif args:\n\t\tprint \"Warning, unneeded arguments will be ignored: %s\" % (\" \".join(args))\n\tscanner = CheckForILOServiceScanner(\n\t\ttargetServer =  ThisTargetServer(),\n\t\ttimeoutMin     = opt.atMost,\n\t\twaitUpfrontMin = 1,\n\t\tlog = LOG\n\t)\n\ttry:\n\t\tscanner()\n\texcept TimeoutError, why:\n\t\tLOG.exception(why)\n\t\tprint \"Error: The iLO service did not  become available after %d minutes.\" % opt.atMost\n\t\tprint \"This Build Plan requires the iLO service and can't continue without it.\"\n\t\treturn 10\n\n\nif __name__ == \"__main__\" :\n\tsys.exit(main())\n",
            "description": "Verifies that the target server has an iLO4 management processor or newer.  If the target server has iLO, iLO2, iLO3, or no iLO at all, the script will return an error.\n\nusage: Verify server has iLO4 or newer\n\noptions:\n  -h, --help            show this help message and exit\n  -t MINUTES, --atMost=MINUTES\n                        Wait at most this many minutes before timing out.\n                        Default 10 minutes.\n\nPrerequisites:\n- Target server must have an iLO4 management processor or newer\n",
            "status": null,
            "name": "Verify server has iLO4 or newer",
            "state": null,
            "eTag": "2015-08-04T07:29:47.000Z",
            "modified": "2015-08-04T07:29:47.000Z",
            "created": "2015-08-04T07:29:47.000Z",
            "category": "os-deployment-ogfs-scripts",
            "uri": "/rest/os-deployment-ogfs-scripts/1500001"
        },
        {
            "codeType": "OGFS",
            "displayCodeType": "OGFS",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "71",
                    "createdBy": "opsware",
                    "createdDate": "2015-08-04T07:29:53.000Z",
                    "usage": "Validates whether the server model selected  running Windows or Linux OS is supported or not\n\nRequired Parameters:\n--prodname     The comma separated list of server model name.\n\nOptional Parameters:\n--exact\tMatch the exact sequence of string provided in --prodname\n\nCustom Attributes:  None",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-08-04T07:29:53.000Z",
            "version": {
                "versionLabel": "71",
                "createdBy": "opsware",
                "createdDate": "2015-08-04T07:29:53.000Z",
                "usage": "Validates whether the server model selected  running Windows or Linux OS is supported or not\n\nRequired Parameters:\n--prodname     The comma separated list of server model name.\n\nOptional Parameters:\n--exact\tMatch the exact sequence of string provided in --prodname\n\nCustom Attributes:  None",
                "current": true
            },
            "source": "#!/usr/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n#\n\"\"\"\n(C) Copyright 2014-2015 Hewlett-Packard Development Company, L.P.\nValidates Build plan is running on supported server model.\nThe script takes --prodname as argument \nEg. -prodname=\"PROLIANT WS460C GEN9 WS BLADE\"\n\"\"\"\n\nimport sys\n\nfrom optparse import OptionParser, OptionError\nfrom pytwist.com.opsware.server import ServerRef\nfrom pytwist.com.opsware.server import ServerHardwareVO\nfrom osprov import sa\nfrom osprov.osbp import ThisTargetServer\n\nclass validateServerplatform(OptionParser):\n#parse the arguments provided\n#prodname:- Takes the Product name of the server \n\tdef __init__(self, *args, **kwargs):\n\t\tOptionParser.__init__(self, *args, **kwargs)\n\t\tself.add_option(\"--prodname\", help=\"validates support of the selected server\")\n\t\tself.add_option(\"--exact\", help=\"matches exact sequence to product name\", dest='exactmatch', default =False, action = 'store_true')\n\t\tself.usage = \"Pass --prodname as argument with valid comma separated server productname list.\"\n\ntwistServer = sa.getTwistServer()\n\ndef main():\n\toptions, remainingArgs = validateServerplatform().parse_args()\n\t# save the server models \n\tlistprodname= options.prodname\n\tif not listprodname:\n\t\traise OptionError (\"Missing required argument\", \"--prodname\")\n\t#Check if the paramter passed has more then one server model passed.\n\tarrlist = listprodname.split(\",\")\n\t\n\ttry:\n\t# Get the server SA ID and then get its Product name as listed in Appliance\n        mid = ThisTargetServer().id\n\t\tobjServerHardwareVO = twistServer.server.ServerService.getServerHardwareVO(ServerRef(mid))\n\t\tstrServerModel = objServerHardwareVO.getModel()\n\t\t#Traverse throught the list of supported server passed as arugment and check if the target selected matches in the list.\n\t\tfor (strlist) in  arrlist:\n\t\t\tstrlist.strip()\n\t\t\tif options.exactmatch:\n\t\t\t\tif strlist.lower() in strServerModel.lower():\n\t\t\t\t\tprint \"The target %s is supported\\n\" % strServerModel\n\t\t\t\t\tsys.exit(0)\n\t\t\telse:\n\t\t\t\t#Check for each key word is present in Product name\n\t\t\t\tarrname= strlist.split(\" \")\n\t\t\t\tcounter=0\n\t\t\t\tfor (servermodel) in arrname :\n\t\t\t\t\tif servermodel.lower() in strServerModel.lower():\n\t\t\t\t\t\tcounter = counter + 1\n\t\t\t\tif (counter == len(arrname)):\n\t\t\t\t\t\tprint \"The target %s is supported\\n\" % strServerModel\n\t\t\t\t\t\tsys.exit(0)\n\n\t\tprint \"The build plan can not run on the current server model %s.\" % strServerModel\n\t\tprint \"The build plan requires one of the following server model(s):\"\n\t\tfor (strlist) in  arrlist:\n\t\t\tprint \"\\t%s\" %strlist\n\t\tprint \"Please run the build plan on an appropriate platform or update the build plan.\"\n\t\tsys.exit(2)\n\t\t\t\t\n\t\t\t\t\n\texcept (IOError, OSError), ose:\n        sys.stderr.write(\"Unable to read the target server's MID in the OGFS. %s\\n\" % ose.args[0])\n        return EC_TARGET_SERVER\n\t   \nif __name__ == \"__main__\":\n    sys.exit(main())\n",
            "description": "Validates whether the server model selected  running Windows or Linux OS is supported or not\n\nRequired Parameters:\n--prodname     The comma separated list of server model name.\n\nOptional Parameters:\n--exact\tMatch the exact sequence of string provided in --prodname\n\nCustom Attributes:  None",
            "status": null,
            "name": "Validate Server Platform",
            "state": null,
            "eTag": "2015-08-04T07:29:53.000Z",
            "modified": "2015-08-04T07:29:53.000Z",
            "created": "2015-08-04T07:29:53.000Z",
            "category": "os-deployment-ogfs-scripts",
            "uri": "/rest/os-deployment-ogfs-scripts/1560001"
        },
        {
            "codeType": "OGFS",
            "displayCodeType": "OGFS",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "6",
                    "createdBy": "opsware",
                    "createdDate": "2015-08-04T07:29:59.000Z",
                    "usage": "Updated description field for Check Windows OS Version\n\nVerify the server is running an appropriate version of Windows for this build plan\nRequired Parameters:\n    --version=<OS Short-name1>,<OS Short-name2> …\nWhere <OS Short-name> is a comma separated list of Windows versions that this build plan will support. Versions must be specified using the short name abbreviations listed below. At least one version must be specified.\nWindows short names:  Win2008  Win2008R2  Win2012  Win2012R2  Win7  Win81\nIf no parameter or invalid parameter(s) are specified, then step fails and stops further execution.\n\nExamples:\n     --version=Win2012,Win2012R2\n     --version=Win7",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-08-04T07:29:59.000Z",
            "version": {
                "versionLabel": "6",
                "createdBy": "opsware",
                "createdDate": "2015-08-04T07:29:59.000Z",
                "usage": "Updated description field for Check Windows OS Version\n\nVerify the server is running an appropriate version of Windows for this build plan\nRequired Parameters:\n    --version=<OS Short-name1>,<OS Short-name2> …\nWhere <OS Short-name> is a comma separated list of Windows versions that this build plan will support. Versions must be specified using the short name abbreviations listed below. At least one version must be specified.\nWindows short names:  Win2008  Win2008R2  Win2012  Win2012R2  Win7  Win81\nIf no parameter or invalid parameter(s) are specified, then step fails and stops further execution.\n\nExamples:\n     --version=Win2012,Win2012R2\n     --version=Win7",
                "current": true
            },
            "source": "#!/usr/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n#\n'''\n(C) Copyright 2012-2015 Hewlett-Packard Development Company, L.P.\n\nThis script verifies that the target server is running the correct version of the OS for this build plan.\nSo that, this script can be used a step in any OSBP that would like to prevent the accidental work on a\ndifferent OS version.\n\nThe script at present supports the following Windows flavours :\n\t--------------------------------------------------------------\n\t FCQN of OS\t\t\tShort name to be used as argument\n\t--------------------------------------------------------------\n\t Windows 2008 \t\t\tWin2008\n\t Windows 2008 R2 \t\tWin2008R2\n\t Windows 2012\t\t\tWin2012\n\t Windows 2012 R2\t\tWin2012R2\n\t Windows 7\t\t\tWin7\n\t Windows 8.1\t\t\tWin81\n\t---------------------------------------------------------------\n\t\nNew flavours of Windows can be easily added to extend the support by placing the short name and FCQN in\nOsNameTuple tuple list.  The script uses the longest match pattern to accurately identify the OS version that\nis running on the target machine.  This pattern is much desired to identify same family of OS versions that\nsimply differs by release version (e.g. R2).\n\nThe typical usage displays the following help text.\n\n\tCheck Windows OS Version\n        Usage: --version=<OS Short-name1>,<OS Short-name2> ...\n            Version keyword :  ['--version']\n            OS short names  :  ['Win2008', 'Win2008R2', 'Win2012', 'Win2012R2', 'Win7', 'Win81']\n\n        Example: Check Windows OS Version --version=Win2012,Win2012R2 \n\nIn future if the same functionality has to be extended for Linux flavours, simply add the FCQN and their\ncorresponding short names to OsNameTuple.  It will simply work! The entire step is platform agnostic.\t\t\n\n'''\n\nimport re\nimport subprocess\nimport sys\nfrom pytwist \t\t\t\t\t\timport *\nfrom pytwist.com.opsware.server \t\timport ServerRef, ServerDetails\nfrom osprov.osbp \t\t\t\t\timport logger, thisServerID, ThisTargetServer\nfrom pytwist.com.opsware.server \t\timport ServerRef\nfrom osprov.osbp import logger\n\nsys.path.append(\"/opt/opsware/pylibs\")\n\n# Variable holding the reference to the Twist Server\nTwistServerInstance = twistserver.TwistServer()\n\n# Variable holding the value of server id aka SA Object Id \nThisServerIdentity = thisServerID()\n\n# Variable holding reference to target servers reference structure\nThisServerReference = ServerRef( ThisServerIdentity )\n\n# Variable holding reference to server service of the twist server\nThisServerService = TwistServerInstance.server.ServerService\n\n# Variable holding reference to target servers inventory\nThisServerVO = ThisServerService.getServerVO( ThisServerReference )\n  \nLOG = logger.getIt(\"Check Windows OS Version\")\n\n# Tuple list enlisting the OS flavours that are going to be supported by this script.  To extend the script \n# further to support any other OS, simply have to add the short-name and the full name into this list as tuple\nOsNameTuple = [\t\n\t\t('Win2008', \t\t'Windows 2008'), \n\t\t('Win2008R2',\t'Windows 2008 R2'), \n\t\t('Win2012', \t\t'Windows 2012'), \n\t\t('Win2012R2', \t'Windows 2012 R2'), \n\t\t('Win7',\t\t'Windows 7'),\n        \t('Win81',        'Windows 8.1')\t\t\n\t       ]\n# Name of this function; helpful in uncluttering the code\nFunctionNameString = 'Check Windows OS Version'\n# Verifies the version parameter passed in script with the following valid version parameter \nVersionParameter  = ['--version']\n# OS short name parameters; will be populated with only the OS short names from the parameter list\nOsShortNameParameterList = []\n# Will be populated from the OsNameTuple during parameter verification.  Though this is not needed still\n# helps in repeating the code to extract the short names from the tuple list (OsNameTuple)\nOsShortNamesList = []\n\n# Get the full OS name from appliance.\ndef getOSName():\n\treturn ThisServerVO.getOsFlavor()\n\n# The usage display function that emits the help text on the right usage of the script.\ndef showUsageHelp() :\n\tprint '{0:s}\\n\\tUsage: --version=<OS Shortname1>,<OS Shortname2> ...'.format(FunctionNameString)\n\tprint '\\t\\tVersion keyword : ', VersionParameter\n\tprint '\\t\\tOS short names   : ', [ sn for (sn, ln) in OsNameTuple ]\n\tprint '\\n\\tExample: {0:s} --version=Win2012,Win2012R2'.format(FunctionNameString)\n\tprint '\\n\\tNote: Short names are comma separated and no spaces are allowed'\n\t\n# When called evaluates all the arguments to the script and populates the necessary data structure for\n# consumption later.\ndef validateArguments(argv) :\n\t# Too few argument check!\n\tif ( len(argv) != 2 ) :\n\t\tshowUsageHelp()\n\t\tsys.exit(1)\n\t\t\n\tglobal OsShortNameParameterList\n\tglobal OsShortNamesList\n\t\t\n\t# Pick the version argument for checking it later\n\tversion_arg   = argv[1]\n\t#Populates the list of os_sn values passed in script into the os_snParameterList \n\tos_snParameterList = []\n\t\n\tif(version_arg.find(\"=\") == -1) :\n\t\tshowUsageHelp()\n\t\tsys.exit(1)\n\n\t#Split the version parameter and os_sn values into separate strings for validation\n\tversionParam , os_snParameterList = version_arg.split(\"=\")\n\n\tif((len(versionParam) == 0) or (len(os_snParameterList) == 0)) :\n\t\tshowUsageHelp()\n\t\tsys.exit(1)\n\n\t# Assign the OS version parameters to OsShortNameParameterList\n\tOsShortNameParameterList = os_snParameterList.split(\",\")\t\t\n\n\t# Extract and assign all the defined OS short names. Done in order to prevent repeated extraction later\n\tOsShortNamesList = [ sn for (sn, ln) in OsNameTuple ] \n\t# List comprehension! For every valid short names declared evaluate whether or not the same is passed\n\t# as argument by the user calling the script\n\tos_found = [ sn for sn in OsShortNamesList if sn in OsShortNameParameterList ]\n\n\t# Finally validate the version string itself against valid set of version strings\n\t\n\tif ( versionParam not in VersionParameter ) :\n\t\tshowUsageHelp()\n\t\tsys.exit(1)\n\t\t\n\t# Verify whether all the supplied OS versions are valid.  When the lengths of both the lists differ\n\t# it simply means that some argument passed is invalid\n\tif len(os_found) != len(OsShortNameParameterList) :\n\t\t# Found an entry that is not supported by this OSBP step Inform the user about this and show \n\t\t# all the supported OS and their short names\n\t\tmissing = [ os_sn for os_sn in OsShortNameParameterList if os_sn not in OsShortNamesList ]\n\n\t\tprint 'ERROR: Invalid OS short name(s) -> ', missing\n\t\tprint 'INFO : Valid list of OS short names are given below'\n\t\tprint '\\t', OsShortNamesList\t\t\n\t\tsys.exit(1)\n\t\t\n\treturn True\n\t\n# Then entry point function for the script.\t\ndef main(argv) :\n\tif ( validateArguments(argv) ) :\n\t\tcurrent_os_tuple = ()\n\t\tos_matched \t = False\n\t\tos_name\t\t = getOSName() \n\t\t\n\t\tif not os_name or os_name == \"\" :\n\t\t\tprint 'ERROR: Unknown OS detected'\n\t\t\tprint 'INFO : Non-Windows OS detected. This build plan can only be run on Microsoft Windows.'\t\t\t\n\t\t\tsys.exit(-2)\n\t\t\t\n\t\tif not os_name :\n\t\t\tprint 'ERROR: Unknown OS detected'\n\t\t\tprint 'INFO : Non-Windows OS detected. This build plan can only be run on Microsoft Windows.'\n\t\t\tsys.exit(-2)\n\t\t\t\n\t\t# Very important step, never remove this or modify.  Change to this line would impact\n\t\t# the entire evaluation logic using regular expression.  The following line sets the \n\t\t# right order for longest length match\n\t\tOsNameTuple.sort(reverse=True)\n\t\t\n\t\t# Debug statement comment it out for the production code.\n\t\t# print OsNameTuple\n\t\t# print os_name, os_name\n\t\t\n\t\t\n\t\tfor (os_sn, os_ln) in OsNameTuple :\n\t\t\t# Generate the pattern string against each of the OS long name. To this add the \n\t\t\t# regular expression pattern to be used for RE evaluation\n\t\t\tsn_list    = os_ln.split(' ')\n\t\t\tsn_pat_str = '(.*)'.join(sn_list)\n\t\t\tmatched_os = re.search(sn_pat_str, os_name)\n\t\t\t\n\t\t\t# If a match is found the assign the short and long OS name to tuple set.  Also \n\t\t\t# if the short name is part of the requested OS short name list turn the matched\n\t\t\t# flag and break off.  \n\t\t\tif matched_os :\n\t\t\t\tcurrent_os_tuple = (os_sn, os_ln)\n\n\t\t\t\tif os_sn in OsShortNameParameterList :\n\t\t\t\t\tos_matched = True\n\t\t\t\n\t\t\t\t# Be careful with this break statement, one position off would certainly break\n\t\t\t\t# the code and should be tab aligned to the inner if statement.\n\t\t\t\tbreak\n\n\t\tif os_matched :\n\t\t\tprint ' Current running OS \"{0} ({1})\"\\n'.format( os_ln, os_sn )\n\t\t\tprint ' This OS is supported for this build plan. '\n\n\t\telse:\n\t\t\tprint 'ERROR: This server is not running a version of Windows that is compatible with this build plan.\\nThe',\n\t\t\tprint 'parameters of this step indicate that the server be running one of the following operating systems:'\n\t\t\t\n\t\t\tfor os_expected in [ (os_sn, os_ln) for (os_sn, os_ln) in OsNameTuple if os_sn in OsShortNameParameterList ] :\n\t\t\t\tprint '\\t{0} ({1})'.format( os_expected[1], os_expected[0])\n\t\t\t\t\n\t\t\tprint '\\nHowever, this server is running {0} ({1})\\n'.format( current_os_tuple[1], current_os_tuple[0] )\n\t\t\tprint 'Action: Please run the build plan that is appropriate for the version of Windows your server is running,\\n',\n\t\t\tprint 'or update the parameters of this step to allow running on this version of windows by adding \\n',\n\t\t\tprint '\"{0}\" to the parameter list.'.format( current_os_tuple[0] )\n\t\t\t\n\t\t\tsys.exit(1)\n\n# Call the main with arguments\nif __name__ == \"__main__\":\n    sys.exit(main(sys.argv))",
            "description": "Updated description field for Check Windows OS Version\n\nVerify the server is running an appropriate version of Windows for this build plan\nRequired Parameters:\n    --version=<OS Short-name1>,<OS Short-name2> …\nWhere <OS Short-name> is a comma separated list of Windows versions that this build plan will support. Versions must be specified using the short name abbreviations listed below. At least one version must be specified.\nWindows short names:  Win2008  Win2008R2  Win2012  Win2012R2  Win7  Win81\nIf no parameter or invalid parameter(s) are specified, then step fails and stops further execution.\n\nExamples:\n     --version=Win2012,Win2012R2\n     --version=Win7",
            "status": null,
            "name": "Validate Windows OS Version",
            "state": null,
            "eTag": "2015-08-04T07:29:59.000Z",
            "modified": "2015-08-04T07:29:59.000Z",
            "created": "2015-08-04T07:29:58.000Z",
            "category": "os-deployment-ogfs-scripts",
            "uri": "/rest/os-deployment-ogfs-scripts/1610001"
        },
        {
            "codeType": "OGFS",
            "displayCodeType": "OGFS",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "45",
                    "createdBy": "opsware",
                    "createdDate": "2015-08-04T07:29:59.000Z",
                    "usage": "Verifies that a gateway (gw) has been specified when using static network configuration\n\nSome OS's require a gateway when doing a static network configuration.This step checks for a gateway and will fail the build plan if it is not specified. \n\nParameters: None\nCustom Attribute: hpsa_netconfig\n",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-08-04T07:29:59.000Z",
            "version": {
                "versionLabel": "45",
                "createdBy": "opsware",
                "createdDate": "2015-08-04T07:29:59.000Z",
                "usage": "Verifies that a gateway (gw) has been specified when using static network configuration\n\nSome OS's require a gateway when doing a static network configuration.This step checks for a gateway and will fail the build plan if it is not specified. \n\nParameters: None\nCustom Attribute: hpsa_netconfig\n",
                "current": true
            },
            "source": "#!/usr/bin/python\n# (C) Copyright 2012-2015 Hewlett-Packard Development Company, L.P.\nimport sys\nfrom osprov.netconfig.helpers import getNetconfig\nfrom osprov.osbp import logger\n\nHPSA_NETCONFIG=\"\"\"@hpsa_netconfig@\"\"\"\nREQUIRE_NETCONFIG=\"@require_netconfig:false@\"\nlog = logger.getIt(\"Boot\")\n\nEC_OK=0\nEC_NO_GATEWAY=2\n\ndef main(): \n\tnetconfig = getNetconfig(hpsa_netconfig=HPSA_NETCONFIG,require_netconfig=REQUIRE_NETCONFIG,log=log)\n\tif netconfig:\n\t\tprint(\"Validating if Gateway is specified for static network configuration \")\n\t\tnet_data = netconfig.interfaces[0]\n\t\tif hasattr(net_data,\"gw\"):\n\t\t\tgateway_data=net_data.gw[0]\n\t\t\tprint (\"Gateway validation successful\")\n\t\t\treturn EC_OK\n\t\telse:\n\t\t\tprint (\"Gateway validation failed\")\n\t\t\tprint (\"This Build plan requires a gateway to be specified  when doing a static network configuration\")\n\t\t\treturn EC_NO_GATEWAY\n\telse:\n\t\tprint (\"Skipping gateway validation\")\n\t\tprint(\"No static network configuration details has been specified\")\n\t\treturn EC_OK\n\nif __name__==\"__main__\":\n\tsys.exit (main())",
            "description": "Verifies that a gateway (gw) has been specified when using static network configuration\n\nSome OS's require a gateway when doing a static network configuration.This step checks for a gateway and will fail the build plan if it is not specified. \n\nParameters: None\nCustom Attribute: hpsa_netconfig\n",
            "status": null,
            "name": "Validate Gateway Setting for Static Network Configuration",
            "state": null,
            "eTag": "2015-08-04T07:29:59.000Z",
            "modified": "2015-08-04T07:29:59.000Z",
            "created": "2015-08-04T07:29:59.000Z",
            "category": "os-deployment-ogfs-scripts",
            "uri": "/rest/os-deployment-ogfs-scripts/1620001"
        },
        {
            "codeType": "OGFS",
            "displayCodeType": "OGFS",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "22",
                    "createdBy": "opsware",
                    "createdDate": "2015-08-04T07:30:01.000Z",
                    "usage": "Configures bladeservers, DL580Gen8, and Gen9 servers or newer to boot from SAN by disabling the embedded storage controllers.  Non-blade G6, G7, and Gen8 servers, with the exception of the DL580Gen8, are not supported.\n\nOptions:\n  --fibre_channel_first  Moves the fibre channel device to the top of the boot order when set to true.  This option only applies to UEFI boot mode.  It has no effect in Legacy BIOS mode.\n\nPrerequisites:\n- A supported ProLiant server with a supported HBA/CNA.\n",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-08-04T07:30:01.000Z",
            "version": {
                "versionLabel": "22",
                "createdBy": "opsware",
                "createdDate": "2015-08-04T07:30:01.000Z",
                "usage": "Configures bladeservers, DL580Gen8, and Gen9 servers or newer to boot from SAN by disabling the embedded storage controllers.  Non-blade G6, G7, and Gen8 servers, with the exception of the DL580Gen8, are not supported.\n\nOptions:\n  --fibre_channel_first  Moves the fibre channel device to the top of the boot order when set to true.  This option only applies to UEFI boot mode.  It has no effect in Legacy BIOS mode.\n\nPrerequisites:\n- A supported ProLiant server with a supported HBA/CNA.\n",
                "current": true
            },
            "source": "#!/usr/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n#\n\"\"\"\n(C) Copyright 2014-2015 Hewlett-Packard Development Company, L.P.\n\"\"\"\n\nimport sys\nimport re\nimport time\nfrom optparse import OptionParser\nfrom osprov import ilo\nfrom osprov.osbp import ThisTargetServer, logger\nfrom osprov.util.twist import toByteList, toPyString\nfrom pytwist.com.opsware.common import OpswareException, OpswareSystemException\nfrom pytwist.com.opsware.ilo import IloException\n\nDEBUG=@Debug:0@\n\nILO_TEMPORARY_NAMESPACE = \"TMP\"\nICSP_UEFI_FIBRE_CHANNEL_FIRST = \"ICSP_UEFI_FIBRE_CHANNEL_FIRST\"\n\nEC_SUCCESS = 0\nEC_FAILED = 1\n\nlog = logger.getIt(\"configure_boot_from_san\")\n\n# Parses the command line arguments.\ndef parseArgs(args):\n    parser = OptionParser()\n    parser.add_option(\"--fibre_channel_first\", \n            action=\"store_true\",\n            default=False,\n            dest = \"fibreChannelFirst\",\n            help = \"Moves the fibre channel device to the top of the UEFI boot order.\")\n    options, args = parser.parse_args(args)\n    if args:\n        parser.error(\"Additional positional arguments are not supported\")\n    return options, args\n\n# Writes an debug message to stdout.\ndef writeDebugMessage(msg):\n\n    # Write the message to stdout so that it shows up in the job output.\n    if (DEBUG):\n        print msg\n\n# Writes an info message to stdout.\ndef writeInfoMessage(msg):\n\n    # Write the message to stdout so that it shows up in the job output.\n    print msg\n\n# Writes an error message to stderr.\ndef writeErrorMessage(msg):\n\n    # Write the message to stderr so that it shows up in the job output.\n    sys.stderr.write(msg)\n\n# Returns \"True\" if the server is in UEFI mode; \"False\" otherwise.\ndef isServerInUefiMode(iloMgmtProc):\n\n    currentBootMode = iloMgmtProc.getCurrentBootMode()\n\n    if (DEBUG):\n        print \"currentBootMode = %s\" % currentBootMode\n\n    # For UEFI, the boot mode can come back as UEFI, UEFI_OPTIMIZED, or UEFI_OPTIMIZED_SECURE.\n    uefiPattern = re.compile(r\".*UEFI.*\")\n\n    result = uefiPattern.search(currentBootMode)\n\n    if result:\n        uefiMode = True\n    else:\n        uefiMode = False\n\n    return uefiMode\n\n# Writes a blob to the specified namespace.\ndef writeBlob( iloMgmtProc, iloNameSpace, blobName, blobData):\n\n    writeDebugMessage(\"Writing blob %s to namespace %s\" % (blobName, iloNameSpace))\n\n    maxTries = 10\n\n    # Retry loop in case the iLO can't service our request and gives us an error.\n    for i in range( 0, maxTries):\n        try:\n            iloMgmtProc.ims.writeBlobStore( iloMgmtProc.iloManagerRef, iloNameSpace, blobName, toByteList(blobData))\n            break\n        except (OpswareException, OpswareSystemException), why:\n            writeDebugMessage(\"Failed to write blob %s on try %d of %d\" % (blobName, (i+1), maxTries))\n\n            if (i < (maxTries - 1)):\n                time.sleep(15)\n            else:\n                raise Exception(\"Failed to write blob %s: %s\" % (blobName, why))\n\n# Main Routine\ndef main():\n\n    options, remaining_args = parseArgs(sys.argv[1:])\n\n    targetServer = ThisTargetServer()\n\n    iloMgmtProc = None\n\n    # Don't fail the step if the target server has no iLO, since the target server\n    # may be a VM.\n    try:\n        iloMgmtProc = ilo.getIlo(targetServer, log=log)\n    except (Exception), why:\n        writeInfoMessage(\"This server has no iLO\")\n        writeDebugMessage(str(why))\n\n    # Does the server have an associated iLO?\n    if (iloMgmtProc is not None):\n        uefiBootMode = False\n\n        try:\n            writeInfoMessage(\"Enabling boot from SAN\")\n            iloMgmtProc.ims.enableBootFromSAN(iloMgmtProc.iloManagerRef)\n        except (IloException, Exception), why:\n            writeErrorMessage(\"Error configuring boot from SAN:\\n%s\\n\" % str(why))\n            return EC_FAILED\n\n        try:\n            # Query the iLO to see if the server is in UEFI boot mode.\n            uefiBootMode = isServerInUefiMode(iloMgmtProc)\n        except (IloException, Exception), why:\n            writeErrorMessage(\"Error determining boot mode:\\n%s\\n\" % str(why))\n            return EC_FAILED\n\n        # We can only change the boot order if the server is in UEFI boot mode.  If the\n        # server is not in UEFI boot mode, then we do nothing.\n        if (uefiBootMode):\n            writeDebugMessage(\"Boot Mode is UEFI\")\n\n            if (options.fibreChannelFirst):\n                try:\n                    writeInfoMessage(\"Moving Fibre Channel to top of UEFI boot order\")\n\n                    # Writing anything to the ICSP_UEFI_FIBRE_CHANNEL_FIRST blob causes\n                    # the fibre channel device to be moved to the top of the UEFI boot\n                    # order.\n                    writeBlob( iloMgmtProc, ILO_TEMPORARY_NAMESPACE, ICSP_UEFI_FIBRE_CHANNEL_FIRST, \"1\")\n                except (OpswareException, OpswareSystemException, Exception), why:\n                    writeErrorMessage(\"Could not move fibre channel device to top of UEFI boot order:\\n%s\\n\" % str(why))\n                    return EC_FAILED\n        else:\n            writeInfoMessage(\"Boot Mode is not UEFI.\")\n    else:\n        writeInfoMessage(\"Target server does not have an iLO.  Skipping this step.\")\n\n    return EC_SUCCESS\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n",
            "description": "Configures bladeservers, DL580Gen8, and Gen9 servers or newer to boot from SAN by disabling the embedded storage controllers.  Non-blade G6, G7, and Gen8 servers, with the exception of the DL580Gen8, are not supported.\n\nOptions:\n  --fibre_channel_first  Moves the fibre channel device to the top of the boot order when set to true.  This option only applies to UEFI boot mode.  It has no effect in Legacy BIOS mode.\n\nPrerequisites:\n- A supported ProLiant server with a supported HBA/CNA.\n",
            "status": null,
            "name": "Configure Boot From SAN",
            "state": null,
            "eTag": "2015-08-04T07:30:01.000Z",
            "modified": "2015-08-04T07:30:01.000Z",
            "created": "2015-08-04T07:30:00.000Z",
            "category": "os-deployment-ogfs-scripts",
            "uri": "/rest/os-deployment-ogfs-scripts/1640001"
        },
        {
            "codeType": "OGFS",
            "displayCodeType": "OGFS",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "22",
                    "createdBy": "opsware",
                    "createdDate": "2015-08-04T07:30:04.000Z",
                    "usage": "Attempts a graceful shutdown using the iLO for ACPI-aware operating systems configured to support graceful shutdown.  A hard power off is performed after 2 minutes if the server is still not off.  This step does not power off VMs.\n\nParameters:\n  --failVM  Causes the script to fail with an error if the target server is a VM",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-08-04T07:30:04.000Z",
            "version": {
                "versionLabel": "22",
                "createdBy": "opsware",
                "createdDate": "2015-08-04T07:30:04.000Z",
                "usage": "Attempts a graceful shutdown using the iLO for ACPI-aware operating systems configured to support graceful shutdown.  A hard power off is performed after 2 minutes if the server is still not off.  This step does not power off VMs.\n\nParameters:\n  --failVM  Causes the script to fail with an error if the target server is a VM",
                "current": true
            },
            "source": "#!/usr/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n#\n\"\"\"\n(C) Copyright 2014-2015 Hewlett-Packard Development Company, L.P.\n\"\"\"\n\nimport sys\nfrom osprov import ilo\nfrom osprov.optparse_ext import OptionParser\nfrom osprov.osbp import ThisTargetServer, logger\nfrom pytwist.com.opsware.common import OpswareException, OpswareSystemException\nfrom pytwist.com.opsware.ilo import IloException\n\nEC_SUCCESS = 0\nEC_FAILED = 1\n\nDEBUG=@Debug:0@\n\nlog = logger.getIt(\"shutdown_server\")\n\n# Parses the command line arguments.\ndef parseArgs(args):\n    parser = OptionParser()\n\n    parser.add_option(\"--failVM\",\n           action=\"store_true\",\n           default=False,\n           dest=\"failVM\",\n           help=\"Fail if target server is a VM\")\n    options, args = parser.parse_args(args)\n    if args:\n        parser.error(\"Additional positional arguments are not supported\")\n    return options, args\n\n# Writes an debug message to stdout.\ndef writeDebugMessage(msg):\n\n    # Write the message to stdout so that it shows up in the job output.\n    if (DEBUG):\n        print msg\n\n# Writes an info message to stdout.\ndef writeInfoMessage(msg):\n\n    # Write the message to stdout so that it shows up in the job output.\n    print msg\n\n# Writes an error message to stderr.\ndef writeErrorMessage(msg):\n\n    # Write the message to stderr so that it shows up in the job output.\n    sys.stderr.write(msg)\n\n# Main Routine\ndef main():\n\n    options, remaining_args = parseArgs(sys.argv[1:])\n\n    targetServer = ThisTargetServer()\n\n    iloMgmtProc = None\n\n    # Don't fail the step if the target server has no iLO, since the target server\n    # may be a VM.\n    try:\n        iloMgmtProc = ilo.getIlo(targetServer, log=log)\n    except (Exception), why:\n        if (options.failVM):\n            writeErrorMessage(\"The server cannot be powered off because it has no iLO.\\n\")\n            writeErrorMessage(\"If the server is a VM and you don't want the script to fail, do not use the --failVM option.\\n\")\n            writeErrorMessage(str(why) + \"\\n\")\n            return EC_FAILED\n        else:\n            writeDebugMessage(str(why))\n\n    # Does the server have an associated iLO?\n    if (iloMgmtProc is not None):\n        uefiBootMode = False\n\n        try:\n            writeInfoMessage(\"Powering off server via the iLO\")\n            iloMgmtProc.ims.setPowerStatus(iloMgmtProc.iloManagerRef, False)\n            writeInfoMessage(\"Power off complete\")\n        except (IloException, Exception), why:\n            writeErrorMessage(\"An error occurred while attempting to power off server:\\n%s\\n\" % str(why))\n            return EC_FAILED\n    else:\n        writeInfoMessage(\"Target server does not have an iLO.  Skipping this step.\")\n\n    return EC_SUCCESS\n\nif __name__ == \"__main__\":\n    sys.exit(main())",
            "description": "Attempts a graceful shutdown using the iLO for ACPI-aware operating systems configured to support graceful shutdown.  A hard power off is performed after 2 minutes if the server is still not off.  This step does not power off VMs.\n\nParameters:\n  --failVM  Causes the script to fail with an error if the target server is a VM",
            "status": null,
            "name": "Shutdown Server",
            "state": null,
            "eTag": "2015-08-04T07:30:04.000Z",
            "modified": "2015-08-04T07:30:04.000Z",
            "created": "2015-08-04T07:30:04.000Z",
            "category": "os-deployment-ogfs-scripts",
            "uri": "/rest/os-deployment-ogfs-scripts/1680001"
        },
        {
            "codeType": "OGFS",
            "displayCodeType": "OGFS",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "8",
                    "createdBy": "opsware",
                    "createdDate": "2015-08-04T07:30:05.000Z",
                    "usage": "This scripts removes all or specific Custom Attributes for a server.\n\nThis script can also remove just the custom attributes generated by the “Collect and Store System Data” script.\n\nRequired Parameters:\n Only one of the following three must be specified:\n --all - Removes all of the custom attributes associated with that server.\n --allGeneratedAttrs - Removes only custom attributes that were set using the \"Collect and Store System Data \" step.\n --custAttrNames \"CA1 CA2 ...\"  - Removes just the specified custom attributes from the server.\n\nUsage:\n --all, --allGeneratedAttrs and --custAttrNames are mutually exclusive.  \n\nExamples:\n To remove all the custom attributes set on the target server/machine. \n --all\t\t\n\n To remove all the custom attributes created using the script \" Collect and Store System Data \" from the target machine.\n --allGeneratedAttrs\t\t\n\n To remove only selected set of attributes from the target server/machine.\n --custAttrNames \"NIC_MAC_Address Manufacturer Appliance_IP\"\n\nPrerequisite:\n Target servers run a service OS or supported Operating system.\n",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-08-04T07:30:05.000Z",
            "version": {
                "versionLabel": "8",
                "createdBy": "opsware",
                "createdDate": "2015-08-04T07:30:05.000Z",
                "usage": "This scripts removes all or specific Custom Attributes for a server.\n\nThis script can also remove just the custom attributes generated by the “Collect and Store System Data” script.\n\nRequired Parameters:\n Only one of the following three must be specified:\n --all - Removes all of the custom attributes associated with that server.\n --allGeneratedAttrs - Removes only custom attributes that were set using the \"Collect and Store System Data \" step.\n --custAttrNames \"CA1 CA2 ...\"  - Removes just the specified custom attributes from the server.\n\nUsage:\n --all, --allGeneratedAttrs and --custAttrNames are mutually exclusive.  \n\nExamples:\n To remove all the custom attributes set on the target server/machine. \n --all\t\t\n\n To remove all the custom attributes created using the script \" Collect and Store System Data \" from the target machine.\n --allGeneratedAttrs\t\t\n\n To remove only selected set of attributes from the target server/machine.\n --custAttrNames \"NIC_MAC_Address Manufacturer Appliance_IP\"\n\nPrerequisite:\n Target servers run a service OS or supported Operating system.\n",
                "current": true
            },
            "source": "#!/usr/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n#\n\n'''\n(C) Copyright 2014-2015 Hewlett-Packard Development Company, L.P.\n\nSTEP FUNCTIONALITY SHORT NOTE\n-----------------------------\nThis scripts removes all or specific Custom Attributes for a server. This script can also remove just the custom attributes generated by the Collect and Store System Data script.\nIf a specified custom attribute does not exist on the server then, the script will simply generate an INFO message and move ahead with other attributes without failing.\nAny attribute(s) that are removed from the server are logged into the job log for future reference.\n\nCUSTOM ATTRIBUTES from Collect and Store System Data\n------------------------------------------------------\nfollowing are the list of attributes that this step supports.\n\n==========================================================================================\n\tCA\t\t\t\tDescription\n==========================================================================================\n\tModel \t\t\t\tHardware Model \t\t\t\n\tUUID \t\t\t\tUUID \t\t\t\t\t\n\tSerial \t\t\t\tSerial Number \t\t\t\n\tCPU \t\t\t\t# of CPUs \t\t\t\t\n\tMemory \t\t\t\tMemory \t\t\t\t\t\n\tNIC_Name \t\t\tDeployment NIC Name \t\n\tNIC_MAC_Address \t\tDeployment NIC MAC address \n\tIP_Address \t\t\tDeployment IP \t\t\t\n\tiLO_IP \t\t\t\tiLO IP address \t\t\t\n\tRack \t\t\t\tRack \t\t\t\t\t\n\tEnclosure \t\t\tEnclosure \t\t\t\t\n\tBay \t\t\t\tBay \t\t\t\t\t\n\tSA_Object_Id \t\t\tSA Object ID \t\t\t\n\tManufacturer \t\t\tManufacturer \t\t\t\n\tNum_Disks \t\t\tNumber of disks \t\n\tDisk_Size\t\t\tTotal storage assigned to server\t\t\n\tAppliance_IP \t\t\tAppliance deployment IP \n\tMedia_Server_Share_IP \t\tMedia server share IP \t\t\n\tMedia_Server_Http_IP\t\tHTTP media server IP \n\n==========================================================================================\n\t\nARGUMENTS AND IMPLICATIONS\n--------------------------\nThe step offers several arguments which it supports for the users benefit.  Below is the \nlist of arguments and their implications on the step.\n\n-------------------------------------------------------------------------------------------\n\tArguments\t\t\tImplication\n-------------------------------------------------------------------------------------------\n\t\n\t--all\t\t\t\tWhen specified, the script removes all of the custom attributes associated with that server.\n\t\t\t\t\t\t\t\t\n\t--allGeneratedAttrs \t\tWhen specified, removes only custom attributes that were set on the target server using the Collect and Store System Data  step.\n\n\t--custAttrNames\t\"CA1 CA2 ...\" \tWhen specified removed just the specified custom attributes from the server.\n\t\t\t\t\t\t\t\t\n\n-------------------------------------------------------------------------------------------\t\n\n\nUSAGE GUIDELINES\n----------------\nFollowing are the general guidelines for using the step.\n\n\t1. --all, --allGeneratedAttrs and --custAttrNames are mutually exclusive.  When both the arguments are passed the\n\t\tstep will generate error and stop further execution\n\t\t\n\t2. --all or --allGeneratedAttrs or --custAttrNames is mandatory for the step. When none of them are mentioned the\n\t\tstep will generate usage help and generate error\n\n\t\t\nEXAMPLES ON THE STEP\n--------------------\n\tTo remove all the custom attributes set on the target server/machine \n\t\t--all\n\t\t\n\tTo remove all the custom attributes set using the step \"Create Custom Attributes For Server\"\n\tfrom the target machine\n\t\t--allGeneratedAttrs\n\t\t\n\tTo remove only selected set of attributes from the target server/machine\n\t\t--custAttrNames \"NIC_MAC_Address Manufacturer Appliance_IP\"\n\t\t\n\n'''\n\nimport re\nimport platform\nimport sys\nimport string\n\nfrom pytwist \t\t\t\t\t\t\timport *\nfrom pytwist.com.opsware.search \t\timport Filter\nfrom pytwist.com.opsware.server \t\timport ServerRef, ServerDetails\nfrom osprov.osbp \t\t\t\t\t\timport logger, thisServerID, ThisTargetServer\nfrom osprov.decorators \t\t\t\t\timport HandleShowErrorMessage\nfrom osprov.ogfs \t\t\t\t\t\timport ogsh_spin\nfrom osprov.server.sa \t\t\t\t\timport SAServer\nfrom pytwist.com.opsware.server \t\timport ServerRef\nfrom pytwist.com.opsware.shared \t\timport TwistConsoleService\nfrom pytwist.com.opsware.mgmtservice \timport *\n\nsys.path.append(\"/opt/opsware/pylibs\")\n\n# The log file\nLOG = logger.getIt(\"Remove Custom Attributes From Server\")\n\n# Valid attribute list\nValidServerAttributes = [\n\t\t('Model', \t\t\t\t\t'Hardware Model'), \t\t\t\n\t\t('UUID', \t\t\t\t\t'UUID'), \t\t\t\t\t\n\t\t('Serial', \t\t\t\t\t'Serial Number'), \t\t\t\n\t\t('CPU', \t\t\t\t\t'# of CPUs'), \t\t\t\t\n\t\t('Memory', \t\t\t\t\t'Memory'), \t\t\t\t\t\n\t\t('NIC_Name', \t\t\t\t'Deployment NIC Name'), \t\n\t\t('NIC_MAC_Address', \t\t'Deployment NIC MAC Address'), \n\t\t('IP_Address', \t\t\t\t'Deployment IP Address'), \t\t\t\n\t\t('iLO_IP', \t\t\t\t\t'iLO IP Address'),\n\t\t('Rack', \t\t\t\t\t'Rack'), \t\t\t\t\t\n\t\t('Enclosure', \t\t\t\t'Enclosure'), \t\t\t\t\n\t\t('Bay', \t\t\t\t\t'Bay'), \t\t\t\t\t\n\t\t('SA_Object_Id', \t\t\t'SA Object ID'), \t\t\t\n\t\t('Manufacturer', \t\t\t'Manufacturer'), \t\t\t\n\t\t('Num_Disks', \t\t\t\t'Number of disks'), \t\t\n\t\t('Disk_Size',\t\t\t\t'Total storage assigned to server'),\t\n\t\t('Appliance_IP', \t\t\t'Appliance deployment IP'), \n\t\t('Media_Server_Share_IP',\t'Media server share IP'), \t\t\n\t    ('Media_Server_HTTP_IP',    'HTTP media server IP')\n\t]\n\t\n# Valid arguments list\nValidArgumentsList = [\n\t\t'--all',\n\t\t'--allGeneratedAttrs',\n\t\t'--custAttrNames'\n\t]\n\n# Name of this function; helpful in uncluttering the code\nFunctionName = 'Remove Custom Attributes From Server'\n\n# Parameters passed for --allGeneratedAttrs agrument will be held in this\nParametersForAllVars = []\n\n# Boolean flag to indicate whether its going to be a clean sweep or not\nRemoveAllCustomAttributes = False\n\n# Boolean flag to indicate whether we need to remove selected variables\n# from the server or not.  We need a seperate variable for this as to seek\n# whether or not all the parameters given to be removed are correct and there\n# is actually something to remove.  Combining this with RemoveAllCustomAttributes\n# might yield adverse results.\nRemoveSelectedCustomAttributes = False\n\n# Twiste server instance\nTwistServerInstance = twistserver.TwistServer()\n\n# Target servers reference object\nThisServerReference = ServerRef( thisServerID() )\n\n# Target sever's server service instance reference\nThisServerService = TwistServerInstance.server.ServerService\n\n# The usage display function that emits the help text on the right usage of the script.\ndef showUsageHelp() :\n\tindex = 0\n\t\n\tprint '\\nStep : {0:s}\\n\\nUsage:  --all | --allGeneratedAttrs | --custAttrNames \"CA1 CA2 ...\"'.format(FunctionName)\n\tprint '\\n\\tArguments --all, --allGeneratedAttrs and --custAttrNames are mutually exclusive.'\n\tprint '\\n\\t--all               : when mentioned, this step will remove only the server level custom  ' \\\n\t\t\t'\\n\\t\\t\\t      attributes assigned to this server' \\\n\t\t\t'\\n\\t--allGeneratedAttrs : when mentioned, all the custom attributes that were create by the step  \\n' \\\n\t\t\t'\\t\\t\\t      \"Create Custom Attributes For Server\" will be removed from the server.\\n' \\\n\t\t\t'\\t--custAttrNames     : when mentiond removes a list of custom attributes supplied to it.\\n'\n\n\tprint '\\n\\tAttributes that will be removed when --allGeneratedAttrs is passed are given below.\\n\\t    ',\n\t\t\n\tfor item in ValidServerAttributes :\n\t\tindex = index + 1\n\t\tprint '%-23s ' % item[0],\n\t\tif ( index % 3 == 0) :\n\t\t\tprint '\\n\\t    ',\n\tprint '\\n\\n\\tNOTE: --custAttrNames, in additon to above listed parameters can take any other valid \\n' \\\n\t\t\t'\\t      Custom Attribute associated with the server'\n\t\n\ndef validateArguments(argv) :\n\t# Extract only the arguments from the list of arguments provided\n\targs = [ argument for argument in argv if argument[0:2] == '--' ]\t\t\n\targLen = len(args)\n\t\n\tif ( argLen < 1 ) :\n\t\tprint 'ERROR: No arguments are provided for the step. Please refer to the help on step.' \n\t\tshowUsageHelp()\n\t\tsys.exit(1)\n\t\n\tif argLen > 1 :\n\t\tprint 'ERROR: Conflicting arguments are provided for the step.  Please refer to the help on step.'\n\t\tshowUsageHelp()\n\t\tsys.exit(1)\n\t\t\n\t# Extract only those arguments that are not valid arguments\n\tnotArgs = [ argument for argument in args if argument not in ValidArgumentsList ]\n\n\tif len(notArgs) > 0 :\n\t\tprint 'ERROR: Invalid arguments passed for the step'\n\t\tprint 'INFO : List of invalid arguments are : ', ', '.join(notArgs)\n\t\tshowUsageHelp()\n\t\tsys.exit(1)\n\t\t\n\tglobal ValidAttributesList\n\tglobal ParametersForAllVars\n\tglobal RemoveAllCustomAttributes\n\tglobal RemoveSelectedCustomAttributes\n\n\tValidAttributesList = [ key for (key, value) in ValidServerAttributes ]\n\t\t\n\tif '--custAttrNames' in args :\n\t\tif len(argv) < 3 :\n\t\t\tprint 'ERROR: No attribute names were specified. --custAttrNames requires a list of attribute names to delete.Please refer to the help on step.'\n\t\t\tshowUsageHelp()\n\t\t\tsys.exit(1)\n\t\tRemoveSelectedCustomAttributes = True\n\t\tParametersForAllVars = argv[2].split(\" \")                 \n\t\t# Check for  any invalid set of attributes from ParametersForAllVars\n\t\tinvalidAttributes = [ attr for attr in ParametersForAllVars if attr not in ValidAttributesList ]\n\n\t\t\t\t\t\t\n\tif '--allGeneratedAttrs' in args :\n\t\tRemoveSelectedCustomAttributes = True\n\t\tParametersForAllVars = ValidAttributesList\n\t\t\n\tif '--all' in args :\n\t\tRemoveAllCustomAttributes = True\n\n\t\t\n\treturn True\n\t\n\n\t\ndef deleteCustomAttributes() :\n\t# Place holder for filtered custom attributes\n\tfilteredCAs = {}\n\t# Every possible attribute that is inherited or set for the server.\n\tallAttributes = ThisServerService.getCustAttrs(ThisServerReference, None, False)\n\t\n\t# In case the step has to remove all the attributes set on it. Then we exclude\n\t# the facility level or appliance level attribute here from the list\n\tif RemoveAllCustomAttributes :\n\t\tfor elem in allAttributes :\n\t\t\tif elem[0:6] != '__OPSW' :\n\t\t\t\tfilteredCAs[elem] = allAttributes[elem]\n\t\n\t# Pretty print flag \n\tprintOnce = True\n\t\n\t# Print/Log all the attributes that do not exist or many be incorrect to the \n\t# admin for reference\n\tif RemoveSelectedCustomAttributes :\n\t\tfor elem in ParametersForAllVars :\n\t\t\tif allAttributes.__contains__(elem) :\n\t\t\t\tfilteredCAs[elem] = allAttributes[elem]\n\t\t\telse :\n\t\t\t\tif printOnce :\n\t\t\t\t\tprintOnce = False\n\t\t\t\t\tprint 'The following custom attributes do not exist on the server'\n\t\t\t\t\tprint '-' * 86\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\tLOG.info('Custom Attribute ' + elem + ' does not exist')\n\t\t\t\tprint elem\n\t\t\n\t# If there are valid set of custom attributes that are to be removed knock them\n\t# off from the target server.\n\tif filteredCAs :\n\t\tprint '\\nThe following custom attributes have been removed from the server'\n\t\tprint '-' * 86\n\t\t\n\t\tLOG.info('\\nThe following custom attributes have been removed from the server')\n\t\tLOG.info('-' * 86)\n\t\t\n\t\tfor attribute in filteredCAs :\n\t\t\tThisServerService.removeCustAttr(ThisServerReference, attribute)\n\t\t\tLOG.info('{0:25s} : {1:50s}'.format(attribute, allAttributes[attribute]))\n\t\t\tprint '    {0:25s} : {1:50s}'.format(attribute, allAttributes[attribute])\n\t\n\t\tprint '-' * 86\n\t\tLOG.info('-' * 86)\n\t\t\ndef main(argv) :\n\tif validateArguments(argv) :\n\t\tdeleteCustomAttributes()\n\n\t\nif __name__ == \"__main__\":\n    sys.exit(main(sys.argv))\n",
            "description": "This scripts removes all or specific Custom Attributes for a server.\n\nThis script can also remove just the custom attributes generated by the “Collect and Store System Data” script.\n\nRequired Parameters:\n Only one of the following three must be specified:\n --all - Removes all of the custom attributes associated with that server.\n --allGeneratedAttrs - Removes only custom attributes that were set using the \"Collect and Store System Data \" step.\n --custAttrNames \"CA1 CA2 ...\"  - Removes just the specified custom attributes from the server.\n\nUsage:\n --all, --allGeneratedAttrs and --custAttrNames are mutually exclusive.  \n\nExamples:\n To remove all the custom attributes set on the target server/machine. \n --all\t\t\n\n To remove all the custom attributes created using the script \" Collect and Store System Data \" from the target machine.\n --allGeneratedAttrs\t\t\n\n To remove only selected set of attributes from the target server/machine.\n --custAttrNames \"NIC_MAC_Address Manufacturer Appliance_IP\"\n\nPrerequisite:\n Target servers run a service OS or supported Operating system.\n",
            "status": null,
            "name": "Remove Custom Attributes From Server",
            "state": null,
            "eTag": "2015-08-04T07:30:05.000Z",
            "modified": "2015-08-04T07:30:05.000Z",
            "created": "2015-08-04T07:30:05.000Z",
            "category": "os-deployment-ogfs-scripts",
            "uri": "/rest/os-deployment-ogfs-scripts/1700001"
        },
        {
            "codeType": "OGFS",
            "displayCodeType": "OGFS",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "36",
                    "createdBy": "opsware",
                    "createdDate": "2015-08-04T07:30:12.000Z",
                    "usage": "Adjusts the SystemDiskNumber custom attribute on Gen8 servers. The \"diskpart\" command may list the Virtual Install Disk before the system disk on some Gen8 servers.  When this situation occurs, the SystemDiskNumber custom attribute needs to be adjusted so that it references the system disk and not the Virtual Install Disk.  The server's SystemDiskNumber custom attribute is updated with the new value.\n\nOptional Parameters:\n--ca=\"Alternate-Custom-Attribute-Name\"   Specifies an alternate custom attribute name where the adjusted system disk number will get saved.  The default custom attribute is \"SystemDiskNumber\".\n\nCustom Attributes:  \n* SystemDiskNumber",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-08-04T07:30:12.000Z",
            "version": {
                "versionLabel": "36",
                "createdBy": "opsware",
                "createdDate": "2015-08-04T07:30:12.000Z",
                "usage": "Adjusts the SystemDiskNumber custom attribute on Gen8 servers. The \"diskpart\" command may list the Virtual Install Disk before the system disk on some Gen8 servers.  When this situation occurs, the SystemDiskNumber custom attribute needs to be adjusted so that it references the system disk and not the Virtual Install Disk.  The server's SystemDiskNumber custom attribute is updated with the new value.\n\nOptional Parameters:\n--ca=\"Alternate-Custom-Attribute-Name\"   Specifies an alternate custom attribute name where the adjusted system disk number will get saved.  The default custom attribute is \"SystemDiskNumber\".\n\nCustom Attributes:  \n* SystemDiskNumber",
                "current": true
            },
            "source": "#!/usr/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n#\n\"\"\"\n(C) Copyright 2013-2015 Hewlett-Packard Development Company, L.P.\n\"\"\"\n\nimport sys\nimport re\n\nfrom osprov.ogfs\timport\tRosh\nfrom osprov.osbp\timport  ThisTargetServer, logger\nfrom osprov.errors\timport ShowErrorMessage\nfrom optparse\t\timport  OptionParser\n \nDISK_CA_WINDOWS = \"SystemDiskNumber\"\n \nLOG = logger.getIt('adjust_system_disk_number_on_hp_proliant_gen8')\n\nresolution1 = \"Please edit the SystemDiskNumber custom attribute and set it to a valid disk number,\" \\\n              \"\\nor remove it so that the first available disk is automatically chosen for you.\"\n\n############################################################################################\n# Class to parse command line arguments.\n############################################################################################\n\ndef parseArgs(args):\n\t\"\"\" parse and normalise arguments for the script \"\"\"\n\tparser = OptionParser()\n\tparser.add_option(\"-c\", \"--ca\", metavar = \"CA\",\n\t\t\t\t\t  default = None,\n\t\t\t\t\t  help = \"The name of the custom attribute to set\")\n\toptions, args = parser.parse_args(args)\n\tif args:\n\t\tparser.error(\"Additional positional arguments are not supported\")\n\treturn options\n\n###########################################################################\n# A class to hold some basic disk information.\n###########################################################################\n\nclass MyDisk:\n\n\tdef __init__(self):\n\t\tself.diskNum = None\n\t\tself.status = None\n\t\tself.size = None\n\t\tself.interfaceType = None\n\n\tdef setDiskNumber(self, diskNum):\n\t\tself.diskNum = diskNum\n\n\tdef setStatus(self, status):\n\t\tself.status = status\n\n\tdef setSize(self, size):\n\t\tself.size = size\n\n\tdef setInterfaceType(self, interfaceType):\n\t\tself.interfaceType = interfaceType\n\n\tdef getDiskNumber(self):\n\t\treturn self.diskNum\n\n\tdef getStatus(self):\n\t\treturn self.status\n\n\tdef getSize(self):\n\t\treturn self.size\n\n\tdef getInterfaceType(self):\n\t\treturn self.interfaceType\n\n###########################################################################\n# This class adjusts the SystemDiskNumber custom attribute, so that the\n# correct system disk (e.g. boot disk) is selected.  The Gen8 servers have\n# embedded disks, known as the VID (Virtual Install Disk), which may show\n# up in the disk order before the real disks.  Since we do not want to\n# install Windows on those disks, we need to find the real system disk and\n# set SystemDiskNumber to reference it.  This allows subsequent Build Plan\n# Steps to correctly identify the system disk (e.g. boot disk).\n###########################################################################\n\nclass WinpeDiskNumberAdjuster:\n \n\tdiskCA = DISK_CA_WINDOWS\n \n\tsystemDiskNumberCA = \"@SystemDiskNumber@\"\n\n\tdef __init__(self, targetServer):\n\t\tself.targetServer = targetServer\n\t\tself.serverRef = targetServer.getServerRef()\n\t\tself.twistServer = targetServer.twistServer\n\t\tself.log = logger.getIt('WinpeDiskNumberAdjuster')\n \n\t###################################################################\n\t# Display some basic information about the disks, such as the\n        # disk number, status (e.g. Online, Offline, Missing), size, and \n        # the interface type (e.g. USB, RAID, FIBRE).\n\t###################################################################\n\n\tdef showDisks(self, disks):\n\n\t\tprint \"%-6s %-12s %-12s %-15s\" % (\"\", \"\", \"\", \"Interface\")\n\t\tprint \"%-6s %-12s %-12s %-15s\" % (\"Disk #\", \"Status\", \"Size\", \"Type\")\n\t\tprint \"%-6s %-12s %-12s %-15s\" % (\"------\", \"------------\", \"------------\", \"---------------\")\n\n\t\tfor disk in disks:\n\t\t\tif (disk.getDiskNumber() is not None):\n\t\t\t\tdiskNum = disk.getDiskNumber()\n\t\t\telse:\n\t\t\t\tdiskNum = \"\"\n\n\t\t\tif (disk.getStatus() is not None):\n\t\t\t\tstatus = disk.getStatus()\n\t\t\telse:\n\t\t\t\tstatus = \"\"\n\n\t\t\tif (disk.getSize() is not None):\n\t\t\t\tsize = disk.getSize()\n\t\t\telse:\n\t\t\t\tsize = \"\"\n\n\t\t\tif (disk.getInterfaceType() is not None):\n\t\t\t\tinterfaceType = disk.getInterfaceType()\n\t\t\telse:\n\t\t\t\tinterfaceType = \"\"\n\n\t\t\tprint \"%-6s %-12s %-12s %-15s\" % (diskNum, status, size, interfaceType)\n\n\t###################################################################\n\t# Returns the interface type (e.g. USB, RAID, FIBRE, etc) of the\n\t# disk that corresponds to the specified disk number.\n\t###################################################################\n\n\tdef getInterfaceTypeFromDiskNumber(self, diskNum):\n\n\t\tinterfaceType = None\n\n\t\tif (diskNum is not None):\n\n\t\t\tdiskpartCmdList = [\"RESCAN\"]\n\n\t\t\tdiskpartCmdList.append(\"SELECT DISK %s\" % diskNum)\n\t\t\tdiskpartCmdList.append(\"DETAIL DISK\")\n\t\t\tdiskpartCmdList.append(\"EXIT\")\n\t \t\t# retrieve the diskinfo in one bunch\n\t\t\tdiskpartOUT = self._runDiskpart(diskpartCmdList)\n\n\t\t\t# This regular expression extracts the interface type from the \"Type :\"\n\t\t\t# field, if there's a match. The \"(.+)\" is what puts the interface type\n\t\t\t# in the variable \"result.group(1)\".\n\t\t\tpattern = re.compile(r\"^\\s*Type\\s*:\\s*(.+)\\s*$\")\n\n\t\t\tfor line in diskpartOUT.splitlines():\n\t\t\t\tresult = pattern.search(line)\n\n\t\t\t\tif result:\n\t\t\t\t\tinterfaceType = result.group(1)\n\t\t\t\t\tbreak\n\n\t\treturn interfaceType\n\n\t###################################################################\n\t# Returns the disk that corresponds to the specified disk number.\n\t###################################################################\n\n\tdef getDiskByDiskNumber(self, disks, diskNumber):\n\t\tdiskReturned = None\n\n\t\tfor disk in disks:\n\t\t\tif (disk.getDiskNumber() == diskNumber):\n\t\t\t\tdiskReturned = disk\n\t\t\t\tbreak\n\n\t\treturn diskReturned\n\n\t###################################################################\n\t# Returns a list of disks obtained from the \"diskpart.exe\" command.\n\t###################################################################\n\n\tdef getDisksFromDiskpart(self):\n\n\t\tdisks = []\n\n\t\tpattern = re.compile(r\"^\\s*Disk\\s*(\\d+)\\s+([a-zA-Z]+)\\s+(\\d+ [a-zA-z]+)\\s+.*\")\n\n\t\t# get disk numbers from diskpart\n\t\tdisklistOUT = self._runDiskpart([\"RESCAN\",\"LIST DISK\",\"EXIT\"])\n\t\tdiskNumberList = []\n\t\tfor line in disklistOUT.split(\"\\n\"):\n\t\t\tresult = pattern.search(line)\n\n\t\t\tif result:\n\t\t\t\tdisk = MyDisk()\n\n\t\t\t\tdiskNumber = result.group(1)\n\t\t\t\tdisk.setDiskNumber(diskNumber)\n\n\t\t\t\tstatus = result.group(2)\n\t\t\t\tdisk.setStatus(status)\n\n\t\t\t\tsize = result.group(3)\n\t\t\t\tdisk.setSize(size)\n\n\t\t\t\tinterfaceType = self.getInterfaceTypeFromDiskNumber(diskNumber)\n\t\t\t\tdisk.setInterfaceType(interfaceType)\n\n\t\t\t\tdisks.append(disk)\n\n\t\treturn disks\n\n\t###################################################################\n\t# Finds the disk that is to be used as the boot disk.\n\t###################################################################\n\n \tdef findTargetBootDisk(self):\n\n\t\t# Get the list of disks from the \"diskpart.exe\" command.\n\t\tdisks = self.getDisksFromDiskpart()\n\n\t\t# Display some basic information about the disks.\n\t\tself.showDisks(disks)\n\n\t\t# Find the first available disk.  We skip disks that are\n                # USB or whose status is not \"Online\".\n\t\ttargetDevice = self.findFirstAvailableDisk(disks)\n\n\t\tif (targetDevice is not None):\n\t\t\tprint \"The system disk is disk #%s\" % targetDevice\n\t\telse:\n\t\t\tprint \"WARNING: Could not find a system disk\"\n\n\t\tif self.systemDiskNumberCA:\n\n\t\t\tprint \"The %s custom attribute is set to disk #%s\" % (DISK_CA_WINDOWS, self.systemDiskNumberCA)\n\t\t\tif (targetDevice is not None):\n\t\t\t\tif targetDevice == self.systemDiskNumberCA:\n\t\t\t\t\tprint \"The %s custom attribute matches the system disk\" % DISK_CA_WINDOWS\n\t\t\t\telse:\n\t\t\t\t\tprint \"WARNING: The %s custom attribute does not match the system disk\" % DISK_CA_WINDOWS\n\n\t\t\t# Let's get information about the disk referenced by the \"SystemDiskNumber\" custom attribute.\n\t\t\tdisk = self.getDiskByDiskNumber(disks, self.systemDiskNumberCA)\n\n\t\t\tif (disk is not None):\n\t\t\t\t# If the \"SystemDiskNumber\" custom attribute references a USB drive, then we must\n\t\t\t\t# exit with an error, because the VID disks on Gen8 servers show up as USB drives\n\t\t\t\t# and if we allow the VID to be partition, then the Intelligent Provisioning\n\t\t\t\t# embedded OS will no longer start.\n\t\t\t\tif (disk.getInterfaceType() == \"USB\"):\n\t\t\t\t\tmsg = \"The %s custom attribute is referencing disk #%s, which is a USB drive.\" % (DISK_CA_WINDOWS, self.systemDiskNumberCA)\n\t\t\t\t\tmsg += \"\\n\" + resolution1\n\t\t\t\t\tself.log.error(msg)\n\t\t\t\t\traise ShowErrorMessage(msg)\n\t\t\t\telse:\n\t\t\t\t\t# Issue a warning if the SystemDiskNumber custom attribute is referencing\n\t\t\t\t\t# a disk whose status is not \"Online\".\n\t\t\t\t\tif (disk.getStatus() != \"Online\"):\n\t\t\t\t\t\tprint \"WARNING: The %s custom attribute is referencing disk #%s, which has a status of '%s'.\" % (DISK_CA_WINDOWS, self.systemDiskNumberCA, disk.getStatus())\n\n\t\t\t\t\ttargetDevice = self.systemDiskNumberCA\n\t\t\telse:\n\t\t\t\tmsg = \"The %s custom attribute is referencing disk #%s, which does not exist.\" % (DISK_CA_WINDOWS, self.systemDiskNumberCA)\n\t\t\t\tmsg += \"\\n\" + resolution1\n\t\t\t\tself.log.error(msg)\n\t\t\t\traise ShowErrorMessage(msg)\n\n\t\treturn targetDevice\n\n\t###################################################################\n\t# Finds the first available disk. We skip disks that are USB or\n\t# whose status is not \"Online\".\n\t###################################################################\n\n\tdef findFirstAvailableDisk(self, disks):\n\n\t\tprint \"Searching for first available system disk ...\"\n\n\t\tdiskNum = None\n\n\t\tfor disk in disks:\n\t\t\tif (disk.getInterfaceType() != \"USB\"):\n\t\t\t\tif (disk.getStatus() == \"Online\"):\n\t\t\t\t\tdiskNum = disk.getDiskNumber()\n\t\t\t\t\tprint \"First available system disk is disk #%s\" % (disk.getDiskNumber())\n\t\t\t\t\tbreak\n\t\t\t\telse:\n\t\t\t\t\tprint \"Skipping disk #%s because its status is '%s'\" % (disk.getDiskNumber(),disk.getStatus())\n\t\t\telse:\n\t\t\t\tprint \"Skipping disk #%s because it is a USB drive\" % (disk.getDiskNumber())\n\n\t\treturn diskNum\n\n\t###################################################################\n\t# Runs the \"diskpart.exe\" utility and returns its output.\n\t###################################################################\n\n\tdef _runDiskpart(self, cmdlist=None):\n\t\t\"\"\" exeute diskpart with a command file generated string array \"\"\"\n\t\tdiskpartPath = Rosh.escape(\"diskpart.exe\")\n\t\ttempDiskpartTxtPath = self.targetServer.expandEnvVars(\"%temp%\\\\diskpart.txt\")\n\t\ttempfile = open(self.targetServer.pathToOGFS(tempDiskpartTxtPath), \"w\")\n\t\tfor cmd in cmdlist:\n\t\t\ttempfile.write(\"%s \\n\" % cmd)\n\t\ttempfile.close()\n\t\ttry:\n\t\t\toutput = self.targetServer.rosh().getStdout(\"'%s' /s '%s'\" % (diskpartPath, tempDiskpartTxtPath), log=self.log, displayName=\"Diskpart utility\")\n\t\texcept ProcessExecutionError, why:\n\t\t\traise why\n\t\treturn output\n\n\t###################################################################\n\t# Sets the value of the custom attribute whose name is specified\n        # by the \"caname\" argument to the method.  If no custom attribute\n        # name is specified, it defaults to the \"SystemDiskNumber\" custom\n        # attribute.\n\t###################################################################\n\n\tdef setTargetDeviceCA(self, value, caname=None):\n\t\t\"\"\" Set the boot disk device CA\n\t\t\t:param value:\tthe value of the CA\n\t\t\t:param caname:\tnon default CA name\n\t\t\"\"\"\n\t\tif not caname:\n\t\t\tcaname = self.diskCA\n\t\tprint \"Setting custom attribute %s = %s\" % (caname, value)\n \t\tself._setCA(caname, value)\n\n\t###################################################################\n        # Sets the specified custom attribute on the server.\n\t###################################################################\n\n\tdef _setCA(self, caName, caValue):\n\t\t\"\"\" get the value of a CA \"\"\"\n\t\tself.log.debug(\"Setting CA %s = %s\" % (caName, caValue))\n\t\tself.twistServer.server.ServerService.setCustAttr(self.serverRef, caName, caValue)\n\ndef main():\n\n\toptions = parseArgs(sys.argv[1:])\n\n\ttargetServer = ThisTargetServer()\n\n\twinpeDNA = WinpeDiskNumberAdjuster(targetServer)\n\n\ttry:\n\t\ttargetDevice = winpeDNA.findTargetBootDisk()\n\texcept (ShowErrorMessage), why:\n\t\tLOG.exception(why)\n\t\tsys.stderr.write(\"%s\\n\" % why)\n\t\treturn 1\n\n\tif targetDevice:\n\t\tprint \"Setting disk %s as boot target disk\" % targetDevice\n\t\twinpeDNA.setTargetDeviceCA(targetDevice, caname=options.ca)\n\telse:\n\t\tsys.stderr.write(\"Could not find a system disk.\")\n\t\treturn 1\n\nif __name__ == \"__main__\":\n\tsys.exit(main())",
            "description": "Adjusts the SystemDiskNumber custom attribute on Gen8 servers. The \"diskpart\" command may list the Virtual Install Disk before the system disk on some Gen8 servers.  When this situation occurs, the SystemDiskNumber custom attribute needs to be adjusted so that it references the system disk and not the Virtual Install Disk.  The server's SystemDiskNumber custom attribute is updated with the new value.\n\nOptional Parameters:\n--ca=\"Alternate-Custom-Attribute-Name\"   Specifies an alternate custom attribute name where the adjusted system disk number will get saved.  The default custom attribute is \"SystemDiskNumber\".\n\nCustom Attributes:  \n* SystemDiskNumber",
            "status": null,
            "name": "Adjust Windows System Disk Number on HP ProLiant Gen8",
            "state": null,
            "eTag": "2015-08-04T07:30:12.000Z",
            "modified": "2015-08-04T07:30:12.000Z",
            "created": "2015-08-04T07:30:12.000Z",
            "category": "os-deployment-ogfs-scripts",
            "uri": "/rest/os-deployment-ogfs-scripts/1730001"
        },
        {
            "codeType": "OGFS",
            "displayCodeType": "OGFS",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "51",
                    "createdBy": "opsware",
                    "createdDate": "2015-08-04T07:30:15.000Z",
                    "usage": "Verifies that the target server is configured in a boot mode that supported by the Build Plan.  The boot modes that the build plan supports can be specified using the options listed below.  For example, if the Build Plan installs an OS which does not support the UEFI boot mode, then the \"--uefi=false\" option should be specified, so that the Build Plan execution is stopped before the OS is attempted to be installed.\n\nOptions:\n    --legacy={true|false}  Specifies whether the build plan can be run on a server whose boot mode is set to Legacy BIOS mode.  Default is 'true'.\n    --uefi={true|false}  Specifies whether the build plan can be run on a server whose boot mode is set to UEFI mode.  Default is 'true'.\n    --optimized={enabled|disabled|any}  Specifies whether the build plan can only be run on a server with UEFI optimization enabled, disabled, or any.  The default is \"any\".\n    --secure={enabled|disabled|any}  Specifies whether the build plan can only be run on a server with UEFI secure boot enabled, disabled, or any.  The default is \"any\".",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-08-04T07:30:15.000Z",
            "version": {
                "versionLabel": "51",
                "createdBy": "opsware",
                "createdDate": "2015-08-04T07:30:15.000Z",
                "usage": "Verifies that the target server is configured in a boot mode that supported by the Build Plan.  The boot modes that the build plan supports can be specified using the options listed below.  For example, if the Build Plan installs an OS which does not support the UEFI boot mode, then the \"--uefi=false\" option should be specified, so that the Build Plan execution is stopped before the OS is attempted to be installed.\n\nOptions:\n    --legacy={true|false}  Specifies whether the build plan can be run on a server whose boot mode is set to Legacy BIOS mode.  Default is 'true'.\n    --uefi={true|false}  Specifies whether the build plan can be run on a server whose boot mode is set to UEFI mode.  Default is 'true'.\n    --optimized={enabled|disabled|any}  Specifies whether the build plan can only be run on a server with UEFI optimization enabled, disabled, or any.  The default is \"any\".\n    --secure={enabled|disabled|any}  Specifies whether the build plan can only be run on a server with UEFI secure boot enabled, disabled, or any.  The default is \"any\".",
                "current": true
            },
            "source": "#!/usr/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n#\n\"\"\"\n(C) Copyright 2014-2015 Hewlett-Packard Development Company, L.P.\n\"\"\"\n\nimport sys\nimport re\nfrom optparse import OptionParser\nfrom osprov import ilo\nfrom osprov.osbp import ThisTargetServer, logger\nfrom pytwist.com.opsware.common import OpswareException, OpswareSystemException\n\nDEBUG=@Debug:0@\n\nEC_SUCCESS = 0\nEC_FAILED = 1\n\nlog = logger.getIt(\"Verify Supported Boot Modes\")\n\nSuccessMsg = \"\\nThis server is running in a supported boot mode.\"\nErrorMsg   = \"\\nError: The current boot mode of this server is not supported by this Build Plan.\\\n              \\nChange the boot mode of the server to one of the supported boot modes or select a Build Plan that supports this boot mode.\\\n              \\nTo change the supported boot modes of this Build Plan, modify the parameters of this step.\"\n\ndef parseArgs(args):\n    parser = OptionParser()\n    parser.add_option(\"--legacy\", \n                      default=\"true\",\n                      dest = \"legacy\",\n                      help=\"Set to 'true' if the Build Plan can be run on a server configured \\\n                            in Legacy BIOS boot mode; 'false' otherwise.  The default is 'true'.\")\n    parser.add_option(\"--uefi\", \n                      default=\"true\",\n                      dest = \"uefi\",\n                      help=\"Set to 'true' if the Build Plan can be run on a server configured \\\n                            in UEFI boot mode; 'false' otherwise.  The default is 'true'.\")\n    parser.add_option(\"--optimized\",\n                      default=\"any\",\n                      dest = \"optimized\",\n                      help=\"Set to 'any' if the Build Plan can be run on a server configured with both UEFI optimized enabled and disabled. \\\n                            Set to 'enabled' if the Build Plan can be run on a server configured with UEFI optimized enabled. \\\n                            Set to 'disabled' if the Build Plan can be run on a server configured with UEFI optimized disabled. \\\n                            The default is 'any'.\")\n    parser.add_option(\"--secure\",\n                      default=\"any\",\n                      dest = \"secure_boot\",\n                      help=\"Set to 'any' if the Build Plan can be run on a server configured with UEFI secure boot enabled and disabled. \\\n                            Set to 'enabled' if the Build Plan can be run on a server configured with UEFI secure boot enabled. \\\n                            Set to 'disabled' if the Build Plan can be run on a server configured with UEFI secure boot disabled. \\\n                            The default is 'any'.\")\n\n    options, args = parser.parse_args(args)\n    if args:\n        parser.error(\"Additional positional arguments are not supported\")\n    return options, args\n\n# Writes an debug message to stdout.\ndef writeDebugMessage(msg):\n\n    # Write the message to stdout so that it shows up in the job output.\n    if (DEBUG):\n        print msg\n\n# Writes an info message to stdout.\ndef writeInfoMessage(msg):\n\n    # Write the message to stdout so that it shows up in the job output.\n    print msg\n\n# Writes an error message to stderr.\ndef writeErrorMessage(msg):\n\n    # Write the message to stderr so that it shows up in the job output.\n    sys.stderr.write(msg)\n\n# Checks the boot mode of the target server against the parameters passed to the script.\ndef checkBootMode( options, iloMgmtProc):\n\n    # Get the target server's current boot mode.\n    currentBootMode = iloMgmtProc.getCurrentBootMode()\n    writeInfoMessage(\"\\nThis server is currently running in %s mode.\" % currentBootMode)\n    \n    if (currentBootMode.upper() == \"LEGACY\"):\n        if (options.legacy.upper() == \"TRUE\"):\n            writeInfoMessage(SuccessMsg)\n        else:\n            raise Exception(ErrorMsg)\n    if (currentBootMode.upper() == \"UEFI\"):\n        if ((options.uefi.upper() == \"TRUE\") and \\\n           ((options.optimized.upper() == \"ANY\") or (options.optimized.upper() == \"DISABLED\")) and \\\n           ((options.secure_boot.upper() == \"ANY\") or (options.secure_boot.upper() == \"DISABLED\"))):\n            writeInfoMessage(SuccessMsg)\n        else:\n            raise Exception(ErrorMsg)\n\n    if (currentBootMode.upper() == \"UEFI_OPTIMIZED\"):\n        if ((options.uefi.upper() == \"TRUE\") and \\\n           ((options.optimized.upper() == \"ANY\") or (options.optimized.upper() == \"ENABLED\")) and \\\n           ((options.secure_boot.upper() == \"ANY\") or (options.secure_boot.upper() == \"DISABLED\"))):\n            writeInfoMessage(SuccessMsg)\n        else:\n            raise Exception(ErrorMsg)\n    if (currentBootMode.upper() == \"UEFI_OPTIMIZED_SECURE\"):\n        if ((options.uefi.upper() == \"TRUE\") and \\\n           ((options.optimized.upper() == \"ANY\") or (options.optimized.upper() == \"ENABLED\")) and \\\n           ((options.secure_boot.upper() == \"ANY\") or (options.secure_boot.upper() == \"ENABLED\"))):\n            writeInfoMessage(SuccessMsg)\n        else:\n            raise Exception(ErrorMsg)\n\n# Validates the options.\ndef validateOptions(options):\n\n    # The '--legacy\" option must be 'true' or 'false'.\n    if (options.legacy.upper() not in [ \"TRUE\", \"FALSE\" ]):\n        raise Exception(\"Invalid value for '--legacy'. Valid values are 'true' or 'false'.\")\n\n    # The '--uefi\" option must be 'true' or 'false'.\n    if (options.uefi.upper() not in [ \"TRUE\", \"FALSE\" ]):\n        raise Exception(\"Invalid value for '--uefi'. Valid values are 'true' or 'false'.\")\n\n    # The \"--optimized\" option must be \"any\", \"enabled\", or \"disabled\".\n    if (options.optimized.upper() not in [ \"ANY\", \"ENABLED\", \"DISABLED\" ]):\n        raise Exception(\"Invalid value for '--optimized'. Valid values are 'enabled', 'disabled', or 'any'.\")\n\n    # The \"--secure\" option must be \"any\", \"enabled\", or \"disabled\".\n    if (options.secure_boot.upper() not in [ \"ANY\", \"ENABLED\", \"DISABLED\" ]):\n        raise Exception(\"Invalid value for '--secure'. Valid values are 'enabled', 'disabled', or 'any'.\")\n\n    if ((options.uefi.upper()== \"FALSE\") and ((options.secure_boot.upper()==\"ENABLED\") or (options.optimized.upper()==\"ENABLED\"))):\n        raise Exception(\"\\nError: Conflicting Arguments found.If UEFI is false, Optimized or Secure mode can not be enabled. \\\n                         \\nCorrect the error by modifying the parameters of the \\\"Verify Supported boot Modes\\\" step. \")\n\n    if ((options.optimized.upper()==\"DISABLED\") and (options.secure_boot.upper()==\"ENABLED\")):\n        raise Exception(\"\\nError: Conflicting Arguments found.If UEFI Optimized mode is disabled, Secure mode can not be enabled. \\\n                         \\nCorrect the error by modifying the parameters of the \\\"Verify Supported boot Modes\\\" step. \")\ndef printUnsupportedMode(options):\n\n    list = []\n    if(options.legacy.upper()==\"FALSE\"):\n        list.append(\"Legacy mode\")\n    if(options.uefi.upper()==\"FALSE\"):\n        list.append(\"UEFI mode\")\n    else:\n        if(options.optimized.upper()==\"DISABLED\"):\n            list.append(\"UEFI with Optimization enabled\")\n        else:\n            if(options.optimized.upper()==\"ENABLED\"):\n                list.append(\"UEFI with optimization disabled\")\n            if(options.secure_boot.upper()==\"DISABLED\"):\n                list.append(\"UEFI with secure boot enabled\")\n            else:\n                if(options.secure_boot.upper()==\"ENABLED\"):\n                    list.append(\"UEFI with secure boot disabled\")\n\n    if len(list):\n        writeInfoMessage(\"\\nThis Build Plan does not support the following  boot modes:\")\n        for modes in list:\n            writeInfoMessage( \" - \" + modes)\n    else:\n         writeInfoMessage(\"\\nThis Build Plan supports all boot modes.\")\n\n# Main Routine\ndef main():\n\n    options, remaining_args = parseArgs(sys.argv[1:])\n    writeInfoMessage(\"Input Parameters: \" + str(options) )\n   \n    iloMgmtProc = None\n\n    targetServer = ThisTargetServer()\n\n    # Don't fail the step if the target server has no iLO, since the target server\n    # may be a VM.\n    try:\n        iloMgmtProc = ilo.getIlo(targetServer, log=log)\n    except (Exception), why:\n        writeDebugMessage(str(why))\n\n    # Does the server have an iLO?\n    if (iloMgmtProc is not None):\n        try:\n            # Make sure that the options contain valid values.\n            validateOptions(options)\n            # list the unsupported bootmode\n            printUnsupportedMode(options)\n\n            # Get the target server's boot mode.\n            currentBootMode = iloMgmtProc.getCurrentBootMode()\n\n            # Verify that the build plan supports the target server's boot mode,\n            # based on the values specified in the script parameters.\n            checkBootMode( options, iloMgmtProc);\n\n        except (Exception), why:\n            writeInfoMessage(why)\n            return EC_FAILED\n    else:\n        writeInfoMessage(\"Target server does not have an iLO.  Skipping this step.\")\n\n    return EC_SUCCESS\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n",
            "description": "Verifies that the target server is configured in a boot mode that supported by the Build Plan.  The boot modes that the build plan supports can be specified using the options listed below.  For example, if the Build Plan installs an OS which does not support the UEFI boot mode, then the \"--uefi=false\" option should be specified, so that the Build Plan execution is stopped before the OS is attempted to be installed.\n\nOptions:\n    --legacy={true|false}  Specifies whether the build plan can be run on a server whose boot mode is set to Legacy BIOS mode.  Default is 'true'.\n    --uefi={true|false}  Specifies whether the build plan can be run on a server whose boot mode is set to UEFI mode.  Default is 'true'.\n    --optimized={enabled|disabled|any}  Specifies whether the build plan can only be run on a server with UEFI optimization enabled, disabled, or any.  The default is \"any\".\n    --secure={enabled|disabled|any}  Specifies whether the build plan can only be run on a server with UEFI secure boot enabled, disabled, or any.  The default is \"any\".",
            "status": null,
            "name": "Verify Supported Boot Modes",
            "state": null,
            "eTag": "2015-08-04T07:30:15.000Z",
            "modified": "2015-08-04T07:30:15.000Z",
            "created": "2015-08-04T07:30:15.000Z",
            "category": "os-deployment-ogfs-scripts",
            "uri": "/rest/os-deployment-ogfs-scripts/1760001"
        },
        {
            "codeType": "OGFS",
            "displayCodeType": "OGFS",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "11",
                    "createdBy": "opsware",
                    "createdDate": "2015-08-04T07:30:18.000Z",
                    "usage": "Injects settings for personalization from HP CloudSystem Matrix into a Windows setup answer file. Personalization settings include network settings and certain OS settings that are often computer specific like Administrator password.\n\nUsage:\nMulti_NIC_inject_personalization_settings.py\n\nOptions: None\n\nNOTE: This file has not implemented plain text (Windows prior to 2008)\n\nThis script will use the standard file locations. \nThe following path locations are checked (in order), and if that file exists, it is updated and no further files are checked. X/Windows/Temp/Unattend.xml (For Windows 2008 OS Media installs),\nC/Windows/Panther/unattend.xml (For Windows 2008 WIM installs).\n\nPrerequisites:\n * Target file must be a valid Unattend answer file\n * Target file must be writable\n * multi_nic_configuration custom attribute must be present",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-08-04T07:30:18.000Z",
            "version": {
                "versionLabel": "11",
                "createdBy": "opsware",
                "createdDate": "2015-08-04T07:30:18.000Z",
                "usage": "Injects settings for personalization from HP CloudSystem Matrix into a Windows setup answer file. Personalization settings include network settings and certain OS settings that are often computer specific like Administrator password.\n\nUsage:\nMulti_NIC_inject_personalization_settings.py\n\nOptions: None\n\nNOTE: This file has not implemented plain text (Windows prior to 2008)\n\nThis script will use the standard file locations. \nThe following path locations are checked (in order), and if that file exists, it is updated and no further files are checked. X/Windows/Temp/Unattend.xml (For Windows 2008 OS Media installs),\nC/Windows/Panther/unattend.xml (For Windows 2008 WIM installs).\n\nPrerequisites:\n * Target file must be a valid Unattend answer file\n * Target file must be writable\n * multi_nic_configuration custom attribute must be present",
                "current": true
            },
            "source": "#!/usr/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n#\n\"\"\"\n(C) Copyright 2014-2015 Hewlett-Packard Development Company, L.P.\nInjects personalization settings from HP CloudeSystem Matrix into Unattend.xml\n\n\"\"\"\nimport os\nimport re\nimport sys\nfrom xml.dom.minidom import parse, parseString\n\nfrom osprov.optparse_ext import OptionParser, OptionValueError\nfrom osprov.errors import ShowErrorMessage\nfrom osprov.osbp import ThisTargetServer, logger\nfrom osprov.decorators import HandleShowErrorMessage\nfrom osprov.netconfig.helpers import getNetconfig\nfrom osprov.parsers.netconfig import getActiveInterface\nfrom osprov.profile import unattend\nfrom osprov import helpers\n\nLOG = logger.getIt(\"inject personalization\")\n\n# Server wide Custom Attribute field names\nHOST_NAME = 'hostname'\nMS_DOMAIN_TYPE = 'msdomaintype'\nDOMAIN = 'domain'\nDNS_SUFFIX_SEARCH_ORDER = 'dnssuffixsearchorder'\n\n# Nic specific field names\nMAC = 'mac'\nWINS = 'wins'\n\n# IPv4 Custom Attribute field names\nV4_PREFIX_SIZE = 'v4prefixsize'\nV4_GATEWAY = 'v4gateway'\nV4_DNS_SERVERS = 'v4dnsservers'\nV4_IPADDRESS = 'v4ipaddress'\nV4_DHCP = 'v4dhcp'\n\n# IPv6 Custom Attribute field names\nV6_PREFIX_SIZE = 'v6prefixsize'\nV6_GATEWAY = 'v6gateway'\nV6_DNS_SERVERS = 'v6dnsservers'\nV6_IPADDRESS = 'v6ipaddress'\nV6_DHCP = 'v6dhcp'\n\n# xml element names\nPUBLIC_KEY_TOKEN ='31bf3856ad364e35'\nMICROSOFT_WINDOWS_TCPIP = 'Microsoft-Windows-TCPIP'\nMICROSOFT_WINDOWS_SHELL_SETUP = 'Microsoft-Windows-Shell-Setup'\nMICROSOFT_WINDOWS_DNS_CLIENT = 'Microsoft-Windows-DNS-Client'\nMICROSOFT_WINDOWS_NETBT = 'Microsoft-Windows-NetBT'\nAMD_64 = 'amd64'\nNON_SXS = 'nonSxS'\nWCM_SCHEMA = 'http://schemas.microsoft.com/WMIConfig/2002/State'\nXSI_SCHEMA = 'http://www.w3.org/2001/XMLSchema-instance'\nLANGUAGE_NEUTRAL = 'neutral'\n\nMAXIMUM_NUMBER_OF_NICS = 16\n\nEC_NO_ERR = 0\nEC_USAGE = 1\nEC_TARGET_SERVER = 5\nEC_NO_CA = 20\nEC_NO_UNATTEND = 12\nEC_EXCEPTION = 100\nUSAGE = \"Usage: %s Unattend_path_in_OGFS\"\n\n\n\nCOMPUTER_NAME = \"\"\"@ComputerName@\"\"\"\n#Custom Attributes are limited to 1333 characters stored in the database, and so may be split into multiple \"chunks\"\nca_chunks_list = [\"\"\"@multi_nic_customization0@\"\"\",\n\t\"\"\"@multi_nic_customization1@\"\"\",\n\t\"\"\"@multi_nic_customization2@\"\"\",\n\t\"\"\"@multi_nic_customization3@\"\"\",\n\t\"\"\"@multi_nic_customization4@\"\"\",\n\t\"\"\"@multi_nic_customization5@\"\"\",\n\t\"\"\"@multi_nic_customization6@\"\"\",\n\t\"\"\"@multi_nic_customization7@\"\"\",\n\t\"\"\"@multi_nic_customization8@\"\"\",\n\t\"\"\"@multi_nic_customization9@\"\"\"]\n\ndef parseCustomization(string):\n\tresultDict = {}\n\n\tlines = string.splitlines()\n\tfor line in lines:\n\t\tline = line.rstrip()\n\t\tkey,value = line.split('=')\n\t\tmatch=re.search('\\d+$',key);\n\t\tif (match):\n\t\t\t# try and get the interface dict\n\t\t\tinterfaceNumber = int(match.group(0))\n\t\t\tinterfaceDict = {}\n\t\t\tif ( interfaceNumber in resultDict ):\n\t\t\t\tinterfaceDict = resultDict[interfaceNumber]\n\t\t\telse:\n\t\t\t\t# interface not already known, insert a new one\n\t\t\t\tresultDict[interfaceNumber] = interfaceDict\n\t\t\t# Strip the interface from this key and add it to the interface dict\n\t\t\tkey = key[0:match.start(0)]\n\t\t\t#print 'Adding new key' + key\n\t\t\tinterfaceDict[key] = value \n\t\t\t\t\n\t\telse:\n\t\t\t# add it as a key to the dictionary\n\t\t\tresultDict[key] = value\n\n\treturn resultDict\n\ndef get_net_size(netmask):\n\t(octet1, octet2, octet3, octet4) = netmask.split('.')\n\toctet1 = int(octet1)\n\toctet2 = int(octet2)\n\toctet3 = int(octet3)\n\toctet4 = int(octet4)\n\tsubnetBin = (octet1 << 24) + (octet2 << 16) + (octet3 << 8) + octet4;\n\tfor i in xrange(0,32):\n\t\tif (subnetBin & (1 << i)) != 0 :\n\t\t\treturn (32-i)\n\treturn 32\n\ndef createComponent(unattendDom, componentName):\n\tcomponent = unattendDom.createElement(\"component\")\n\tcomponent.setAttribute('language',LANGUAGE_NEUTRAL)\n\tcomponent.setAttribute('name',componentName)\n\tcomponent.setAttribute('processorArchitecture',AMD_64)\n\tcomponent.setAttribute('publicKeyToken',PUBLIC_KEY_TOKEN)\n\tcomponent.setAttribute('versionScope',NON_SXS)\n\tcomponent.setAttribute('xmlns:wcm',WCM_SCHEMA)\n\tcomponent.setAttribute('xmlns:xsi',XSI_SCHEMA)\n\treturn component\n\ndef addInterfacesElement(unattendDom, component):\n\tinterfaces = unattendDom.createElement('Interfaces')\n\tcomponent.appendChild(interfaces)\n\treturn interfaces\n\ndef addInterface(unattendDom, interfaces, interfaceDict):\n\t#print 'Adding interface with mac = %s' % interfaceDict[MAC]\n\tinterface = unattendDom.createElement('Interface')\n\tinterfaces.appendChild(interface)\n\t#interface.setAttribute('wcm:action', 'add')\n\n\taddChildWithTextNode(unattendDom, interface, 'Identifier', interfaceDict[MAC].replace(':','-'))\n\t\n\t# IPv4 DHCP Settings\n\tipv4Settings = unattendDom.createElement('Ipv4Settings')\n\tinterface.appendChild(ipv4Settings)\n\taddChildWithTextNode(unattendDom, ipv4Settings, 'DhcpEnabled', interfaceDict[V4_DHCP])\n\n\t# IPv6 DHCP Settings\n\tipv6Settings = unattendDom.createElement('Ipv6Settings')\n\tinterface.appendChild(ipv6Settings)\n\taddChildWithTextNode(unattendDom, ipv6Settings, 'DhcpEnabled', interfaceDict[V6_DHCP])\n\n\tunicastIpAddresses = unattendDom.createElement('UnicastIpAddresses')\n\tinterface.appendChild(unicastIpAddresses)\n\n\tif interfaceDict[V4_DHCP] != 'true':\n\t\tip4Cidr = interfaceDict[V4_IPADDRESS] + '/' + interfaceDict[V4_PREFIX_SIZE]\n\t\tip4Address = addChildWithTextNode(unattendDom, unicastIpAddresses, 'IpAddress', ip4Cidr)\n\t\tip4Address.setAttribute('wcm:action','add')\n\t\tip4Address.setAttribute('wcm:keyValue','1')\n\n\tif (interfaceDict[V6_DHCP] != 'true') and (V6_IPADDRESS in interfaceDict):\n\t\tip6Cidr = interfaceDict[V6_IPADDRESS] + '/' + interfaceDict[V6_PREFIX_SIZE]\n\t\ti6pAddress = addChildWithTextNode(unattendDom, unicastIpAddresses, 'IpAddress', ip6Cidr)\n\t\ti6pAddress.setAttribute('wcm:action','add')\n\t\ti6pAddress.setAttribute('wcm:keyValue','2')\n\n\troutes = unattendDom.createElement('Routes')\n\tinterface.appendChild(routes)\n\n\tif (V4_GATEWAY in interfaceDict):\n\t\troute = unattendDom.createElement('Route')\n\t\troutes.appendChild(route)\n\t\troute.setAttribute('wcm:action', 'add')\n\t\n\t\taddChildWithTextNode(unattendDom, route, 'Identifier', '1')\n\t\taddChildWithTextNode(unattendDom, route, 'Prefix', '0.0.0.0/0')\n\n\t\trouteNextHopAddress = unattendDom.createElement('NextHopAddress')\n\t\troute.appendChild(routeNextHopAddress)\n\t\trouteNextHopAddressValue = unattendDom.createTextNode(interfaceDict[V4_GATEWAY])\n\t\trouteNextHopAddress.appendChild(routeNextHopAddressValue)\n\t\n\t\taddChildWithTextNode(unattendDom, route, 'Metric', '0')\n\n\tif (V6_GATEWAY in interfaceDict):\n\t\troute = unattendDom.createElement('Route')\n\t\troutes.appendChild(route)\n\t\troute.setAttribute('wcm:action', 'add')\n\t\n\t\taddChildWithTextNode(unattendDom, route, 'Identifier', '2')\n\t\taddChildWithTextNode(unattendDom, route, 'Prefix', '::/0')\n\n\t\trouteNextHopAddress = unattendDom.createElement('NextHopAddress')\n\t\troute.appendChild(routeNextHopAddress)\n\t\trouteNextHopAddressValue = unattendDom.createTextNode(interfaceDict[V6_GATEWAY])\n\t\trouteNextHopAddress.appendChild(routeNextHopAddressValue)\n\t\n\t\taddChildWithTextNode(unattendDom, route, 'Metric', '0')\n\n\treturn interface\n\ndef findElementByAttribute(nodes, attribute, attributeName):\n\tfor n in nodes:\n\t\tif n.nodeType == 1:\n\t\t\tfor attrName, attrValue in n.attributes.items():\n\t\t\t\tif (attrName == attribute) and (attrValue == attributeName):\n\t\t\t\t\treturn n\n\treturn None\n\n\ndef doTcpipPersonalization (unattendDom, multi_netconfig):\n\t#print 'doing TCIP personalization'\n\tsettings = unattendDom.getElementsByTagName (\"settings\")\n\tsetting = findElementByAttribute(settings, 'pass', 'specialize')\n\tif setting is not None :\n\t\ttcpipComponent = createComponent(unattendDom,MICROSOFT_WINDOWS_TCPIP)\n\t\tsetting.appendChild(tcpipComponent)\n\t\tinterfaces=addInterfacesElement(unattendDom, tcpipComponent)\n\t\tfor i in xrange(0, MAXIMUM_NUMBER_OF_NICS) :\n\t\t\tif (i in multi_netconfig) :\n\t\t\t\taddInterface(unattendDom, interfaces, multi_netconfig[i])\n\ndef addChildWithTextNode (unattendDom, parent, childName, childTextValue):\n\tchild = unattendDom.createElement(childName)\n\tparent.appendChild(child)\n\tchild.appendChild(unattendDom.createTextNode(childTextValue))\n\treturn child\n\n\ndef addDnsInterface (unattendDom, multi_netconfig, interfaces, i):\n\tinterfaceDict = multi_netconfig[i]\n\n\tinterface = unattendDom.createElement('Interface')\n\tinterfaces.appendChild(interface)\n\tinterface.setAttribute('wcm:action', 'add')\n\n\taddChildWithTextNode (unattendDom, interface, 'Identifier', interfaceDict[MAC])\n\t\n\tif (DOMAIN in interfaceDict):\n\t\taddChildWithTextNode (unattendDom, interface, 'DNSDomain', interfaceDict[DOMAIN])\n\n\tallDnsServers = ''\n\n\tif (V4_DNS_SERVERS in interfaceDict):\n\t\tallDnsServers += interfaceDict[V4_DNS_SERVERS]\n\n\tif (V6_DNS_SERVERS in interfaceDict):\n\t\tif len(allDnsServers) > 0:\n\t\t\tallDnsServers += ','\n\t\tallDnsServers += interfaceDict[V6_DNS_SERVERS]\n\t\n\tif len(allDnsServers) > 0:\n\t\tdnsServerSearchOrder = unattendDom.createElement('DNSServerSearchOrder')\n\t\tinterface.appendChild(dnsServerSearchOrder)\n\t\tdnsEntries = allDnsServers.split(',')\n\t\tfor addr in xrange(0, len(dnsEntries)):\n\t\t\tipAddress = addChildWithTextNode (unattendDom, \n\t\t\t\tdnsServerSearchOrder, 'IpAddress', dnsEntries[addr])\n\t\t\tipAddress.setAttribute('wcm:action','add')\n\t\t\tipAddress.setAttribute('wcm:keyValue',str(addr+1))\n\t\taddChildWithTextNode (unattendDom, interface, 'EnableAdapterDomainNameRegistration', 'false')\n\t\taddChildWithTextNode (unattendDom, interface, 'DisableDynamicUpdate','false')\n\treturn interface\n\n\ndef doDnsPersonalization (unattendDom, multi_netconfig):\n\t#print 'Doing DNS personalization'\n\tsettings = unattendDom.getElementsByTagName ('settings')\n\tsetting = findElementByAttribute(settings, 'pass', 'specialize')\n\tif setting is not None :\n\t\tdnsComponent = createComponent(unattendDom, MICROSOFT_WINDOWS_DNS_CLIENT)\n\t\tsetting.appendChild(dnsComponent)\n\n\t\tsuffixSearchOrder = unattendDom.createElement('DNSSuffixSearchOrder')\n\t\tdnsComponent.appendChild(suffixSearchOrder)\n\n\t\tif DOMAIN in multi_netconfig :\n\t\t\taddChildWithTextNode(unattendDom, dnsComponent, 'DNSDomain', multi_netconfig[DOMAIN])\n\n\t\taddChildWithTextNode(unattendDom, dnsComponent, 'UseDomainNameDevolution','true')\n\t\t\n\t\tif DNS_SUFFIX_SEARCH_ORDER in multi_netconfig:\n\t\t\tsuffixes = multi_netconfig[DNS_SUFFIX_SEARCH_ORDER].split(',')\n\t\t\tfor suffix in xrange(0, len(suffixes)):\n\t\t\t\tdomainName = addChildWithTextNode (unattendDom, \n\t\t\t\t\tsuffixSearchOrder, 'DomainName',suffixes[suffix])\n\n\t\t\t\tdomainName.setAttribute('wcm:action','add')\n\t\t\t\tdomainName.setAttribute('wcm:keyValue',str(suffix+1))\n\n\t\tinterfaces=addInterfacesElement(unattendDom, dnsComponent)\n\t\tfor i in xrange(0, MAXIMUM_NUMBER_OF_NICS) :\n\t\t\tif (i in multi_netconfig) :\n\t\t\t\t#print 'checking nic ' + str(i)\n\t\t\t\taddDnsInterface(unattendDom, multi_netconfig, interfaces, i)\n\telse:\n\t\tprint 'Could not find \"specialize\" settings'\n\n\ndef doComputerNamePersonalization (unattendDom, multi_netconfig):\n\tsettings = unattendDom.getElementsByTagName ('settings')\n\tsetting = findElementByAttribute(settings, 'pass' ,'specialize')\n\tif setting is not None :\n\t\tshellComponent = findElementByAttribute(setting.childNodes, 'name', MICROSOFT_WINDOWS_SHELL_SETUP)\n\t\tif shellComponent is not None :\n\t\t\tcomputerNames = shellComponent.getElementsByTagName('ComputerName')\n\t\t\tif computerNames is not None:\n\t\t\t\t# computer name is already present, so replace the contents\n\t\t\t\tcomputerName=computerNames[0]\n\t\t\t\twhile computerName.firstChild is not None:\n\t\t\t\t\tcomputerName.removeChild(computerName.firstChild)\n\t\t\telse:\n\t\t\t\t# computer name is not present, so we create it.\n\t\t\t\tcomputerName = unattendDom.createElement('ComputerName')\n\t\t\t\tshellComponent.appendChild(computerName)\n\t\t\tcomputerNameValue = unattendDom.createTextNode(multi_netconfig[HOST_NAME])\n\t\t\tcomputerName.appendChild(computerNameValue)\n\t\t\t\n\t\telse:\n\t\t\tprint 'Could not find \"Microsoft-Windows-Shell-Setup\" component'\n\telse:\n\t\tprint 'Could not find \"specialize\" settings'\n\ndef addNetBtInterface (unattendDom, interfaces, multi_netconfig, i):\n\tinterfaceDict = multi_netconfig[i]\n\tif (WINS in interfaceDict) and (len(interfaceDict[WINS]) > 0):\n\t\twinsList = interfaceDict[WINS].split(',')\n\n\t\tinterface = unattendDom.createElement('Interface')\n\t\tinterfaces.appendChild(interface)\n\t\tinterface.setAttribute('wcm:action', 'add')\n\n\t\taddChildWithTextNode (unattendDom, interface, 'Identifier', interfaceDict[MAC])\n\n\t\tnameServerList = unattendDom.createElement('NameServerList')\n\t\tinterface.appendChild(nameServerList)\n\t\tfor i in xrange(0, len(winsList)):\n\t\t\twins = addChildWithTextNode(unattendDom, nameServerList, 'IpAddress', winsList[i])\n\t\t\twins.setAttribute('wcm:action','add')\n\t\t\twins.setAttribute('wcm:keyValue',str(i))\n\n\ndef doWinsPersonalization (unattendDom, multi_netconfig):\n\t#print 'doing WINS personalization'\n\n\tsettings = unattendDom.getElementsByTagName ('settings')\n\tsetting = findElementByAttribute(settings, 'pass' ,'specialize')\n\tif setting is not None :\n\t\tnetBtComponent = findElementByAttribute(setting.childNodes, 'name', MICROSOFT_WINDOWS_NETBT)\n\t\tif netBtComponent is None :\n\t\t\tnetBtComponent = createComponent (unattendDom, MICROSOFT_WINDOWS_NETBT)\n\t\t\tsetting.appendChild(netBtComponent)\n\t\tinterfaces=addInterfacesElement (unattendDom, netBtComponent)\n\n\t\tfor i in xrange(0, MAXIMUM_NUMBER_OF_NICS) :\n\t\t\tif (i in multi_netconfig) :\n\t\t\t\taddNetBtInterface(unattendDom, interfaces, multi_netconfig, i)\n\n\t\t\n\ndef injectPersonalization(targetServer, unattendPathOGFS, multi_netconfig):\n\t\"\"\" Inject the personalization information to the XML \"\"\"\n\ttry:\n\t\tif unattendPathOGFS[-3:].lower() == \"xml\":\n\t\t\tfileData = targetServer.readFile(unattendPathOGFS)\n\t\t\tunattendDom = parseString(fileData)\n\t\t\tdoComputerNamePersonalization(unattendDom, multi_netconfig)\n\t\t\tdoTcpipPersonalization(unattendDom, multi_netconfig)\n\t\t\tdoDnsPersonalization(unattendDom, multi_netconfig)\n\t\t\tdoWinsPersonalization(unattendDom, multi_netconfig)\n\t\telse:\n\t\t\tprint \"This script does not support .txt configuration files\"\n\t\t#print unattendDom.toprettyxml()\n\t\ttargetServer.writeFile(unattendPathOGFS, unattendDom.toxml())\n\texcept OSError, error:\n\t\traise ShowErrorMessage(\n\t\t\t\t\"Unable to update answer file over OGFS. %s\" % str(error.args), EC_EXCEPTION)\n\texcept IOError, error:\n\t\tLOG.exception(error)\n\t\traise ShowErrorMessage(\n\t\t\t\t\"Unable to update answer file over OGFS. %s\" % str(error.args), EC_EXCEPTION)\n\n@HandleShowErrorMessage(\"Inject Personalizations\", LOG)\ndef main():\n\t\"\"\" Main entry point \"\"\"\n\t#print MULTI_CUSTOMIZATION\n\ttargetServer = ThisTargetServer()\n\ttargetServer.setWorkDir(targetServer.getRemoteRoot())\n\tprint ca_chunks_list\n\tmultiinfo = parseCustomization(''.join(ca_chunks_list))\n\t#print multiinfo\n\tif multiinfo is None:\n\t\traise ShowErrorMessage (\"Error : multi_nic_customization Custom Attribute missing\")\n\n\tdiscoveredDefault = False\n\tcommonPaths = []\n\tcommonPaths.append(\"X/Windows/Temp/Unattend.xml\") #2008 OS Media\n\tcommonPaths.append(helpers.getSystemDrive(\"@SystemDrive:C@\")+\"/Windows/Panther/unattend.xml\") #2008 WIM\n\tfor unattendPathOGFS in commonPaths:\n\t\tif os.path.isfile(unattendPathOGFS):\n\t\t\tdiscoveredDefault = True\n\t\t\tbreak\n\tif not discoveredDefault:\n\t\traise ShowErrorMessage(USAGE % sys.argv[0] + \"\\n\")\n\n\tinjectPersonalization(targetServer, unattendPathOGFS, multiinfo)\n\tprint 'inject multi-nic personalization complete'\n\nif __name__ == \"__main__\":\n\tsys.exit(main())",
            "description": "Injects settings for personalization from HP CloudSystem Matrix into a Windows setup answer file. Personalization settings include network settings and certain OS settings that are often computer specific like Administrator password.\n\nUsage:\nMulti_NIC_inject_personalization_settings.py\n\nOptions: None\n\nNOTE: This file has not implemented plain text (Windows prior to 2008)\n\nThis script will use the standard file locations. \nThe following path locations are checked (in order), and if that file exists, it is updated and no further files are checked. X/Windows/Temp/Unattend.xml (For Windows 2008 OS Media installs),\nC/Windows/Panther/unattend.xml (For Windows 2008 WIM installs).\n\nPrerequisites:\n * Target file must be a valid Unattend answer file\n * Target file must be writable\n * multi_nic_configuration custom attribute must be present",
            "status": null,
            "name": "Inject Multi-NIC Personalization Settings",
            "state": null,
            "eTag": "2015-08-04T07:30:18.000Z",
            "modified": "2015-08-04T07:30:18.000Z",
            "created": "2015-08-04T07:30:18.000Z",
            "category": "os-deployment-ogfs-scripts",
            "uri": "/rest/os-deployment-ogfs-scripts/1830001"
        },
        {
            "codeType": "OGFS",
            "displayCodeType": "OGFS",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "23",
                    "createdBy": "opsware",
                    "createdDate": "2015-08-04T07:30:19.000Z",
                    "usage": "Displays media server settings provided in settings page.\n\nTo fully test your media server, run this step on one Windows and one Linux target.",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-08-04T07:30:19.000Z",
            "version": {
                "versionLabel": "23",
                "createdBy": "opsware",
                "createdDate": "2015-08-04T07:30:19.000Z",
                "usage": "Displays media server settings provided in settings page.\n\nTo fully test your media server, run this step on one Windows and one Linux target.",
                "current": true
            },
            "source": "#!/usr/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Do not change the two lines above. See PEP 8, PEP 263.\n#\n\n\n\"\"\"\n(C) Copyright 2014-2015 Hewlett-Packard Development Company, L.P.\n\"\"\"\n\nimport re\nimport sys\n\ndef main(argv):\n\n\tmediaServerPath = \"@__OPSW-Media-WinUser@@__OPSW-Media-WinPath@\"[6:]\n\tmediaServerPwd = [\"@__OPSW-Media-WinPassword@\"]\n\tmediaServerDls = re.split(\"[\\/\\\\:@]\",mediaServerPath)\n\n\tprint \"Your media server settings: \\n\"\n\tprint \"Media server host: \"+mediaServerDls[2]+\"\\n\"\n\tprint \"File share name: \"+mediaServerDls[3]+\"\\n\"\n\tprint \"File share user: \"+mediaServerDls[0]+\"\\n\"\n\n\tprint \"URL passed to Set Media Source: \\n\"\n\tprint \"@__OPSW-Media-WinUser@******@__OPSW-Media-WinPath@\\n\"\n\n\thttpmediaServerPath = \"@__OPSW-Media-LinURI@\"[6:]\n\tHTTPdls = re.split(\"[/]\",httpmediaServerPath)\n\tprint \"HTTP server host: \"+HTTPdls[1]+\"\\n\"\n\tprint \"HTTP server path specified: \"+HTTPdls[2]+\"\\n\"\n\tprint \"URI passed:@__OPSW-Media-LinURI@ \\n\"\n\t \n\t\n\t\n \t\nif __name__ == \"__main__\":\n    sys.exit(main(sys.argv))\n",
            "description": "Displays media server settings provided in settings page.\n\nTo fully test your media server, run this step on one Windows and one Linux target.",
            "status": null,
            "name": "Display Media Server Settings",
            "state": null,
            "eTag": "2015-08-04T07:30:19.000Z",
            "modified": "2015-08-04T07:30:19.000Z",
            "created": "2015-08-04T07:30:19.000Z",
            "category": "os-deployment-ogfs-scripts",
            "uri": "/rest/os-deployment-ogfs-scripts/1840001"
        },
        {
            "codeType": "OGFS",
            "displayCodeType": "OGFS",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "11",
                    "createdBy": "opsware",
                    "createdDate": "2015-08-04T07:30:21.000Z",
                    "usage": "Injects settings from HP CloudSystem Matrix for personalization into a Kickstart installation profile.\nPersonalization settings include network settings.\n\nUsage: inject_ks_personalization_settings.py\n\nOptions: None\n\n\nPrerequisites:\n- Target server runs a maintenance Linux OS.\n- Multi NIC customization custom attribute must be present.",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-08-04T07:30:21.000Z",
            "version": {
                "versionLabel": "11",
                "createdBy": "opsware",
                "createdDate": "2015-08-04T07:30:21.000Z",
                "usage": "Injects settings from HP CloudSystem Matrix for personalization into a Kickstart installation profile.\nPersonalization settings include network settings.\n\nUsage: inject_ks_personalization_settings.py\n\nOptions: None\n\n\nPrerequisites:\n- Target server runs a maintenance Linux OS.\n- Multi NIC customization custom attribute must be present.",
                "current": true
            },
            "source": "#!/usr/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n#\n\"\"\"\n(C) Copyright 2014-2015 Hewlett-Packard Development Company, L.P.\nThis program will inject personalized settings from HP CloudeSystem Matrix\ninto the kickstart file.\n\"\"\"\n\nimport sys\nimport re\n\nfrom osprov.profile import Kickstart\nfrom osprov.profile.kickstart import Directive\nfrom osprov.profile.kickstart import Script\nfrom osprov.errors import ShowErrorMessage\nfrom osprov.osbp import ThisTargetServer, logger\n\n\nEC_NO_ERR = 0\nEC_NO_CA = 20\nEC_EXCEPTION = 100\nKS_PATH = \"tmp/user.ks.cfg\"\n\nLOG = logger.getIt('inject_multi_nic_ks_pers')\n\n# Server wide Custom Attribute field names\nHOST_NAME = 'hostname'\nMS_DOMAIN_TYPE = 'msdomaintype'\nDOMAIN = 'domain'\nDNS_SUFFIX_SEARCH_ORDER = 'dnssuffixsearchorder'\n\n# Nic specific field names\nMAC = 'mac'\nWINS = 'wins'\n\n# IPv4 Custom Attribute field names\nV4_PREFIX_SIZE = 'v4prefixsize'\nV4_PREFIX = 'v4netmask'\nV4_GATEWAY = 'v4gateway'\nV4_DNS_SERVERS = 'v4dnsservers'\nV4_IPADDRESS = 'v4ipaddress'\nV4_DHCP = 'v4dhcp'\n\n# IPv6 Custom Attribute field names\nV6_PREFIX_SIZE = 'v6prefixsize'\nV6_GATEWAY = 'v6gateway'\nV6_DNS_SERVERS = 'v6dnsservers'\nV6_IPADDRESS = 'v6ipaddress'\nV6_DHCP = 'v6dhcp'\n\nMAXIMUM_NUMBER_OF_NICS = 16\n\n#Custom Attributes are limited to 1333 characters stored in the database, \n#and so may be split into multiple \"chunks\"\nca_chunks_list = [\"\"\"@multi_nic_customization0@\"\"\",\n\t\"\"\"@multi_nic_customization1@\"\"\",\n\t\"\"\"@multi_nic_customization2@\"\"\",\n\t\"\"\"@multi_nic_customization3@\"\"\",\n\t\"\"\"@multi_nic_customization4@\"\"\",\n\t\"\"\"@multi_nic_customization5@\"\"\",\n\t\"\"\"@multi_nic_customization6@\"\"\",\n\t\"\"\"@multi_nic_customization7@\"\"\",\n\t\"\"\"@multi_nic_customization8@\"\"\",\n\t\"\"\"@multi_nic_customization9@\"\"\"]\n\ndef parseCustomization(string):\n\tresultDict = {}\n\n\tlines = string.splitlines()\n\tfor line in lines:\n\t\tline = line.rstrip()\n\t\tkey,value = line.split('=')\n\t\tmatch=re.search('\\d+$',key);\n\t\tif (match):\n\t\t\t# try and get the interface dict\n\t\t\tinterfaceNumber = int(match.group(0))\n\t\t\tinterfaceDict = {}\n\t\t\tif ( interfaceNumber in resultDict ):\n\t\t\t\tinterfaceDict = resultDict[interfaceNumber]\n\t\t\telse:\n\t\t\t\t# interface not already known, insert a new one\n\t\t\t\tresultDict[interfaceNumber] = interfaceDict\n\t\t\t# Strip the interface from this key and add it to the interface dict\n\t\t\tkey = key[0:match.start(0)]\n\t\t\t#print 'Adding new key' + key\n\t\t\tinterfaceDict[key] = value \n\t\t\t\t\n\t\telse:\n\t\t\t# add it as a key to the dictionary\n\t\t\tresultDict[key] = value\n\n\treturn resultDict\n\ndef injectPersonalization(ks, multi_netconfig):\n\t\"\"\" Inject static networking configuration into the kickstart profile\"\"\"\n\t# ! remove the network directive if already there\n\tif hasattr(ks, \"network\"):\n\t\tks.directives.remove(ks.network)\n\n\tfor i in xrange(0, MAXIMUM_NUMBER_OF_NICS) :\n\t\tif (i in multi_netconfig) :\n\t\t\tstatic_dir = Directive(\"network\")\n\t\t\tinterfaceDict = multi_netconfig[i]\n\t\t\tif (HOST_NAME in multi_netconfig):\n\t\t\t\tfqdnStr = multi_netconfig[HOST_NAME]\n\t\t\t\tif (DOMAIN in multi_netconfig):\n\t\t\t\t\tfqdnStr += \".\" + multi_netconfig[DOMAIN]\n\t\t\t\tstatic_dir[\"hostname\"] = fqdnStr\n\n\t\t\tif (MAC in interfaceDict):\n\t\t\t\tstatic_dir[\"device\"]    =\tinterfaceDict[MAC].replace(\"-\",\":\")\n\n\t\t\tif interfaceDict[V4_DHCP] == 'false':\n\t\t\t\tstatic_dir[\"bootproto\"] = \"static\"\n\t\t\t\tif (V4_IPADDRESS in interfaceDict):\n\t\t\t\t\tstatic_dir[\"ip\"]        = interfaceDict[V4_IPADDRESS]\n\t\t\t\tif (V4_PREFIX in interfaceDict):\n\t\t\t\t\tstatic_dir[\"netmask\"]   = interfaceDict[V4_PREFIX]\n\t\t\t\t\t\n\t\t\t\t# Note V6 default gateway will overwrite V4 default gateway\n\t\t\t\t# To reverse this behavior, reverse the order of the following\n\t\t\t\t# gateway settings.\n\t\t\t\tif (V4_GATEWAY in interfaceDict):\n\t\t\t\t\tstatic_dir[\"gateway\"]   = interfaceDict[V4_GATEWAY]\n\t\t\t\tif (V6_GATEWAY in interfaceDict):\n\t\t\t\t\tstatic_dir[\"gateway\"]    = interfaceDict[V6_GATEWAY]\n\n\t\t\t\t\n\t\t\t\tnameServers = ''\n\t\t\t\tif (V6_DNS_SERVERS in interfaceDict):\n\t\t\t\t\tnameServers = interfaceDict[V6_DNS_SERVERS]\n\n\t\t\t\tif (V4_DNS_SERVERS in interfaceDict):\n\t\t\t\t\tif (len(nameServers) > 0):\n\t\t\t\t\t\tnameServers += \",\"+ interfaceDict[V4_DNS_SERVERS]\n\t\t\t\t\telse:\n\t\t\t\t\t\tnameServers = interfaceDict[V4_DNS_SERVERS]\n\t\t\t\tif (len(nameServers) > 0):\n\t\t\t\t\tstatic_dir[\"nameserver\"] = nameServers\n\t\t\t\t\n\t\t\telse:\n\t\t\t\tstatic_dir[\"bootproto\"] = \"dhcp\"\n\t\t\tif (interfaceDict[V6_DHCP] == \"false\"):\n\t\t\t\tif (V6_IPADDRESS in interfaceDict):\n\t\t\t\t\tif (V6_PREFIX_SIZE in interfaceDict):\n\t\t\t\t\t\tstatic_dir[\"ipv6\"] = interfaceDict[V6_IPADDRESS] + \"/\" + interfaceDict[V6_PREFIX_SIZE];\n\t\t\t\t\telse:\n\t\t\t\t\t\tstatic_dir[\"ipv6\"] = interfaceDict[V6_IPADDRESS]\n\t\t\telse:\n\t\t\t\tstatic_dir[\"ipv6\"] = \"dhcp\"\n\t\t\t#add directive to kickstart file\n\t\t\tks.directives.append(static_dir)\n\ndef writeKsFile(ksFile, ks):\n    \"\"\" Write the ks file to disk  \"\"\"\n    ksf = open(ksFile, \"w+\")\n    ksf.write(str(ks))\n    ksf.close()\n\n\ndef main():\n\ttry:\n\t\ttargetServer = ThisTargetServer()\n\t\ttargetServer.setWorkDir(targetServer.getRemoteRoot())\n\t\tmultiinfo = parseCustomization(''.join(ca_chunks_list))\n\n\t\tif not multiinfo:\n\t\t\treturn\n\t\t# open the kickstart\n\t\tksObj = Kickstart(open(KS_PATH))\n\t\t# start injecting\n\t\tinjectPersonalization(ksObj, multiinfo)\n\t\twriteKsFile(KS_PATH, ksObj)\n\texcept (OSError, IOError, ShowErrorMessage), why:\n\t\tprint \"Failed to inject multi-nic personalization settings:\\n%s\" % why\n\t\treturn EC_EXCEPTION\n\nif __name__ == \"__main__\":\n\tsys.exit(main())",
            "description": "Injects settings from HP CloudSystem Matrix for personalization into a Kickstart installation profile.\nPersonalization settings include network settings.\n\nUsage: inject_ks_personalization_settings.py\n\nOptions: None\n\n\nPrerequisites:\n- Target server runs a maintenance Linux OS.\n- Multi NIC customization custom attribute must be present.",
            "status": null,
            "name": "Inject Multi-NIC Kickstart Personalization Settings",
            "state": null,
            "eTag": "2015-08-04T07:30:21.000Z",
            "modified": "2015-08-04T07:30:21.000Z",
            "created": "2015-08-04T07:30:21.000Z",
            "category": "os-deployment-ogfs-scripts",
            "uri": "/rest/os-deployment-ogfs-scripts/1860001"
        },
        {
            "codeType": "OGFS",
            "displayCodeType": "OGFS",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "14",
                    "createdBy": "opsware",
                    "createdDate": "2015-08-04T07:30:23.000Z",
                    "usage": "Reset server life-cycle.\n\nAfter running this script, server life-cycle is set to UNPROVISIONED. This is intended to be used after decommissioning and erasing a server.\n\nParameters: None\n\nCustom Attributes: None",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-08-04T07:30:23.000Z",
            "version": {
                "versionLabel": "14",
                "createdBy": "opsware",
                "createdDate": "2015-08-04T07:30:23.000Z",
                "usage": "Reset server life-cycle.\n\nAfter running this script, server life-cycle is set to UNPROVISIONED. This is intended to be used after decommissioning and erasing a server.\n\nParameters: None\n\nCustom Attributes: None",
                "current": true
            },
            "source": "#!/usr/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n#\n\"\"\"\n    (C) Copyright 2013-2015 Hewlett-Packard Development Company, L.P.\n    Resets a server's lifecycle.\n\"\"\"\nimport sys\nimport time\n \nfrom osprov.decorators import HandleShowErrorMessage\nfrom osprov.ogfs import ogsh_spin\nfrom osprov.osbp import logger, ThisTargetServer\nfrom osprov.server.sa import Lifecycle\n \nlog = logger.getIt(\"Reset Server Life-Cycle\")\n \n \ndef updateLifecycle(targetServer, lifecycle, attempts=5, sleep=3):\n    for i in range(attempts):\n        try:\n            targetServer.updateState(lifecycle = lifecycle)\n            return\n        except: # pylint: disable=W0702\n            if i == attempts - 1:\n                raise\n            else:\n                log.warn(\"Failed to update server lifecycle\")\n        time.sleep(sleep)\n \n \n@HandleShowErrorMessage(\"reset lifecycle\", log)\ndef main():\n    targetServer = ThisTargetServer()\n    updateLifecycle(targetServer, Lifecycle.UNPROVISIONED)\n   \n    return 0\n \nif __name__ == \"__main__\":\n    sys.exit(main())",
            "description": "Reset server life-cycle.\n\nAfter running this script, server life-cycle is set to UNPROVISIONED. This is intended to be used after decommissioning and erasing a server.\n\nParameters: None\n\nCustom Attributes: None",
            "status": null,
            "name": "Reset Server Lifecycle To Unprovisioned",
            "state": null,
            "eTag": "2015-08-04T07:30:23.000Z",
            "modified": "2015-08-04T07:30:23.000Z",
            "created": "2015-08-04T07:30:23.000Z",
            "category": "os-deployment-ogfs-scripts",
            "uri": "/rest/os-deployment-ogfs-scripts/1880001"
        },
        {
            "codeType": "OGFS",
            "displayCodeType": "OGFS",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "12",
                    "createdBy": "opsware",
                    "createdDate": "2015-08-04T07:30:28.000Z",
                    "usage": "Injects required HP CloudSystem Matrix settings into a ESXi Kickstart answer file.  The install NFS directive will be inserted with the values used at the mount NFS share step.  This inject step also checks if an encrypted password was used, since such a password, cannot be used to automatically manage the hypervisor.  The SSH service is also enabled and started.\n\nArguments:\n    accept-encrypted-password - accept the password to be encrypted\n\nPrerequisites:\n* Target server runs a maintenance Linux OS.\n* The user provided or default ks file must be in /tmp/user.ks.cfg.\n* multi_nic_configuration custom attribute must be present\n* standard_switch custom attribute must be present",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-08-04T07:30:28.000Z",
            "version": {
                "versionLabel": "12",
                "createdBy": "opsware",
                "createdDate": "2015-08-04T07:30:28.000Z",
                "usage": "Injects required HP CloudSystem Matrix settings into a ESXi Kickstart answer file.  The install NFS directive will be inserted with the values used at the mount NFS share step.  This inject step also checks if an encrypted password was used, since such a password, cannot be used to automatically manage the hypervisor.  The SSH service is also enabled and started.\n\nArguments:\n    accept-encrypted-password - accept the password to be encrypted\n\nPrerequisites:\n* Target server runs a maintenance Linux OS.\n* The user provided or default ks file must be in /tmp/user.ks.cfg.\n* multi_nic_configuration custom attribute must be present\n* standard_switch custom attribute must be present",
                "current": true
            },
            "source": "#!/usr/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n\"\"\"\n(C) Copyright 2014-2015 Hewlett-Packard Development Company, L.P.\n Inject required options from HP CloudeSystem Matrix\n and move the file onto the boot partition.\n\n\"\"\"\n\nimport os\nimport re\nimport sys\nimport random\nimport optparse\nfrom osprov.netconfig.helpers import getNetconfig\nfrom osprov.parsers.netconfig import getActiveInterface\n\nfrom osprov.profile import Kickstart, ProfileError\nfrom osprov.profile.kickstart import Script, Directive\nfrom osprov.osbp import ThisTargetServer\nfrom osprov.errors import ShowErrorMessage\nfrom osprov import helpers, media\n\nBASE_KS_FILE = \"tmp/user.ks.cfg\"\n\n# Server wide Custom Attribute field names\nHOST_NAME = 'hostname'\nMS_DOMAIN_TYPE = 'msdomaintype'\nDOMAIN = 'domain'\nDNS_SUFFIX_SEARCH_ORDER = 'dnssuffixsearchorder'\n\n# Nic specific field names\nMAC = 'mac'\nWINS = 'wins'\nNETWORK_NAME = 'networkname'\n\n# IPv4 Custom Attribute field names\nV4_PREFIX_SIZE = 'v4prefixsize'\nV4_PREFIX = 'v4netmask'\nV4_GATEWAY = 'v4gateway'\nV4_DNS_SERVERS = 'v4dnsservers'\nV4_IPADDRESS = 'v4ipaddress'\nV4_DHCP = 'v4dhcp'\n\n# IPv6 Custom Attribute field names\nV6_PREFIX_SIZE = 'v6prefixsize'\nV6_GATEWAY = 'v6gateway'\nV6_DNS_SERVERS = 'v6dnsservers'\nV6_IPADDRESS = 'v6ipaddress'\nV6_DHCP = 'v6dhcp'\n\nMAXIMUM_NUMBER_OF_NICS = 16\n\n# Custom Attributes are limited to 1333 characters stored in the database, \n# and so may be split into multiple \"chunks\"\nca_chunks_list = [\"\"\"@multi_nic_customization0@\"\"\",\n\t\"\"\"@multi_nic_customization1@\"\"\",\n\t\"\"\"@multi_nic_customization2@\"\"\",\n\t\"\"\"@multi_nic_customization3@\"\"\",\n\t\"\"\"@multi_nic_customization4@\"\"\",\n\t\"\"\"@multi_nic_customization5@\"\"\",\n\t\"\"\"@multi_nic_customization6@\"\"\",\n\t\"\"\"@multi_nic_customization7@\"\"\",\n\t\"\"\"@multi_nic_customization8@\"\"\",\n\t\"\"\"@multi_nic_customization9@\"\"\"]\n\n# Custom attribute to configure the vSwitches\n# Format is vSwitch0=<vlan-name>,<vlan-name>;vSwitch1=<vlan-name>,<vlan-name>;...\n# vSwitch0 must have at least one vlan.  Additional vlans are optional and separated by semicolons\nstandard_switch = \"\"\"@standard_switch@\"\"\"\nmanagement_layer3_applied = False\n\ndef parseCustomization(string):\n\tresultDict = {}\n\n\tlines = string.splitlines()\n\tfor line in lines:\n\t\tline = line.rstrip()\n\t\tkey,value = line.split('=')\n\t\tmatch=re.search('\\d+$',key);\n\t\tif (match):\n\t\t\t# try and get the interface dict\n\t\t\tinterfaceNumber = int(match.group(0))\n\t\t\tinterfaceDict = {}\n\t\t\tif ( interfaceNumber in resultDict ):\n\t\t\t\tinterfaceDict = resultDict[interfaceNumber]\n\t\t\telse:\n\t\t\t\t# interface not already known, insert a new one\n\t\t\t\tresultDict[interfaceNumber] = interfaceDict\n\t\t\t# Strip the interface from this key and add it to the interface dict\n\t\t\tkey = key[0:match.start(0)]\n\t\t\t#print 'Adding new key' + key\n\t\t\tinterfaceDict[key] = value \n\t\t\t\t\n\t\telse:\n\t\t\t# add it as a key to the dictionary\n\t\t\tresultDict[key] = value\n\n\treturn resultDict\n\ndef checkMultipleLayer3Definitions():\n\tif management_layer3_applied == True:\n\t\tprint 'Error : Multiple Layer 3 network information cannot be specified vSwitches.'\n\t\tprint 'Suggested resolution : Remove layer 3 network information from all but one interface.'\n\t\tsys.exit (1)\n\ndef addNicToVswitch (interfaceDict, switchName, env_num):\n\t#print 'adding MAC ' + interfaceDict[MAC].replace(\"-\",\":\") + ' to ' + switchName\n\n\t# Here we create an enumerated environment variable with a value set to \n\t# the device name found by the MAC address.\n\tnic = 'VMNIC' + str(env_num) + '=$(esxcli network nic list | grep -i '\n\tnic += interfaceDict[MAC].replace(\"-\",\":\")\n\tnic += ' |'\n\tnic += ' awk -F \" \"'\n\tnic += \" '{ print $1 }')\\n\"\n\n\t# Set the IP address and mask\n\tif switchName=='vSwitch0':\n\n\t\t# If vlan tagging  is not used then esx_mgmt_vlan_id value should be 0\n\t\t# A esx_mgmt_vlan_id of 0 disables vlan_tagging in ESX and causes Mgmt to use interface of vswitch\n\t\tnic += 'esxcli network vswitch standard portgroup set --portgroup-name ' \n\t\tnic += '\"Management Network\" --vlan-id 0 --vswitch-name vSwitch0\\n'\n\n\t\tif interfaceDict[V4_DHCP] == 'false' and V4_IPADDRESS in interfaceDict:\n\t\t\tcheckMultipleLayer3Definitions()\n\t\t\tmanagement_layer3_applied = True\n\t\t\tnic += 'esxcli network ip interface ipv4 set  --interface-name=vmk0 --ipv4='\n\t\t\tnic += interfaceDict[V4_IPADDRESS]\n\t\t\tnic += ' --netmask='\n\t\t\tnic += interfaceDict[V4_PREFIX]\n\t\t\tnic += ' --type=static\\n'\n\n\t\t\t# Set the gateway\n\t\t\tif V4_GATEWAY in interfaceDict:\n\t\t\t\tnic += 'esxcli network ip route ipv4 add --gateway '\n\t\t\t\tnic += interfaceDict[V4_GATEWAY]\n\t\t\t\tnic += ' --network default\\n'\n\t\telse:\n\t\t\tcheckMultipleLayer3Definitions()\n\t\t\tmanagement_layer3_applied = True\n\t\t\tnic += 'esxcli network ip interface ipv4 set --interface-name=vmk0 --type=dhcp\\n'\n\telse:\n\t\tnic += createVSwitchAndPortgroup(switchName, interfaceDict[NETWORK_NAME])\n\n\t\t# Add NIC to failover policy\n\t\tnic += 'esxcli network vswitch standard policy failover set --active-uplinks=$VMNIC'\n\t\tnic += str(env_num) + '--vswitch-Name=\"' + switchName + '\"\\n'\n\n\t# Add uplink ports to the vSwitch\n\tnic += 'esxcli network vswitch standard uplink add --uplink-name=$VMNIC'\n\tnic += str(env_num) + ' --vswitch-name=\"' + switchName + '\"\\n'\n\n\treturn nic\n\ndef createVSwitchAndPortgroup(vSwitchName, portGroupName):\n\tswitch_def  = 'esxcli network vswitch standard add --vswitch-name=\"' + vSwitchName + '\"\\n'\n\tswitch_def += 'esxcli network vswitch standard portgroup add --portgroup-name=\"' \n\tswitch_def += portGroupName + '\" --vswitch-name=\"' + vSwitchName + '\"\\n'\n\treturn switch_def\n\n\ndef injectVMNICPersonalization(ks, multi_netconfig):\n\t\"\"\" Inject static management network information\"\"\"\n\n\tvm_nic = '%firstboot --interpreter=busybox\\n'\n\n\t# Remove all uplink ports from vSwitch0 (this assumes 4 uplink NICs)\n\tvm_nic += 'esxcli network vswitch standard uplink remove --uplink-name=vmnic0 --vswitch-name=vSwitch0\\n'\n\tvm_nic += 'esxcli network vswitch standard uplink remove --uplink-name=vmnic1 --vswitch-name=vSwitch0\\n'\n\tvm_nic += 'esxcli network vswitch standard uplink remove --uplink-name=vmnic2 --vswitch-name=vSwitch0\\n'\n\tvm_nic += 'esxcli network vswitch standard uplink remove --uplink-name=vmnic3 --vswitch-name=vSwitch0\\n'\n\n\tenv_num = 0\n\t# HPIO strips the line feeds from user defined properties, and we delimit it with a semi-colon.\n\tswitchesToConfigure = standard_switch.split(';')\n\tfor i in xrange(0, len(switchesToConfigure)):\n\t\tswitchName = switchesToConfigure[i].split('=')[0]\n\t\tnetwork_names = switchesToConfigure[i].split('=')[1]\n\t\t#print switchName + ' defined by ' + network_names\n\n\t\t# Configure the management vSwitch\t\n\t\t# Find the device name by the MAC address and set an environment variable\n\n\t\tlayerThreeSpecified = False\n\t\n\t\t#print 'User defined subnet names to add to the standard switch ' + switchName + ' are:' + str(network_names)\n\n\t\tfor i in xrange(0, MAXIMUM_NUMBER_OF_NICS) :\n\t\t\tif i in multi_netconfig and  NETWORK_NAME in multi_netconfig[i]:\n\t\t\t\tinterfaceDict = multi_netconfig[i]\n\t\t\t\tif interfaceDict[NETWORK_NAME] in network_names and interfaceDict[NETWORK_NAME] != 'vSwitch0':\n\t\t\t\t\tvm_nic += '\\n# Configure standard switch for ' + switchName + '\\n'\n\t\t\t\t\tvm_nic += addNicToVswitch (interfaceDict, switchName, env_num)\n\t\t\t\t\tenv_num += 1\n\n\t# Set the host name\n\tvm_nic += '\\n#Set the host name\\n'\n\tif (HOST_NAME in multi_netconfig):\n\t\tvm_nic += 'esxcli system hostname set '\n\t\tvm_nic += '--fqdn ' + multi_netconfig[HOST_NAME]\n\t\tif (DOMAIN in multi_netconfig):\n\t\t\tvm_nic += '.' + multi_netconfig[DOMAIN]\n\t\tvm_nic += '\\n'\n\n\n\t# Enable and start SSH\n\tvm_nic += '\\n# Enable and start ssh service\\n'\n\tvm_nic += 'vim-cmd hostsvc/enable_ssh\\n'\n\tvm_nic += 'vim-cmd hostsvc/start_ssh\\n'\n\n\tstatic_dir=Directive(vm_nic)\n\tks.directives.append(static_dir)\n\n\ndef initKickstart(baseFile):\n\t\"\"\" Initialize a Kickstart object \"\"\"\n\treturn  Kickstart(open(baseFile, \"r\"))\n\ndef removeConflictingOsprov(ksobj):\n\t\"\"\" Remove conflicting directives  \"\"\"\n\tif hasattr(ksobj, \"install\"):\n\t\tfor instance in  ksobj.getDirectiveList(\"install\"):\n\t\t\tprint \"Removing %s from the profile\" % instance\n\t\t\tinstance.name = \"#%s\" % instance.name\n\ndef injectRequiredOsprov(ksobj, mediaUrl):\n\t\"\"\" inject settings required for OS provisioning to work\n\t\tcurrently it only injects the nfs share. ESX uses different syntax.\n\t\"\"\"\n\tif not hasattr(ksobj, \"install\"):\n\t\tinst = Directive(\"install\")\n\t\tif mediaUrl.scheme == \"nfs\":\n\t\t\tinst[1] = \"nfs\"\n\t\t\tinst[\"server\"] = mediaUrl.netloc\n\t\t\tinst[\"dir\"]    = mediaUrl.path\n\t\telif mediaUrl.scheme in [ \"http\", \"https\" ]:\n\t\t\tif mediaUrl.username:\n\t\t\t\traise ShowErrorMessage(\n\t\t\t\t\t\"ESXi 4.1 doesn't support installing from a media server that requires authentication.\", 100)\n\t\t\tinst[1] = \"url\"\n\t\t\tinst[2] = mediaUrl.canonical()\n\t\telse:\n\t\t\traise ShowErrorMessage(\n\t\t\t\t\"ERROR: %s is not supported at this time\" % mediaUrl.scheme)\n\t\tksobj.directives.append(inst)\n\ndef hasEncPasswd(ksobj):\n\t\"\"\"Check if the root pwd is encrypted \"\"\"\n\ttry :\n\t\tif ksobj.rootpw[\"iscrypted\"]:\n\t\t\tpass\n\t\treturn True\n\texcept (KeyError, AttributeError):\n\t\treturn False\n\ndef getMediaURL(keys):\n\t\"\"\" determine the media URL \"\"\"\n\tif keys.media.url:\n\t\turl = keys.media.url\n\telse:\n\t\t# Fall back in case of old NFS mount script  \n\t\tmediaServer = open(\"/tmp/osbp_info/media_server\", \"r\").read().strip()\n\t\tmediaPath   = open(\"/tmp/osbp_info/media_path\", \"r\").read().strip()\n\t\tmediaMount  = open(\"/tmp/osbp_info/media_mount\", \"r\").read().strip()\n\t\turl = \"nfs://%s:%s/#%s\" % (mediaServer, mediaPath, mediaMount)\n\treturn media.parseUrl(url)\n\n\n\ndef injectPost(ksobj, unsupported, agentGW, mid, crypto):\n\t\"\"\" Inject code to stall the installer\"\"\"\n\t# Don't inject the IP change script  if this is static provisioning \n\n\tfor  script in ksobj.scripts:\n\t\tif  script.type == \"post\" and \\\n\t\t\t\"###  CODE BY HPSA ###\" in [ x.strip() for x in script.contents]:\n\t\t\treturn\n\n\tagentSrv, opswareCaCrt = crypto\n\n\tcontents = []\n\tcontents.append(\"###  CODE BY HPSA ###\")\n\tcontents.append(\"#### DON'T REMOVE THE ABOVE COMMENT ###\")\n\n\tcontents.extend((\"\"\"\n\ncat > /tmp/hpsa_agent_mid << EOF\n%s\nEOF\n\ncat > /tmp/hpsa_agent.srv << EOF\n%s\nEOF\n\ncat > /tmp/hpsa_ca.crt << EOF\n%s\nEOF\n\ncd /tmp\ntar xzf /hpsa_agent.tar.gz\ncd usr/hpsa_agent\ncp osprov/esxi_reg.sh /tmp/esxi_reg.sh\nchmod 755 /tmp/esxi_reg.sh\nif which localcli ; then\n\tlocalcli network firewall set -e false\n\tlocalcli network firewall get >> /tmp/hpsa_osprov.out\nfi\n/tmp/esxi_reg.sh \"/tmp/usr/hpsa_agent\" \"%s\"\nRC=$?\nif which localcli ; then\n\tlocalcli network firewall set -e true\n\tlocalcli network firewall get >> /tmp/hpsa_osprov.out\nfi\nexit $RC\n\"\"\" % (mid, agentSrv, opswareCaCrt, agentGW)).split(\"\\n\"))\n\n\tcontents.append('### END OF HPSA CODE ###')\n\n\tpost = Script(\"post\")\n\tif unsupported:\n\t\tpost[\"unsupported\"] = None\n\tpost[\"interpreter\"] = \"busybox\"\n\tpost[\"ignorefailure\"] = \"false\"\n\n\tpost.contents.extend(contents)\n\tksobj.scripts.append(post)\n\n\ndef writeFinalKs(ksobj):\n\t\"\"\" Write the kickstart file onto the boot disk \"\"\"\n\tksfile = open(BASE_KS_FILE, \"w\")\n\tksfile.write(str(ksobj))\n\tksfile.close()\n\tprint \"Kickstart file written to disk\"\n\ndef handleOsprov(ksobj, keys):\n\t\"\"\" change the profile to suit the environment \"\"\"\n\tremoveConflictingOsprov(ksobj)\n\tinjectRequiredOsprov(ksobj, getMediaURL(keys))\n\ndef parseArgs(args):\n\t\"\"\"Parse the command line arguments\"\"\"\n\tparser = optparse.OptionParser(description=__doc__,\tversion = '0.0.1', )\n\tparser.add_option('--accept-encrypted-password', default = False, dest=\"acceptencrypted\",\n\t\thelp = \"Continue installation even if user has given an encrypted password \",\n\t\taction = \"store_true\")\n\n\topt, args = parser.parse_args(args)\n\treturn opt\n\n\ndef injectDevice(ksobj, targetServer):\n    ksobj.network[\"device\"] = targetServer.getMACAddress()\n\n\ndef main():\n\t\"\"\" Do the injection into the kickstart \"\"\"\n\n\topt = parseArgs(sys.argv[1:])\n\n\tunsupported = False\n\t### FLAG_OVERRIDE ###\n\t# parse out flags\n\ttry:\n\t\ttargetServer = ThisTargetServer()\n\t\ttargetServer.setWorkDir(targetServer.getRemoteRoot())\n\t\tkeys = helpers.getDataStore(targetServer)\n\t\tksobj = initKickstart(BASE_KS_FILE)\n\t\t#exit if unable to retrieve password from ks.cfg\n\t\ttry:\n\t\t\tksobj.rootpw[1]\n\t\texcept (KeyError, AttributeError):\n\t\t\tprint \"Unable to read root password from kick start file. \"\\\n\t\t\t\t\"Please verify kickstart configuration in the build plan\"\n\t\t\treturn 10\n\n\t\tif hasEncPasswd(ksobj) and not opt.acceptencrypted:\n\t\t\tprint   \"Can not proceed with installation as the root password is encrypted\"\n\t\t\treturn 11\n\t\telse:\n\t\t\t# Save the root password for lather use \n\t\t\tkeys = helpers.getDataStore(targetServer)\n\t\t\tkeys.profile.username = \"root\"\n\t\t\tkeys.profile.password = ksobj.rootpw[1]\n\t\t\thelpers.putDataStore(keys, targetServer)\n\n\t\tmultiinfo = parseCustomization(''.join(ca_chunks_list))\n\t\tif len(standard_switch) == 0:\n\t\t\tprint 'Error : Custom Attribute \"standard_switch\" is not defined.'\n\t\t\tprint 'Resolution : define the custom attribute and retry.'\n\t\t\tsys.exit(1)\n\t\tinjectVMNICPersonalization(ksobj, multiinfo)\n\n\t\t# Extra steps\n\t\t# Below comment is used to generate scripts with additional actions,\n\t\t# don't remove\n\t\t## EXTRA STEPS ##\n\t\tstatic = False\n\t\tnetconfig = getNetconfig(\"\"\"@hpsa_netconfig@\"\"\", \"false\")\n\t\tif netconfig:\n\t\t\tactiveKey, activeIface = getActiveInterface(targetServer, netconfig)\n\t\t\tstatic = activeIface.static\n\t\tif not static:\n\t\t\tagentGw = targetServer.getRandomAgentGateway()\n\t\t\tmid = targetServer.getId()\n\t\t\tagentSrv = targetServer.readFile(os.path.join(targetServer.localServer.CRYPTO_DIR, \"agent.srv\"))\n\t\t\topswareCaCrt = targetServer.readFile(os.path.join(targetServer.localServer.CRYPTO_DIR, \"opsware-ca.crt\"))\n\t\t\tinjectPost(ksobj, unsupported, agentGw, mid, (agentSrv, opswareCaCrt))\n\t\tinjectDevice(ksobj, targetServer)\n\t\twriteFinalKs(ksobj)\n\t\t#print ksobj\n\t\tprint \"Successfully injected required settings\"\n\texcept (IOError, OSError, ProfileError, ShowErrorMessage), why:\n\t\tsys.stderr.write(\"Failed to inject required settings.%s\\n\" % why)\n\t\treturn 1\n\nif __name__ == \"__main__\":\n\tsys.exit(main())",
            "description": "Injects required HP CloudSystem Matrix settings into a ESXi Kickstart answer file.  The install NFS directive will be inserted with the values used at the mount NFS share step.  This inject step also checks if an encrypted password was used, since such a password, cannot be used to automatically manage the hypervisor.  The SSH service is also enabled and started.\n\nArguments:\n    accept-encrypted-password - accept the password to be encrypted\n\nPrerequisites:\n* Target server runs a maintenance Linux OS.\n* The user provided or default ks file must be in /tmp/user.ks.cfg.\n* multi_nic_configuration custom attribute must be present\n* standard_switch custom attribute must be present",
            "status": null,
            "name": "Inject Multi-NIC Required ESXi 5 Kickstart Settings",
            "state": null,
            "eTag": "2015-08-04T07:30:28.000Z",
            "modified": "2015-08-04T07:30:28.000Z",
            "created": "2015-08-04T07:30:28.000Z",
            "category": "os-deployment-ogfs-scripts",
            "uri": "/rest/os-deployment-ogfs-scripts/1950001"
        },
        {
            "codeType": "OGFS",
            "displayCodeType": "OGFS",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "24",
                    "createdBy": "opsware",
                    "createdDate": "2015-08-04T07:30:29.000Z",
                    "usage": "In UEFI mode, this step moves the PXE boot options to the end of the UEFI boot order.  The boot order is not changed if the server is in Legacy BIOS mode.",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-08-04T07:30:29.000Z",
            "version": {
                "versionLabel": "24",
                "createdBy": "opsware",
                "createdDate": "2015-08-04T07:30:29.000Z",
                "usage": "In UEFI mode, this step moves the PXE boot options to the end of the UEFI boot order.  The boot order is not changed if the server is in Legacy BIOS mode.",
                "current": true
            },
            "source": "#!/usr/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n#\n\"\"\"\n(C) Copyright 2014-2015 Hewlett-Packard Development Company, L.P.\n\"\"\"\n\nimport sys\nimport re\nfrom optparse import OptionParser\nfrom osprov import ilo\nfrom osprov.osbp import ThisTargetServer, logger\nfrom osprov.util.twist import toByteList, toPyString\nfrom pytwist.com.opsware.common import OpswareException, OpswareSystemException\n\nDEBUG=@Debug:0@\n\nILO_TEMPORARY_NAMESPACE = \"TMP\"\nICSP_UEFI_PXE_LAST = \"ICSP_UEFI_PXE_LAST\"\n\nEC_SUCCESS = 0\nEC_FAILED = 1\n\nlog = logger.getIt(\"Move PXE To The End Of UEFI Boot Order\")\n\n# Writes an debug message to stdout.\ndef writeDebugMessage(msg):\n\n    # Write the message to stdout so that it shows up in the job output.\n    if (DEBUG):\n        print msg\n\n# Writes an info message to stdout.\ndef writeInfoMessage(msg):\n\n    # Write the message to stdout so that it shows up in the job output.\n    print msg\n\n# Writes an error message to stderr.\ndef writeErrorMessage(msg):\n\n    # Write the message to stderr so that it shows up in the job output.\n    sys.stderr.write(msg)\n\n# Returns \"True\" if the server is in UEFI mode; \"False\" otherwise.\ndef isServerInUefiMode(iloMgmtProc):\n\n    currentBootMode = iloMgmtProc.getCurrentBootMode()\n\n    if (DEBUG):\n        print \"currentBootMode = %s\" % currentBootMode\n\n    # For UEFI, the boot mode can come back as UEFI, UEFI_OPTIMIZED, or UEFI_OPTIMIZED_SECURE.\n    uefiPattern = re.compile(r\".*UEFI.*\")\n\n    result = uefiPattern.search(currentBootMode)\n\n    if result:\n        uefiMode = True\n    else:\n        uefiMode = False\n\n    return uefiMode\n\n# Writes a blob to the specified namespace.\ndef writeBlob( iloMgmtProc, iloNameSpace, blobName, blobData):\n\n    writeDebugMessage(\"Writing blob %s to namespace %s\" % (blobName, iloNameSpace))\n\n    maxTries = 10\n\n    # Retry loop in case the iLO can't service our request and gives us an error.\n    for i in range( 0, maxTries):\n        try:\n            iloMgmtProc.ims.writeBlobStore( iloMgmtProc.iloManagerRef, iloNameSpace, blobName, toByteList(blobData))\n            break\n        except (OpswareException, OpswareSystemException), why:\n            writeDebugMessage(\"Failed to write blob %s on try %d of %d\" % (blobName, (i+1), maxTries))\n\n            if (i < (maxTries - 1)):\n                time.sleep(15)\n            else:\n                raise Exception(\"Failed to write blob %s: %s\" % (blobName, why))\n\n# Main Routine\ndef main():\n\n    targetServer = ThisTargetServer()\n\n    iloMgmtProc = None\n\n    # Don't fail the step if the target server has no iLO, since the target server\n    # may be a VM.\n    try:\n        iloMgmtProc = ilo.getIlo(targetServer, log=log)\n    except (Exception), why:\n        writeDebugMessage(str(why))\n\n    if (iloMgmtProc is not None):\n        uefiBootMode = False\n\n        try:\n            # Query the iLO to see if the server is in UEFI boot mode.\n            uefiBootMode = isServerInUefiMode(iloMgmtProc)\n        except (Exception), why:\n            writeErrorMessage(\"Error determining boot mode:\\n%s\\n\" % str(why))\n            return EC_FAILED\n\n        # We can only change the boot order if the server is in UEFI boot mode.  If the\n        # server is not in UEFI boot mode, then we do nothing.\n        if (uefiBootMode):\n            writeDebugMessage(\"Boot Mode is UEFI\")\n\n            try:\n                # Writing to the ICSP_UEFI_PXE_LAST blob causes PXE to be moved to the\n                # end of the UEFI boot order. Both the IPv4 and IPv6 PXE boot options are\n                # moved.  The order of the PXE boot is not changed, however.  That is,\n                # if IPv4 PXE came before IPv6 PXE, for example, that will remain the same\n                # after they are moved to the end of the boot order.\n                writeBlob( iloMgmtProc, ILO_TEMPORARY_NAMESPACE, ICSP_UEFI_PXE_LAST, \"1\")\n            except (OpswareException, OpswareSystemException, Exception), why:\n                writeErrorMessage(\"Could not set ESXi Boot Option:\\n%s\\n\" % str(why))\n                return EC_FAILED\n        else:\n            writeInfoMessage(\"Boot Mode is not UEFI.  Skipping this step.\")\n    else:\n        writeInfoMessage(\"Target server does not have an iLO.  Skipping this step.\")\n\n    return EC_SUCCESS\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n",
            "description": "In UEFI mode, this step moves the PXE boot options to the end of the UEFI boot order.  The boot order is not changed if the server is in Legacy BIOS mode.",
            "status": null,
            "name": "Move PXE To The End Of UEFI Boot Order",
            "state": null,
            "eTag": "2015-08-04T07:30:29.000Z",
            "modified": "2015-08-04T07:30:29.000Z",
            "created": "2015-08-04T07:30:29.000Z",
            "category": "os-deployment-ogfs-scripts",
            "uri": "/rest/os-deployment-ogfs-scripts/1970001"
        },
        {
            "codeType": "OGFS",
            "displayCodeType": "OGFS",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "9",
                    "createdBy": "opsware",
                    "createdDate": "2015-08-04T07:30:31.000Z",
                    "usage": "Collects system properties and stores the values in custom attributes or a text file.\n\nRequired Parameters: \n --allProps - Collect and store all supported properties\n --props “Property1 Property2\" - Collect and store only the properties specified \n --varfile \"file-name\" – Write the collected properties to the specified file\n --CA - Creates custom attributes for the collected properties.\n\nUsage:\n --allProps and --props are mutually exclusive\n You must specify either --varfile or --CA\n\nExamples:\n --allProps  --varfile \"C:\\ManagementSpace\\Attributes.txt\"\t\t\n --allProps  --CA\t\t\n --props \"NIC_MAC_Address Manufacturer Appliance_IP\" --varfile \"C:\\Temp\\Attributes.txt\"\t\t\n --props \"NIC_MAC_Address Manufacture Appliance_IP\" –CA\n\nPrerequisite:\n Target servers run a service OS or supported Operating system.\n\nAvailable properties:\nModel, UUID, Serial, CPU, Memory, NIC_Name, NIC_MAC_Address, IP_Address, iLO_IP, \nRack, Enclosure, Bay, SA_Object_Id, Manufacturer, Num_Disks, Disk_Size, Appliance_IP, \nMedia_Server_Share_IP, Media_Server_Http_IP",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-08-04T07:30:31.000Z",
            "version": {
                "versionLabel": "9",
                "createdBy": "opsware",
                "createdDate": "2015-08-04T07:30:31.000Z",
                "usage": "Collects system properties and stores the values in custom attributes or a text file.\n\nRequired Parameters: \n --allProps - Collect and store all supported properties\n --props “Property1 Property2\" - Collect and store only the properties specified \n --varfile \"file-name\" – Write the collected properties to the specified file\n --CA - Creates custom attributes for the collected properties.\n\nUsage:\n --allProps and --props are mutually exclusive\n You must specify either --varfile or --CA\n\nExamples:\n --allProps  --varfile \"C:\\ManagementSpace\\Attributes.txt\"\t\t\n --allProps  --CA\t\t\n --props \"NIC_MAC_Address Manufacturer Appliance_IP\" --varfile \"C:\\Temp\\Attributes.txt\"\t\t\n --props \"NIC_MAC_Address Manufacture Appliance_IP\" –CA\n\nPrerequisite:\n Target servers run a service OS or supported Operating system.\n\nAvailable properties:\nModel, UUID, Serial, CPU, Memory, NIC_Name, NIC_MAC_Address, IP_Address, iLO_IP, \nRack, Enclosure, Bay, SA_Object_Id, Manufacturer, Num_Disks, Disk_Size, Appliance_IP, \nMedia_Server_Share_IP, Media_Server_Http_IP",
                "current": true
            },
            "source": "#!/usr/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n#\n\n'''\n(C) Copyright 2014-2015 Hewlett-Packard Development Company, L.P.\n\nSTEP FUNCTIONALITY SHORT NOTE\n-----------------------------\nThis script queries properties that pertain to the target server, such as model, UUID, deployment IP address, etc. \nand either creates a custom attribute for these properties, where the custom attribute name is the same as the property name, \nor writes properties to a text file as tag/value pairs.  \nThese properties can then be read by your custom scripts to perform actions based on the property values.\n\n\nPROPERTIES & generated CUSTOM ATTRIBUTES \n----------------------------------------\nFollowing are the list of System properties that this step supports and generated Custom attribute name.\n\n==========================================================================================\n\tGenerated CA name\t\t\t\tDescription\n==========================================================================================\n\tModel \t\t\t\tHardware Model \t\t\t\n\tUUID \t\t\t\tUUID \t\t\t\t\t\n\tSerial \t\t\t\tSerial Number \t\t\t\n\tCPU \t\t\t\t# of CPUs \t\t\t\t\n\tMemory \t\t\t\tMemory \t\t\t\t\t\n\tNIC_Name \t\t\tDeployment NIC Name \t\n\tNIC_MAC_Address \t\tDeployment NIC MAC address \n\tIP_Address \t\t\tDeployment IP \t\t\t\n\tiLO_IP \t\t\t\tiLO IP address \t\t\t\n\tRack \t\t\t\tRack \t\t\t\t\t\n\tEnclosure \t\t\tEnclosure \t\t\t\t\n\tBay \t\t\t\tBay \t\t\t\t\t\n\tSA_Object_Id \t\t\tSA Object ID \t\t\t\n\tManufacturer \t\t\tManufacturer \t\t\t\n\tNum_Disks \t\t\tNumber of disks \t\n\tDisk_Size\t\t\tTotal storage assigned to server\t\t\n\tAppliance_IP \t\t\tAppliance deployment IP \n\tMedia_Server_Share_IP \t\tMedia server share IP \t\t\n\tMedia_Server_Http_IP\t\tHTTP media server IP \n\n==========================================================================================\n\t\n\t\nARGUMENTS AND IMPLICATIONS\n--------------------------\nThe step offers several arguments which it supports for the users benefit.  Below is the \nlist of arguments and their implications on the step.\n\n-------------------------------------------------------------------------------------------\n\tArguments\t\t\t       Implication\n-------------------------------------------------------------------------------------------\n\t\n\t--allProps \t\t\t       when specified, the script will create custom attributes \n\t\t\t\t\t       or write variables for all the supported properties listed below. \n\t\t\t\t\t\t\t\t\n\t--props \"Property1 Property2..\" ...    When specified, followed by a list of supported properties, the script \n\t\t\t\t\t       will create custom attributes or write variables only for the properties that were specified\n\t\t\t\t\t\t\t\t\n\t--varfile \"file-name\"\t\t       When specified, this parameter will cause the requested properties to be written to a file on the target server \n\t\t\t\t\t       and a series of name/value pairs. The file name specified should be fully qualified (for example C:\\ManagementSpace\\Attributes.txt for Windows based systems and /home/management/attributes.txt for Linux based systems). Note that the format of the specified path (Windows or Linux) is checked against the running OS type, and if there is a mismatch, the step will fail.\n\t\t\t\t\t\t\t\t\n\t--CA\t\t\t\t       When specified the script will create custom attributes on the target server for all of the specified properties. \n\n-------------------------------------------------------------------------------------------\t\n\n\nUSAGE GUIDELINES\n----------------\nFollowing are the general guidelines for using the step.\n\n\t1. --allProps  and --props are mutually exclusive.  When both the arguments are passed the\n\t\tstep will generate error and stop further execution\n\t\t\n\t2. --varfile or --CA are mandatory arguments and the step expects at least one among them\n\t\tto be mentioned in the list of argument.  Absence of both will result in a error and\n\t\tstep stops further execution.  However, both the arguments can be passed to the step\n\t\ttogether.\n\n\t\t\nEXAMPLES ON THE STEP\n--------------------\n\tTo dump all the supported keywords to be dumped onto the target server/machine \n\t\t--allProps  --varfile \"C:\\ManagementSpace\\Attributes.txt\"\n\t\t\n\tTo create custom attributes on the server/machine for all the supported keywords\n\t\t--allProps  --CA\n\t\t\n\tTo dump only selected set of keywords onto the target server/machine\n\t\t--props \"NIC_MAC_Address Manufacturer Appliance_IP\" --varfile \"C:\\Temp\\Attributes.txt\"\n\t\t\n\tTo create custom attributes on the server/machine for a selected set of keywords\n\t\t--props \"NIC_MAC_Address Manufacturer Appliance_IP\" --CA\n\n'''\n\nimport re\nimport platform\nimport sys\nimport string\n\nfrom pytwist \t\t\t\t\t\t\timport *\nfrom pytwist.com.opsware.search \t\timport Filter\nfrom pytwist.com.opsware.server \t\timport ServerRef, ServerDetails\nfrom osprov.osbp \t\t\t\t\t\timport logger, thisServerID, ThisTargetServer\nfrom osprov.decorators \t\t\t\t\timport HandleShowErrorMessage\nfrom osprov.ogfs \t\t\t\t\t\timport ogsh_spin\nfrom osprov.server.sa \t\t\t\t\timport SAServer\nfrom pytwist.com.opsware.server \t\timport ServerRef\nfrom pytwist.com.opsware.shared \t\timport TwistConsoleService\nfrom pytwist.com.opsware.mgmtservice \timport *\nfrom pytwist.com.opsware.locality\t\timport *\n\nsys.path.append(\"/opt/opsware/pylibs\")\n\nLOG = logger.getIt(\"Collect_and_Store_System_Data\")\n\n# Valid attribute list and keywords mapping\nValidServerAttributes = [\n\t\t('Model', \t\t\t\t\t'Hardware Model'), \t\t\t\n\t\t('UUID', \t\t\t\t\t'UUID'), \t\t\t\t\t\n\t\t('Serial', \t\t\t\t\t'Serial Number'), \t\t\t\n\t\t('CPU', \t\t\t\t\t'# of CPUs'), \t\t\t\t\n\t\t('Memory', \t\t\t\t\t'Memory'), \t\t\t\t\t\n\t\t('NIC_Name', \t\t\t\t'Deployment NIC Name'), \t\n\t\t('NIC_MAC_Address', \t\t'Deployment NIC MAC Address'), \n\t\t('IP_Address', \t\t\t\t'Deployment IP Address'), \t\t\t\n\t\t('iLO_IP', \t\t\t\t\t'iLO IP Address'),\n\t\t('Rack', \t\t\t\t\t'Rack'), \t\t\t\t\t\n\t\t('Enclosure', \t\t\t\t'Enclosure'), \t\t\t\t\n\t\t('Bay', \t\t\t\t\t'Bay'), \t\t\t\t\t\n\t\t('SA_Object_Id', \t\t\t'SA Object ID'), \t\t\t\n\t\t('Manufacturer', \t\t\t'Manufacturer'), \t\t\t\n\t\t('Num_Disks', \t\t\t\t'Number of disks'), \t\t\n\t\t('Disk_Size',\t\t\t\t'Total storage assigned to server'),\t\n\t\t('Appliance_IP', \t\t\t'Appliance deployment IP'), \n\t\t('Media_Server_Share_IP',\t'Media server share IP'), \t\t\n\t    ('Media_Server_HTTP_IP',    'HTTP media server IP')\n\t]\n\t\n# Global variables, though can be avoided helps in optimizing too many references \n# being opened at later point in time\n#\n# Variable holding the reference to the Twist Server\nTwistServerInstance = twistserver.TwistServer()\n\n# Variable holding the reference to core facility\nTwistCoreFacility = TwistServerInstance.shared.TwistConsoleService.getCoreFacility()\n\n# Variable holding the reference to twist servers facility service\nTwistFacilityService = TwistServerInstance.locality.FacilityService\n\n# Variable holding the value of server id aka SA Object Id \nThisServerIdentity = thisServerID()\n\n# Variable holding reference to instance of target server object\nThisServer = ThisTargetServer()\n\n# Variable holding reference to target servers reference structure\nThisServerReference = ServerRef( ThisServerIdentity )\n\n# Variable holding reference to server service of the twist server\nThisServerService = TwistServerInstance.server.ServerService\n\n# Variable holding reference to the server hardware inventory \nThisServerHardwareVO = ThisServerService.getServerHardwareVO( ThisServerReference )\n\n# Variable holding reference to target servers inventory\nThisServerVO = ThisServerService.getServerVO( ThisServerReference )\n\n# Function that returns the iLO ip address associated with the server, in case the target\n# is a physical machine.  For physical servers iLO ip address is returned and in case of \n# of a virtual machine or non-iLO based servers 'iLO not found' is returned.\ndef getIloIpAddress() :\n\tiloRef = ThisServerService.findManagersOfType(ThisServerReference, ManagerTypeConstant.ILO_MANAGER_TYPE)\n\t\t\n\tif iloRef :\n\t\tMgrService = TwistServerInstance.mgmtservice.ManagerService\n\t\tiloVo = MgrService.getManagerVO(iloRef[0])\t\t\n\t\treturn iloVo.getConnection().getNetworkAddress() \n\telse :\n\t\treturn None\n\t\t\n# Function that returns the model of the server\t\t\ndef getServerModel() :\n\treturn ThisServerHardwareVO.getModel()\n\t\n# Function that returns the UUID assigned to the server\t\ndef getServerUuid() :\n\treturn ThisServerHardwareVO.getUuid()\n\t\n# Function that returns the serial number associated with the server\ndef getServerSerialNumber() :\n\treturn ThisServerHardwareVO.getSerialNumber() \n\t\n# Function when called returns the number of CPUs present on it.\ndef getServerCpuCount() :\n\treturn len(ThisServerHardwareVO.getCpus())\n\n# Function when called returns the total physical memory or the RAM \n# associated with it.\ndef getServerMemorySize() :\n\tmemoryObj  = ThisServerHardwareVO.getMemories();\n\ttotRamSize = 0\n\t\n\tfor elem in memoryObj :\n\t\tif elem.getType() == \"RAM\" :\n\t\t\ttotRamSize = totRamSize + int(elem.getQuantity())\n\t\t\t\n\treturn totRamSize\n\t\n# Function when called returns the management ip address assigned to it\ndef getServerIpAddress() :\n\treturn ThisServerVO.getManagementIP()\n\t\n# Function when called returns the MAC address associated with the NIC that\n# is used as management node\ndef getServerMacAddress() :\n\tinterfaceObj = ThisServerHardwareVO.getInterfaces()\n\ttheIpAddress = getServerIpAddress()\n\t\n\tfor elem in interfaceObj :\n\t\tif elem.getIpAddress()  == theIpAddress :\n\t\t\treturn elem.getHardwareAddress()\n\t\n\treturn None\n\n# Returns the NIC name aka slot value associated with the card that is used\n# for management\ndef getServerNicName() :\n\tinterfaceObj = ThisServerHardwareVO.getInterfaces()\n\ttheIpAddress = getServerIpAddress()\n\t\n\tfor elem in interfaceObj :\n\t\tif elem.getIpAddress()  == theIpAddress :\n\t\t\treturn elem.getSlot()\n\t\n\treturn None\n\n# Returns the Rack details if the server is associated with a rack and the\n# information is assigned within the appliance. If no rack information is \n# found then 'Rack information not set' is returned.\ndef getServerRack() :\n\thwLocationObj = ThisServerHardwareVO.getServerHwLocation()\n\t\n\tif hwLocationObj :\n\t\treturn hwLocationObj.getRack()\n\telse :\n\t\treturn None\n\n# Returns the Bay details if the server is associated with a Bay and the\n# information is assigned within the appliance. If no Bay information is \n# found then 'Bay information not set' is returned.\t\t\ndef getServerBay() :\n\thwLocationObj = ThisServerHardwareVO.getServerHwLocation()\n\t\n\tif hwLocationObj :\n\t\treturn hwLocationObj.getBay()\n\telse :\n\t\treturn None\n\t\t\n# Returns the Enclosure details if the server is associated with a Enclosure and the\n# information is assigned within the appliance. If no Enclosure information is \n# found then 'Enclosure information not set' is returned.\t\ndef getServerEnclosure() :\n\thwLocationObj = ThisServerHardwareVO.getServerHwLocation()\n\t\n\tif hwLocationObj :\n\t\treturn hwLocationObj.getEnclosure()\n\telse :\n\t\treturn None\n\t\n# Returns the information about the server manufacturer \t\ndef getServerManufacturer() :\n\treturn ThisServerHardwareVO.getManufacturer()\n\t\n# Returns number of disks that are associated with the server.  The function only \n# considers physical disks that are connected to it, any other types (like CDROM,\n# USB, Virtual Drive etc) are ignored\ndef getServerNumDisks() :\n\tserverStorage  = ThisServerHardwareVO.getStorages()\n\tdrivesAttached = 0\n\t\n\tfor elem in serverStorage :\n\t\tif elem.getMedia() == 'SCSI DISK' :\n\t\t\tdrivesAttached = drivesAttached + 1\n\t\t\t\n\treturn drivesAttached\n\t\n# Returns the size of disk space allocated to the server. The function only \n# considers physical disks that are connected to it, any other types (like CDROM,\n# USB, Virtual Drive etc) are ignored\ndef getServerTotalDiskSize() :\n\tserverStorage  = ThisServerHardwareVO.getStorages()\n\ttotalDriveSize = 0\n\t\n\tfor elem in serverStorage :\n\t\tif elem.getMedia() == 'SCSI DISK' :\n\t\t\ttotalDriveSize = totalDriveSize + int(elem.getCapacity())\n\t\t\t\n\treturn totalDriveSize\n\n# Returns the SA object id assigned to the server\ndef getSAObjectId() :\n\t\treturn ThisServerIdentity\n\n# Returns the IP address associated with the appliance\ndef getApplianceIP() :\n\treturn TwistServerInstance.shared.TwistConsoleService.getTwistIP()\n\n# Returns the media servers IP address. If no media server is setup then \n# 'Media Share not set' is returned.\ndef getMediaServerShareIP() :\n\tmediaShareIp = TwistFacilityService.getCustAttr(TwistCoreFacility, '__OPSW-Media-WinPath', False)\n\t\n\tif mediaShareIp :\n\t\tmediaShareIp = mediaShareIp[1:].split('/')\n\t\n\tif len(mediaShareIp) > 0 :\n\t\treturn mediaShareIp[0]\n\t\n\treturn None\n\n# Returns the media servers HTTP publishing IP address.  If not HTTP server is set\n# then 'HTTP Media share not set' is returned\ndef getMediaServerHttpIP() :\n\thttpShareIp = TwistFacilityService.getCustAttr(TwistCoreFacility, '__OPSW-Media-LinURI', False)\n\t\n\tif httpShareIp :\n\t\thttpShareIp = httpShareIp.split('/')\n\t\t\n\tif len(httpShareIp) >= 2 :\n\t\treturn httpShareIp[2]\n\t\t\n\treturn None\n\t\n# Dictionary of keywords to API mapping.  This technique is adopted to avoid huge list of \n# if else conditional branching further in the code.  Any function which will be added in\n# future as keyword support should be added above this declaration, otherwise Python will\n# raise an error of unknown symbol.\t\nApiMapping = {\n\t\t'Model' \t\t\t\t: getServerModel,\n\t\t'UUID' \t\t\t\t\t: getServerUuid,\n\t\t'Serial' \t\t\t\t: getServerSerialNumber,\n\t\t'CPU' \t\t\t\t\t: getServerCpuCount,\n\t\t'Memory' \t\t\t\t: getServerMemorySize,\n\t\t'NIC_Name' \t\t\t\t: getServerNicName,\n\t\t'NIC_MAC_Address' \t\t: getServerMacAddress,\n\t\t'IP_Address' \t\t\t: getServerIpAddress,\n\t\t'iLO_IP' \t\t\t\t: getIloIpAddress,\n\t\t'Rack' \t\t\t\t\t: getServerRack,\n\t\t'Enclosure' \t\t\t: getServerEnclosure,\n\t\t'Bay' \t\t\t\t\t: getServerBay,\n\t\t'SA_Object_Id' \t\t\t: getSAObjectId,\n\t\t'Manufacturer' \t\t\t: getServerManufacturer,\n\t\t'Num_Disks' \t\t\t: getServerNumDisks,\n\t\t'Disk_Size'\t\t\t\t: getServerTotalDiskSize,\n\t\t'Appliance_IP' \t\t\t: getApplianceIP,\n\t\t'Media_Server_Share_IP' : getMediaServerShareIP,\n\t\t'Media_Server_HTTP_IP'\t: getMediaServerHttpIP\n\t}\n\n# Valid arguments list\nValidArgumentsList = [\n\t\t'--allProps',\n\t\t'--props',\n\t\t'--varfile',\n\t\t'--CA'\n\t]\n# Name of this function; helpful in uncluttering the code\nFunctionName = 'Collect and Store System Data'\n\n# File name to which the data should be dumped \nDumpFileName = ''\nDumpFileHandle = None\nUseFilteringOfAttributes = False\nSetCustomAttributesToServer = False\n\n# Specific variables that the caller is interested in\nUserPreferredVariables = []\n\n# Just the attributes, not necessary but optimizes the code\nValidAttributesList = []\n\n# The usage display function that emits the help text on the right usage of the script.\ndef showUsageHelp() :\n\tindex = 0\n\t\n\tprint '\\nStep : {0:s}\\nUsage:  ( --allProps  | --props \"Property1 Property2...\" ) ' \\\n\t\t  '--varfile \"file name\" [ --CA ]'.format(FunctionName)\n\tprint '\\tArguments --allProps  and --props are mutually exclusive, and mandatory.'\n\tprint '\\tWhen option --CA is mentioned, step will create Custom Attribute for all ' \\\n\t\t  'the supported properties on target server\\n'\n\tprint 'INFO: Extended help on the OSBP step ...\\n\\tValid argument list is : ', ValidArgumentsList\n\tprint '\\tValid attributes for --props\\n\\t    ',\n\t\t\n\tfor item in ValidServerAttributes :\n\t\tindex = index + 1\n\t\tprint '%-23s ' % item[0],\n\t\tif ( index % 3 == 0) :\n\t\t\tprint '\\n\\t    ',\n\t\t\n\t\t\n# Function that validates the arguments passed and sets the global data structures\t\ndef validateArguments(argv) :\n\t# Too few argument check!\n\targLen = len(argv)\n\t\n\tif ( argLen < 2 ) :\n\t\tif argLen == 1 :\n\t\t\tprint 'ERROR: No valid arguments were supplied for the step'\n\t\telse :\n\t\t\tprint 'ERROR: Mandatory arguments were not passed for the step'\n\t\t\t\n\t\tshowUsageHelp()\n\t\tsys.exit(1)\n\n\t# Extract only the arguments from the list of arguments provided\n\targs = [ argument for argument in argv if argument[0:2] == '--' ]\n\t# Extract only those arguments that are not valid arguments\n\tnotArgs = [ argument for argument in args if argument not in ValidArgumentsList ]\n\t\n\tglobal ValidAttributesList\n\tglobal UseFilteringOfAttributes\n\tglobal SetCustomAttributesToServer\n\t\n\tif ( len( notArgs) > 0 or ( ('--allProps' not in args and '--props' not in args) or\n\t                                 ('--allProps' in args and '--props' in args) ) ) : \n\t\tif('--allProps' in args and '--props' in args):\n\t\t\tprint 'ERROR: --allProps and --props arguments can not be used together in step invocation'\n\t\telse:\n\t\t\tprint 'ERROR: Mandatory arguments are missing in step invocation'\n\t\tprint 'INFO : Invalid argument(s) :', ', '.join(notArgs)\n\t\tshowUsageHelp()\n\t\tsys.exit(1)\n\n\tif ('--varfile' not in args and '--CA' not in args ) :\n\t\tprint 'ERROR: Mandatory arguments are missing in step invocation'\n\t\tprint 'INFO : Arguments must have at least one among --varfile or --CA'\n\t\tshowUsageHelp()\n\t\tsys.exit(1)\n\n\tValidAttributesList = [ key for (key, value) in ValidServerAttributes ]\n\t\t\n\tif '--props' in args :\n\t\textractpropsCompanions( argv )\n\t\t\n\tif '--varfile' in args :\n\t\tprepareDumpFile( argv )\n\t\t\n\tif len(UserPreferredVariables) > 0 :\n\t\tUseFilteringOfAttributes = True\n\t\t\n\tif '--CA' in args :\n\t\tSetCustomAttributesToServer = True\n\t\n\treturn True\n\n# Finalizes the dump file and closes the handlers\ndef finalizeDumpFile() :\n\tif DumpFileHandle :\n\t\tDumpFileHandle.flush()\n\t\tDumpFileHandle.close()\n\t\t\n# Function that extracts the dump file name from the list of arguments\n# that are passed to the step\ndef prepareDumpFile(argv) :\n\tglobal DumpFileName\n\tglobal DumpFileHandle\n\thasErrors = False\n\t\n\tvarFilePosition = argv.index('--varfile') + 1\n\t\n\tif ( len(argv) > varFilePosition and argv[varFilePosition][0:2] != '--' ) :\n\t\tDumpFileName = argv[ varFilePosition ]\n\t\t\n\t\tif 'win' in ThisServerVO.getOsVersion().lower() :\n\t\t\tif ( (':' not in DumpFileName) or ('/' in DumpFileName) ) :\n\t\t\t\tprint 'ERROR: File name convention is not standard to WINDOWS platform ,please review the File name (%s).'%DumpFileName\n\t\t\t\thasErrors = True\n\t\telse :\n\t\t\tif ( (':' in DumpFileName and '\\\\' in DumpFileName) or ('/' not in DumpFileName) ) :\n\t\t\t\tprint 'ERROR: File name convention is not standard to UNIX platform ,please review the File name (%s).'%DumpFileName\t\t\t\t                                           \n\t\t\t\thasErrors = True\n\t\t\t\t\n\t\tif hasErrors :\n\t\t\tsys.exit(1)\t\n\t\t\t\t\t\t\t\t\n\t\ttry:\n\t\t\tfilePath = ThisServer.pathToOGFS(DumpFileName)\n\t\t\tDumpFileHandle = open( filePath, 'w' )\n\t\texcept:\n\t\t\tprint 'ERROR: A file could not be opened for writing on the given path . Please ' \\\n\t\t\t\t  '       check if the given path exists and should not be write protected'\n\t\t\tsys.exit(1)\n\t\t\t\n\telse :\n\t\tprint 'ERROR: No parameter was found for --varfile'\n\t\tshowUsageHelp()\n\t\tsys.exit(1)\n\t\n\n# Function that extracts the arguments or variables passed to the --props\n# arguments, also validates the rightness of the arguments.  Prints the \n# warning on invalid set of attributes, if any found\ndef extractpropsCompanions(argv) :\n\tindex \t  = 0\n\thasErrors = False\n\n\tglobal UserPreferredVariables\n\tglobal ValidAttributesList\n\t\n\tUserPreferredVariables = argv[ argv.index('--props') + 1] \n\t\n\t# Make sure that the value for --props is not another argument type\n\tif UserPreferredVariables[:2] == '--' :\n\t\tprint 'ERROR: At least one attribute is expected for the argument --props'\n\t\tshowUsageHelp()\n\t\tsys.exit(1)\n\t\n\t# Populate the attributes a elements of an array\n\tUserPreferredVariables = UserPreferredVariables.split(\" \")\n\t# Populate a valid list of attributes from defined custom attributes\n\tValidAttributesList = [vt for (vt, va) in ValidServerAttributes]\n\t# Get a list of invalid set of attributes from the given or passed list\n\tinvalidAttributes = [ attr for attr in UserPreferredVariables if attr not in ValidAttributesList ]\n\t# Yank any invalid set of attributes from UserPreferredVariables\n\tUserPreferredVariables = [ attr for attr in UserPreferredVariables if attr in ValidAttributesList ]\n\t\n\tif len(UserPreferredVariables) == 0 :\n\t\tprint 'ERROR: At least one valid attribute is expected for the argument --props'\n\t\thasErrors = True\n\n\tif len(invalidAttributes) > 0 :\n\t\tprint 'ERROR: Found invalid set of attributes for the argument --props'\t\t\n\t\tprint '     ', ', '.join(invalidAttributes)\n\t\thasErrors = True \n\t\t\n\tif hasErrors :\n\t\tprint 'INFO : Valid set of attributes for --props are given below\\n\\t',\n\t\t\n\t\tfor item in ValidServerAttributes :\n\t\t\tindex = index + 1\n\t\t\tprint '%-23s ' % item[0],\n\t\t\tif ( index % 3 == 0) :\n\t\t\t\tprint '\\n\\t',\n\t\t\n\t\tsys.exit(1)\n\t\n\t\t\n# The main function that assembles rest of the functions in a orderly fashion\t\t\ndef main(argv) :\n\tif ( validateArguments(argv) ) :\n\t\t# Proxy variable that would point to right list of attributes once the\n\t\t# arguments are assessed\n\t\tattributesToQuery = None\n\t\t\n\t\t# Check for user preferred attributes enablement, if not grab all the \n\t\t# attributes from the defined dictionary\n\t\tif UseFilteringOfAttributes == False :\n\t\t\tattributesToQuery = [ attrib for attrib in ApiMapping.keys() ]\n\t\telse :\n\t\t\tattributesToQuery = UserPreferredVariables\n\t\t\t\n\t\t#print DumpFileHandle, DumpFileName\n\t\t\n\t\tif SetCustomAttributesToServer :\n\t\t\tprint '\\nThe following custom attributes have been created on the server'\n\t\t\tprint '-' * 86\n\t\t\t\n\t\t\tLOG.info('\\nThe following custom attributes have been created on the server')\n\t\t\tLOG.info('-' * 86)\n\t\tif DumpFileHandle :\n\t\t\tprint '\\nThe following custom attributes have been written to file (' + DumpFileName + ') on server'\n\t\t\tprint '-' * 86\n\t\t\t\n\t\t\tLOG.info('\\nThe following custom attributes have been written to file (' + DumpFileName + ') on server')\n\t\t\tLOG.info('-' * 86)\n\t\t\t\n\t\t# Now we have set of attributes to be queried.  So go over them and \n\t\t# invoke all the functions to get the data\n\t\tfor attribute in attributesToQuery :\n\t\t\tif (attribute in ApiMapping and ApiMapping[attribute]) :\n\t\t\t\t# The function is invoked from the dictionary definition \n\t\t\t\t# directly here, this technique avoids a large amount of \n\t\t\t\t# conditional branching statements\n\t\t\t\tresult = ApiMapping[attribute]()\n\t\t\t\t\n\t\t\t\t# If file dumping is enabled write to the file\n\t\t\t\tif DumpFileHandle :\n\t\t\t\t\tDumpFileHandle.write( attribute + '=' + str(result) + '\\r\\n' )\n\t\t\t\t\n\t\t\t\t# If --CA is chosen then set the attribute to the server\n\t\t\t\tif SetCustomAttributesToServer :\n\t\t\t\t\tThisServerService.setCustAttr(ThisServerReference, attribute, str(result))\n\t\t\t\t\tLOG.info('{0:25s} : {1:50s}'.format(attribute, str(result)))\n\t\t\t\t\t\n\t\t\t\t# Print the attribute information to the console\n\t\t\t\tprint '    {0:25s} : {1:50s}'.format(attribute, str(result))\n\t\t\n\t\tprint '-' * 86\n\t\tLOG.info('-' * 86)\t\t\n\t\t\n\t\t# Finalize the dump file and complete the execution\n\t\tif DumpFileHandle :\n\t\t\tfinalizeDumpFile()\n\t\t\t\n\n# Call the main with arguments\nif __name__ == \"__main__\":\n    sys.exit(main(sys.argv))\n",
            "description": "Collects system properties and stores the values in custom attributes or a text file.\n\nRequired Parameters: \n --allProps - Collect and store all supported properties\n --props “Property1 Property2\" - Collect and store only the properties specified \n --varfile \"file-name\" – Write the collected properties to the specified file\n --CA - Creates custom attributes for the collected properties.\n\nUsage:\n --allProps and --props are mutually exclusive\n You must specify either --varfile or --CA\n\nExamples:\n --allProps  --varfile \"C:\\ManagementSpace\\Attributes.txt\"\t\t\n --allProps  --CA\t\t\n --props \"NIC_MAC_Address Manufacturer Appliance_IP\" --varfile \"C:\\Temp\\Attributes.txt\"\t\t\n --props \"NIC_MAC_Address Manufacture Appliance_IP\" –CA\n\nPrerequisite:\n Target servers run a service OS or supported Operating system.\n\nAvailable properties:\nModel, UUID, Serial, CPU, Memory, NIC_Name, NIC_MAC_Address, IP_Address, iLO_IP, \nRack, Enclosure, Bay, SA_Object_Id, Manufacturer, Num_Disks, Disk_Size, Appliance_IP, \nMedia_Server_Share_IP, Media_Server_Http_IP",
            "status": null,
            "name": "Collect and Store System Data",
            "state": null,
            "eTag": "2015-08-04T07:30:31.000Z",
            "modified": "2015-08-04T07:30:31.000Z",
            "created": "2015-08-04T07:30:30.000Z",
            "category": "os-deployment-ogfs-scripts",
            "uri": "/rest/os-deployment-ogfs-scripts/1980001"
        },
        {
            "codeType": "OGFS",
            "displayCodeType": "OGFS",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "22",
                    "createdBy": "opsware",
                    "createdDate": "2015-08-04T07:30:33.000Z",
                    "usage": "Implements the BIOS reset by booting the target server and then powering it off.\n\nRequired Parameters:\n--serviceOS='SERVICE_OS' - represents the Service OS into which to boot; See the method parameter for the supported Service OSs.\n\nOptional Parameters:\n--method='METHOD'  - the boot method to be used. Possible values:\n            auto - it will behave as embedded or network, depending on the target server\n            embedded - supported only if the IloService is enabled on the target server and this is a HP ProLiant Gen8\n                  - the following service OSs are possible: linux, winpe64\n            network - configures PXE network booting into the selected Service OS\n                  - specifying an ogfs PXE-option as the Service OS is supported\n                  - if the IloService is enabled on the target server it will also set the one time boot option to NETWORK\n--force - Forces the boot configuration and reboot of the target server.\n--wait <time> - Specify a new wait time.  Default is 45 seconds.\n\nCustom Attribute:  None",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-08-04T07:30:33.000Z",
            "version": {
                "versionLabel": "22",
                "createdBy": "opsware",
                "createdDate": "2015-08-04T07:30:33.000Z",
                "usage": "Implements the BIOS reset by booting the target server and then powering it off.\n\nRequired Parameters:\n--serviceOS='SERVICE_OS' - represents the Service OS into which to boot; See the method parameter for the supported Service OSs.\n\nOptional Parameters:\n--method='METHOD'  - the boot method to be used. Possible values:\n            auto - it will behave as embedded or network, depending on the target server\n            embedded - supported only if the IloService is enabled on the target server and this is a HP ProLiant Gen8\n                  - the following service OSs are possible: linux, winpe64\n            network - configures PXE network booting into the selected Service OS\n                  - specifying an ogfs PXE-option as the Service OS is supported\n                  - if the IloService is enabled on the target server it will also set the one time boot option to NETWORK\n--force - Forces the boot configuration and reboot of the target server.\n--wait <time> - Specify a new wait time.  Default is 45 seconds.\n\nCustom Attribute:  None",
                "current": true
            },
            "source": "#!/usr/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n#\n# Also note that a Python version greater than 2.3 is needed\n#\n \n\"\"\"\n(C) Copyright 2011-2015 Hewlett-Packard Development Company, L.P.\n \nThis python script tries to boot a machine into the user selected Service OS.\n \n\"\"\"\n \nimport sys\nfrom cStringIO import StringIO\n \nimport time\nfrom optparse import OptionParser\nfrom osprov.decorators import HandleShowErrorMessage\nfrom osprov.netconfig.helpers import getNetconfig\nfrom osprov.parsers.netconfig import SmartNetconfig\nfrom osprov.osbp import ThisTargetServer, logger\nfrom osprov.power import getPowerController\nfrom pytwist.com.opsware.common import OpswareException, OpswareSystemException\nfrom osprov import boot\nfrom osprov import ilo\n \nlog = logger.getIt(\"Boot\")\n \nEC_OK = 0\nEC_INVALID_ARGS = 1\nEC_UNSUPPORTED = 2\nEC_FAILED_BOOT = 3\nEC_FAILED_BOOT_SETUP = 4\n \nHPSA_NETCONFIG=\"\"\"@hpsa_netconfig@\"\"\"\nREQUIRE_NETCONFIG=\"@require_netconfig:false@\"\n \n \nclass BootStepOptionsParser(OptionParser):\n \n    def __init__(self, *args, **kwargs):\n        OptionParser.__init__(self, *args, **kwargs)\n        self.add_option(\"--serviceOS\",\n            help=\"The Service OS to boot into.\" \\\n                 \"Possible options: linux32, linux64 (linux), winpe32, winpe64 (winpe)\")\n        self.add_option(\"--method\", default=\"auto\",\n            help = \"it represents the boot method to be used.\")\n        self.add_option(\"--wait\", default=\"45\",\n            help = \"Specify the duration before server power off.\")\n        self.add_option(\"--force\", default=False, action = \"store_true\",\n            help = \"Forces the boot configuration and reboot of the target server.\")\n        self.add_option(\"--ipv6\", action=\"store_true\", default=False,\n            help=\"Starts the selected Service OS in IPv6 mode\")\n \n \n@HandleShowErrorMessage(\"boot target server\", log)\ndef main():\n    \"\"\" build plan script to boot the target system \"\"\"\n    parser = BootStepOptionsParser()\n    options, args = parser.parse_args()\n \n    serviceOS = options.serviceOS\n    method = options.method\n    waitTime = int(options.wait)\n \n    targetServer = ThisTargetServer()\n \n    print(\"Boot method: \" + method)\n    bootController = boot.getBootController(targetServer, method, log=log)\n \n    if serviceOS not in bootController.getSupportedServiceOSs():\n        print(\"Service OS %s not supported for boot method %s\" % (serviceOS, method))\n        return EC_INVALID_ARGS\n \n    if targetServer.isMaintenance():\n        if not targetServer.isAccessible():\n            print \"The target server is in MAINTENANCE but not accessible, continuing...\"\n        elif serviceOS[:5] in targetServer.PXEOption and not options.force:\n            print \"Skipping boot configuration, the target server is booted into the same Service OS\"\n            bootController.storeBootInformation(serviceOS)\n            return EC_OK\n \n    try:\n        print(\"Configuring boot to Service OS: %s\" % serviceOS)\n        netconfigParser = SmartNetconfig.readonly(StringIO(HPSA_NETCONFIG),\n                                                  activeMacAddress=None, ipv6default=targetServer.isIPv6Managed())\n        netconfig = netconfigParser.info()\n \n        bootController.configureBoot(serviceOS, netconfig, ipv6=options.ipv6)\n \n \n        print(\"Rebooting the target server...\")\n        targetServer.reboot(getPowerController(targetServer, log = log))\n \n        print(\"Waiting for the target server's BIOS to reset...\")\n        time.sleep(waitTime)\n \n        print(\"Powering off target server...\")\n        iloServ = ilo.getIlo(targetServer, log = log)\n        iloServ.ims.setPowerStatus(iloServ.iloManagerRef, False)\n    except (OpswareException, OpswareSystemException), why:\n        log.exception(why)\n        sys.stderr.write(\"Failed to boot:\\n%s\\n\" % str(why))\n        return EC_FAILED_BOOT\n    return EC_OK\n \nif __name__ == \"__main__\":\n    sys.exit(main())\n",
            "description": "Implements the BIOS reset by booting the target server and then powering it off.\n\nRequired Parameters:\n--serviceOS='SERVICE_OS' - represents the Service OS into which to boot; See the method parameter for the supported Service OSs.\n\nOptional Parameters:\n--method='METHOD'  - the boot method to be used. Possible values:\n            auto - it will behave as embedded or network, depending on the target server\n            embedded - supported only if the IloService is enabled on the target server and this is a HP ProLiant Gen8\n                  - the following service OSs are possible: linux, winpe64\n            network - configures PXE network booting into the selected Service OS\n                  - specifying an ogfs PXE-option as the Service OS is supported\n                  - if the IloService is enabled on the target server it will also set the one time boot option to NETWORK\n--force - Forces the boot configuration and reboot of the target server.\n--wait <time> - Specify a new wait time.  Default is 45 seconds.\n\nCustom Attribute:  None",
            "status": null,
            "name": "Reboot to Apply BIOS Changes and Power Off",
            "state": null,
            "eTag": "2015-08-04T07:30:33.000Z",
            "modified": "2015-08-04T07:30:33.000Z",
            "created": "2015-08-04T07:30:33.000Z",
            "category": "os-deployment-ogfs-scripts",
            "uri": "/rest/os-deployment-ogfs-scripts/2010001"
        }
    ],
    "nextPageUri": null,
    "start": 0,
    "prevPageUri": null,
    "total": 73,
    "count": 73,
    "eTag": null,
    "modified": null,
    "created": null,
    "category": null,
    "uri": null
}
