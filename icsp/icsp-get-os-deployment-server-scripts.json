{
    "type": "OsdPaginatedCollection",
    "members": [
        {
            "runAsSuperUser": true,
            "serverChanging": true,
            "codeType": "SH",
            "displayCodeType": "Unix",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "1",
                    "createdBy": "opsware",
                    "createdDate": "2015-06-13T04:48:39.000Z",
                    "usage": "Installs and configures GRUB (GRand Unified Boot Loader) onto the stub partition of the boot disk on the target server in order to enable the booting into the CentOS 7 installation image.\n\nThe step will also auto detect directories with the names \"addon\", \"AddOn\" and \"ADDON\" in the repository and for SuSE Linux Enterprise Server installations append the proper \"addon='path-to-addon-dir' to the kernel parameters of the grub boot loader.\n\nUsage:\n\nThis script expects no command line arguments, but the following argument(s) can optionally be specified:\n    --kernel_arguments=KERNEL_ARGUMENTS\n                        a string of arguments that will be passed to the OS\n                        installer kernel\n    --disableWarning    Do not show warnings of old hpsa_netconfig format\n\nPrerequisites:\n- Target server runs a maintenance Linux OS.\n- The files in the grub.zip archive must be extracted in /tmp.\n- The \"Create Stub Partition\" step must have been executed. \n\nThis script is intended to be used only as a Build Plan step.",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-06-13T04:48:39.000Z",
            "version": {
                "versionLabel": "1",
                "createdBy": "opsware",
                "createdDate": "2015-06-13T04:48:39.000Z",
                "usage": "Installs and configures GRUB (GRand Unified Boot Loader) onto the stub partition of the boot disk on the target server in order to enable the booting into the CentOS 7 installation image.\n\nThe step will also auto detect directories with the names \"addon\", \"AddOn\" and \"ADDON\" in the repository and for SuSE Linux Enterprise Server installations append the proper \"addon='path-to-addon-dir' to the kernel parameters of the grub boot loader.\n\nUsage:\n\nThis script expects no command line arguments, but the following argument(s) can optionally be specified:\n    --kernel_arguments=KERNEL_ARGUMENTS\n                        a string of arguments that will be passed to the OS\n                        installer kernel\n    --disableWarning    Do not show warnings of old hpsa_netconfig format\n\nPrerequisites:\n- Target server runs a maintenance Linux OS.\n- The files in the grub.zip archive must be extracted in /tmp.\n- The \"Create Stub Partition\" step must have been executed. \n\nThis script is intended to be used only as a Build Plan step.",
                "current": true
            },
            "source": "#!/opt/opsware/agent/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# lint_ignore=E501,I0011\n# Please do not change the two lines above. See PEP 8, PEP 263.\n\"\"\"\n    (C) Copyright 2013-2015 Hewlett-Packard Development Company, L.P.\n\n    This python script installs and configures Grub for BIOS and Grub2 for UEFI.\n\"\"\"\n\nimport os\nimport sys\nimport re\nimport glob\nimport shutil\nfrom cStringIO import StringIO\n\nfrom osprov.decorators import HandleShowErrorMessage\nfrom osprov.diskmgr.disk import LinuxDisk\nfrom osprov.networking.discovery import LinuxNetworkDiscovery\nfrom osprov.optparse_ext import OptionParser\nfrom osprov.osbp import logger\nfrom osprov.parsers.syslinux import Syslinux\nfrom osprov.util import process\nfrom osprov.errors import DiscoveryError, ShowErrorMessage, SetupError\nfrom osprov import helpers, media, netconfig\nfrom osprov.parsers.netconfig import SmartNetconfig, OLD_SYNTAX_WARNING\nfrom osprov.server.local import ThisLocalServer\nfrom osprov.constants import DEFAULT_INITRD_DIR, DEFAULT_SA_INITRD_MASK\nfrom osprov.wrappers.efibootmgr import EfiBootMgr, DiskBootEntry\nfrom osprov import ipaddr\n\nEC_INVALID_ARGS = 1\nEC_IG_FAILED = 5\nEC_GRUBMENU_FAILED = 6\nEC_NO_BOOTDISK = 7\n\nLOG = logger.getIt(\"install_configure_grub\")\n\n\n# for easier mocking\ndef _open(filepath, mode=\"r\"):\n    return open(filepath, mode)\n\n\ndef get_partition_name(device_name, partition_num):\n    \"\"\"Returns the partition with number partition_num for device_name\"\"\"\n    if not partition_num:\n        return device_name\n    base_name = os.path.basename(device_name)\n    if re.search(r\"c\\dd\\d\", base_name):\n        return device_name + \"p\" + str(partition_num)\n    return device_name + str(partition_num)\n\n\nclass Grub(object):\n    \"\"\" Helper class for configuring and installing the Grub boot loader. \"\"\"\n\n    MENU_PATHS = [\"boot/grub/menu.lst\"]\n    MODULES_PATH = \"boot/grub\"\n\n    def __init__(self, location):\n        self.location = location\n        self.grubinfo = self.validate()\n\n    def _getInfo(self):\n        info = {}\n        # first test for newer info.txt file\n        infofile = os.path.join(self.location, \"info.txt\")\n        if os.path.exists(infofile):\n            # get the path info from into.txt\n            execfile(infofile, info)\n            for value in [\"grub\", \"loaderfiles\"]:\n                if not info[value]:\n                    # expected value is missing\n                    return {}\n        else:\n            # set the required info values manually for older grub packages\n            info[\"grub\"] = \"sbin/grub\"\n            info[\"loaderfiles\"] = \"share/grub/i386-pc\"\n        return info\n\n    def validate(self):\n        \"\"\"    Performs some simple validation on the directory where GRUB is located.\n        info.txt can provide non default values for grub binary and loader files\n        and saves from hardcoding more paths in here.\n        info.txt should also contain version info for better tracking of versions.\n        required info entries are:\n                \"grub\"            - path to grub binary\n                \"loaderfiles\"   - path to loader files\n        \"\"\"\n        info = self._getInfo()\n        if not info:\n            return {}\n        # finally verify the paths\n        for path in [info[\"grub\"], info[\"loaderfiles\"]]:\n            if not os.path.exists(os.path.join(self.location, path)):\n                return {}\n        return info\n\n    def copyFilesTo(self, bootDiskMount):\n        \"\"\" Copies files to the location specified. \"\"\"\n        print(\"Copying Boot Loader files to runtime location\")\n        grubinfo = self.grubinfo\n        if not grubinfo:\n            raise ShowErrorMessage(\n                \"Failed to validate %s. A previous Build Plan step may be missing.\" % self.location)\n        targetLocation = os.path.join(bootDiskMount, self.MODULES_PATH)\n        helpers.makeDirs(targetLocation)\n        files = glob.glob(\"%s/*\" % os.path.join(self.location, grubinfo[\"loaderfiles\"]))\n        if not files:\n            raise ShowErrorMessage(\"No file to copy. A previous Build Plan step may be missing\")\n        for source in files:\n            destination = os.path.join(targetLocation, os.path.basename(source))\n            LOG.debug(\"Copying %s to %s\", source, destination)\n            shutil.copyfile(source, destination)\n\n    def install(self, bootDiskMount, bootDisk):\n        \"\"\"\n        Installs the files needed for GRuB on boot_disk.\n        Note that it will overwrite the Master Boot Record for boot_disk.\n        \"\"\"\n        self.copyFilesTo(bootDiskMount)\n        print(\"Preparing Boot Loader config script\")\n        config = list()\n        config.append(\"device (hd0) \" + bootDisk)\n        config.append(\"root (hd0,0)\")\n        config.append(\"install --stage2=%s/boot/grub/stage2 /boot/grub/stage1 d (hd0) \"\n                      \"/boot/grub/stage2 p /boot/grub/menu.lst\" % bootDiskMount)\n        config.append(\"quit\")\n        config_str = \"\\n\".join(config) + \"\\n\"\n\n        print(\"Installing Boot Loader\")\n        os.chmod(\"%s\" % os.path.join(self.location, self.grubinfo[\"grub\"]), 0777)\n        params = \"--batch --no-floppy --config-file=/boot/grub/menu.lst\"\n        process.runIt(\"%s %s\" %\n                      (os.path.join(self.location, self.grubinfo[\"grub\"]), params), input=config_str, quiet=True)\n        return config_str\n\n    def configureMenu(self, title, kernel, kernelArguments, initrds, keys):\n        \"\"\"    Creates a GRUB menu.lst configuration. \"\"\"\n        return \"\"\"\ndefault 0\ntimeout 5\ntitle %(title)s\nroot (hd0,0)\n\nkernel /%(kernel)s %(kernelArguments)s\ninitrd %(initrds)s\n\n\"\"\" % {\n            'title': title,\n            'kernel': kernel,\n            'kernelArguments': kernelArguments,\n            'initrds': ' '.join(initrds)\n        }\n\n\nclass Grub2(Grub):\n    BOOT_DIRECTORY = \"boot/\"\n    MENU_PATHS = [os.path.join(BOOT_DIRECTORY, \"grub/grub.cfg\"), os.path.join(BOOT_DIRECTORY, \"grub2/grub.cfg\")]\n    EFI_BOOT_DIR = \"EFI/BOOT/\"\n    EFI_BOOT_PATH = os.path.join(EFI_BOOT_DIR)\n    EFI_CMD_SUFFIX = \"\"\n\n    def _getInfo(self):\n        info = dict()\n        info[\"grub\"] = \"sbin/grub-install\"\n        info[\"loaderfiles\"] = \"lib/grub/x86_64-efi\"\n        return info\n\n    def install(self, bootDiskMount, bootDisk):\n        secureBootLoader = self.configureSecureBootLoader(bootDiskMount)\n        if not secureBootLoader:\n            process.runIt(\"%(grub-install)s --removable --efi-directory=%(bootDiskMount)s --boot-directory=%(bootDirectory)s %(bootDisk)s\"\n                          % {'grub-install': os.path.join(self.location, self.grubinfo['grub']),\n                             'bootDiskMount': bootDiskMount,\n                             'bootDirectory': os.path.join(bootDiskMount, self.BOOT_DIRECTORY),\n                             'bootDisk': bootDisk}, log=LOG, quiet=True)\n            # configure the UEFI boot entries\n            osInstallerBootEntry = DiskBootEntry(\"HPSA Assisted OS Installer\", disk=bootDisk)\n        else:\n            # configure the UEFI boot entries with specific path to loader\n            print(\"Found UEFI secure boot files in media\")\n            osInstallerBootEntry = DiskBootEntry(\"HPSA Assisted OS Installer\", disk=bootDisk, loader=secureBootLoader)\n        efibootmgr = EfiBootMgr(log=LOG)\n        efibootmgr.bootOneTime(osInstallerBootEntry)\n        print(\"Configured boot to: %s\" % osInstallerBootEntry)\n\n    def configureSecureBootLoader(self, bootDiskMount):\n        keys = helpers.getDataStore()\n        mediaFS = media.factor(keys.media.url, log=LOG)\n        bootEFIFiles = mediaFS.findFiles(path=self.EFI_BOOT_DIR)\n        secureBootFiles = {'boot': None, 'grub': None}\n        for boot in bootEFIFiles:\n            if re.match(\"bootx64\\.efi\", boot, re.IGNORECASE):\n                secureBootFiles['boot'] = boot\n            if re.match(\"grubx64\\.efi\", boot, re.IGNORECASE):\n                secureBootFiles['grub'] = boot\n        LOG.debug(\"Boot files for SecureBoot found in media : %s\" % str(bootEFIFiles))\n        if secureBootFiles['boot'] and secureBootFiles['grub']:\n            # create path on stub partition\n            os.makedirs(os.path.join(bootDiskMount, self.EFI_BOOT_PATH))\n            for boot in bootEFIFiles:\n                if boot and \".efi\" in boot.lower():\n                    mediaFS.copyTo(os.path.join(self.EFI_BOOT_DIR, boot), os.path.join(bootDiskMount, self.EFI_BOOT_PATH))\n            # add new path for grub.cfg and efi suffix\n            self.MENU_PATHS.append(os.path.join(self.EFI_BOOT_PATH, \"grub.cfg\"))\n            self.EFI_CMD_SUFFIX = \"efi\"\n            return os.path.join(\"/\", self.EFI_BOOT_PATH, secureBootFiles['boot']).replace(\"/\", \"\\\\\")\n        return None\n\n    def configureMenu(self, title, kernel, kernelArguments, initrds, keys):\n        \"\"\" Creates a GRUB2 grub.conf configuration \"\"\"\n        return \"\"\"\nset default=0\nset timeout=5\n\ninsmod all_video\n\nmenuentry '%(title)s' {\n    linux%(efi)s  /%(kernel)s %(kernelArguments)s\n    initrd%(efi)s %(initrds)s\n}\n\n\"\"\" % {\n            'efi': self.EFI_CMD_SUFFIX,\n            'title': title,\n            'kernel': kernel,\n            'kernelArguments': kernelArguments,\n            'initrds': ' '.join(initrds),\n            'device_uuid': keys.disk.device_uuid\n        }\n\n\ndef getGrub(bootDisk):\n    \"\"\" Factor a Grub or Grub2 object based on the partition table type of the boot disk \"\"\"\n    if bootDisk.partitionTableType == \"msdos\":\n        return Grub(\"/tmp/grub\")\n    else:\n        return Grub2(\"/tmp/grub2\")\n\n\ndef checkCompleteStaticNetData(netdata, ipv):\n    values = netdata.values()\n    if None in values or \"\" in values:\n        print \"WARNING: The provided %s static configuration is incomplete. The OS installer may fail.\" % ipv\n\n\ndef getIPv6NameServer():\n    lnd = LinuxNetworkDiscovery()\n    lnd.discover()\n    if lnd.netinfo.nics and lnd.netinfo.nics[0].ipv6DnsServers:\n        return lnd.netinfo.nics[0].ipv6DnsServers[0]\n    else:\n        return \"\"\n\n\ndef getNetworkingParams(mac, osdata, netconfig, isIPv6Managed):\n    try:\n        activeIface = [x for x in netconfig.nics if x.provisioning][0]\n    except IndexError:\n        raise SetupError(\"Found no provisioning interface\")\n\n    isRHEL7 = \"RHEL7\" == osdata[\"os_version\"]\n    ip_params = \"\"\n\n    if isIPv6Managed:\n        if activeIface.ipv6Autoconfig:\n            ip_params += \" \" + osdata[\"ip_config_auto6\"] % {'mac': mac}\n            # for RHEL7 on IPv6 we need to set the nameserver since dracut\n            # does not generate a proper dhcpv6 client config\n            # note that NetworkManager does eventually start after the squashfs.img is downloaded\n            # so it will overwrite what dracut configures\n            if \"RHEL7\" == osdata[\"os_version\"]:\n                ip_params += \" nameserver=%s\" % getIPv6NameServer()\n        elif activeIface.ipv6Networks:\n            net_data = {\n                \"ip\": (\"[%s]\" if isRHEL7 else \"%s\") % activeIface.ipv6Networks[0].ip,\n                \"mask\": activeIface.ipv6Networks[0].netmask,\n                \"prefix\": activeIface.ipv6Networks[0].prefixlen,\n                \"dns\": \"\",\n                \"gw\": \"\",\n                \"mac\": mac,\n            }\n            for dnsserv in activeIface.ipv6DnsServers:\n                net_data[\"dns\"] = dnsserv\n                break\n            for route in [x for x in netconfig.ipv6Routes if x.nic == activeIface]:\n                net_data[\"gw\"] = (\"[%s]\" if isRHEL7 else \"%s\") % route.gateway\n                break\n            # support for autoconf + static network in the installer\n            if isRHEL7 and activeIface.ipv6Autoconfig:\n                if not net_data[\"dns\"]:\n                    net_data[\"dns\"] = getIPv6NameServer()\n            ip_params += \" \" + (osdata[\"ip_config_static6\"] % net_data)\n            checkCompleteStaticNetData(net_data, \"IPv6\")\n        else:\n            print \"Can not complete network personalization. \" \\\n                  \"Auto configuration is turned off for IPv6 and there is no static address defined\"\n            sys.exit(37)\n    else:\n        if activeIface.ipv4Networks:\n            net_data = {\n                \"ip\": activeIface.ipv4Networks[0].ip,\n                \"mask\": activeIface.ipv4Networks[0].netmask,\n                \"dns\": \"\",\n                \"gw\": \"\",\n            }\n            for dnsserv in activeIface.dnsServers:\n                if isinstance(dnsserv, ipaddr.IPv4Address):\n                    net_data[\"dns\"] = dnsserv\n                    break\n            for route in [x for x in netconfig.ipv4Routes if x.nic == activeIface]:\n                net_data[\"gw\"] = route.gateway\n                break\n            ip_params += \" \" + (osdata[\"ip_config_static\"] % net_data)\n            checkCompleteStaticNetData(net_data, \"IPv4\")\n        elif activeIface.dhcpv4:\n            ip_params += \" \" + osdata[\"ip_config_dhcp\"]\n        else:\n            print \"Can not complete network personalization. \" \\\n                  \"DHCP is turned off for IPv4 and there is no static address defined\"\n            sys.exit(38)\n\n    return ip_params.strip()\n\n\ndef updateExecInstructions(params1=\"\", params2=\"\"):\n    \"\"\"If both params strings contain the exec argument, the method will remove it form second string and combine\n    the 2 instructions in to the first string\"\"\"\n    if params2.count(\"exec=\") and params1.count(\"exec=\"):\n        ip_param_exec = params2[params2.index(\"exec=\\\"\"):params2.index(\"\\\"\", params2.index(\"exec=\\\"\") + 6) + 1]\n        params2 = params2.replace(ip_param_exec, \"\")\n        if \"exec='\" in params1:\n            params1 = params1.replace(\"exec='\", \"exec='\" + ip_param_exec[6:-1] + \";\")\n        else:\n            params1 = params1.replace('exec=\"', 'exec=\"' + ip_param_exec[6:-1] + \";\")\n    return params1, params2\n\n\ndef configureKernelArguments(osdata, keys, netcfg_parser, kernel_arguments=\"\"):\n    \"\"\" Configures the kernel arguments \"\"\"\n    localServer = ThisLocalServer()\n    boot_disk = keys.disk.device_path\n    boot_disk_uuid = keys.disk.device_uuid\n    # to be used by install_params\n    root_partition = get_partition_name(boot_disk[5:], 1)\n    if \"SLES\" in osdata[\"os_version\"] and \"cciss\" in boot_disk:\n        boot_disk = \"%s//\" % boot_disk\n    # ALERT: do not remove lower(), SLES doesn't recognize a MAC address if upper\n    mac = localServer.getMACAddress().lower()\n    url = mediaUrl(keys)\n    arg_dict = {\n        \"mac\": mac,\n        \"boot_disk\": boot_disk,\n        \"root_partition\": root_partition,\n        \"boot_disk_uuid\": boot_disk_uuid,\n        \"url\": url.canonical(),\n        \"bootif\": netconfig.macToBootIf(mac)\n    }\n    kernel_params = osdata['install_params'] % arg_dict\n    if kernel_arguments:\n        print(\"Found kernel arguments: \" + kernel_arguments)\n        kernel_params = kernel_params + \" \" + kernel_arguments\n\n    # Handle TCP/IP settings to make sure that installers behave  ##\n    ip_params = getNetworkingParams(mac, osdata, netcfg_parser.info(), localServer.isIPv6Managed())\n    if ip_params:\n        print(\"Additional kernel arguments for network configuration: %s\" % ip_params)\n        kernel_params, ip_params = updateExecInstructions(params1=kernel_params, params2=ip_params)\n        kernel_params += \" \" + ip_params\n\n    # Limit ports only if we are doing NFS, sles 11 sp0 has issues with this setting\n    if url.scheme == \"nfs\":\n        # Make sure that the nfs client doesn't use the agent port\n        kernel_params += \" sunrpc.max_resvport=1000\"\n\n    # if present handle addonloc\n    if \"addonloc\" in osdata and osdata[\"addonloc\"]:\n        # Handle SLES addon sources (eg. by use of kISO content)\n        if \"SLES\" in osdata[\"os_version\"]:\n            if kernel_params.lower().find(\"addon=\") == -1:\n                # no addon parameter present - add it using the found location if any\n                print \"Boot Loader (SLES) auto appending kernel parameter \"\"addon=%s\"\" \" % osdata[\"addonloc\"]\n                kernel_params += \" addon=%s\" % osdata[\"addonloc\"]\n            else:\n                print \"Boot Loader (SLES) \"\"addon=\"\" parameter present - not auto appending\"\n\n    # tidy up the kernel_params to contain only one blank between and no trailing blanks\n    # required for SLES's picky addon parameter handler (would fail with nfs:// source)\n    kernel_params = ' '.join(kernel_params.split())\n\n    return kernel_params\n\n\ndef configureInitrds(osdata, keys):\n    # start with the default initrd\n    initrdlist = [\"/%s\" % osdata[\"initrd\"]]\n\n    discoverLocalRds(osdata, root=keys.disk.device_mount)\n\n    # if present add supplemental local initrds\n    if \"localrds\" in osdata:\n        for eachrd in osdata[\"localrds\"]:\n            initrdlist.append(eachrd)\n        # max number of initrds that can be handled is limited by the line length\n        # limit of grubs menu.lst: 1500 chars.\n        if len(initrdlist) > (1500 - 1):\n            raise DiscoveryError(\"INITRD parameter: Maximum parameter length (1500) exceeded! \"\n                                 \"- Too many additional initrd files found.\")\n    return initrdlist\n\n\ndef discoverLocalRds(osdata, root):\n    \"\"\" Get initrd files from /localrds directory \"\"\"\n    rds = helpers.findFiles(\n        path=os.path.join(root, DEFAULT_INITRD_DIR), mask=DEFAULT_SA_INITRD_MASK)\n    if rds:\n        rdlist = []\n        # add the local path to make it suitable for grub\n        for eachrd in rds:\n            rdlist.append(os.path.join(os.path.sep, DEFAULT_INITRD_DIR, eachrd))\n        osdata[\"localrds\"] = helpers.numericalSort(rdlist)\n    return\n\n\ndef discoverOsdata(osdata, keys):\n    \"\"\" Discover the kernel and initrd to use based on the media \"\"\"\n    # the copy boot media step should have run by now, so we work with the\n    # stub partition. This is just so we don't access the media twice\n    stub_path = keys.disk.device_mount\n    if not stub_path:\n        raise DiscoveryError(\"Cannot discover boot disk mount point. \"\n                             \"Was the stub partition created?\")\n    isocfg = Syslinux.readonly(_open(os.path.join(stub_path, \"isolinux.cfg\")))\n    isocfg_label = isocfg.info()[\"label \" + isocfg.first_non_local_label()]\n    # discover the kernel\n    osdata[\"kernel\"] = os.path.basename(isocfg_label[\"kernel\"])\n    # discover the initrd\n    append = isocfg_label[\"append\"].split(' ')\n    for each in append:\n        if '=' in each:\n            key, value = [x.strip() for x in each.split('=', 1)]\n            if key == \"initrd\":\n                osdata[\"initrd\"] = os.path.basename(value)\n    if \"initrd\" not in osdata:\n        raise DiscoveryError(\"Failed to discover the initrd\")\n\n    # verify the files are there otherwise the boot loader will fail to find them\n    kernel = os.path.join(stub_path, osdata[\"kernel\"])\n    initrd = os.path.join(stub_path, osdata[\"initrd\"])\n    if not os.path.exists(kernel) or not os.path.exists(initrd):\n        raise DiscoveryError(\"Failed to discover the boot kernel or initrd\")\n\n\ndef discoverSlesAddon(osdata, keys):\n    \"\"\" Discover addon directories for\n            SLES: kISO formatted media w/ \"addon\" directory\n    \"\"\"\n    url = mediaUrl(keys)\n    thismedia = media.factor(str(url))\n    # for SLES check for addon directory in the repository\n    SLES_ADDON_LOCATIONS = [\n        # common names for SLES addon directory\n        \"addon/\", \"ADDON/\", \"AddOn/\"\n    ]\n    for each_file in SLES_ADDON_LOCATIONS:\n        if thismedia.exists(each_file):\n            osdata[\"addonloc\"] = url.canonical() + \"/\" + each_file\n            print \"Boot Loader (SLES) ADDON directory found in source location: %s\" % osdata[\"addonloc\"]\n            return\n\n\ndef mediaUrl(keys):\n    \"\"\" determine the media server and path \"\"\"\n    url = keys.media.url\n    if not url:\n        # Fall back in case of old NFS mount script\n        mediaServer = _open(\"/tmp/osbp_info/media_server\", \"r\").read().strip()\n        mediaPath = _open(\"/tmp/osbp_info/media_path\", \"r\").read().strip()\n        mediaMount = _open(\"/tmp/osbp_info/media_mount\", \"r\").read().strip()\n        url = \"nfs://%s:%s/#%s\" % (mediaServer, mediaPath, mediaMount)\n    return media.parseUrl(url)\n\n\nclass InstallConfigureGrubOptionParser(OptionParser):\n    def defineOptions(self):\n        self.add_option(\"--kernel_arguments\", default=\"\",\n                        help=\"a string of arguments that will be passed to the OS installer kernel\")\n        self.add_option(\"--disableWarning\", dest=\"disableWarning\", action=\"store_true\",\n                        default=False,\n                        help=\"Do not show warnings of old hpsa_netconfig format\")\n\n\n@HandleShowErrorMessage(\"install and configure bootloader\", log=LOG)\ndef main():\n    options, remainingArgs = InstallConfigureGrubOptionParser().parse_args()\n    del remainingArgs\n\n    localServer = ThisLocalServer()\n    parser = SmartNetconfig.readwrite(\n        StringIO(HPSA_NETCONFIG),\n        activeMacAddress=localServer.getMACAddress(),\n        ipv6default=localServer.isIPv6Managed(),\n        log=LOG\n    )\n    if parser.info().oldSyntax and not options.disableWarning:\n        newFormat = parser.format()\n        print OLD_SYNTAX_WARNING + \"\\n%s\" % str(newFormat)\n\n    typosList = parser.getTyposList()\n    if typosList:\n        print(\"The following keys were not recognized in the netconfig CA and could be typos: %s\" % typosList)\n\n    keys = helpers.getDataStore()\n\n    bootDiskMount = keys.disk.device_mount\n    if not bootDiskMount:\n        raise DiscoveryError(\"Discovery of the boot disk mount point failed. \"\n                             \"Was the stub partition created?\", EC_NO_BOOTDISK)\n\n    bootDisk = LinuxDisk(keys.disk.device_path, None, None)\n    grub = getGrub(bootDisk)\n    try:\n        grub.install(bootDiskMount, bootDisk.getDeviceFilePath())\n    except (OSError, IOError), why:\n        print \"Installing GRuB failed. %s\" % why\n        return EC_IG_FAILED\n\n    # build.py will perform the needed substitutions here\n    osdata = dict()\n    osdata[\"os_display_name\"] = 'CentOS 7'\n    osdata[\"os_version\"] = 'RHEL7'\n    osdata[\"install_params\"] = 'ks=file:/user.ks.cfg'\n    osdata[\"ip_config_static\"] = ''\n    osdata[\"ip_config_static6\"] = 'ifname=provisioning:%(mac)s bootdev=provisioning ip=%(ip)s::%(gw)s:%(prefix)s::provisioning:none: nameserver=%(dns)s'\n    osdata[\"ip_config_dhcp\"] = ''\n    osdata[\"ip_config_auto6\"] = 'ifname=provisioning:%(mac)s bootdev=provisioning ip=provisioning:auto6'\n\n    discoverOsdata(osdata, keys)\n    if \"SLES\" in osdata[\"os_version\"]:\n        discoverSlesAddon(osdata, keys)\n\n    title = 'HP SA assisted %s installer' % osdata['os_display_name']\n    kernelArguments = configureKernelArguments(osdata, keys, parser,\n                                               kernel_arguments=options.kernel_arguments + \" hpsa_monitoring_agent=1\")\n    initrds = configureInitrds(osdata, keys)\n\n    menu = grub.configureMenu(title,\n                              osdata['kernel'], kernelArguments,\n                              initrds, keys)\n    for menuPath in grub.MENU_PATHS:\n        if not os.path.exists(os.path.join(bootDiskMount, os.path.dirname(menuPath))):\n            os.makedirs(os.path.join(bootDiskMount, os.path.dirname(menuPath)))\n        _open(os.path.join(bootDiskMount, menuPath), \"w\").write(menu)\n\n    return 0\n\nHPSA_NETCONFIG = \"\"\"@hpsa_netconfig@\"\"\"\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n",
            "description": "Installs and configures GRUB (GRand Unified Boot Loader) onto the stub partition of the boot disk on the target server in order to enable the booting into the CentOS 7 installation image.\n\nThe step will also auto detect directories with the names \"addon\", \"AddOn\" and \"ADDON\" in the repository and for SuSE Linux Enterprise Server installations append the proper \"addon='path-to-addon-dir' to the kernel parameters of the grub boot loader.\n\nUsage:\n\nThis script expects no command line arguments, but the following argument(s) can optionally be specified:\n    --kernel_arguments=KERNEL_ARGUMENTS\n                        a string of arguments that will be passed to the OS\n                        installer kernel\n    --disableWarning    Do not show warnings of old hpsa_netconfig format\n\nPrerequisites:\n- Target server runs a maintenance Linux OS.\n- The files in the grub.zip archive must be extracted in /tmp.\n- The \"Create Stub Partition\" step must have been executed. \n\nThis script is intended to be used only as a Build Plan step.",
            "status": null,
            "name": "Install bootloader for CentOS 7",
            "state": null,
            "eTag": "2015-06-13T04:48:39.000Z",
            "modified": "2015-06-13T04:48:39.000Z",
            "created": "2015-06-13T04:48:39.000Z",
            "category": "os-deployment-server-scripts",
            "uri": "/rest/os-deployment-server-scripts/310001"
        },
        {
            "runAsSuperUser": true,
            "serverChanging": false,
            "codeType": "PY2",
            "displayCodeType": "Python",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "1",
                    "createdBy": "opsware",
                    "createdDate": "2015-06-13T04:48:39.000Z",
                    "usage": "This program will modify the Automated Installer manifest files to inject IPS source and root password info.\n\nUsage: inject_required_ai.py [options]\n\noptions:\n  -i IPS_SOURCE, --ips-source=IPS_SOURCE\n                        IPS origin used for installation\n  -m MIRROR, --mirror=MIRROR\n                        IPS mirror used for installation, can be specified multiple times\n  -p PASSWORD, --encrypted-root-password=PASSWORD\n                        Root password for the installed system, encrypted in standard /etc/shadow format\n  -x PROXY, --http-proxy=PROXY\n\t\t\tHTTP proxy used for IPS installation\n\nPrerequisites:\n\n- This script must be run as part of a Build Plan under a Solaris Service OS\n- This script must be run after ai.xml and sc.xml configuration files were deployed on the server",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-06-13T04:48:39.000Z",
            "version": {
                "versionLabel": "1",
                "createdBy": "opsware",
                "createdDate": "2015-06-13T04:48:39.000Z",
                "usage": "This program will modify the Automated Installer manifest files to inject IPS source and root password info.\n\nUsage: inject_required_ai.py [options]\n\noptions:\n  -i IPS_SOURCE, --ips-source=IPS_SOURCE\n                        IPS origin used for installation\n  -m MIRROR, --mirror=MIRROR\n                        IPS mirror used for installation, can be specified multiple times\n  -p PASSWORD, --encrypted-root-password=PASSWORD\n                        Root password for the installed system, encrypted in standard /etc/shadow format\n  -x PROXY, --http-proxy=PROXY\n\t\t\tHTTP proxy used for IPS installation\n\nPrerequisites:\n\n- This script must be run as part of a Build Plan under a Solaris Service OS\n- This script must be run after ai.xml and sc.xml configuration files were deployed on the server",
                "current": true
            },
            "source": "#!/opt/opsware/agent/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n\"\"\"\n    (C) Copyright 2013-2015 Hewlett-Packard Development Company, L.P.\n\n    This program will modify the ai.xml and sc.xml manifest files to inject\n    the essential personalization settings for the final system.\n\n    This includes IPS source, an optional http proxy and root password.\n\"\"\"\n\nimport sys\n\nfrom osprov.profile import AIManifest, SCManifest\nfrom osprov.decorators import HandleShowErrorMessage\nfrom osprov.optparse_ext import OptionParser\nfrom osprov.osbp import logger\n\nAI_XML_PATH = \"/tmp/ai.xml\"\nSC_XML_PATH = \"/tmp/sc.xml\"\n\nLOG = logger.getIt(\"Inject Required AI settings\")\n\n\nclass InjectOptionsParser(OptionParser):\n\n    def defineOptions(self):\n        self.add_option(\"-i\", \"--ips-source\", help=\"IPS origin used for installation\")\n        self.add_option(\"-m\", \"--mirror\", action=\"append\", dest=\"mirrors\",\n                        help=\"IPS mirror used for installation, can specify multiple times\")\n        self.add_option(\"-p\", \"--encrypted-root-password\", dest=\"password\",\n                        help=\"Root password for the installed system, encrypted\")\n        self.add_option(\"-x\", \"--http-proxy\", dest=\"proxy\",\n                        help=\"HTTP proxy used for IPS installation\")\n\n\n@HandleShowErrorMessage(\"inject required AI\", LOG)\ndef main():\n    \"\"\"Inject required AI settings.\"\"\"\n\n    opts, args = InjectOptionsParser().parse_args()\n\n    aiFile = open(AI_XML_PATH, \"r\")\n    aiManifest = AIManifest(aiFile)\n    scFile = open(SC_XML_PATH, \"r\")\n    scManifest = SCManifest(scFile)\n\n    if opts.mirrors:\n        mirrors = opts.mirrors\n    else:\n        mirrors = []\n\n    try:\n        aiManifest.autoreboot = False\n        if opts.ips_source:\n            aiManifest.setIPSPublisherInfo(\"solaris\", ([opts.ips_source], mirrors))\n        if opts.password:\n            scManifest.rootPassword = opts.password\n        if opts.proxy:\n            aiManifest.httpProxy = opts.proxy\n\n        aiManifest.save()\n        scManifest.save()\n    finally:\n        aiFile.close()\n        scFile.close()\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n",
            "description": "This program will modify the Automated Installer manifest files to inject IPS source and root password info.\n\nUsage: inject_required_ai.py [options]\n\noptions:\n  -i IPS_SOURCE, --ips-source=IPS_SOURCE\n                        IPS origin used for installation\n  -m MIRROR, --mirror=MIRROR\n                        IPS mirror used for installation, can be specified multiple times\n  -p PASSWORD, --encrypted-root-password=PASSWORD\n                        Root password for the installed system, encrypted in standard /etc/shadow format\n  -x PROXY, --http-proxy=PROXY\n\t\t\tHTTP proxy used for IPS installation\n\nPrerequisites:\n\n- This script must be run as part of a Build Plan under a Solaris Service OS\n- This script must be run after ai.xml and sc.xml configuration files were deployed on the server",
            "status": null,
            "name": "Inject Required AI Settings",
            "state": null,
            "eTag": "2015-06-13T04:48:39.000Z",
            "modified": "2015-06-13T04:48:39.000Z",
            "created": "2015-06-13T04:48:39.000Z",
            "category": "os-deployment-server-scripts",
            "uri": "/rest/os-deployment-server-scripts/320001"
        },
        {
            "runAsSuperUser": false,
            "serverChanging": true,
            "codeType": "SH",
            "displayCodeType": "Unix",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "1",
                    "createdBy": "opsware",
                    "createdDate": "2015-06-13T04:48:40.000Z",
                    "usage": "This script inject required settings into the preseed file:\n- The media server used in the installation process. Only HTTP is supported.\n- Sets the network interface detection to auto. Later on the BOOTIF kernel parameter will be set to the specific network interface that should be used by the system.\nThis is determined either from the hpsa_netconfig custom attribute in static IP deployments or the interface the agent used to connect to the agent gateway.\n- Sets the disk to be used for partitioning, if not already customized by the user, to the first available disk or as specified by the boot_disk custom attribute.\n\nUsage: inject_required_preseed.py\n\nPrerequisites:\n- Target server runs a maintenance Linux OS.\n- The user provided or default ps file must be in /tmp/preseed.cfg.",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-06-13T04:48:40.000Z",
            "version": {
                "versionLabel": "1",
                "createdBy": "opsware",
                "createdDate": "2015-06-13T04:48:40.000Z",
                "usage": "This script inject required settings into the preseed file:\n- The media server used in the installation process. Only HTTP is supported.\n- Sets the network interface detection to auto. Later on the BOOTIF kernel parameter will be set to the specific network interface that should be used by the system.\nThis is determined either from the hpsa_netconfig custom attribute in static IP deployments or the interface the agent used to connect to the agent gateway.\n- Sets the disk to be used for partitioning, if not already customized by the user, to the first available disk or as specified by the boot_disk custom attribute.\n\nUsage: inject_required_preseed.py\n\nPrerequisites:\n- Target server runs a maintenance Linux OS.\n- The user provided or default ps file must be in /tmp/preseed.cfg.",
                "current": true
            },
            "source": "#!/opt/opsware/agent/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n\"\"\"\n    (C) Copyright 2013-2015 Hewlett-Packard Development Company, L.P.\n\n    Inject required options and move the file onto the boot\n    partition.\n\"\"\"\n\nimport os\nimport sys\n\nfrom osprov import helpers\nfrom osprov.decorators import HandleShowErrorMessage\nfrom osprov.profile.preseed import Preseed\nfrom osprov.osbp import logger\nfrom osprov.osbp.constants import MONITORING_STOP_FLAG\nfrom osprov.diskmgr.disk import Disk\nfrom osprov.server.local import ThisLocalServer\n\nLOG = logger.getIt('inject_required')\n\nBASE_PS_FILE = \"tmp/preseed.cfg\"\nBOOT_DISK = \"@boot_disk@\"  # ScriptWeaver will parametrize this data at run time\n\n\ndef initPreseed(baseFile):\n    \"\"\" Initialize a Preseed object \"\"\"\n    return Preseed(open(baseFile, \"r\"))\n\n\ndef writeFinalPs(psobj):\n    \"\"\" Write the preseed file onto the boot disk \"\"\"\n    psfile = open(BASE_PS_FILE, \"w\")\n    psfile.write(str(psobj))\n    psfile.close()\n    LOG.info(\"Preseed contents after injecting required settings\")\n    LOG.info(str(psobj))\n    print \"Preseed file written to disk\"\n\n\ndef injectMonitoringAgentPreScript(targetServer, psobj):\n    \"\"\" Configure the monitoring osprov ogfs agent to start during the install before anything else \"\"\"\n    agwIpPort = targetServer.getRandomAgentGateway()\n    ogfsAgentStartScript = targetServer.getOgfsAgentStartupScript(\n        agent=targetServer.AGENT_PATH,\n        agwIpPort=agwIpPort,\n        env=\"LD_LIBRARY_PATH=%s\" % os.path.join(\n            targetServer.AGENT_PATH, \"osprov/lib\"),\n        flags={\"daemonize\": True, \"mount\": False, \"quiet\": True})\n    LOG.debug(\"Using the following script to start the monitoring agent:\\n%s\" %\n              ogfsAgentStartScript)\n    psobj.setPreScript(script=ogfsAgentStartScript)\n\n\ndef injectDisk(preseed):\n    \"\"\" Inject the disk the installer to use. Only do this if the user does not have custom partitioning.\n        Also make use of the boot_disk custom attribute. \"\"\"\n    # Only set the disk if the user does not have custom partitioning.\n    _cmd, (_type, value) = getattr(preseed, \"d-i partman-auto/disk\", (None, (None, \"\")))\n    if not value.strip():\n        # Use the first disk for partitioning or the one specified by the boot_disk CA.\n        if BOOT_DISK and not \"@\" in BOOT_DISK:\n            bootDisk = Disk(BOOT_DISK).getDeviceFilePath()\n            print \"Injecting 'd-i partman-auto/disk %s' into the preseed\" % bootDisk\n            # configure grub to use the same disk as the installer\n            preseed.setPathToGrubInstaller(bootDisk)\n            print \"Configured grub-installer to use %s as install disk\" % bootDisk\n        else:\n            bootDisk = None\n            print \"Configuring 'd-i partman-auto/disk' to use the first available disk\"\n        preseed.setDisk(bootDisk)\n        return True\n    else:\n        return False\n\n\n@HandleShowErrorMessage(\"inject required preseed settings\", LOG)\ndef main():\n    \"\"\" Do the injection into the preseed \"\"\"\n    try:\n        localServer = ThisLocalServer()\n        keys = helpers.getDataStore(localServer)\n\n        preseed = initPreseed(BASE_PS_FILE)\n        mediaUrl = keys.media.url\n\n        if not mediaUrl.startswith(\"http:\"):\n            print \"Provisioning Ubuntu Server through anything other than http is not yet supported : \\n%s\" % str(\n                mediaUrl)\n            return 100\n\n        preseed.setMediaSource(mediaUrl)\n        preseed.setLiveInstaller(mediaUrl)\n        injectDisk(preseed)\n\n        # Start the ogfs agent during the installation.\n        injectMonitoringAgentPreScript(localServer, preseed)\n        # This flag is used to stop the monitoring step.\n        preseed.setPostScript(\"touch %s\" % MONITORING_STOP_FLAG)\n        # Stop the installer in order to integrate the HPSA agent.\n        preseed.stopInstaller()\n\n        writeFinalPs(preseed)\n        print \"Successfully injected required settings\"\n        LOG.info(\"Preseed after required settings were injected:\\n%s\" % str(preseed))\n    except (IOError, OSError), why:\n        LOG.exception(why)\n        sys.stderr.write(\"Failed to inject required settings.%s\\n\" % why)\n        return 1\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n",
            "description": "This script inject required settings into the preseed file:\n- The media server used in the installation process. Only HTTP is supported.\n- Sets the network interface detection to auto. Later on the BOOTIF kernel parameter will be set to the specific network interface that should be used by the system.\nThis is determined either from the hpsa_netconfig custom attribute in static IP deployments or the interface the agent used to connect to the agent gateway.\n- Sets the disk to be used for partitioning, if not already customized by the user, to the first available disk or as specified by the boot_disk custom attribute.\n\nUsage: inject_required_preseed.py\n\nPrerequisites:\n- Target server runs a maintenance Linux OS.\n- The user provided or default ps file must be in /tmp/preseed.cfg.",
            "status": null,
            "name": "Inject Required Preseed Settings",
            "state": null,
            "eTag": "2015-06-13T04:48:40.000Z",
            "modified": "2015-06-13T04:48:40.000Z",
            "created": "2015-06-13T04:48:39.000Z",
            "category": "os-deployment-server-scripts",
            "uri": "/rest/os-deployment-server-scripts/330001"
        },
        {
            "runAsSuperUser": true,
            "serverChanging": true,
            "codeType": "SH",
            "displayCodeType": "Unix",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "1",
                    "createdBy": "opsware",
                    "createdDate": "2015-06-13T04:48:40.000Z",
                    "usage": "Installs and configures GRUB (GRand Unified Boot Loader) onto the stub partition of the boot disk on the target server in order to enable the booting into the RedHat Enterprise Linux Server installation image.\n\nThe step will also auto detect directories with the names \"addon\", \"AddOn\" and \"ADDON\" in the repository and for SuSE Linux Enterprise Server installations append the proper \"addon='path-to-addon-dir' to the kernel parameters of the grub boot loader.\n\nUsage:\n\nThis script expects no command line arguments, but the following argument(s) can optionally be specified:\n    --kernel_arguments=KERNEL_ARGUMENTS\n                        a string of arguments that will be passed to the OS\n                        installer kernel\n    --disableWarning    Do not show warnings of old hpsa_netconfig format\n\nPrerequisites:\n- Target server runs a maintenance Linux OS.\n- The files in the grub.zip archive must be extracted in /tmp.\n- The \"Create Stub Partition\" step must have been executed. \n\nThis script is intended to be used only as a Build Plan step.",
                    "current": false
                },
                {
                    "versionLabel": "2",
                    "createdBy": "opsware",
                    "createdDate": "2015-08-04T07:30:29.000Z",
                    "usage": "Installs and configures GRUB (GRand Unified Boot Loader) onto the stub partition of the boot disk on the target server in order to enable the booting into the RedHat Enterprise Linux Server installation image.\n\nThe step will also auto detect directories with the names \"addon\", \"AddOn\" and \"ADDON\" in the repository and for SuSE Linux Enterprise Server installations append the proper \"addon='path-to-addon-dir' to the kernel parameters of the grub boot loader.\n\nUsage:\n\nThis script expects no command line arguments, but the following argument(s) can optionally be specified:\n    --kernel_arguments=KERNEL_ARGUMENTS\n                        a string of arguments that will be passed to the OS\n                        installer kernel\n    --disableWarning    Do not show warnings of old hpsa_netconfig format\n\nPrerequisites:\n- Target server runs a maintenance Linux OS.\n- The files in the grub.zip archive must be extracted in /tmp.\n- The \"Create Stub Partition\" step must have been executed. \n\nThis script is intended to be used only as a Build Plan step.",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-08-04T07:30:29.000Z",
            "version": {
                "versionLabel": "2",
                "createdBy": "opsware",
                "createdDate": "2015-08-04T07:30:29.000Z",
                "usage": "Installs and configures GRUB (GRand Unified Boot Loader) onto the stub partition of the boot disk on the target server in order to enable the booting into the RedHat Enterprise Linux Server installation image.\n\nThe step will also auto detect directories with the names \"addon\", \"AddOn\" and \"ADDON\" in the repository and for SuSE Linux Enterprise Server installations append the proper \"addon='path-to-addon-dir' to the kernel parameters of the grub boot loader.\n\nUsage:\n\nThis script expects no command line arguments, but the following argument(s) can optionally be specified:\n    --kernel_arguments=KERNEL_ARGUMENTS\n                        a string of arguments that will be passed to the OS\n                        installer kernel\n    --disableWarning    Do not show warnings of old hpsa_netconfig format\n\nPrerequisites:\n- Target server runs a maintenance Linux OS.\n- The files in the grub.zip archive must be extracted in /tmp.\n- The \"Create Stub Partition\" step must have been executed. \n\nThis script is intended to be used only as a Build Plan step.",
                "current": true
            },
            "source": "#!/opt/opsware/agent/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# lint_ignore=E501,I0011\n# Please do not change the two lines above. See PEP 8, PEP 263.\n\"\"\"\n    (C) Copyright 2013-2015 Hewlett-Packard Development Company, L.P.\n\n    This python script installs and configures Grub for BIOS and Grub2 for UEFI.\n\"\"\"\n\nimport os\nimport sys\nimport re\nimport glob\nimport shutil\nfrom cStringIO import StringIO\n\nfrom osprov.decorators import HandleShowErrorMessage\nfrom osprov.diskmgr.disk import LinuxDisk\nfrom osprov.networking.discovery import LinuxNetworkDiscovery\nfrom osprov.optparse_ext import OptionParser\nfrom osprov.osbp import logger\nfrom osprov.parsers.syslinux import Syslinux\nfrom osprov.util import process\nfrom osprov.errors import DiscoveryError, ShowErrorMessage, SetupError\nfrom osprov import helpers, media, netconfig\nfrom osprov.parsers.netconfig import SmartNetconfig, OLD_SYNTAX_WARNING\nfrom osprov.server.local import ThisLocalServer\nfrom osprov.constants import DEFAULT_INITRD_DIR, DEFAULT_SA_INITRD_MASK\nfrom osprov.wrappers.efibootmgr import EfiBootMgr, DiskBootEntry\nfrom osprov import ipaddr\n\nEC_INVALID_ARGS = 1\nEC_IG_FAILED = 5\nEC_GRUBMENU_FAILED = 6\nEC_NO_BOOTDISK = 7\n\nLOG = logger.getIt(\"install_configure_grub\")\n\n\n# for easier mocking\ndef _open(filepath, mode=\"r\"):\n    return open(filepath, mode)\n\n\ndef get_partition_name(device_name, partition_num):\n    \"\"\"Returns the partition with number partition_num for device_name\"\"\"\n    if not partition_num:\n        return device_name\n    base_name = os.path.basename(device_name)\n    if re.search(r\"c\\dd\\d\", base_name):\n        return device_name + \"p\" + str(partition_num)\n    return device_name + str(partition_num)\n\n\nclass Grub(object):\n    \"\"\" Helper class for configuring and installing the Grub boot loader. \"\"\"\n\n    MENU_PATHS = [\"boot/grub/menu.lst\"]\n    MODULES_PATH = \"boot/grub\"\n\n    def __init__(self, location):\n        self.location = location\n        self.grubinfo = self.validate()\n\n    def _getInfo(self):\n        info = {}\n        # first test for newer info.txt file\n        infofile = os.path.join(self.location, \"info.txt\")\n        if os.path.exists(infofile):\n            # get the path info from into.txt\n            execfile(infofile, info)\n            for value in [\"grub\", \"loaderfiles\"]:\n                if not info[value]:\n                    # expected value is missing\n                    return {}\n        else:\n            # set the required info values manually for older grub packages\n            info[\"grub\"] = \"sbin/grub\"\n            info[\"loaderfiles\"] = \"share/grub/i386-pc\"\n        return info\n\n    def validate(self):\n        \"\"\"    Performs some simple validation on the directory where GRUB is located.\n        info.txt can provide non default values for grub binary and loader files\n        and saves from hardcoding more paths in here.\n        info.txt should also contain version info for better tracking of versions.\n        required info entries are:\n                \"grub\"            - path to grub binary\n                \"loaderfiles\"   - path to loader files\n        \"\"\"\n        info = self._getInfo()\n        if not info:\n            return {}\n        # finally verify the paths\n        for path in [info[\"grub\"], info[\"loaderfiles\"]]:\n            if not os.path.exists(os.path.join(self.location, path)):\n                return {}\n        return info\n\n    def copyFilesTo(self, bootDiskMount):\n        \"\"\" Copies files to the location specified. \"\"\"\n        print(\"Copying Boot Loader files to runtime location\")\n        grubinfo = self.grubinfo\n        if not grubinfo:\n            raise ShowErrorMessage(\n                \"Failed to validate %s. A previous Build Plan step may be missing.\" % self.location)\n        targetLocation = os.path.join(bootDiskMount, self.MODULES_PATH)\n        helpers.makeDirs(targetLocation)\n        files = glob.glob(\"%s/*\" % os.path.join(self.location, grubinfo[\"loaderfiles\"]))\n        if not files:\n            raise ShowErrorMessage(\"No file to copy. A previous Build Plan step may be missing\")\n        for source in files:\n            destination = os.path.join(targetLocation, os.path.basename(source))\n            LOG.debug(\"Copying %s to %s\", source, destination)\n            shutil.copyfile(source, destination)\n\n    def install(self, bootDiskMount, bootDisk):\n        \"\"\"\n        Installs the files needed for GRuB on boot_disk.\n        Note that it will overwrite the Master Boot Record for boot_disk.\n        \"\"\"\n        self.copyFilesTo(bootDiskMount)\n        print(\"Preparing Boot Loader config script\")\n        config = list()\n        config.append(\"device (hd0) \" + bootDisk)\n        config.append(\"root (hd0,0)\")\n        config.append(\"install --stage2=%s/boot/grub/stage2 /boot/grub/stage1 d (hd0) \"\n                      \"/boot/grub/stage2 p /boot/grub/menu.lst\" % bootDiskMount)\n        config.append(\"quit\")\n        config_str = \"\\n\".join(config) + \"\\n\"\n\n        print(\"Installing Boot Loader\")\n        os.chmod(\"%s\" % os.path.join(self.location, self.grubinfo[\"grub\"]), 0777)\n        params = \"--batch --no-floppy --config-file=/boot/grub/menu.lst\"\n        process.runIt(\"%s %s\" %\n                      (os.path.join(self.location, self.grubinfo[\"grub\"]), params), input=config_str, quiet=True)\n        return config_str\n\n    def configureMenu(self, title, kernel, kernelArguments, initrds, keys):\n        \"\"\"    Creates a GRUB menu.lst configuration. \"\"\"\n        return \"\"\"\ndefault 0\ntimeout 5\ntitle %(title)s\nroot (hd0,0)\n\nkernel /%(kernel)s %(kernelArguments)s\ninitrd %(initrds)s\n\n\"\"\" % {\n            'title': title,\n            'kernel': kernel,\n            'kernelArguments': kernelArguments,\n            'initrds': ' '.join(initrds)\n        }\n\n\nclass Grub2(Grub):\n    BOOT_DIRECTORY = \"boot/\"\n    MENU_PATHS = [os.path.join(BOOT_DIRECTORY, \"grub/grub.cfg\"), os.path.join(BOOT_DIRECTORY, \"grub2/grub.cfg\")]\n    EFI_BOOT_DIR = \"EFI/BOOT/\"\n    EFI_BOOT_PATH = os.path.join(EFI_BOOT_DIR)\n    EFI_CMD_SUFFIX = \"\"\n\n    def _getInfo(self):\n        info = dict()\n        info[\"grub\"] = \"sbin/grub-install\"\n        info[\"loaderfiles\"] = \"lib/grub/x86_64-efi\"\n        return info\n\n    def install(self, bootDiskMount, bootDisk):\n        secureBootLoader = self.configureSecureBootLoader(bootDiskMount)\n        if not secureBootLoader:\n            process.runIt(\"%(grub-install)s --removable --efi-directory=%(bootDiskMount)s --boot-directory=%(bootDirectory)s %(bootDisk)s\"\n                          % {'grub-install': os.path.join(self.location, self.grubinfo['grub']),\n                             'bootDiskMount': bootDiskMount,\n                             'bootDirectory': os.path.join(bootDiskMount, self.BOOT_DIRECTORY),\n                             'bootDisk': bootDisk}, log=LOG, quiet=True)\n            # configure the UEFI boot entries\n            osInstallerBootEntry = DiskBootEntry(\"HPSA Assisted OS Installer\", disk=bootDisk)\n        else:\n            # configure the UEFI boot entries with specific path to loader\n            print(\"Found UEFI secure boot files in media\")\n            osInstallerBootEntry = DiskBootEntry(\"HPSA Assisted OS Installer\", disk=bootDisk, loader=secureBootLoader)\n        efibootmgr = EfiBootMgr(log=LOG)\n        efibootmgr.bootOneTime(osInstallerBootEntry)\n        print(\"Configured boot to: %s\" % osInstallerBootEntry)\n\n    def configureSecureBootLoader(self, bootDiskMount):\n        keys = helpers.getDataStore()\n        mediaFS = media.factor(keys.media.url, log=LOG)\n        bootEFIFiles = mediaFS.findFiles(path=self.EFI_BOOT_DIR)\n        secureBootFiles = {'boot': None, 'grub': None}\n        for boot in bootEFIFiles:\n            if re.match(\"bootx64\\.efi\", boot, re.IGNORECASE):\n                secureBootFiles['boot'] = boot\n            if re.match(\"grub(x64)?\\.efi\", boot, re.IGNORECASE):\n                secureBootFiles['grub'] = boot\n        LOG.debug(\"Boot files for SecureBoot found in media : %s\" % str(bootEFIFiles))\n        if secureBootFiles['boot'] and secureBootFiles['grub']:\n            # create path on stub partition\n            os.makedirs(os.path.join(bootDiskMount, self.EFI_BOOT_PATH))\n            for boot in bootEFIFiles:\n                if boot and \".efi\" in boot.lower():\n                    mediaFS.copyTo(os.path.join(self.EFI_BOOT_DIR, boot), os.path.join(bootDiskMount, self.EFI_BOOT_PATH))\n            # add new path for grub.cfg and efi suffix\n            self.MENU_PATHS.append(os.path.join(self.EFI_BOOT_PATH, \"grub.cfg\"))\n            self.EFI_CMD_SUFFIX = \"efi\"\n            return os.path.join(\"/\", self.EFI_BOOT_PATH, secureBootFiles['boot']).replace(\"/\", \"\\\\\")\n        return None\n\n    def configureMenu(self, title, kernel, kernelArguments, initrds, keys):\n        \"\"\" Creates a GRUB2 grub.conf configuration \"\"\"\n        return \"\"\"\nset default=0\nset timeout=5\n\ninsmod all_video\n\nmenuentry '%(title)s' {\n    linux%(efi)s  /%(kernel)s %(kernelArguments)s\n    initrd%(efi)s %(initrds)s\n}\n\n\"\"\" % {\n            'efi': self.EFI_CMD_SUFFIX,\n            'title': title,\n            'kernel': kernel,\n            'kernelArguments': kernelArguments,\n            'initrds': ' '.join(initrds),\n            'device_uuid': keys.disk.device_uuid\n        }\n\n\ndef getGrub(bootDisk):\n    \"\"\" Factor a Grub or Grub2 object based on the partition table type of the boot disk \"\"\"\n    if bootDisk.partitionTableType == \"msdos\":\n        return Grub(\"/tmp/grub\")\n    else:\n        return Grub2(\"/tmp/grub2\")\n\n\ndef checkCompleteStaticNetData(netdata, ipv):\n    values = netdata.values()\n    if None in values or \"\" in values:\n        print \"WARNING: The provided %s static configuration is incomplete. The OS installer may fail.\" % ipv\n\n\ndef getIPv6NameServer():\n    lnd = LinuxNetworkDiscovery()\n    lnd.discover()\n    if lnd.netinfo.nics and lnd.netinfo.nics[0].ipv6DnsServers:\n        return lnd.netinfo.nics[0].ipv6DnsServers[0]\n    else:\n        return \"\"\n\n\ndef getNetworkingParams(mac, osdata, netconfig, isIPv6Managed):\n    try:\n        activeIface = [x for x in netconfig.nics if x.provisioning][0]\n    except IndexError:\n        raise SetupError(\"Found no provisioning interface\")\n\n    isRHEL7 = \"RHEL7\" == osdata[\"os_version\"]\n    ip_params = \"\"\n\n    if isIPv6Managed:\n        if activeIface.ipv6Autoconfig:\n            ip_params += \" \" + osdata[\"ip_config_auto6\"] % {'mac': mac}\n            # for RHEL7 on IPv6 we need to set the nameserver since dracut\n            # does not generate a proper dhcpv6 client config\n            # note that NetworkManager does eventually start after the squashfs.img is downloaded\n            # so it will overwrite what dracut configures\n            if \"RHEL7\" == osdata[\"os_version\"]:\n                ip_params += \" nameserver=%s\" % getIPv6NameServer()\n        elif activeIface.ipv6Networks:\n            net_data = {\n                \"ip\": (\"[%s]\" if isRHEL7 else \"%s\") % activeIface.ipv6Networks[0].ip,\n                \"mask\": activeIface.ipv6Networks[0].netmask,\n                \"prefix\": activeIface.ipv6Networks[0].prefixlen,\n                \"dns\": \"\",\n                \"gw\": \"\",\n                \"mac\": mac,\n            }\n            for dnsserv in activeIface.ipv6DnsServers:\n                net_data[\"dns\"] = dnsserv\n                break\n            for route in [x for x in netconfig.ipv6Routes if x.nic == activeIface]:\n                net_data[\"gw\"] = (\"[%s]\" if isRHEL7 else \"%s\") % route.gateway\n                break\n            # support for autoconf + static network in the installer\n            if isRHEL7 and activeIface.ipv6Autoconfig:\n                if not net_data[\"dns\"]:\n                    net_data[\"dns\"] = getIPv6NameServer()\n            ip_params += \" \" + (osdata[\"ip_config_static6\"] % net_data)\n            checkCompleteStaticNetData(net_data, \"IPv6\")\n        else:\n            print \"Can not complete network personalization. \" \\\n                  \"Auto configuration is turned off for IPv6 and there is no static address defined\"\n            sys.exit(37)\n    else:\n        if activeIface.ipv4Networks:\n            net_data = {\n                \"ip\": activeIface.ipv4Networks[0].ip,\n                \"mask\": activeIface.ipv4Networks[0].netmask,\n                \"dns\": \"\",\n                \"gw\": \"\",\n            }\n            for dnsserv in activeIface.dnsServers:\n                if isinstance(dnsserv, ipaddr.IPv4Address):\n                    net_data[\"dns\"] = dnsserv\n                    break\n            for route in [x for x in netconfig.ipv4Routes if x.nic == activeIface]:\n                net_data[\"gw\"] = route.gateway\n                break\n            ip_params += \" \" + (osdata[\"ip_config_static\"] % net_data)\n            checkCompleteStaticNetData(net_data, \"IPv4\")\n        elif activeIface.dhcpv4:\n            ip_params += \" \" + osdata[\"ip_config_dhcp\"]\n        else:\n            print \"Can not complete network personalization. \" \\\n                  \"DHCP is turned off for IPv4 and there is no static address defined\"\n            sys.exit(38)\n\n    return ip_params.strip()\n\n\ndef updateExecInstructions(params1=\"\", params2=\"\"):\n    \"\"\"If both params strings contain the exec argument, the method will remove it form second string and combine\n    the 2 instructions in to the first string\"\"\"\n    if params2.count(\"exec=\") and params1.count(\"exec=\"):\n        ip_param_exec = params2[params2.index(\"exec=\\\"\"):params2.index(\"\\\"\", params2.index(\"exec=\\\"\") + 6) + 1]\n        params2 = params2.replace(ip_param_exec, \"\")\n        if \"exec='\" in params1:\n            params1 = params1.replace(\"exec='\", \"exec='\" + ip_param_exec[6:-1] + \";\")\n        else:\n            params1 = params1.replace('exec=\"', 'exec=\"' + ip_param_exec[6:-1] + \";\")\n    return params1, params2\n\n\ndef configureKernelArguments(osdata, keys, netcfg_parser, kernel_arguments=\"\"):\n    \"\"\" Configures the kernel arguments \"\"\"\n    localServer = ThisLocalServer()\n    boot_disk = keys.disk.device_path\n    boot_disk_uuid = keys.disk.device_uuid\n    # to be used by install_params\n    root_partition = get_partition_name(boot_disk[5:], 1)\n    if \"SLES\" in osdata[\"os_version\"] and \"cciss\" in boot_disk:\n        boot_disk = \"%s//\" % boot_disk\n    # ALERT: do not remove lower(), SLES doesn't recognize a MAC address if upper\n    mac = localServer.getMACAddress().lower()\n    url = mediaUrl(keys)\n    arg_dict = {\n        \"mac\": mac,\n        \"boot_disk\": boot_disk,\n        \"root_partition\": root_partition,\n        \"boot_disk_uuid\": boot_disk_uuid,\n        \"url\": url.canonical(),\n        \"bootif\": netconfig.macToBootIf(mac)\n    }\n    kernel_params = osdata['install_params'] % arg_dict\n    if kernel_arguments:\n        print(\"Found kernel arguments: \" + kernel_arguments)\n        kernel_params = kernel_params + \" \" + kernel_arguments\n\n    # Handle TCP/IP settings to make sure that installers behave  ##\n    ip_params = getNetworkingParams(mac, osdata, netcfg_parser.info(), localServer.isIPv6Managed())\n    if ip_params:\n        print(\"Additional kernel arguments for network configuration: %s\" % ip_params)\n        kernel_params, ip_params = updateExecInstructions(params1=kernel_params, params2=ip_params)\n        kernel_params += \" \" + ip_params\n\n    # Limit ports only if we are doing NFS, sles 11 sp0 has issues with this setting\n    if url.scheme == \"nfs\":\n        # Make sure that the nfs client doesn't use the agent port\n        kernel_params += \" sunrpc.max_resvport=1000\"\n\n    # if present handle addonloc\n    if \"addonloc\" in osdata and osdata[\"addonloc\"]:\n        # Handle SLES addon sources (eg. by use of kISO content)\n        if \"SLES\" in osdata[\"os_version\"]:\n            if kernel_params.lower().find(\"addon=\") == -1:\n                # no addon parameter present - add it using the found location if any\n                print \"Boot Loader (SLES) auto appending kernel parameter \"\"addon=%s\"\" \" % osdata[\"addonloc\"]\n                kernel_params += \" addon=%s\" % osdata[\"addonloc\"]\n            else:\n                print \"Boot Loader (SLES) \"\"addon=\"\" parameter present - not auto appending\"\n\n    # tidy up the kernel_params to contain only one blank between and no trailing blanks\n    # required for SLES's picky addon parameter handler (would fail with nfs:// source)\n    kernel_params = ' '.join(kernel_params.split())\n\n    return kernel_params\n\n\ndef configureInitrds(osdata, keys):\n    # start with the default initrd\n    initrdlist = [\"/%s\" % osdata[\"initrd\"]]\n\n    discoverLocalRds(osdata, root=keys.disk.device_mount)\n\n    # if present add supplemental local initrds\n    if \"localrds\" in osdata:\n        for eachrd in osdata[\"localrds\"]:\n            initrdlist.append(eachrd)\n        # max number of initrds that can be handled is limited by the line length\n        # limit of grubs menu.lst: 1500 chars.\n        if len(initrdlist) > (1500 - 1):\n            raise DiscoveryError(\"INITRD parameter: Maximum parameter length (1500) exceeded! \"\n                                 \"- Too many additional initrd files found.\")\n    return initrdlist\n\n\ndef discoverLocalRds(osdata, root):\n    \"\"\" Get initrd files from /localrds directory \"\"\"\n    rds = helpers.findFiles(\n        path=os.path.join(root, DEFAULT_INITRD_DIR), mask=DEFAULT_SA_INITRD_MASK)\n    if rds:\n        rdlist = []\n        # add the local path to make it suitable for grub\n        for eachrd in rds:\n            rdlist.append(os.path.join(os.path.sep, DEFAULT_INITRD_DIR, eachrd))\n        osdata[\"localrds\"] = helpers.numericalSort(rdlist)\n    return\n\n\ndef discoverOsdata(osdata, keys):\n    \"\"\" Discover the kernel and initrd to use based on the media \"\"\"\n    # the copy boot media step should have run by now, so we work with the\n    # stub partition. This is just so we don't access the media twice\n    stub_path = keys.disk.device_mount\n    if not stub_path:\n        raise DiscoveryError(\"Cannot discover boot disk mount point. \"\n                             \"Was the stub partition created?\")\n    isocfg = Syslinux.readonly(_open(os.path.join(stub_path, \"isolinux.cfg\")))\n    isocfg_label = isocfg.info()[\"label \" + isocfg.first_non_local_label()]\n    # discover the kernel\n    osdata[\"kernel\"] = os.path.basename(isocfg_label[\"kernel\"])\n    # discover the initrd\n    append = isocfg_label[\"append\"].split(' ')\n    for each in append:\n        if '=' in each:\n            key, value = [x.strip() for x in each.split('=', 1)]\n            if key == \"initrd\":\n                osdata[\"initrd\"] = os.path.basename(value)\n    if \"initrd\" not in osdata:\n        raise DiscoveryError(\"Failed to discover the initrd\")\n\n    # verify the files are there otherwise the boot loader will fail to find them\n    kernel = os.path.join(stub_path, osdata[\"kernel\"])\n    initrd = os.path.join(stub_path, osdata[\"initrd\"])\n    if not os.path.exists(kernel) or not os.path.exists(initrd):\n        raise DiscoveryError(\"Failed to discover the boot kernel or initrd\")\n\n\ndef discoverSlesAddon(osdata, keys):\n    \"\"\" Discover addon directories for\n            SLES: kISO formatted media w/ \"addon\" directory\n    \"\"\"\n    url = mediaUrl(keys)\n    thismedia = media.factor(str(url))\n    # for SLES check for addon directory in the repository\n    SLES_ADDON_LOCATIONS = [\n        # common names for SLES addon directory\n        \"addon/\", \"ADDON/\", \"AddOn/\"\n    ]\n    for each_file in SLES_ADDON_LOCATIONS:\n        if thismedia.exists(each_file):\n            osdata[\"addonloc\"] = url.canonical() + \"/\" + each_file\n            print \"Boot Loader (SLES) ADDON directory found in source location: %s\" % osdata[\"addonloc\"]\n            return\n\n\ndef mediaUrl(keys):\n    \"\"\" determine the media server and path \"\"\"\n    url = keys.media.url\n    if not url:\n        # Fall back in case of old NFS mount script\n        mediaServer = _open(\"/tmp/osbp_info/media_server\", \"r\").read().strip()\n        mediaPath = _open(\"/tmp/osbp_info/media_path\", \"r\").read().strip()\n        mediaMount = _open(\"/tmp/osbp_info/media_mount\", \"r\").read().strip()\n        url = \"nfs://%s:%s/#%s\" % (mediaServer, mediaPath, mediaMount)\n    return media.parseUrl(url)\n\n\nclass InstallConfigureGrubOptionParser(OptionParser):\n    def defineOptions(self):\n        self.add_option(\"--kernel_arguments\", default=\"\",\n                        help=\"a string of arguments that will be passed to the OS installer kernel\")\n        self.add_option(\"--disableWarning\", dest=\"disableWarning\", action=\"store_true\",\n                        default=False,\n                        help=\"Do not show warnings of old hpsa_netconfig format\")\n\n\n@HandleShowErrorMessage(\"install and configure bootloader\", log=LOG)\ndef main():\n    options, remainingArgs = InstallConfigureGrubOptionParser().parse_args()\n    del remainingArgs\n\n    localServer = ThisLocalServer()\n    parser = SmartNetconfig.readwrite(\n        StringIO(HPSA_NETCONFIG),\n        activeMacAddress=localServer.getMACAddress(),\n        ipv6default=localServer.isIPv6Managed(),\n        log=LOG\n    )\n    if parser.info().oldSyntax and not options.disableWarning:\n        newFormat = parser.format()\n        print OLD_SYNTAX_WARNING + \"\\n%s\" % str(newFormat)\n\n    typosList = parser.getTyposList()\n    if typosList:\n        print(\"The following keys were not recognized in the netconfig CA and could be typos: %s\" % typosList)\n\n    keys = helpers.getDataStore()\n\n    bootDiskMount = keys.disk.device_mount\n    if not bootDiskMount:\n        raise DiscoveryError(\"Discovery of the boot disk mount point failed. \"\n                             \"Was the stub partition created?\", EC_NO_BOOTDISK)\n\n    bootDisk = LinuxDisk(keys.disk.device_path, None, None)\n    grub = getGrub(bootDisk)\n    try:\n        grub.install(bootDiskMount, bootDisk.getDeviceFilePath())\n    except (OSError, IOError), why:\n        print \"Installing GRuB failed. %s\" % why\n        return EC_IG_FAILED\n\n    # build.py will perform the needed substitutions here\n    osdata = dict()\n    osdata[\"os_display_name\"] = 'RedHat Enterprise Linux Server'\n    osdata[\"os_version\"] = 'RHEL'\n    osdata[\"install_params\"] = 'ks=file:/user.ks.cfg  ksdevice=%(mac)s'\n    osdata[\"ip_config_static\"] = 'ip=%(ip)s gateway=%(gw)s netmask=%(mask)s'\n    osdata[\"ip_config_static6\"] = 'ip=%(ip)s gateway=%(gw)s netmask=%(mask)s'\n    osdata[\"ip_config_dhcp\"] = 'ip=dhcp noipv6'\n    osdata[\"ip_config_auto6\"] = 'ipv6=auto noipv4'\n\n    discoverOsdata(osdata, keys)\n    if \"SLES\" in osdata[\"os_version\"]:\n        discoverSlesAddon(osdata, keys)\n\n    title = 'HP SA assisted %s installer' % osdata['os_display_name']\n    kernelArguments = configureKernelArguments(osdata, keys, parser,\n                                               kernel_arguments=options.kernel_arguments + \" hpsa_monitoring_agent=1\")\n    initrds = configureInitrds(osdata, keys)\n\n    menu = grub.configureMenu(title,\n                              osdata['kernel'], kernelArguments,\n                              initrds, keys)\n    for menuPath in grub.MENU_PATHS:\n        if not os.path.exists(os.path.join(bootDiskMount, os.path.dirname(menuPath))):\n            os.makedirs(os.path.join(bootDiskMount, os.path.dirname(menuPath)))\n        _open(os.path.join(bootDiskMount, menuPath), \"w\").write(menu)\n\n    return 0\n\nHPSA_NETCONFIG = \"\"\"@hpsa_netconfig@\"\"\"\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n",
            "description": "Installs and configures GRUB (GRand Unified Boot Loader) onto the stub partition of the boot disk on the target server in order to enable the booting into the RedHat Enterprise Linux Server installation image.\n\nThe step will also auto detect directories with the names \"addon\", \"AddOn\" and \"ADDON\" in the repository and for SuSE Linux Enterprise Server installations append the proper \"addon='path-to-addon-dir' to the kernel parameters of the grub boot loader.\n\nUsage:\n\nThis script expects no command line arguments, but the following argument(s) can optionally be specified:\n    --kernel_arguments=KERNEL_ARGUMENTS\n                        a string of arguments that will be passed to the OS\n                        installer kernel\n    --disableWarning    Do not show warnings of old hpsa_netconfig format\n\nPrerequisites:\n- Target server runs a maintenance Linux OS.\n- The files in the grub.zip archive must be extracted in /tmp.\n- The \"Create Stub Partition\" step must have been executed. \n\nThis script is intended to be used only as a Build Plan step.",
            "status": null,
            "name": "Install bootloader for RedHat Enterprise Linux Server",
            "state": null,
            "eTag": "2015-08-04T07:30:29.000Z",
            "modified": "2015-08-04T07:30:29.000Z",
            "created": "2015-06-13T04:48:40.000Z",
            "category": "os-deployment-server-scripts",
            "uri": "/rest/os-deployment-server-scripts/340001"
        },
        {
            "runAsSuperUser": true,
            "serverChanging": true,
            "codeType": "PY2",
            "displayCodeType": "Python",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "1",
                    "createdBy": "opsware",
                    "createdDate": "2015-06-13T04:48:43.000Z",
                    "usage": "This script is used to deploy a WinPE ServiceOS on localdisk which will be booted later.\nMust NOT be part of a build plan. This step is called by step named 'Install and\nboot into local WinPE'\n\nUsage: deploy_winpe_on_localdisk.py [options]\n\nOptions:\n-h, --help : show this help message and exit\n--systemDiskNumber : system disk number where Windows is installed (default disk number is '0')\n--systemDrive : system drive letter where WinPE will be copied\n--espLabel : Efi System Partition label (default value is 'ESP')\n--winpeVersion : WinPE version which will be downloaded (default value is 'any')\n--bootMode : boot mode of the server, can be UEFI or Legacy\n--disableWarning : Do not show warnings of old hpsa_netconfig format\n\nPrerequisites:\n- Target server runs a maintenance Windows PE OS.",
                    "current": false
                },
                {
                    "versionLabel": "2",
                    "createdBy": "opsware",
                    "createdDate": "2015-08-04T07:30:09.000Z",
                    "usage": "This script is used to deploy a WinPE ServiceOS on localdisk which will be booted later.\nMust NOT be part of a build plan. This step is called by step named 'Install and\nboot into local WinPE'\n\nUsage: deploy_winpe_on_localdisk.py [options]\n\nOptions:\n-h, --help : show this help message and exit\n--systemDiskNumber : system disk number where Windows is installed (default disk number is '0')\n--systemDrive : system drive letter where WinPE will be copied\n--espLabel : Efi System Partition label (default value is 'ESP')\n--winpeVersion : WinPE version which will be downloaded (default value is 'any')\n--bootMode : boot mode of the server, can be UEFI or Legacy\n--disableWarning : Do not show warnings of old hpsa_netconfig format\n\nPrerequisites:\n- Target server runs a maintenance Windows PE OS.",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-08-04T07:30:09.000Z",
            "version": {
                "versionLabel": "2",
                "createdBy": "opsware",
                "createdDate": "2015-08-04T07:30:09.000Z",
                "usage": "This script is used to deploy a WinPE ServiceOS on localdisk which will be booted later.\nMust NOT be part of a build plan. This step is called by step named 'Install and\nboot into local WinPE'\n\nUsage: deploy_winpe_on_localdisk.py [options]\n\nOptions:\n-h, --help : show this help message and exit\n--systemDiskNumber : system disk number where Windows is installed (default disk number is '0')\n--systemDrive : system drive letter where WinPE will be copied\n--espLabel : Efi System Partition label (default value is 'ESP')\n--winpeVersion : WinPE version which will be downloaded (default value is 'any')\n--bootMode : boot mode of the server, can be UEFI or Legacy\n--disableWarning : Do not show warnings of old hpsa_netconfig format\n\nPrerequisites:\n- Target server runs a maintenance Windows PE OS.",
                "current": true
            },
            "source": "# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n#\n\"\"\"\n    (C) Copyright 2013-2015 Hewlett-Packard Development Company, L.P.\n \"\"\"\n\nimport os\nimport sys\nfrom StringIO import StringIO\nfrom optparse import OptionError\nfrom osprov.osbp import logger\nfrom osprov.scripts import bootmode\nfrom osprov.util import process, winpe, NullLog\nfrom osprov.helpers import getMyServerRef\nfrom osprov.optparse_ext import OptionParser\nfrom osprov.server.local import ThisLocalServer\nfrom osprov.decorators import HandleShowErrorMessage\nfrom osprov.diskmgr.disk import WindowsDisk\nfrom osprov.diskmgr.diskmanager import WindowsDiskManager\nfrom osprov.diskmgr.partition import WindowsPartition\nfrom osprov.errors import DiscoveryError, NotFoundError, InvalidArgumentsError\nfrom osprov.parsers.netconfig import SmartNetconfig, OLD_SYNTAX_WARNING\n\nfrom pytwist.com.opsware.search import Filter\nfrom pytwist.com.opsware.ilo import ServerBootMode\n\nLOG = logger.getIt(\"Deploy WinPE on localdisk\")\n\nRESPONSE_FILE = \"hpsa_response_file.txt\"\nHPSA_NETCONFIG = \"\"\"@hpsa_netconfig@\"\"\"\n\n\nclass DeployWinpeOptionsParser(OptionParser):\n    \"\"\" An option parser for this step. \"\"\"\n\n    def defineOptions(self):\n        \"\"\" definition of options \"\"\"\n        self.add_option(\"--systemDiskNumber\", type=\"int\", default=0,\n                        help=\"System disk number where Windows is installed (default disk number is '0').\")\n        self.add_option(\"--systemDrive\", type=\"string\", default=\"C\",\n                        help=\"System drive letter where WinPE will be copied\")\n        self.add_option(\"--espLabel\", type=\"string\", default=\"ESP\",\n                        help=\"Efi System Partition label (default value is 'ESP'\")\n        self.add_option(\"--winpeVersion\", type=\"string\", default=\"any\",\n                        help=\"WinPE version which will be downloaded (default value is 'any').\")\n        self.add_option(\"--bootMode\", type=\"string\",\n                        help=\"Boot mode of the server, can be UEFI or Legacy\")\n        self.add_option(\"--disableWarning\", dest=\"disableWarning\", action=\"store_true\",\n                        default=False,\n                        help=\"Do not show warnings of old hpsa_netconfig format\")\n\n    def validateArgs(self, opt, args):\n        \"\"\" options validation \"\"\"\n        winpeVersions = map(str.strip, opt.winpeVersion.upper().split(\",\"))\n        for ver in winpeVersions:\n            if ver not in winpe.WINPE_VERSION_TO_ISO.keys():\n                raise OptionError(\"Invalid WinPE version was requested: %s. Supported WinPE options: %s\" % (\n                    ver, str(winpe.WINPE_VERSION_TO_ISO.keys()).strip(\"[]\")), option=\"winpeVersion\")\n        if opt.bootMode and not bootmode.isBootModeSupported(opt.bootMode):\n            raise OptionError(\"Invalid boot mode: \" + opt.bootMode, \"bootMode\")\n\n\ndef downloadIso(targetServer, isoNames, destinationDrive):\n    foundMultipleIsos = False\n    _isoName = None\n\n    if not isoNames:\n        raise InvalidArgumentsError(\"No iso file name was provided\")\n    if not destinationDrive:\n        raise InvalidArgumentsError(\"No destination drive was provided\")\n\n    for iso in isoNames:\n        unitFilter = Filter()\n        unitFilter.setObjectType(\"software_unit\")\n        filterExpression = \"( (PackageVO.fileName EQUAL_TO %s) & \\\n                              (UnitVO.unitType EQUAL_TO UNKNOWN) & \\\n                              (PackageVO.fileType EQUAL_TO UNKNOWN) )\"\n        unitFilter.setExpression(filterExpression % iso)\n        twistServer = targetServer.twistServer\n        ref = twistServer.pkg.UnitService.findUnitRefs(unitFilter)\n        if not ref:\n            continue\n        elif len(ref) > 1:\n            foundMultipleIsos = True\n            _isoName = iso\n            continue\n        from coglib import reconcile\n        reconcile.retrieveFile(str(ref[0].id), destinationDrive + \":\\\\winpe.iso\", destinationDrive + \":\\\\\", \"theword\")\n        return\n\n    if foundMultipleIsos:\n        raise DiscoveryError(\"More than one iso named %s was found\" % _isoName)\n    else:\n        raise NotFoundError(\"Iso files named %s were not found\" % isoNames)\n\n\ndef unpackIso(destinationDrive):\n    unIsoCmdLine = \"7z.exe x %s:\\\\winpe.iso -y -o%s:\\\\\" % (\n        destinationDrive, destinationDrive)  # \"7z x c:\\\\winpe.iso -y -oc:\\\"\n    newEnv = os.environ\n    newEnv[\"PATH\"] = newEnv[\"PATH\"] + \";%s\\\\tools\" % newEnv[\"SYSTEMDRIVE\"]\n    process.runIt(unIsoCmdLine, quiet=True, checkExitCode=(0,), env=newEnv, log=LOG)\n\n\ndef storeStaticNetworkInfo(targetSrv, destinationDrive):\n    agwIpPort = targetSrv.getRandomAgentGateway(formatted=False)\n    mid = str(getMyServerRef().id)\n    mac = targetSrv.getMACAddress()\n    responseConf = SmartNetconfig.readwrite(StringIO(HPSA_NETCONFIG), activeMacAddress=mac, agwIpPort=agwIpPort,\n                                            mid=mid, ipv6default=targetSrv.isIPv6Managed(), log=LOG).format()\n    respfile = open(os.path.join(\"%s:\" % destinationDrive, RESPONSE_FILE), \"a\")\n    respfile.write(responseConf)\n    respfile.close()\n\n\ndef assignDriveLetterToESP(systemDiskNumber, espLabel, log=NullLog()):\n    espPartition = None\n    freeLetter = WindowsDiskManager().findFirstAvailableDriveLetter()\n    try:\n        espPartition = WindowsDisk(systemDiskNumber).getPartitionWithLabel(espLabel)\n    except NotFoundError as why:\n        raise NotFoundError(\"Cannot find Efi System Partition (%s).\" % str(why))\n    WindowsPartition(systemDiskNumber, espPartition.partitionNr).setPartitionLetter(freeLetter)\n    return freeLetter\n\n\ndef setUefiBootloader(systemDriveLetter, espLetter, log=NullLog()):\n    # steps are documented here: https://technet.microsoft.com/en-us/library/hh265131%28v=ws.10%29.aspx\n\n    commands = (\"XCOPY %s:\\\\efi\\\\* %s:\\\\efi\\\\* /cherkyfs\" % (systemDriveLetter, espLetter),\n                \"COPY /Y %s:\\\\boot\\\\boot.sdi %s:\\\\sources\" % (systemDriveLetter, systemDriveLetter),\n                \"COPY /Y x:\\\\windows\\\\boot\\\\efi\\\\*.efi %s:\\\\efi\\\\Microsoft\\\\Boot\\\\*\" % espLetter,\n                \"DEL %s:\\\\efi\\\\Microsoft\\\\Boot\\\\BCD /F\" % espLetter,\n                \"BCDEDIT -createstore %s:\\\\efi\\\\Microsoft\\\\Boot\\\\BCD\" % espLetter,\n                \"BCDEDIT -store %s:\\\\EFI\\\\Microsoft\\\\Boot\\\\BCD -create {bootmgr} /d \\\"Boot Manager\\\"\" % espLetter,\n                \"BCDEDIT -store %s:\\\\EFI\\\\Microsoft\\\\Boot\\\\BCD -create {globalsettings} /d \\\"globalsettings\\\"\" % espLetter,\n                \"BCDEDIT -store %s:\\\\EFI\\\\Microsoft\\\\Boot\\\\BCD -create {ramdiskoptions} /d \\\"ramdiskoptions\\\"\" % espLetter\n    )\n    for command in commands:\n        process.runIt(command, log=log, quiet=True, shell=True)\n\n    # this command is different from others because we have to parse and use the output\n    command = \"BCDEDIT -store %s:\\\\EFI\\\\Microsoft\\\\Boot\\\\BCD -create /d \\\"Windows PE\\\" -application osloader\" % espLetter\n    output = process.getStdout(command, log=log, shell=True)\n    uuid = output.split()[2]\n    # quick uuid validator\n    if uuid[0] != '{' or uuid[-1] != '}':\n        raise DiscoveryError(\"Command '%s' has an invalid output '%s'\" % (command, output))\n\n    commands = (\"BCDEDIT -store %s:\\\\EFI\\\\Microsoft\\\\Boot\\\\BCD /default %s\" % (espLetter, uuid),\n                \"BCDEDIT -store %s:\\\\EFI\\\\Microsoft\\\\Boot\\\\BCD -set {bootmgr} device partition=%s:\" % (\n                    espLetter, espLetter),\n                \"BCDEDIT -store %s:\\\\EFI\\\\Microsoft\\\\Boot\\\\BCD -set {bootmgr} path \\\\EFI\\\\Microsoft\\\\Boot\\\\bootmgfw.efi\" % espLetter,\n                \"BCDEDIT -store %s:\\\\EFI\\\\Microsoft\\\\Boot\\\\BCD -set {bootmgr} description WindowsPE\" % espLetter,\n                \"BCDEDIT -store %s:\\\\EFI\\\\Microsoft\\\\Boot\\\\BCD -set {bootmgr} locale en-us\" % espLetter,\n                \"BCDEDIT -store %s:\\\\EFI\\\\Microsoft\\\\Boot\\\\BCD -set {bootmgr} timeout 5\" % espLetter,\n\n                \"BCDEDIT -store %s:\\\\EFI\\\\Microsoft\\\\Boot\\\\BCD -set {Default} device ramdisk=[%s:]\\\\sources\\\\boot.wim,{ramdiskoptions}\" % (\n                    espLetter, systemDriveLetter),\n                \"BCDEDIT -store %s:\\\\EFI\\\\Microsoft\\\\Boot\\\\BCD -set {Default} path \\\\windows\\\\system32\\\\winload.efi\" % espLetter,\n                \"BCDEDIT -store %s:\\\\EFI\\\\Microsoft\\\\Boot\\\\BCD -set {Default} osdevice ramdisk=[%s:]\\\\sources\\\\boot.wim,{ramdiskoptions}\" % (\n                    espLetter, systemDriveLetter),\n                \"BCDEDIT -store %s:\\\\EFI\\\\Microsoft\\\\Boot\\\\BCD -set {Default} systemroot \\\\windows\" % espLetter,\n                \"BCDEDIT -store %s:\\\\EFI\\\\Microsoft\\\\Boot\\\\BCD -set {Default} winpe yes\" % espLetter,\n                \"BCDEDIT -store %s:\\\\EFI\\\\Microsoft\\\\Boot\\\\BCD -set {Default} nx optin\" % espLetter,\n                \"BCDEDIT -store %s:\\\\EFI\\\\Microsoft\\\\Boot\\\\BCD -set {Default} detecthal yes\" % espLetter,\n                \"BCDEDIT -store %s:\\\\EFI\\\\Microsoft\\\\Boot\\\\BCD -displayorder {Default} -addfirst\" % espLetter,\n\n                \"BCDEDIT -store %s:\\\\EFI\\\\Microsoft\\\\Boot\\\\BCD -set {ramdiskoptions} ramdisksdidevice partition=%s:\" % (\n                    espLetter, systemDriveLetter),\n                \"BCDEDIT -store %s:\\\\EFI\\\\Microsoft\\\\Boot\\\\BCD -set {ramdiskoptions} ramdisksdipath \\\\sources\\\\boot.sdi\" % espLetter,\n\n                \"BCDEDIT /import %s:\\\\EFI\\\\Microsoft\\\\Boot\\\\BCD /clean\" % espLetter,\n                \"BCDEDIT /set {fwbootmgr} displayorder {bootmgr} /addfirst\",\n    )\n    for command in commands:\n        process.runIt(command, log=log, quiet=True, shell=True)\n\n\n@HandleShowErrorMessage(\"Deploy WinPE on localdisk\")\ndef main():\n    opt, remainingArgs = DeployWinpeOptionsParser().parse_args()\n    winpeVersions = map(str.strip, opt.winpeVersion.split(\",\"))\n    if opt.bootMode:\n        bootMode = opt.bootMode\n    else:\n        bootMode = bootmode.getCurrentBootMode(ThisLocalServer(), log=LOG)\n    targetServer = ThisLocalServer()\n\n    netconfigParser = SmartNetconfig.readwrite(StringIO(HPSA_NETCONFIG),\n                                               activeMacAddress=None,\n                                               ipv6default=targetServer.isIPv6Managed(),\n                                               log=LOG)\n    netconfig = netconfigParser.info()\n    if netconfig.oldSyntax and not opt.disableWarning:\n        newFormat = netconfigParser.format()\n        print OLD_SYNTAX_WARNING + \"\\n%s\" % str(newFormat)\n\n    typosList = netconfigParser.getTyposList()\n    if typosList:\n        print(\"The following keys were not recognized in the netconfig CA and could be typos: %s\" % typosList)\n\n    correctWinPE, isoName = winpe.haveValidWinPE(targetServer, winpeVersions, log=LOG)\n\n    downloadIso(targetServer, isoName, opt.systemDrive)\n    unpackIso(opt.systemDrive)\n\n    # if static provisioning -> drop hpsa_response_file.txt file\n    storeStaticNetworkInfo(targetServer, opt.systemDrive)\n\n    # set bootloader\n    if bootMode == ServerBootMode.LEGACY:\n        process.runIt(\"bootsect.exe /nt60 %s: /force /mbr\" % opt.systemDrive, quiet=True, checkExitCode=(0,), log=LOG)\n        return\n    if bootMode == ServerBootMode.UEFI:\n        espLetter = assignDriveLetterToESP(opt.systemDiskNumber, opt.espLabel, log=LOG)\n        setUefiBootloader(opt.systemDrive, espLetter, log=LOG)\n        return\n    raise InvalidArgumentsError(\"Invalid bootmode detected: %s\" % str(bootMode))\n\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n",
            "description": "This script is used to deploy a WinPE ServiceOS on localdisk which will be booted later.\nMust NOT be part of a build plan. This step is called by step named 'Install and\nboot into local WinPE'\n\nUsage: deploy_winpe_on_localdisk.py [options]\n\nOptions:\n-h, --help : show this help message and exit\n--systemDiskNumber : system disk number where Windows is installed (default disk number is '0')\n--systemDrive : system drive letter where WinPE will be copied\n--espLabel : Efi System Partition label (default value is 'ESP')\n--winpeVersion : WinPE version which will be downloaded (default value is 'any')\n--bootMode : boot mode of the server, can be UEFI or Legacy\n--disableWarning : Do not show warnings of old hpsa_netconfig format\n\nPrerequisites:\n- Target server runs a maintenance Windows PE OS.",
            "status": null,
            "name": "Deploy WinPE on Localdisk",
            "state": null,
            "eTag": "2015-08-04T07:30:09.000Z",
            "modified": "2015-08-04T07:30:09.000Z",
            "created": "2015-06-13T04:48:43.000Z",
            "category": "os-deployment-server-scripts",
            "uri": "/rest/os-deployment-server-scripts/410001"
        },
        {
            "runAsSuperUser": true,
            "serverChanging": true,
            "codeType": "PY2",
            "displayCodeType": "Python",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "1",
                    "createdBy": "opsware",
                    "createdDate": "2015-06-13T04:48:44.000Z",
                    "usage": "This program will package the production agent for the specific machine it's running\non into a new IPS repository and injects installation instructions into the AI manifest.\n\nUsage: integrate_11_hpsa_agent.py\n\nThis script expects no command line arguments.\n\nPrerequisites:\n\n- This script must be run as part of a Build Plan under a Solaris Service OS\n- This script must be run after 'Deploy Agent'\n- This script must be run before 'Modify Boot Archive'",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-06-13T04:48:44.000Z",
            "version": {
                "versionLabel": "1",
                "createdBy": "opsware",
                "createdDate": "2015-06-13T04:48:44.000Z",
                "usage": "This program will package the production agent for the specific machine it's running\non into a new IPS repository and injects installation instructions into the AI manifest.\n\nUsage: integrate_11_hpsa_agent.py\n\nThis script expects no command line arguments.\n\nPrerequisites:\n\n- This script must be run as part of a Build Plan under a Solaris Service OS\n- This script must be run after 'Deploy Agent'\n- This script must be run before 'Modify Boot Archive'",
                "current": true
            },
            "source": "#!/opt/opsware/agent/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n\"\"\"\n    (C) Copyright 2013-2015 Hewlett-Packard Development Company, L.P.\n\n    This program will create an IPS package containing the HPSA Agent and installer\n    and inject it into the AI manifest to be installed along with the rest of the system.\n\"\"\"\n\nimport os\nimport sys\nimport shutil\nimport tarfile\nimport tempfile\n\nfrom osprov import helpers\nfrom osprov.util import process\nfrom osprov.profile import AIManifest\nfrom osprov.errors import ShowErrorMessage\nfrom osprov.decorators import HandleShowErrorMessage\nfrom osprov.server.local import ThisLocalServer, LocalServer\nfrom osprov.osbp import logger\n\nLOG = logger.getIt(\"Integrate Solaris 11 HPSA Agent\")\n\nSERVICE_MANIFEST_CONTENT = \"\"\"<?xml version=\"1.0\"?>\n<!DOCTYPE service_bundle SYSTEM \"/usr/share/lib/xml/dtd/service_bundle.dtd.1\">\n<service_bundle type='manifest' name='hpsa-agent-installer:hpsa-agent-installer-svc'>\n\n<service\n    name='hpsa-agent-installer'\n    type='service'\n    version='1'>\n    <create_default_instance enabled='true' />\n    <single_instance />\n\n<!-- Run the script late in the startup sequence after first boot. -->\n<dependency name='multi-user' grouping='require_all' restart_on='none' type='service'>\n    <service_fmri value='svc:/milestone/multi-user:default' />\n</dependency>\n<!-- Depend on network being up -->\n<dependency name='network' grouping='require_all' restart_on='none' type='service'>\n    <service_fmri value='svc:/milestone/network:default' />\n</dependency>\n\n<exec_method\n    type='method'\n    name='start'\n    exec='/opt/hpsa/hpsa-agent-installer.sh'\n    timeout_seconds='900'>\n    <method_context>\n        <method_credential user='root'/>\n    </method_context>\n</exec_method>\n\n<exec_method\n    type='method'\n    name='stop'\n    exec=':true'\n    timeout_seconds='60'\n/>\n\n<property_group name='startd' type='framework'>\n    <propval name='duration' type='astring' value='transient' />\n</property_group>\n\n</service>\n</service_bundle>\n\"\"\"\n\nINSTALLER_SCRIPT_TEMPLATE = \"\"\"#!/bin/sh\nHPSA_INSTALL_LOG=/var/log/opsware/agent/install.log\nmkdir -p `dirname $HPSA_INSTALL_LOG`\n\necho \"Installing HPSA Agent\"\n\n# Redirect messages to the log\nexec >> $HPSA_INSTALL_LOG\nexec 2>> $HPSA_INSTALL_LOG\n\nHPSA_BIN=/opt/hpsa/hpsa-agent\n\n# Print diagnostic messages\necho \"START NETWORK DIAGNOSTIC INFO\"\ngw=`echo %(gwIpPort)s | cut -d':' -f1`\nport=`echo %(gwIpPort)s | cut -d':' -f2`\nifconfig -a\nroute -n\nfor i in `seq 20` ; do\n    python -c \"import socket; s = socket.socket(socket.AF_INET, socket.SOCK_STREAM); s.settimeout(10); s.connect(('$gw', $port)); print 'Gateway $gw listening on port $port'\"\n    if [ $? -eq 0 ] ; then break; fi\n    sleep $i\ndone\necho \"END NETWORK DIAGNOSTIC INFO\"\n\n# Copy mid and crypto\necho \"COPYING MID & CRYPTO\"\nmkdir -p /etc/opt/opsware/agent\nmkdir -p /var/opt/opsware/crypto\ncp -p /opt/hpsa/mid /etc/opt/opsware/agent/mid\ncat /etc/opt/opsware/agent/mid\n# Use GNU tar on Solaris\ngtar -xvf /opt/hpsa/crypto.tar -C /var/opt/opsware/crypto\nls /var/opt/opsware/crypto/agent/\n\n# Run the installer\n$HPSA_BIN -s --settime --force_full_hw_reg --force_sw_reg \\\\\n    --logfile $HPSA_INSTALL_LOG    \\\\\n    --opsw_gw_addr %(gwIpPort)s\nRC=$?\n\nif [ $RC -eq 0 ] ; then\n    echo \"Agent Installation successful\"\n    # self destruct\n    svcadm disable svc:/hpsa-agent-installer:default\n    pkg uninstall pkg:/hpsa-agent-installer\n    pkg unset-publisher hpsa\n    exit $SMF_EXIT_OK\nelse\n    #  The installer also logs here, so no extra message is needed\n    echo \"Agent Installation Failed\"\n    # Don't exit with an error because SMF will keep trying to rerun this service\n    exit $SMF_EXIT_OK\nfi\n\"\"\"\n\nPACKAGE_MANIFEST_CONTENTS = \"\"\"set name=pkg.fmri value=hpsa-agent-installer@1.0,5.11\nset name=pkg.summary value=\"HPSA Agent first-boot installer\"\nfile path=lib/svc/manifest/hpsa/hpsa-agent-installer.xml mode=0444 owner=root group=sys\ndir path=opt/hpsa mode=0755 owner=root group=sys\nfile path=opt/hpsa/hpsa-agent-installer.sh mode=0555 owner=root group=sys\nfile path=opt/hpsa/hpsa-agent mode=0555 owner=root group=sys\nfile path=opt/hpsa/mid mode=0644 owner=root group=sys\nfile path=opt/hpsa/crypto.tar mode=0644 owner=root group=sys\n\"\"\"\n\nHPSA_AGENT_PATH = \"/tmp/hpsa_agent_installer\"\nAGENT_INSTALLER_REPO_PATH = \"/tmp/hpsa-repo\"\nAI_XML_PATH = \"/tmp/ai.xml\"\n\n\nclass LocalIPSRepo(object):\n\n    \"\"\"A local Solaris 11 IPS repository directory structure\"\"\"\n\n    def __init__(self, workingDir, publisherName):\n\n        self.workdir = workingDir\n        self.repodir = os.path.join(self.workdir, \"repo\")\n        self.pubName = publisherName\n        self.env = dict(os.environ)\n        self.env[\"PYTHONPATH\"] = \"\"\n\n    def create(self):\n        helpers.makeDirs(self.workdir)\n        if os.path.exists(self.repodir):\n            shutil.rmtree(self.repodir)\n        process.runIt(\"pkgrepo create %s\" % self.repodir, log=LOG, env=self.env)\n        process.runIt(\"pkgrepo -s %s add-publisher %s\" % (self.repodir, self.pubName), log=LOG,\n                      env=self.env)\n\n    def publishPackage(self, manifestPath, protoPath):\n        process.runIt(\"pkgsend publish -d %s -s %s %s\" %\n                      (protoPath, self.repodir, manifestPath), log=LOG, env=self.env)\n\n\ndef packageAgent(tempDir):\n    \"\"\"Packages the agent into an IPS repo\"\"\"\n\n    helpers.makeDirs(os.path.join(tempDir, \"proto/opt/hpsa\"))\n    helpers.makeDirs(os.path.join(tempDir, \"proto/lib/svc/manifest/hpsa\"))\n\n    pkgManifestFilePath = os.path.join(tempDir, \"hpsa-agent-installer.p5m\")\n    pkgManifestFile = open(pkgManifestFilePath, \"w\")\n    pkgManifestFile.write(PACKAGE_MANIFEST_CONTENTS)\n    pkgManifestFile.flush()\n    pkgManifestFile.close()\n\n    svcManifestFile = open(\n        os.path.join(tempDir, \"proto/lib/svc/manifest/hpsa/hpsa-agent-installer.xml\"), \"w\")\n    svcManifestFile.write(SERVICE_MANIFEST_CONTENT)\n    svcManifestFile.flush()\n    svcManifestFile.close()\n\n    installerScriptFile = open(os.path.join(tempDir, \"proto/opt/hpsa/hpsa-agent-installer.sh\"), \"w\")\n    installerScript = INSTALLER_SCRIPT_TEMPLATE % {\n        \"gwIpPort\": ThisLocalServer().getRandomAgentGateway()\n    }\n    installerScriptFile.write(installerScript)\n    installerScriptFile.flush()\n    installerScriptFile.close()\n\n    shutil.copy2(HPSA_AGENT_PATH, os.path.join(tempDir, \"proto/opt/hpsa/hpsa-agent\"))\n\n    copyMidCrypto(tempDir)\n\n    repo = LocalIPSRepo(AGENT_INSTALLER_REPO_PATH, \"hpsa\")\n    repo.create()\n    repo.publishPackage(pkgManifestFilePath, os.path.join(tempDir, \"proto\"))\n\n\ndef injectAIRepo():\n    \"\"\"Injects the hpsa agent installer repository into the AI manifest\"\"\"\n\n    aiFile = open(AI_XML_PATH, \"r\")\n    aiManifest = AIManifest(aiFile)\n    aiManifest.addIPSPublisher(\"hpsa\", ([\"file:///hpsa/repo\"], []))\n    aiManifest.addIPSPackage(\"pkg:/hpsa-agent-installer@latest\")\n    aiManifest.save()\n    aiFile.close()\n\n\ndef copyMidCrypto(tempDir):\n    \"\"\"Copies mid and crypto to agent packaging directory\"\"\"\n\n    server = ThisLocalServer()\n    shutil.copy2(server.MID_FILE, os.path.join(tempDir, \"proto/opt/hpsa/mid\"))\n    cryptoTar = tarfile.open(os.path.join(tempDir, \"proto/opt/hpsa/crypto.tar\"), \"w\")\n    cryptoTar.add(server.CRYPTO_DIR, arcname=\"agent\")\n    cryptoTar.close()\n\n\n@HandleShowErrorMessage(\"Integrate Solaris 11 HPSA Agent\", LOG)\ndef main():\n    if not os.path.isfile(HPSA_AGENT_PATH):\n        raise ShowErrorMessage(\"HPSA Agent not found, have you run the 'Deploy Agent' step?\")\n    tempDir = tempfile.mkdtemp()\n    LOG.info(\"Temporary directory for agent packaging created at: %s\" % tempDir)\n    packageAgent(tempDir)\n    print \"Successfully packaged HPSA Agent...\"\n    shutil.rmtree(tempDir)\n    injectAIRepo()\n    print \"Successfully integrated HPSA Agent with IPS Install...\"\n\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n",
            "description": "This program will package the production agent for the specific machine it's running\non into a new IPS repository and injects installation instructions into the AI manifest.\n\nUsage: integrate_11_hpsa_agent.py\n\nThis script expects no command line arguments.\n\nPrerequisites:\n\n- This script must be run as part of a Build Plan under a Solaris Service OS\n- This script must be run after 'Deploy Agent'\n- This script must be run before 'Modify Boot Archive'",
            "status": null,
            "name": "Integrate Solaris 11 HP SA Agent",
            "state": null,
            "eTag": "2015-06-13T04:48:44.000Z",
            "modified": "2015-06-13T04:48:44.000Z",
            "created": "2015-06-13T04:48:44.000Z",
            "category": "os-deployment-server-scripts",
            "uri": "/rest/os-deployment-server-scripts/450001"
        },
        {
            "runAsSuperUser": true,
            "serverChanging": true,
            "codeType": "PY2",
            "displayCodeType": "Python",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "1",
                    "createdBy": "opsware",
                    "createdDate": "2015-06-13T04:48:45.000Z",
                    "usage": "This script is used to capture a Windows installation to a .WIM image file using ImageX tool.\n\nUsage: windows_image_capture.py [options]\n\nOptions:\n-h, --help : show this help message and exit\n--bootMode=BOOTMODE : boot mode of the server, can be UEFI or Legacy (boot mode is autodetected if this parameter is not passed).\n--systemDiskNumber=SYSTEMDISKNUMBER : system disk number where Windows is installed (default disk number is '0').\n--systemPartitionLabel=SYSTEMPARTITIONLABEL : label of partition where Windows is installed (default partition label is 'System').\n--wimFilePath=WIMFILEPATH : path where to save WIM file (Currently using CA 'WimFileName' to provide WIM file name).\n--wimScript=WIMSCRIPT : path to ImageX config file.\n\nExample: windows_image_capture.py --wimFilePath=\"Z:\\@WimFileName@\" --wimScript=wimscript.ini [--bootMode=UEFI] [--systemDiskNumber=0] [--systemPartitionLabel=System]\n\nFor more details please consult:\nhttp://technet.microsoft.com/en-us/library/cc722145(v=ws.10)\nhttp://technet.microsoft.com/en-us/library/cc749447(v=ws.10)\n\nPrerequisites:\n- Target server runs a maintenance Windows PE OS.\n- Must be run as part of a build plan.\n- Must be run after 'Set Media Source' and after \"Validate ImageX Package Contents\" steps.",
                    "current": false
                },
                {
                    "versionLabel": "2",
                    "createdBy": "opsware",
                    "createdDate": "2015-08-04T07:29:45.000Z",
                    "usage": "This script is used to capture a Windows installation to a .WIM image file using ImageX tool.\n\nUsage: windows_image_capture.py [options]\n\nOptions:\n-h, --help : show this help message and exit\n--bootMode=BOOTMODE : boot mode of the server, can be UEFI or Legacy (boot mode is autodetected if this parameter is not passed).\n--systemDiskNumber=SYSTEMDISKNUMBER : system disk number where Windows is installed (default disk number is '0').\n--systemPartitionLabel=SYSTEMPARTITIONLABEL : label of partition where Windows is installed (default partition label is 'System').\n--wimFilePath=WIMFILEPATH : path where to save WIM file (Currently using CA 'WimFileName' to provide WIM file name).\n--wimScript=WIMSCRIPT : path to ImageX config file.\n\nExample: windows_image_capture.py --wimFilePath=\"Z:\\@WimFileName@\" --wimScript=wimscript.ini [--bootMode=UEFI] [--systemDiskNumber=0] [--systemPartitionLabel=System]\n\nFor more details please consult:\nhttp://technet.microsoft.com/en-us/library/cc722145(v=ws.10)\nhttp://technet.microsoft.com/en-us/library/cc749447(v=ws.10)\n\nPrerequisites:\n- Target server runs a maintenance Windows PE OS.\n- Must be run as part of a build plan.\n- Must be run after 'Set Media Source' and after \"Validate ImageX Package Contents\" steps.",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-08-04T07:29:45.000Z",
            "version": {
                "versionLabel": "2",
                "createdBy": "opsware",
                "createdDate": "2015-08-04T07:29:45.000Z",
                "usage": "This script is used to capture a Windows installation to a .WIM image file using ImageX tool.\n\nUsage: windows_image_capture.py [options]\n\nOptions:\n-h, --help : show this help message and exit\n--bootMode=BOOTMODE : boot mode of the server, can be UEFI or Legacy (boot mode is autodetected if this parameter is not passed).\n--systemDiskNumber=SYSTEMDISKNUMBER : system disk number where Windows is installed (default disk number is '0').\n--systemPartitionLabel=SYSTEMPARTITIONLABEL : label of partition where Windows is installed (default partition label is 'System').\n--wimFilePath=WIMFILEPATH : path where to save WIM file (Currently using CA 'WimFileName' to provide WIM file name).\n--wimScript=WIMSCRIPT : path to ImageX config file.\n\nExample: windows_image_capture.py --wimFilePath=\"Z:\\@WimFileName@\" --wimScript=wimscript.ini [--bootMode=UEFI] [--systemDiskNumber=0] [--systemPartitionLabel=System]\n\nFor more details please consult:\nhttp://technet.microsoft.com/en-us/library/cc722145(v=ws.10)\nhttp://technet.microsoft.com/en-us/library/cc749447(v=ws.10)\n\nPrerequisites:\n- Target server runs a maintenance Windows PE OS.\n- Must be run as part of a build plan.\n- Must be run after 'Set Media Source' and after \"Validate ImageX Package Contents\" steps.",
                "current": true
            },
            "source": "#!/usr/bin/python\r\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\r\n# ex: set tabstop=4 :\r\n# Please do not change the two lines above. See PEP 8, PEP 263.\r\n\"\"\"\r\n    (C) Copyright 2013-2015 Hewlett-Packard Development Company, L.P.\r\n\"\"\"\r\n\r\nimport sys\r\nimport os\r\nfrom optparse import OptionError\r\nfrom osprov.optparse_ext import OptionParser\r\nfrom osprov.scripts import bootmode\r\nfrom osprov.osbp import logger\r\nfrom osprov.util import process\r\nfrom osprov.decorators import HandleShowErrorMessage\r\nfrom osprov import diskmgr\r\nfrom osprov.diskmgr import const, disk, diskmanager, partition\r\nfrom osprov.server.local import ThisLocalServer\r\nfrom osprov.errors import ProcessExecutionError\r\nfrom tempfile import mkstemp\r\n\r\nLOG = logger.getIt(\"windows_image_capture\")\r\n\r\nIMAGEX_CONFIG_FILE = \"\"\"\r\n[ExclusionList]\r\n\"\\\\Boot\"\r\n\"\\\\Program Files\\\\Opsware\"\r\n\"\\\\Program Files\\\\Common Files\\\\Opsware\"\r\n\"\"\"\r\n\r\n\r\nclass WindowsImageCaptureOptionParser(OptionParser):\r\n\r\n    \"\"\" Option parser for this step \"\"\"\r\n\r\n    def defineOptions(self):\r\n        self.add_option(\"--bootMode\", type=\"string\",\r\n                        help=\"boot mode of the server, can be UEFI or Legacy (boot mode is autodetected if this parameter is not passed).\")\r\n        self.add_option(\"--systemDiskNumber\", type=\"int\", default=0,\r\n                        help=\"system disk number where Windows is installed (default disk number is '0').\")\r\n        self.add_option(\"--systemPartitionLabel\", type=\"string\", default=\"System\",\r\n                        help=\"label of partition where Windows is installed (default partition label is 'System').\")\r\n        self.add_option(\"--wimFilePath\", type=\"string\",\r\n                        help=\"path where to save WIM file (Currently using CA 'WimFileName' to provide WIM file name).\")\r\n        self.add_option(\"--wimScript\", type=\"string\",\r\n                        help=\"path to ImageX config file.\")\r\n\r\n    def validateArgs(self, opt, args):\r\n        if opt.bootMode and not bootmode.isBootModeSupported(opt.bootMode):\r\n            raise OptionError(\"Invalid boot mode: \" + opt.bootMode, \"bootMode\")\r\n        if not opt.wimFilePath:\r\n            raise OptionError(\"Missing parameter: --wimFilePath\", \"wimFilePath\")\r\n\r\n\r\ndef captureESP(freeLetter, wimFilePath, log=LOG):\r\n    process.runIt(\"imagex.exe /check /verify /capture %s: \\\"%s_ESP\\\" \\\"ESP\\\"\" %\r\n                  (freeLetter, wimFilePath), checkExitCode=(0,), log=log)\r\n\r\n\r\ndef capturePartition(windowsDriveLetter, wimFilePath, configFilePath=None, log=LOG):\r\n    if not configFilePath:\r\n        fd, configFilePath = mkstemp()\r\n        with os.fdopen(fd, 'w') as f:\r\n            f.write(IMAGEX_CONFIG_FILE)\r\n\r\n    try:\r\n        stdout, stderr = process.getStdoutStderr(\"imagex.exe /config %s /check /verify /capture %s: \\\"%s\\\" \\\"System\\\"\" %\r\n                               (configFilePath, windowsDriveLetter, wimFilePath), checkExitCode=(0,), log=log)\r\n        for line in stdout.split(\"\\n\"):\r\n            if \"successfully imaged\" in line.lower():\r\n                print line\r\n    except ProcessExecutionError, why:\r\n        print \"Failed to capture windows image\"\r\n        print \"Standard output of imagex command:\"\r\n        print why.stdout\r\n        print \"Standard error of imagex command:\"\r\n        print why.stderr\r\n        raise why\r\n\r\n@HandleShowErrorMessage(\"Windows Image Capture\", LOG)\r\ndef main():\r\n\r\n    # get and parse arguments\r\n    options, remainingArgs = WindowsImageCaptureOptionParser().parse_args()\r\n    wimFilePath = options.wimFilePath.strip()\r\n    systemDiskNumber = options.systemDiskNumber\r\n    # get bootmode (legacy bios or uefi)\r\n    if options.bootMode:\r\n        bootMode = options.bootMode\r\n    else:\r\n        bootMode = bootmode.getCurrentBootMode(ThisLocalServer(), log=LOG)\r\n\r\n    windowsDriveLetter = disk.WindowsDisk(systemDiskNumber).getPartitionWithLabel(\r\n        options.systemPartitionLabel).letter\r\n\r\n    partitionTable = diskmgr.getPartitionTable(bootMode)\r\n    if const.PARTITION_TABLE_MBR == partitionTable:\r\n        print \"Capturing Windows Image based on Legacy Windows Partitioning Schema\"\r\n        capturePartition(windowsDriveLetter, wimFilePath, configFilePath=options.wimScript)\r\n    elif const.PARTITION_TABLE_GPT == partitionTable:\r\n        print \"Capturing Windows Image based on Uefi Windows Partitioning Schema\"\r\n        freeLetter = diskmanager.WindowsDiskManager().findFirstAvailableDriveLetter()\r\n        partition.WindowsPartition(systemDiskNumber, 1).setPartitionLetter(freeLetter)\r\n        captureESP(freeLetter, wimFilePath)\r\n        capturePartition(windowsDriveLetter, wimFilePath, configFilePath=options.wimScript)\r\n\r\nif __name__ == \"__main__\":\r\n    sys.exit(main())\r\n",
            "description": "This script is used to capture a Windows installation to a .WIM image file using ImageX tool.\n\nUsage: windows_image_capture.py [options]\n\nOptions:\n-h, --help : show this help message and exit\n--bootMode=BOOTMODE : boot mode of the server, can be UEFI or Legacy (boot mode is autodetected if this parameter is not passed).\n--systemDiskNumber=SYSTEMDISKNUMBER : system disk number where Windows is installed (default disk number is '0').\n--systemPartitionLabel=SYSTEMPARTITIONLABEL : label of partition where Windows is installed (default partition label is 'System').\n--wimFilePath=WIMFILEPATH : path where to save WIM file (Currently using CA 'WimFileName' to provide WIM file name).\n--wimScript=WIMSCRIPT : path to ImageX config file.\n\nExample: windows_image_capture.py --wimFilePath=\"Z:\\@WimFileName@\" --wimScript=wimscript.ini [--bootMode=UEFI] [--systemDiskNumber=0] [--systemPartitionLabel=System]\n\nFor more details please consult:\nhttp://technet.microsoft.com/en-us/library/cc722145(v=ws.10)\nhttp://technet.microsoft.com/en-us/library/cc749447(v=ws.10)\n\nPrerequisites:\n- Target server runs a maintenance Windows PE OS.\n- Must be run as part of a build plan.\n- Must be run after 'Set Media Source' and after \"Validate ImageX Package Contents\" steps.",
            "status": null,
            "name": "Windows Image Capture",
            "state": null,
            "eTag": "2015-08-04T07:29:45.000Z",
            "modified": "2015-08-04T07:29:45.000Z",
            "created": "2015-06-13T04:48:45.000Z",
            "category": "os-deployment-server-scripts",
            "uri": "/rest/os-deployment-server-scripts/460001"
        },
        {
            "runAsSuperUser": false,
            "serverChanging": true,
            "codeType": "BAT",
            "displayCodeType": "Windows .BAT",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "1",
                    "createdBy": "opsware",
                    "createdDate": "2015-06-13T04:48:46.000Z",
                    "usage": "Adds the Hyper-V Role to the Windows Installation. After the role is added the machine is rebooted to re-configure the system.",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-06-13T04:48:46.000Z",
            "version": {
                "versionLabel": "1",
                "createdBy": "opsware",
                "createdDate": "2015-06-13T04:48:46.000Z",
                "usage": "Adds the Hyper-V Role to the Windows Installation. After the role is added the machine is rebooted to re-configure the system.",
                "current": true
            },
            "source": "@echo off\n\n:: (c) Copyright 2013 Hewlett-Packard Development Company, L.P.\n\nset wdir=%windir%\nset FEATURE=Hyper-V\nset RESULTFILE=\"%wdir%\\HVInstallResult.xml\"\n\n:: Try PowerShell if exists\nfor %%X in (powershell.exe) do (set FOUND1=%%~$PATH:X)\nif defined FOUND1 (\n   echo Import-module servermanager > \"%wdir%\\FeatureInstall.ps1\"\n   echo add-windowsfeature -Name %FEATURE% -logPath %RESULTFILE% >> \"%wdir%\\FeatureInstall.ps1\"\n   powershell.exe -ExecutionPolicy Unrestricted -NoLogo -NonInteractive -NoProfile -WindowStyle Hidden -File \"%wdir%\\FeatureInstall.ps1\"\n   set rc=%errorlevel%\n   goto EndWithFailureMessage\n)\n\n:: Try ServerManagerCmd if exists and PowerShell wasn't found\nfor %%X in (ServerManagerCmd.exe) do (set FOUND2=%%~$PATH:X)\nif defined FOUND2 (\n   ServerManagerCmd.exe -install %FEATURE% -resultPath %RESULTFILE%\n   set rc=%errorlevel%\n   goto EndWithFailureMessage\n) \n\nif NOT defined rc (\n   echo PowerShell and ServerManagerCmd were not found and could not set %FEATURE%\n   set rc=999\n   goto End\n)\n\n:EndWithFailureMessage\nif NOT %rc%==0 (\n   echo PowerShell and ServerManagerCmd Add Windows Feature failed to install %FEATURE%:  error code %rc%\n   echo Refer to %RESULTFILE% log file.\n)\n\n:End\nexit /B %rc%",
            "description": "Adds the Hyper-V Role to the Windows Installation. After the role is added the machine is rebooted to re-configure the system.",
            "status": null,
            "name": "Add Hyper-V Role",
            "state": null,
            "eTag": "2015-06-13T04:48:46.000Z",
            "modified": "2015-06-13T04:48:46.000Z",
            "created": "2015-06-13T04:48:46.000Z",
            "category": "os-deployment-server-scripts",
            "uri": "/rest/os-deployment-server-scripts/480001"
        },
        {
            "runAsSuperUser": true,
            "serverChanging": true,
            "codeType": "PY2",
            "displayCodeType": "Python",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "1",
                    "createdBy": "opsware",
                    "createdDate": "2015-06-13T04:48:47.000Z",
                    "usage": "Usage: Check For Windows Service [options]\n\nChecks that the target server has the specified service up and running.\n\nOptions:\n  -h, --help            show this help message and exit\n  -t MINUTES, --atMost=MINUTES\n                        Wait at most this many minutes before timing out.\n                        Default 10.\n  -s SERVICE, --service=SERVICE\n                        The service name you want to wait for to be up and\n                        running\n\nPrerequisites:\n- Script needs to run as part of a build plan on a Windows target OS.",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-06-13T04:48:47.000Z",
            "version": {
                "versionLabel": "1",
                "createdBy": "opsware",
                "createdDate": "2015-06-13T04:48:47.000Z",
                "usage": "Usage: Check For Windows Service [options]\n\nChecks that the target server has the specified service up and running.\n\nOptions:\n  -h, --help            show this help message and exit\n  -t MINUTES, --atMost=MINUTES\n                        Wait at most this many minutes before timing out.\n                        Default 10.\n  -s SERVICE, --service=SERVICE\n                        The service name you want to wait for to be up and\n                        running\n\nPrerequisites:\n- Script needs to run as part of a build plan on a Windows target OS.",
                "current": true
            },
            "source": "#!/usr/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n\"\"\" \n    (C) Copyright 2012-2015 Hewlett-Packard Development Company, L.P.\n\n    Check and wait for a Windows Service\n\"\"\"\nimport sys\n\nfrom osprov.errors import TimeoutError\nfrom osprov.util import process\nfrom osprov.osbp import logger\nfrom osprov.patterns.scanner import TimeoutScanner, StopScan\nfrom osprov.optparse_ext import OptionParser, OptionValueError\nfrom osprov.decorators import HandleShowErrorMessage\n\nLOG = logger.getIt(\"check Windows Service\")\n\n\nclass CheckForWindowsServiceOptparser(OptionParser):\n\n    \"\"\" Custom option parser \"\"\"\n\n    def defineOptions(self):\n        self.prog = \"Check For Windows Service\"\n        self.description = \"Checks that the target server has the specified service up and running.\"\n        self.set_usage(\"%s [options]\" % self.prog)\n        self.add_option(\"-t\", \"--atMost\", type=\"int\", default=\"10\", metavar=\"MINUTES\",\n                        help=\"Wait at most this many minutes before timing out. Default %default.\"\n                        )\n        self.add_option(\"-s\", \"--service\", type=\"string\",\n                        help=\"The service name you want to wait for to be up and running\")\n\n    def validateArgs(self, opt, args):\n        if opt.atMost < 1:\n            raise OptionValueError(\"MINUTES should be more than 1.\")\n        if not opt.service or opt.service == \"\":\n            raise OptionValueError(\"You must specify a service name\")\n\n\nclass CheckForWindowsServiceScanner(TimeoutScanner):\n\n    \"\"\" Custom scanner for a Windows service \"\"\"\n\n    def __init__(self, service, *args, **kwargs):\n        super(CheckForWindowsServiceScanner, self).__init__(*args, **kwargs)\n        self.service = service\n\n    def shortcut(self):\n        self.scan()\n\n    def scan(self):\n        self.log.debug(\"Scanning for Windows Service %s\" % self.service)\n        stdout = process.getStdout('tasklist /fi \"Services eq %s\"' % self.service, checkExitCode=(0,), log=self.log)\n        if \"PID\" in stdout:\n            print \"%s service is up and running.\" % self.service\n            raise StopScan()\n        else:\n            self.log.debug(stdout)\n\n\n@HandleShowErrorMessage(\"check Windows Service\", LOG)\ndef main():\n    opt, args = CheckForWindowsServiceOptparser().parse_args()\n    if args:\n        print \"Warning, unneeded arguments will be ignored: %s\" % (\" \".join(args))\n    scanner = CheckForWindowsServiceScanner(\n        timeoutMin=opt.atMost,\n        waitUpfrontMin=1,\n        log=LOG,\n        service=opt.service\n    )\n    try:\n        scanner()\n    except TimeoutError, why:\n        LOG.exception(why)\n        print \"Error: The Windows Service %s did not start after %d minutes.\" % (opt.service, opt.atMost)\n        LOG.error(\"Error: The Windows Service %s did not start after %d minutes.\" % (opt.service, opt.atMost))\n        return 11\n\n\nif __name__ == \"__main__\":\n    sys.exit(main())",
            "description": "Usage: Check For Windows Service [options]\n\nChecks that the target server has the specified service up and running.\n\nOptions:\n  -h, --help            show this help message and exit\n  -t MINUTES, --atMost=MINUTES\n                        Wait at most this many minutes before timing out.\n                        Default 10.\n  -s SERVICE, --service=SERVICE\n                        The service name you want to wait for to be up and\n                        running\n\nPrerequisites:\n- Script needs to run as part of a build plan on a Windows target OS.",
            "status": null,
            "name": "Check for Windows Service",
            "state": null,
            "eTag": "2015-06-13T04:48:47.000Z",
            "modified": "2015-06-13T04:48:47.000Z",
            "created": "2015-06-13T04:48:47.000Z",
            "category": "os-deployment-server-scripts",
            "uri": "/rest/os-deployment-server-scripts/500001"
        },
        {
            "runAsSuperUser": true,
            "serverChanging": true,
            "codeType": "BAT",
            "displayCodeType": "Windows .BAT",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "1",
                    "createdBy": "opsware",
                    "createdDate": "2015-06-13T04:48:47.000Z",
                    "usage": "Installs Windows 7 x64 from OS Media. Requires full path to setup.exe from the installation media.",
                    "current": false
                },
                {
                    "versionLabel": "2",
                    "createdBy": "opsware",
                    "createdDate": "2015-08-04T07:29:42.000Z",
                    "usage": "Installs Windows 7 x64 from OS Media. Requires full path to setup.exe from the installation media.",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-08-04T07:29:42.000Z",
            "version": {
                "versionLabel": "2",
                "createdBy": "opsware",
                "createdDate": "2015-08-04T07:29:42.000Z",
                "usage": "Installs Windows 7 x64 from OS Media. Requires full path to setup.exe from the installation media.",
                "current": true
            },
            "source": "@echo off\nsetlocal\nset SIG=WINPE64\nset ANSWER=X:\\Windows\\Temp\\Unattend.xml\nset ARGS=/noreboot /unattend:%ANSWER%\nset | find \"opswbasig=%SIG%\" > NUL\nif %ERRORLEVEL% NEQ 0 (\n    echo ERROR: Target server must be running %SIG% but it is not\n    exit /B 1\n)\nif X%1==X (\n    set SETUP=z:\\i386\\winnt32.exe\n) else (\n    set SETUP=%1\n)\nif not exist %SETUP% (\n    echo %SETUP% missing! Cannot install Windows.\n    exit /B 2\n)\nif not exist %ANSWER% (\n    echo %ANSWER% missing! Cannot install Windows.\n    exit /B 3\n)\n\n%SETUP% %ARGS%\n\nif %ERRORLEVEL% == 0 (\n    echo Windows setup completed successfully\n    exit\n) else (\n    echo ERROR: Windows setup exited status %ERRORLEVEL%\n    exit /B %ERRORLEVEL%\n)\n",
            "description": "Installs Windows 7 x64 from OS Media. Requires full path to setup.exe from the installation media.",
            "status": null,
            "name": "Run Windows 7 x64 Setup",
            "state": null,
            "eTag": "2015-08-04T07:29:42.000Z",
            "modified": "2015-08-04T07:29:42.000Z",
            "created": "2015-06-13T04:48:47.000Z",
            "category": "os-deployment-server-scripts",
            "uri": "/rest/os-deployment-server-scripts/510001"
        },
        {
            "runAsSuperUser": true,
            "serverChanging": true,
            "codeType": "BAT",
            "displayCodeType": "Windows .BAT",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "1",
                    "createdBy": "opsware",
                    "createdDate": "2015-06-13T04:48:48.000Z",
                    "usage": "Installs Windows 2012 x64 from OS Media. Requires full path to  setup.exe from the installation media.",
                    "current": false
                },
                {
                    "versionLabel": "2",
                    "createdBy": "opsware",
                    "createdDate": "2015-08-04T07:30:12.000Z",
                    "usage": "Installs Windows 2012 x64 from OS Media. Requires full path to  setup.exe from the installation media.",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-08-04T07:30:12.000Z",
            "version": {
                "versionLabel": "2",
                "createdBy": "opsware",
                "createdDate": "2015-08-04T07:30:12.000Z",
                "usage": "Installs Windows 2012 x64 from OS Media. Requires full path to  setup.exe from the installation media.",
                "current": true
            },
            "source": "@echo off\nsetlocal\nset SIG=WINPE64\nset ANSWER=X:\\Windows\\Temp\\Unattend.xml\nset ARGS=/noreboot /unattend:%ANSWER%\nset | find \"opswbasig=%SIG%\" > NUL\nif %ERRORLEVEL% NEQ 0 (\n    echo ERROR: Target server must be running %SIG% but it is not\n    exit /B 1\n)\nif X%1==X (\n    set SETUP=z:\\i386\\winnt32.exe\n) else (\n    set SETUP=%1\n)\nif not exist %SETUP% (\n    echo %SETUP% missing! Cannot install Windows.\n    exit /B 2\n)\nif not exist %ANSWER% (\n    echo %ANSWER% missing! Cannot install Windows.\n    exit /B 3\n)\n\n%SETUP% %ARGS%\n\nif %ERRORLEVEL% == 0 (\n    echo Windows setup completed successfully\n    exit\n) else (\n    echo ERROR: Windows setup exited status %ERRORLEVEL%\n    exit /B %ERRORLEVEL%\n)\n",
            "description": "Installs Windows 2012 x64 from OS Media. Requires full path to  setup.exe from the installation media.",
            "status": null,
            "name": "Run Windows 2012 x64 Setup",
            "state": null,
            "eTag": "2015-08-04T07:30:12.000Z",
            "modified": "2015-08-04T07:30:12.000Z",
            "created": "2015-06-13T04:48:48.000Z",
            "category": "os-deployment-server-scripts",
            "uri": "/rest/os-deployment-server-scripts/540001"
        },
        {
            "runAsSuperUser": true,
            "serverChanging": false,
            "codeType": "PY2",
            "displayCodeType": "Python",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "1",
                    "createdBy": "opsware",
                    "createdDate": "2015-06-13T04:48:49.000Z",
                    "usage": "Embed an agent zip file into the kickstart profile along with a prescript to extract and start it.\n\nUsage: [agent_path]\n  agent_path\n    The local path to the agent zip file.\n\nPrerequisites:\n- Target server runs a Linux Service OS.\n- OS to be provisioned is at least RHEL 6\n\nThis script is intended to be used only as a Build Plan step.",
                    "current": false
                },
                {
                    "versionLabel": "2",
                    "createdBy": "opsware",
                    "createdDate": "2015-08-04T07:29:57.000Z",
                    "usage": "Embed an agent zip file into the kickstart profile along with a prescript to extract and start it.\n\nUsage: [agent_path]\n  agent_path\n    The local path to the agent zip file.\n\nPrerequisites:\n- Target server runs a Linux Service OS.\n- OS to be provisioned is at least RHEL 6\n\nThis script is intended to be used only as a Build Plan step.",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-08-04T07:29:57.000Z",
            "version": {
                "versionLabel": "2",
                "createdBy": "opsware",
                "createdDate": "2015-08-04T07:29:57.000Z",
                "usage": "Embed an agent zip file into the kickstart profile along with a prescript to extract and start it.\n\nUsage: [agent_path]\n  agent_path\n    The local path to the agent zip file.\n\nPrerequisites:\n- Target server runs a Linux Service OS.\n- OS to be provisioned is at least RHEL 6\n\nThis script is intended to be used only as a Build Plan step.",
                "current": true
            },
            "source": "#!/opt/opsware/agent/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n\"\"\"\n    (C) Copyright 2014-2015 Hewlett-Packard Development Company, L.P.\n\"\"\"\n\nimport sys\nimport argparse\n\nfrom osprov.profile import kickstart\nfrom osprov.server.local import ThisLocalServer\nfrom osprov.decorators import HandleShowErrorMessage\n\n\nCODE_HEADER = '###  CODE BY HPSA ###'\nDEFAULT_KS_PATH = '/tmp/user.ks.cfg'\n\n\nEXTRACT_SCRIPT = '''#!/usr/bin/env python\nimport sys\nimport zipfile\nfrom cStringIO import StringIO\n\nzipfile.ZipFile(StringIO(sys.stdin.read())).extractall(sys.argv[1])\n'''\n\n\ndef cateof(script, path):\n    return 'cat > {path!s} <<EOF\\n{script!s}\\nEOF\\n'.format(script=script, path=path)\n\n\ndef get_prescript(server):\n    agwIpPort = server.getRandomAgentGateway()\n    flags = {'mount': False, 'async': True, 'quiet': True}\n    startup_script = server.getOgfsAgentStartupScript(agwIpPort, flags=flags)\n    scripts = [CODE_HEADER]\n    scripts.append(cateof(kickstart.DEBLOB_SCRIPT, '/tmp/deblob.py'))\n    scripts.append(cateof(EXTRACT_SCRIPT, '/tmp/extract.py'))\n    scripts.append('cat /user.ks.cfg | python /tmp/deblob.py | python /tmp/extract.py /opt/opsware/agent')\n    scripts.append(startup_script)\n    return '\\n'.join(scripts)\n\n\n@HandleShowErrorMessage('embed agent kickstart')\ndef main():\n    parser = argparse.ArgumentParser()\n    parser.add_argument('agent_path', help='The local path to the agent zip file')\n    args = parser.parse_args()\n\n    ksobj = kickstart.Kickstart(open(DEFAULT_KS_PATH, 'r'), endtags=True)\n    ksobj.blob = open(args.agent_path, 'rb').read()\n    prescript = kickstart.Script('pre --erroronfail', endtag=True)\n    prescript.contents.extend(get_prescript(ThisLocalServer()).splitlines())\n    ksobj.scripts.append(prescript)\n\n    with open(DEFAULT_KS_PATH, 'w') as ksfile:\n        ksfile.write(str(ksobj))\n\n\nif __name__ == '__main__':\n    sys.exit(main())\n",
            "description": "Embed an agent zip file into the kickstart profile along with a prescript to extract and start it.\n\nUsage: [agent_path]\n  agent_path\n    The local path to the agent zip file.\n\nPrerequisites:\n- Target server runs a Linux Service OS.\n- OS to be provisioned is at least RHEL 6\n\nThis script is intended to be used only as a Build Plan step.",
            "status": null,
            "name": "Embed Monitoring SA Agent",
            "state": null,
            "eTag": "2015-08-04T07:29:57.000Z",
            "modified": "2015-08-04T07:29:57.000Z",
            "created": "2015-06-13T04:48:49.000Z",
            "category": "os-deployment-server-scripts",
            "uri": "/rest/os-deployment-server-scripts/550001"
        },
        {
            "runAsSuperUser": true,
            "serverChanging": true,
            "codeType": "BAT",
            "displayCodeType": "Windows .BAT",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "1",
                    "createdBy": "opsware",
                    "createdDate": "2015-06-13T04:48:50.000Z",
                    "usage": "Installs Windows 2012 R2 x64 from OS Media. Requires full path to  setup.exe from the installation media.",
                    "current": false
                },
                {
                    "versionLabel": "2",
                    "createdBy": "opsware",
                    "createdDate": "2015-08-04T07:30:22.000Z",
                    "usage": "Installs Windows 2012 R2 x64 from OS Media. Requires full path to  setup.exe from the installation media.",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-08-04T07:30:22.000Z",
            "version": {
                "versionLabel": "2",
                "createdBy": "opsware",
                "createdDate": "2015-08-04T07:30:22.000Z",
                "usage": "Installs Windows 2012 R2 x64 from OS Media. Requires full path to  setup.exe from the installation media.",
                "current": true
            },
            "source": "@echo off\nsetlocal\nset SIG=WINPE64\nset ANSWER=X:\\Windows\\Temp\\Unattend.xml\nset ARGS=/noreboot /unattend:%ANSWER%\nset | find \"opswbasig=%SIG%\" > NUL\nif %ERRORLEVEL% NEQ 0 (\n    echo ERROR: Target server must be running %SIG% but it is not\n    exit /B 1\n)\nif X%1==X (\n    set SETUP=z:\\i386\\winnt32.exe\n) else (\n    set SETUP=%1\n)\nif not exist %SETUP% (\n    echo %SETUP% missing! Cannot install Windows.\n    exit /B 2\n)\nif not exist %ANSWER% (\n    echo %ANSWER% missing! Cannot install Windows.\n    exit /B 3\n)\n\n%SETUP% %ARGS%\n\nif %ERRORLEVEL% == 0 (\n    echo Windows setup completed successfully\n    exit\n) else (\n    echo ERROR: Windows setup exited status %ERRORLEVEL%\n    exit /B %ERRORLEVEL%\n)\n",
            "description": "Installs Windows 2012 R2 x64 from OS Media. Requires full path to  setup.exe from the installation media.",
            "status": null,
            "name": "Run Windows 2012 R2 x64 Setup",
            "state": null,
            "eTag": "2015-08-04T07:30:22.000Z",
            "modified": "2015-08-04T07:30:22.000Z",
            "created": "2015-06-13T04:48:50.000Z",
            "category": "os-deployment-server-scripts",
            "uri": "/rest/os-deployment-server-scripts/570001"
        },
        {
            "runAsSuperUser": true,
            "serverChanging": false,
            "codeType": "PY2",
            "displayCodeType": "Python",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "1",
                    "createdBy": "opsware",
                    "createdDate": "2015-06-13T04:48:51.000Z",
                    "usage": "This program will unpack, resize and modify the Solaris boot_archive to include\nall necessary files for automated installation.\n\nusage: modify_boot_archive.py\n\nThis script expects no command line arguments.\n\nPrerequisites:\n\n- This script must be run as part of a Build Plan under a Solaris Service OS\n- This script must be run after 'Copy Solaris Boot Media'",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-06-13T04:48:51.000Z",
            "version": {
                "versionLabel": "1",
                "createdBy": "opsware",
                "createdDate": "2015-06-13T04:48:51.000Z",
                "usage": "This program will unpack, resize and modify the Solaris boot_archive to include\nall necessary files for automated installation.\n\nusage: modify_boot_archive.py\n\nThis script expects no command line arguments.\n\nPrerequisites:\n\n- This script must be run as part of a Build Plan under a Solaris Service OS\n- This script must be run after 'Copy Solaris Boot Media'",
                "current": true
            },
            "source": "#!/opt/opsware/agent/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n\"\"\"\n    (C) Copyright 2013-2015 Hewlett-Packard Development Company, L.P.\n\n    This program will unpack, resize and modify the Solaris boot_archive to include\n    all necessary files for automated installation.\n\"\"\"\n\nimport os\nimport sys\nimport shutil\n\nfrom osprov.osbp import logger\nfrom osprov import helpers\nfrom osprov.decorators import HandleShowErrorMessage\nfrom osprov.server.local import ThisLocalServer\nfrom osprov.wrappers.boot_archive import BootArchive\n\nLOG = logger.getIt(\"Modify Boot Archive\")\n\nNET_ASSEMBLY_PATH = \"/usr/share/opsware/net-assembly-osprov\"\nMANIFEST_LOCATOR_PATH = \"/usr/share/opsware/manifest-locator-osprov\"\nAGENT_STARTER_NAME = \"hpsa-ogfs-autodl.sh\"\nSOS_AGENT_STARTER_LOCATION = os.path.join(\"/lib/svc/hpsa-ogfs\", AGENT_STARTER_NAME)\nAI_XML_PATH = \"/tmp/ai.xml\"\nSC_XML_PATH = \"/tmp/sc.xml\"\nAGENT_INSTALLER_REPO_PATH = \"/tmp/hpsa-repo/repo\"\n\nNET_ASSEMBLY_TARGET = \"lib/svc/method/net-assembly\"\nMEDIA_ASSEMBLY_TARGET = \"lib/svc/method/media-assembly\"\nMANIFEST_LOCATOR_TARGET = \"lib/svc/method/manifest-locator\"\n\nHPSA_DIR = \"hpsa\"\n\n\n@HandleShowErrorMessage(\"Modify Boot Archive\", LOG)\ndef main():\n    \"\"\"Main method, does all modifications.\"\"\"\n\n    # Temporary: check if x86, if not, fail. SPARC will be implemented in the future.\n    if not os.uname()[-1].startswith(\"i86\"):\n        raise NotImplementedError(\"Module not available yet on SPARC.\")\n\n    bootArchiveObj = BootArchive(\n        log=LOG, thisLocalServer=ThisLocalServer(), dataStoreKeys=helpers.getDataStore(), osVersion=\"11\")\n    # Check if we need to include an hpsa-agent-installer repo, and determine its size\n    if os.path.isdir(AGENT_INSTALLER_REPO_PATH):\n        extrasize = helpers.dirSize(AGENT_INSTALLER_REPO_PATH)\n    else:\n        extrasize = 0\n\n    bootArchiveObj.unpack()\n    bootArchiveObj.grow(400 + (extrasize >> 20))\n    bootArchiveObj.mount()\n\n    hpsaDir = os.path.join(bootArchiveObj.mountpoint, HPSA_DIR)\n    netAssemblyTarget = os.path.join(bootArchiveObj.mountpoint, NET_ASSEMBLY_TARGET)\n    mediaAssemblyTarget = os.path.join(bootArchiveObj.mountpoint, MEDIA_ASSEMBLY_TARGET)\n    manifestLocatorTarget = os.path.join(bootArchiveObj.mountpoint, MANIFEST_LOCATOR_TARGET)\n    helpers.makeDirs(hpsaDir)\n\n    # Modifications per-se\n    # Replace default startup methods\n    shutil.copy2(NET_ASSEMBLY_PATH, netAssemblyTarget)\n    print \"Copied %s to %s\" % (NET_ASSEMBLY_PATH, netAssemblyTarget)\n    shutil.copy2(NET_ASSEMBLY_PATH, mediaAssemblyTarget)\n    print \"Copied %s to %s\" % (NET_ASSEMBLY_PATH, mediaAssemblyTarget)\n    shutil.copy2(MANIFEST_LOCATOR_PATH, manifestLocatorTarget)\n    print \"Copied %s to %s\" % (MANIFEST_LOCATOR_PATH, manifestLocatorTarget)\n\n    # Copy boot files\n    shutil.copy2(\n        os.path.join(bootArchiveObj.bootfilesPath, \"solaris.zlib\"), bootArchiveObj.mountpoint)\n    shutil.copy2(\n        os.path.join(bootArchiveObj.bootfilesPath, \"solarismisc.zlib\"), bootArchiveObj.mountpoint)\n    shutil.copy2(\n        os.path.join(bootArchiveObj.bootfilesPath, \".image_info\"), bootArchiveObj.mountpoint)\n\n    # Copy AI manifests\n    shutil.copy2(AI_XML_PATH, hpsaDir)\n    shutil.copy2(SC_XML_PATH, hpsaDir)\n\n    # Copy mid and crypto\n    destMIDpath = os.path.join(\n        bootArchiveObj.mountpoint, bootArchiveObj.localServer.MID_FILE.lstrip(\"/\"))\n    destCryptoDir = os.path.join(\n        bootArchiveObj.mountpoint, bootArchiveObj.localServer.CRYPTO_DIR.lstrip(\"/\"))\n    helpers.makeDirs(os.path.join(bootArchiveObj.mountpoint, os.path.dirname(destMIDpath)))\n    shutil.copy2(bootArchiveObj.localServer.MID_FILE, destMIDpath)\n    shutil.rmtree(destCryptoDir, ignore_errors=True)\n\n    helpers.makeDirs(os.path.dirname(destCryptoDir))\n    shutil.copytree(bootArchiveObj.localServer.CRYPTO_DIR, destCryptoDir)\n\n    # Include agent starter\n    agentStarterDestination = os.path.join(hpsaDir, AGENT_STARTER_NAME)\n    f = open(agentStarterDestination, \"w\")\n    f.write(bootArchiveObj.localServer.getOgfsAgentStartupScript())\n    f.flush()\n    f.close()\n    shutil.copymode(SOS_AGENT_STARTER_LOCATION, agentStarterDestination)\n\n    # Include hpsa-agent-installer repo if present\n    if extrasize:\n        dest = os.path.join(bootArchiveObj.mountpoint, \"hpsa/repo\")\n        shutil.copytree(AGENT_INSTALLER_REPO_PATH, dest)\n\n    bootArchiveObj.umount()\n    bootArchiveObj.repack()\n    bootArchiveObj.cleanup()\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n",
            "description": "This program will unpack, resize and modify the Solaris boot_archive to include\nall necessary files for automated installation.\n\nusage: modify_boot_archive.py\n\nThis script expects no command line arguments.\n\nPrerequisites:\n\n- This script must be run as part of a Build Plan under a Solaris Service OS\n- This script must be run after 'Copy Solaris Boot Media'",
            "status": null,
            "name": "Modify Boot Archive",
            "state": null,
            "eTag": "2015-06-13T04:48:51.000Z",
            "modified": "2015-06-13T04:48:51.000Z",
            "created": "2015-06-13T04:48:51.000Z",
            "category": "os-deployment-server-scripts",
            "uri": "/rest/os-deployment-server-scripts/600001"
        },
        {
            "runAsSuperUser": true,
            "serverChanging": true,
            "codeType": "PY2",
            "displayCodeType": "Python",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "1",
                    "createdBy": "opsware",
                    "createdDate": "2015-06-13T04:48:52.000Z",
                    "usage": "This program will unpack, resize and modify the Solaris miniroot to include\nall necessary files for automated installation.\n\nusage: prepare_miniroot.py\n\nThis script expects no command line arguments.\n\nPrerequisites:\n\n- This script must be run as part of a Build Plan under a Solaris Service OS on x86\n- This script must be run after 'Inject Required Jumpstart'",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-06-13T04:48:52.000Z",
            "version": {
                "versionLabel": "1",
                "createdBy": "opsware",
                "createdDate": "2015-06-13T04:48:52.000Z",
                "usage": "This program will unpack, resize and modify the Solaris miniroot to include\nall necessary files for automated installation.\n\nusage: prepare_miniroot.py\n\nThis script expects no command line arguments.\n\nPrerequisites:\n\n- This script must be run as part of a Build Plan under a Solaris Service OS on x86\n- This script must be run after 'Inject Required Jumpstart'",
                "current": true
            },
            "source": "# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n\"\"\"\n    (C) Copyright 2013-2015 Hewlett-Packard Development Company, L.P.\n\n    This program will unpack, resize and modify the Solaris miniroot to include\n    all necessary files for automated installation.\n\"\"\"\nimport os\nimport sys\nimport shutil\nimport tarfile\nfrom osprov import helpers\nfrom osprov.osbp import logger\nfrom osprov.server.local import ThisLocalServer\nfrom osprov.decorators import HandleShowErrorMessage\nfrom osprov.wrappers.boot_archive import BootArchive\n\n\nLOG = logger.getIt(\"Prepare Miniroot x86\")\n\n\ndef createConfigTar(jumpstartDir):\n    \"\"\" Creates the config.tar file in the jumpstart directory on the mounted path \"\"\"\n    os.chdir(jumpstartDir)\n    configTarPath = os.path.join(jumpstartDir, \"config.tar\")\n\n    LOG.debug(\"Jumpstart Configuration .tar path : %s\" % configTarPath)\n    tar = tarfile.open(configTarPath, \"w:\")\n    configFilesList = os.listdir(jumpstartDir)\n    for configFile in configFilesList:\n        tar.add(configFile)\n    LOG.debug(\"Files compressed in %s : %s\" % (configTarPath, str(tar.getmembers())))\n    tar.close()\n    return configTarPath\n\n\ndef injectJumpstartToMiniroot(jumpstartDir, unpackMrDir):\n    \"\"\" Copies Jumpstart files to the mounted miniroot \"\"\"\n    createConfigTar(jumpstartDir=jumpstartDir)\n    destJumpstartDir = os.path.join(unpackMrDir, \"jumpstart/\")\n    shutil.copytree(jumpstartDir, destJumpstartDir)\n    LOG.debug(\"Injected Jumpstart Files to miniroot %s \" % destJumpstartDir)\n\n\ndef injectAgentFilesToMiniroot(tmpOGFSAgentPath, unpackMrDir):\n    \"\"\" Copies ogfs agent files to the mounted miniroot \"\"\"\n    destOGFSAgentPath = os.path.join(unpackMrDir, \"opt/opsware/agent/\")\n    shutil.copytree(tmpOGFSAgentPath, destOGFSAgentPath)\n    LOG.debug(\"Injected Agent Files to miniroot %s \" % destOGFSAgentPath)\n\n\ndef injectSmbiosToMiniroot(smbiosPath, unpackMrDir):\n    \"\"\" Copies smbios filee to the mounted miniroot \"\"\"\n    destSmbiosPath = os.path.join(unpackMrDir, \"dev/smbios\")\n    shutil.copyfile(smbiosPath, destSmbiosPath)\n    LOG.debug(\"Injected smbios File to miniroot %s \" % destSmbiosPath)\n\n\ndef setupMiniroot(minirootObj):\n    \"\"\" Unpacking, resizing and mounting miniroot \"\"\"\n    minirootObj.unpack()\n    minirootObj.grow(200)\n    minirootObj.mount()\n    LOG.info(\"Unpacked, resized and mounted the miniroot\")\n\n\ndef cleanupMiniroot(minirootObj):\n    \"\"\" Unmounting, repacking and cleaning up miniroot \"\"\"\n    minirootObj.umount()\n    minirootObj.repack()\n    minirootObj.cleanup()\n    LOG.info(\"Umounted, repacked and cleaned up the miniroot\")\n\n\n@HandleShowErrorMessage(\"Prepare Miniroot x86\", LOG)\ndef main():\n    \"\"\" Injecting the necessary files to the install miniroot \"\"\"\n    keys = helpers.getDataStore()\n    targetServer = ThisLocalServer()\n    minirootObj = BootArchive(\n        osVersion=\"10\", log=LOG, dataStoreKeys=keys, thisLocalServer=targetServer)\n\n    setupMiniroot(minirootObj=minirootObj)\n\n    stubMountpoint = keys.disk.device_mount\n    jumpstartDir = os.path.join(stubMountpoint, \"jumpstart\")\n    injectJumpstartToMiniroot(jumpstartDir, minirootObj.mountpoint)\n    injectAgentFilesToMiniroot(\"/tmp/opt/opsware/agent\", minirootObj.mountpoint)\n    injectSmbiosToMiniroot(\"/dev/smbios\", minirootObj.mountpoint)\n\n    cleanupMiniroot(minirootObj=minirootObj)\n    print \"Prepare Miniroot x86 terminated successfully.\"\n\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n",
            "description": "This program will unpack, resize and modify the Solaris miniroot to include\nall necessary files for automated installation.\n\nusage: prepare_miniroot.py\n\nThis script expects no command line arguments.\n\nPrerequisites:\n\n- This script must be run as part of a Build Plan under a Solaris Service OS on x86\n- This script must be run after 'Inject Required Jumpstart'",
            "status": null,
            "name": "Prepare Miniroot x86",
            "state": null,
            "eTag": "2015-06-13T04:48:52.000Z",
            "modified": "2015-06-13T04:48:52.000Z",
            "created": "2015-06-13T04:48:52.000Z",
            "category": "os-deployment-server-scripts",
            "uri": "/rest/os-deployment-server-scripts/620001"
        },
        {
            "runAsSuperUser": true,
            "serverChanging": true,
            "codeType": "PY2",
            "displayCodeType": "Python",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "1",
                    "createdBy": "opsware",
                    "createdDate": "2015-06-13T04:48:52.000Z",
                    "usage": "Creates a partition on the target server hard drive using diskpart.\n\nUsage: partition_disk_for_windows.py [options]\n\nOptions:\n -h, --help            show this help message and exit\n --bootMode=BOOTMODE   boot mode of the server, can be UEFI or Legacy\n --systemDiskNumber=SYSTEMDISKNUMBER\n        system disk number where Windows is installed (default disk number is '0').\n --systemPartitionLabel=SYSTEMPARTITIONLABEL\n        label of partition where Windows will be installed\n\nPrerequisites:\n - Target server runs a maintenance Windows PE OS.\n - Presence of files \"diskpart_legacy.txt\",\"diskpart_uefi.txt\" in X:\\Windows\\Temp\\",
                    "current": false
                },
                {
                    "versionLabel": "2",
                    "createdBy": "opsware",
                    "createdDate": "2015-08-04T07:29:47.000Z",
                    "usage": "Creates a partition on the target server hard drive using diskpart.\n\nUsage: partition_disk_for_windows.py [options]\n\nOptions:\n -h, --help            show this help message and exit\n --bootMode=BOOTMODE   boot mode of the server, can be UEFI or Legacy\n --systemDiskNumber=SYSTEMDISKNUMBER\n        system disk number where Windows is installed (default disk number is '0').\n --systemPartitionLabel=SYSTEMPARTITIONLABEL\n        label of partition where Windows will be installed\n\nPrerequisites:\n - Target server runs a maintenance Windows PE OS.\n - Presence of files \"diskpart_legacy.txt\",\"diskpart_uefi.txt\" in X:\\Windows\\Temp\\",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-08-04T07:29:47.000Z",
            "version": {
                "versionLabel": "2",
                "createdBy": "opsware",
                "createdDate": "2015-08-04T07:29:47.000Z",
                "usage": "Creates a partition on the target server hard drive using diskpart.\n\nUsage: partition_disk_for_windows.py [options]\n\nOptions:\n -h, --help            show this help message and exit\n --bootMode=BOOTMODE   boot mode of the server, can be UEFI or Legacy\n --systemDiskNumber=SYSTEMDISKNUMBER\n        system disk number where Windows is installed (default disk number is '0').\n --systemPartitionLabel=SYSTEMPARTITIONLABEL\n        label of partition where Windows will be installed\n\nPrerequisites:\n - Target server runs a maintenance Windows PE OS.\n - Presence of files \"diskpart_legacy.txt\",\"diskpart_uefi.txt\" in X:\\Windows\\Temp\\",
                "current": true
            },
            "source": "#!/usr/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n#\n\"\"\"\n    (C) Copyright 2013-2015 Hewlett-Packard Development Company, L.P.\n\"\"\"\n\nimport sys\nimport os\nfrom optparse import OptionError\nfrom osprov.errors import FileNotFoundError\nfrom osprov.optparse_ext import OptionParser\nfrom osprov.scripts import bootmode\nfrom osprov.diskmgr import const, disk, diskmanager\nfrom osprov.util import process\nfrom osprov.osbp import logger\nfrom osprov.decorators import HandleShowErrorMessage\nfrom osprov import diskmgr\nfrom osprov import helpers\nfrom osprov.server.local import ThisLocalServer\n\nLOG = logger.getIt(\"partition_disk_for_windows\")\nDISKPART_LEGACY = r\"X:\\Windows\\Temp\\diskpart_legacy.txt\"\nDISKPART_UEFI = r\"X:\\Windows\\Temp\\diskpart_uefi.txt\"\n\n\nclass PartitionDiskForWindowsOptionParser(OptionParser):\n    \"\"\" Option parser for this step \"\"\"\n\n    def defineOptions(self):\n        self.add_option(\"--bootMode\", type=\"string\",\n                        help=\"boot mode of the server, can be UEFI or Legacy\")\n        self.add_option(\"--systemDiskNumber\", type=\"int\", default=0,\n                        help=\"system disk number where Windows is installed (default disk number is '0').\")\n        self.add_option(\"--systemPartitionLabel\", type=\"string\", default=\"System\",\n                        help=\"label of partition where Windows will be installed\")\n\n    def validateArgs(self, opt, args):\n        if opt.bootMode and not bootmode.isBootModeSupported(opt.bootMode):\n            raise OptionError(\"Invalid boot mode: \" + opt.bootMode, \"bootMode\")\n\n\ndef doDiskpart(dpFile, log=LOG):\n    # check if dpFile exists\n    if False == os.path.isfile(dpFile):\n        raise FileNotFoundError(\"Diskpart configuration file not found: %s\" % dpFile)\n\n    # run diskpart\n    process.runIt(\"diskpart.exe /s %s\" % (dpFile), checkExitCode=(0,), log=log, quiet=True)\n\n\ndef saveDiskDetailsToDatastore(diskSerial, diskId, partitionId):\n    datastore = helpers.getDataStore()\n    if diskSerial is not None:\n        datastore.windows.disk_serial = diskSerial\n    if diskId is not None:\n        datastore.windows.disk_id = diskId\n    if partitionId is not None:\n        datastore.windows.partition_id = partitionId\n    helpers.putDataStore(datastore)\n\n\ndef getDiskSerialNumberFromDatastore():\n    datastore = helpers.getDataStore()\n    if datastore.windows.disk_serial:\n        return datastore.windows.disk_serial\n    return None\n\n\ndef getUpdatedDiskNumber(currentDiskNumber):\n    diskSerialNumber = getDiskSerialNumberFromDatastore()\n    if not diskSerialNumber:\n        return currentDiskNumber\n    newDiskNumber = diskmanager.WindowsDiskManager.findDiskWithSerial(diskSerialNumber)\n    if newDiskNumber is None:\n        return currentDiskNumber\n    return newDiskNumber\n\n\ndef patchDiskpartConfigFile(filePath, oldDiskNumber, newDiskNumber):\n    if not os.path.exists(filePath):\n        return\n    with open(filePath, 'r') as f:\n        content = f.readlines()\n    strToSearch = \"SELECT DISK %s\" % str(oldDiskNumber)\n    strToSearch = strToSearch.replace(\" \", \"\")\n    strToReplaceWith = \"SELECT DISK %s\\n\" % str(newDiskNumber)\n    for nr, val in enumerate(content):\n        line = content[nr].strip().upper().replace(\" \", \"\")\n        if strToSearch == line:\n            content[nr] = strToReplaceWith\n    with open(filePath, 'w') as f:\n        f.writelines(content)\n\n\n@HandleShowErrorMessage(\"Partition Disk for Windows\", LOG)\ndef main():\n    # get and parse arguments\n    options, remainingArgs = PartitionDiskForWindowsOptionParser().parse_args()\n    newSystemDiskNumber = getUpdatedDiskNumber(options.systemDiskNumber)\n    if options.systemDiskNumber != newSystemDiskNumber:\n        # if disk number has changed we have to patch diskpart files\n        patchDiskpartConfigFile(DISKPART_LEGACY, options.systemDiskNumber, newSystemDiskNumber)\n        patchDiskpartConfigFile(DISKPART_UEFI, options.systemDiskNumber, newSystemDiskNumber)\n        options.systemDiskNumber = newSystemDiskNumber\n\n    # get bootmode (legacy bios or uefi)\n    if options.bootMode:\n        bootMode = options.bootMode\n    else:\n        bootMode = bootmode.getCurrentBootMode(ThisLocalServer(), log=LOG)\n\n    partitionTable = diskmgr.getPartitionTable(bootMode)\n    if const.PARTITION_TABLE_MBR == partitionTable:\n        print \"Partitioning disk based on Legacy Windows Partitioning Schema\"\n        doDiskpart(DISKPART_LEGACY)\n    elif const.PARTITION_TABLE_GPT == partitionTable:\n        print \"Partitioning disk based on Uefi Windows Partitioning Schema\"\n        doDiskpart(DISKPART_UEFI)\n\n    _disk = disk.WindowsDisk(options.systemDiskNumber)\n    partition = _disk.getPartitionWithLabel(options.systemPartitionLabel)\n    partitionNr = str(partition.partitionNr)\n    diskSerialNumber = diskmanager.WindowsDiskManager.getSerialNumberForDisk(options.systemDiskNumber)\n    saveDiskDetailsToDatastore(diskSerialNumber, options.systemDiskNumber, partitionNr)\n\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n",
            "description": "Creates a partition on the target server hard drive using diskpart.\n\nUsage: partition_disk_for_windows.py [options]\n\nOptions:\n -h, --help            show this help message and exit\n --bootMode=BOOTMODE   boot mode of the server, can be UEFI or Legacy\n --systemDiskNumber=SYSTEMDISKNUMBER\n        system disk number where Windows is installed (default disk number is '0').\n --systemPartitionLabel=SYSTEMPARTITIONLABEL\n        label of partition where Windows will be installed\n\nPrerequisites:\n - Target server runs a maintenance Windows PE OS.\n - Presence of files \"diskpart_legacy.txt\",\"diskpart_uefi.txt\" in X:\\Windows\\Temp\\",
            "status": null,
            "name": "Partition Disk for Windows",
            "state": null,
            "eTag": "2015-08-04T07:29:47.000Z",
            "modified": "2015-08-04T07:29:47.000Z",
            "created": "2015-06-13T04:48:52.000Z",
            "category": "os-deployment-server-scripts",
            "uri": "/rest/os-deployment-server-scripts/630001"
        },
        {
            "runAsSuperUser": true,
            "serverChanging": true,
            "codeType": "SH",
            "displayCodeType": "Unix",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "1",
                    "createdBy": "opsware",
                    "createdDate": "2015-06-13T04:48:54.000Z",
                    "usage": " Copies a number of files needed to boot the installer environment to the stub partition\n \n usage :\n        copy_boot_media.py [base_path_or_img \"file1\" [\"file2\" [\"file 3\" ...]]]\n\n\tAll parameters are optional. If none are given, the script will check the \n\tinstallation media and figure out the files that the installer needs in\n\torder to boot.\n\t\n\tParameters:\n       \n    base_path_or_img               :  A directory in the installation media, \n\t\t\tor a mountable image file. All other files are relative to this\n\t\t    location. (Deprecated)\n\n    \"file1\" [\"file2\" [\"file3\" ...]] : list of files to copy onto the boot partition\n\nRequired prerequisite state:\n - Must be run as part of a build plan\n - Must be run after 'Create Stub Partition'\n - Must be run after 'Set Media Source'",
                    "current": false
                },
                {
                    "versionLabel": "2",
                    "createdBy": "opsware",
                    "createdDate": "2015-08-04T07:30:11.000Z",
                    "usage": " Copies a number of files needed to boot the installer environment to the stub partition\n \n usage :\n        copy_boot_media.py [base_path_or_img \"file1\" [\"file2\" [\"file 3\" ...]]]\n\n\tAll parameters are optional. If none are given, the script will check the \n\tinstallation media and figure out the files that the installer needs in\n\torder to boot.\n\t\n\tParameters:\n       \n    base_path_or_img               :  A directory in the installation media, \n\t\t\tor a mountable image file. All other files are relative to this\n\t\t    location. (Deprecated)\n\n    \"file1\" [\"file2\" [\"file3\" ...]] : list of files to copy onto the boot partition\n\nRequired prerequisite state:\n - Must be run as part of a build plan\n - Must be run after 'Create Stub Partition'\n - Must be run after 'Set Media Source'",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-08-04T07:30:11.000Z",
            "version": {
                "versionLabel": "2",
                "createdBy": "opsware",
                "createdDate": "2015-08-04T07:30:11.000Z",
                "usage": " Copies a number of files needed to boot the installer environment to the stub partition\n \n usage :\n        copy_boot_media.py [base_path_or_img \"file1\" [\"file2\" [\"file 3\" ...]]]\n\n\tAll parameters are optional. If none are given, the script will check the \n\tinstallation media and figure out the files that the installer needs in\n\torder to boot.\n\t\n\tParameters:\n       \n    base_path_or_img               :  A directory in the installation media, \n\t\t\tor a mountable image file. All other files are relative to this\n\t\t    location. (Deprecated)\n\n    \"file1\" [\"file2\" [\"file3\" ...]] : list of files to copy onto the boot partition\n\nRequired prerequisite state:\n - Must be run as part of a build plan\n - Must be run after 'Create Stub Partition'\n - Must be run after 'Set Media Source'",
                "current": true
            },
            "source": "#!/opt/opsware/agent/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n\"\"\"\n    (C) Copyright 2011-2015 Hewlett-Packard Development Company, L.P.\n\n    Copy the media needed to boot the target installer.\n    Be smart and try to figure out the media that is needed.\n\"\"\"\n\nimport os\nimport sys\nimport StringIO\n\nfrom osprov.osbp import logger\nfrom osprov.parsers.syslinux import Syslinux\nfrom osprov import media, helpers\nfrom osprov.errors import ShowErrorMessage, DiscoveryError\nfrom osprov.decorators import simplecache\n\n\nclass CopyBootMedia(object):\n\n    \"\"\" Do everything needed to copy the media \"\"\"\n\n    CFG_FILES = [\n        # Ubuntu support\n        \"install/netboot/ubuntu-installer/amd64/boot-screens/syslinux.cfg\",\n        \"install/netboot/ubuntu-installer/i386/boot-screens/syslinux.cfg\",\n        # Common locations for isolinux.cfgs in the supported platforms\n        \"isolinux/isolinux.cfg\",\n        \"isolinux.cfg\",\n        \"boot/i386/loader/isolinux.cfg\",\n        \"boot/x86_64/loader/isolinux.cfg\"\n    ]\n\n    def __init__(self, log=None):\n        \"\"\" Init the class \"\"\"\n        if log is None:\n            self.log = logger.getIt(self.__class__.__name__)\n        else:\n            self.log = log\n        self.media = None\n\n    @property\n    @simplecache\n    def keys(self):\n        return helpers.getDataStore()\n\n    def discoverMediaObject(self, arg=None):\n        \"\"\" Figure out the type of media used and return the appropriate object type\"\"\"\n        if self.keys.media.url:\n            self.media = media.factor(self.keys.media.url, log=self.log)\n        else:\n            mediaServer = open(\"/tmp/osbp_info/media_server\", \"r\").read().strip()\n            mediaPath = open(\"/tmp/osbp_info/media_path\", \"r\").read().strip()\n            mediaMount = open(\"/tmp/osbp_info/media_mount\", \"r\").read().strip()\n            url = \"nfs://%s:%s/#%s\" % (mediaServer, mediaPath, mediaMount)\n            self.log.debug(\n                \"Being Backward compatible with old mount script. will use url %s\" % url)\n            self.media = media.factor(url)\n        if arg:\n            if self.media.parsed_url.scheme == \"nfs\" and \\\n                    os.path.isfile(os.path.join(self.media.basepath, arg[0])):\n                #  we can only support the iso if the media is presented using nfs\n                #  and we threat any files as supported\n                #  - This is only to be backwards compatibile,\n                # this would be better off unsupported\n                self.media = media.factor(\"iso://%s/%s\" % (self.media.basepath, arg[0]))\n            else:\n                if not arg[0].lower().endswith(\".iso\"):\n                    # If it's not an iso, consider it a subdir\n                    self.media.subdir(arg[0])\n                # Just ignore an iso if we are not on NFS\n\n    def flattenSyslinuxCfg(self, cfgFile):\n        \"\"\" Flattens nested syslinux.cfg files that use the include statement.\n                If a file to be included is not found it is skipped.\n        \"\"\"\n        result = Syslinux.readwrite(StringIO.StringIO())\n\n        if not self.media.exists(cfgFile):\n            return result\n\n        parser = Syslinux.readonly(self.media.open(cfgFile))\n        for key in parser.info():\n            if key.startswith(\"include\"):\n                nestedCfg = key.split()[1]\n                nestedCfgPath = os.path.join(os.path.dirname(cfgFile), os.path.split(nestedCfg)[-1])\n                nestedParser = self.flattenSyslinuxCfg(nestedCfgPath)\n                for nestedKey, nestedValue in nestedParser.info().items():\n                    result.info()[nestedKey] = nestedValue\n            else:\n                result.info()[key] = parser.info()[key]\n        return result\n\n    def getConfigFile(self):\n        \"\"\" \"\"\"\n        cfg_file = None\n        for each_file in self.CFG_FILES:\n            if self.media.exists(each_file):\n                cfg_file = each_file\n                break\n        if not cfg_file:\n            raise DiscoveryError(\"Found no isolinux config file. \"\n                                 \"Discovery of media files cannot be achieved. Make sure the media is \"\n                                 \"correct\")\n        return cfg_file\n\n    def getBootFiles(self, bootLabel):\n        print \"Adding kernel to be copied\"\n        files = [bootLabel[\"kernel\"]]\n        # hunt for additional files, initrd first\n        for param in bootLabel[\"append\"].split(' '):\n            if param.startswith(\"initrd=\"):\n                print \"Adding initrd(s) to files to be copied\"\n                files.extend([x.strip() for x in param[len(\"initrd=\"):].split(',')])\n                break\n        return files\n\n    def getMBootFiles(self, bootLabel):\n        \"\"\" Get mboot.c32 style files \"\"\"\n        files = []\n        if \" --- \" in bootLabel[\"append\"]:\n            print \"Adding mboot modules\"\n            # might want to account for parameters too here\n            files.extend([x.strip() for x in bootLabel[\"append\"].split(\" --- \")])\n        return files\n\n    def getESXi5BootFiles(self, bootLabel, cfg_file):\n        \"\"\" Get boot files from nested boot configs \"\"\"\n        files = []\n        where = bootLabel[\"append\"].find(\"-c\")\n        if where >= 0:\n            print \"Adding modules from boot configuration file\"\n            bootcfg_name = bootLabel[\"append\"][where + 2:].strip().split(' ', 1)[0]\n            bootcfg_file = self.media.open(\n                os.path.join(os.path.dirname(cfg_file), bootcfg_name))\n            files.append(bootcfg_name)\n            bootcfg = Syslinux.Bootcfg.readonly(bootcfg_file).info()\n            files.append(bootcfg[\"kernel\"])\n            files.extend(bootcfg[\"modules\"])\n            # also retrieve the UEFI bootloader\n            files.append(\"/efi/boot/bootx64.efi\")\n        return files\n\n    def discoverMediaFiles(self):\n        \"\"\" Check the install media  \"\"\"\n        cfg_file = self.getConfigFile()\n        print \"Found configuration at %s\" % cfg_file\n        config = self.flattenSyslinuxCfg(cfg_file)\n        self.log.debug(\"Discovered syslinux cfg file: %s\" % config)\n        # get the first label without a localboot option\n        # we will use that for discovery\n        name = config.first_non_local_label()\n        if name is None:\n            raise DiscoveryError(\"Cannot discover media files. \"\n                                 \"The %s config file has an unexpected configuration.\" % cfg_file)\n        values = config.info()[\"label \" + name]\n        print \"Will discover media using label %s\" % name\n        # if we go this far, we have our name and value\n        # get a list of the media files\n        files = []\n        try:\n            files.extend(self.getBootFiles(values))\n            files.extend(self.getMBootFiles(values))\n            files.extend(self.getESXi5BootFiles(values, cfg_file))\n        except KeyError, why:\n            raise DiscoveryError(\"Cannot discover media files. \"\n                                 \"Unexpected isolinux configuration. Property %s not found\" % why)\n        # normalize the files to the isolinux.cfg location\n        files = [helpers.pathMerge(cfg_file, x) for x in files]\n        return files, config\n\n    def discoverTarget(self):\n        \"\"\" discover the target partition \"\"\"\n        target = self.keys.disk.device_mount\n        if not target:\n            raise DiscoveryError(\"Cannot determine target destination. \"\n                                 \"Was the stub partition created?\")\n        return target\n\n    def copyFiles(self, target, files):\n        \"\"\" copy the files onto the stub partition \"\"\"\n        for each in files:\n            print \"Copying %s to %s\" % (each, target)\n            ex = None\n            for i in xrange(5):\n                try:\n                    self.media.copyTo(each, target)\n                    break\n                except IOError, ex:\n                    self.log.warning(\n                        \"Copy operation of file %s failed, retry %d of 5; exception follows\" % (each, i + 1))\n                    self.log.exception(ex)\n            else:\n                raise ex\n\n    def main(self, args):\n        \"\"\" do the media copying  \"\"\"\n        try:\n            self.discoverMediaObject(args[1:2])\n            print \"Will copy from %s\" % self.media\n            target = self.discoverTarget()\n            if not os.path.isdir(target):\n                print \"Error: %s is not a directory. Can't copy media there.\" % target\n                print \"There might be an issue with the stub partition.\"\n                return 1\n            files = None\n            if args:\n                if args[2:]:\n                    # old style parameters\n                    files = args[2:]\n            if not files:\n                files, config = self.discoverMediaFiles()\n                fd = open(os.path.join(target, \"isolinux.cfg\"), \"w+b\")\n                try:\n                    fd.write(config.format())\n                finally:\n                    fd.close()\n            self.copyFiles(target, files)\n            print \"Successfully copied all boot media\"\n        except DiscoveryError, why:\n            self.log.exception(why)\n            print \"Auto discovery failed: %s\" % why\n            return 3\n        except ShowErrorMessage, why:\n            self.log.exception(why)\n            print \"Failed to copy boot media %s\" % why\n            return why[1]\n        except (IOError, OSError), why:\n            self.log.exception(why)\n            print \"Failed to copy boot media : %s. Is this the correct media?\" % why\n            return 4\n\n\nif __name__ == \"__main__\":\n    sys.exit(CopyBootMedia().main(sys.argv))\n",
            "description": " Copies a number of files needed to boot the installer environment to the stub partition\n \n usage :\n        copy_boot_media.py [base_path_or_img \"file1\" [\"file2\" [\"file 3\" ...]]]\n\n\tAll parameters are optional. If none are given, the script will check the \n\tinstallation media and figure out the files that the installer needs in\n\torder to boot.\n\t\n\tParameters:\n       \n    base_path_or_img               :  A directory in the installation media, \n\t\t\tor a mountable image file. All other files are relative to this\n\t\t    location. (Deprecated)\n\n    \"file1\" [\"file2\" [\"file3\" ...]] : list of files to copy onto the boot partition\n\nRequired prerequisite state:\n - Must be run as part of a build plan\n - Must be run after 'Create Stub Partition'\n - Must be run after 'Set Media Source'",
            "status": null,
            "name": "Copy Boot Media",
            "state": null,
            "eTag": "2015-08-04T07:30:11.000Z",
            "modified": "2015-08-04T07:30:11.000Z",
            "created": "2015-06-13T04:48:54.000Z",
            "category": "os-deployment-server-scripts",
            "uri": "/rest/os-deployment-server-scripts/660001"
        },
        {
            "runAsSuperUser": true,
            "serverChanging": true,
            "codeType": "PY2",
            "displayCodeType": "Python",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "1",
                    "createdBy": "opsware",
                    "createdDate": "2015-06-13T04:48:54.000Z",
                    "usage": "Copies a number of files needed to boot the installer environment to the stub partition.\n \n usage :\n        copy_boot_media.py\n\n\tThe script will check the installation media and figgure out the files that\n\tthe installer needs in order to boot. This script accepts no arguments.\n\nPrerequisites:\n - Must be run as part of a build plan on a Solaris Service OS\n - Must be run after 'Create Solaris Stub Partition'\n - Must be run after 'Set Media Source'",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-06-13T04:48:54.000Z",
            "version": {
                "versionLabel": "1",
                "createdBy": "opsware",
                "createdDate": "2015-06-13T04:48:54.000Z",
                "usage": "Copies a number of files needed to boot the installer environment to the stub partition.\n \n usage :\n        copy_boot_media.py\n\n\tThe script will check the installation media and figgure out the files that\n\tthe installer needs in order to boot. This script accepts no arguments.\n\nPrerequisites:\n - Must be run as part of a build plan on a Solaris Service OS\n - Must be run after 'Create Solaris Stub Partition'\n - Must be run after 'Set Media Source'",
                "current": true
            },
            "source": "#!/opt/opsware/agent/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n\"\"\"\n    (C) Copyright 2013-2015 Hewlett-Packard Development Company, L.P.\n\n    Copy the media needed to boot the target installer.\n    Be smart and try to figure out the media that is needed\n\"\"\"\n\nimport os\nimport sys\n\nfrom osprov.osbp import logger\nfrom osprov import media, helpers\nfrom osprov.errors import ShowErrorMessage, DiscoveryError, NotSupportedError\nfrom osprov.decorators import HandleShowErrorMessage\n\nLOG = logger.getIt(\"Copy Boot Media\")\n\n\nclass CopyBootMedia(object):\n\n    \"\"\" Do everything needed to copy the media \"\"\"\n\n    def __init__(self):\n        self.keys = helpers.getDataStore()\n        self.media = None\n\n    def discoverMediaObject(self):\n        \"\"\"Figure out the type of media used and set the appropriate object type\"\"\"\n        if self.keys.media.url:\n            self.media = media.factor(self.keys.media.url, log=LOG)\n            self.discoverOSVersion()\n        else:\n            raise DiscoveryError(\n                \"Media source not set. You might be missing the 'Set Media Source' step in your Build Plan.\")\n\n    def discoverOSVersion(self):\n        \"\"\"Figure out if multiboot is present in the media source. Based on that set OSVersion.\"\"\"\n        multibootLoc = \"boot/multiboot\"\n        if self.media.exists(multibootLoc):\n            self.osVersion = \"Solaris 10\"\n        else:\n            self.osVersion = \"Solaris 11\"\n        LOG.debug(\"Discovered OS Version : %s\" % self.osVersion)\n\n    def discoverMediaFilesX86(self):\n        \"\"\"Discover files needed for booting\"\"\"\n        if self.osVersion.endswith(\"10\"):\n            multibootPath = \"boot/multiboot\"\n            minirootPath = \"boot/x86.miniroot\"\n            return [multibootPath, minirootPath]\n        else:\n            platformName = os.uname()[-1]\n            kernelPath = \"platform/%s/kernel/amd64/unix\" % platformName\n            baPath = \"platform/%s/amd64/boot_archive\" % platformName\n            solariszPath = \"solaris.zlib\"\n            solarismisczPath = \"solarismisc.zlib\"\n            imginfoPath = \".image_info\"\n            return [kernelPath, baPath, solariszPath, solarismisczPath, imginfoPath]\n\n    def discoverMediaFilesSPARC(self):\n        raise NotSupportedError(\"Not available yet on SPARC.\")\n\n    def discoverMediaFiles(self):\n        \"\"\"Check the install media.\"\"\"\n        if os.uname()[-1].startswith(\"i86\"):\n            return self.discoverMediaFilesX86()\n        else:\n            return self.discoverMediaFilesSPARC()\n\n    def discoverTarget(self):\n        \"\"\"Discover the target partition.\"\"\"\n        target = self.keys.disk.device_mount\n        if not target:\n            raise DiscoveryError(\"Can't determine target destination. \"\n                                 \"Was the stub partition created?\")\n        if self.osVersion.endswith(\"10\"):\n            ret = os.path.join(target, \"sol-x86\")\n        else:\n            ret = os.path.join(target, \"bootfiles\")\n        helpers.makeDirs(ret)\n        LOG.debug(\"Target partition path %s\" % ret)\n        return ret\n\n    def copyFiles(self, target, files):\n        \"\"\" Copy the files onto the stub partition \"\"\"\n        for each in files:\n            print \"Copying %s to %s\" % (each, target)\n            self.media.copyTo(each, target)\n\n    @HandleShowErrorMessage(\"Copy Solaris Boot Media\", LOG)\n    def main(self):\n        \"\"\" Do the media copying.\"\"\"\n        self.discoverMediaObject()\n        print \"Will copy from %s\" % self.media\n        target = self.discoverTarget()\n        if not os.path.isdir(target):\n            raise ShowErrorMessage(\"Error: %s is not a directory. Can't copy media there.\" % target +\n                                   \"\\nThere might be an issue with the stub partition.\")\n        files = self.discoverMediaFiles()\n        self.copyFiles(target, files)\n        print \"Successfully copied all boot media\"\n\n\nif __name__ == \"__main__\":\n    sys.exit(CopyBootMedia().main())\n",
            "description": "Copies a number of files needed to boot the installer environment to the stub partition.\n \n usage :\n        copy_boot_media.py\n\n\tThe script will check the installation media and figgure out the files that\n\tthe installer needs in order to boot. This script accepts no arguments.\n\nPrerequisites:\n - Must be run as part of a build plan on a Solaris Service OS\n - Must be run after 'Create Solaris Stub Partition'\n - Must be run after 'Set Media Source'",
            "status": null,
            "name": "Copy Solaris Boot Media",
            "state": null,
            "eTag": "2015-06-13T04:48:54.000Z",
            "modified": "2015-06-13T04:48:54.000Z",
            "created": "2015-06-13T04:48:54.000Z",
            "category": "os-deployment-server-scripts",
            "uri": "/rest/os-deployment-server-scripts/670001"
        },
        {
            "runAsSuperUser": true,
            "serverChanging": true,
            "codeType": "BAT",
            "displayCodeType": "Windows .BAT",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "1",
                    "createdBy": "opsware",
                    "createdDate": "2015-06-13T04:48:55.000Z",
                    "usage": "This script prepares a running Windows installation (Windows 2008 and newer) from a Managed server to be captured using Sysprep tool\n\nUsage: prepare_windows_image_capture.cmd [path_to_answer_file]\n\nScript takes only one optional parameter passed to Sysprep tool, as parameter: \"/unattend:path_to_answer_file\"\n\nWarning:\nIn case you have provided an answer file at this step and for deploy you will be using  on of the bundled WIM deploy  \nbuild plans, the anwser file is overwritten with the one from the build plan.\n\nPlease consult links:\nhttp://technet.microsoft.com/library/cc766514(WS.10).aspx\nhttp://technet.microsoft.com/en-us/library/cc721973(v=ws.10)\n\nPrerequisites:\n- Target server runs a Windows OS.",
                    "current": false
                },
                {
                    "versionLabel": "2",
                    "createdBy": "opsware",
                    "createdDate": "2015-08-04T07:29:54.000Z",
                    "usage": "This script prepares a running Windows installation (Windows 2008 and newer) from a Managed server to be captured using Sysprep tool\n\nUsage: prepare_windows_image_capture.cmd [path_to_answer_file]\n\nScript takes only one optional parameter passed to Sysprep tool, as parameter: \"/unattend:path_to_answer_file\"\n\nWarning:\nIn case you have provided an answer file at this step and for deploy you will be using  on of the bundled WIM deploy  \nbuild plans, the anwser file is overwritten with the one from the build plan.\n\nPlease consult links:\nhttp://technet.microsoft.com/library/cc766514(WS.10).aspx\nhttp://technet.microsoft.com/en-us/library/cc721973(v=ws.10)\n\nPrerequisites:\n- Target server runs a Windows OS.",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-08-04T07:29:54.000Z",
            "version": {
                "versionLabel": "2",
                "createdBy": "opsware",
                "createdDate": "2015-08-04T07:29:54.000Z",
                "usage": "This script prepares a running Windows installation (Windows 2008 and newer) from a Managed server to be captured using Sysprep tool\n\nUsage: prepare_windows_image_capture.cmd [path_to_answer_file]\n\nScript takes only one optional parameter passed to Sysprep tool, as parameter: \"/unattend:path_to_answer_file\"\n\nWarning:\nIn case you have provided an answer file at this step and for deploy you will be using  on of the bundled WIM deploy  \nbuild plans, the anwser file is overwritten with the one from the build plan.\n\nPlease consult links:\nhttp://technet.microsoft.com/library/cc766514(WS.10).aspx\nhttp://technet.microsoft.com/en-us/library/cc721973(v=ws.10)\n\nPrerequisites:\n- Target server runs a Windows OS.",
                "current": true
            },
            "source": "@echo off\nif not exist %WINDIR%\\system32\\sysprep\\sysprep.exe (\n\techo \"Sysprep tool was not found in this Windows installation. This is only supported for Windows 2008 and newer\"\n\texit 1\n)\n\nif \"%1\"==\"\" (\n  %WINDIR%\\system32\\sysprep\\sysprep.exe /generalize /oobe /quit\n) else (\n  %WINDIR%\\system32\\sysprep\\sysprep.exe /generalize /oobe /quit /unattend:%1\n)\n",
            "description": "This script prepares a running Windows installation (Windows 2008 and newer) from a Managed server to be captured using Sysprep tool\n\nUsage: prepare_windows_image_capture.cmd [path_to_answer_file]\n\nScript takes only one optional parameter passed to Sysprep tool, as parameter: \"/unattend:path_to_answer_file\"\n\nWarning:\nIn case you have provided an answer file at this step and for deploy you will be using  on of the bundled WIM deploy  \nbuild plans, the anwser file is overwritten with the one from the build plan.\n\nPlease consult links:\nhttp://technet.microsoft.com/library/cc766514(WS.10).aspx\nhttp://technet.microsoft.com/en-us/library/cc721973(v=ws.10)\n\nPrerequisites:\n- Target server runs a Windows OS.",
            "status": null,
            "name": "Prepare Windows for Image Capture",
            "state": null,
            "eTag": "2015-08-04T07:29:54.000Z",
            "modified": "2015-08-04T07:29:54.000Z",
            "created": "2015-06-13T04:48:55.000Z",
            "category": "os-deployment-server-scripts",
            "uri": "/rest/os-deployment-server-scripts/700001"
        },
        {
            "runAsSuperUser": true,
            "serverChanging": true,
            "codeType": "SH",
            "displayCodeType": "Unix",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "1",
                    "createdBy": "opsware",
                    "createdDate": "2015-06-13T04:48:57.000Z",
                    "usage": "Installs and configures GRUB (GRand Unified Boot Loader) onto the stub partition of the boot disk on the target server in order to enable the booting into the Oracle Enterprise Linux installation image.\n\nThe step will also auto detect directories with the names \"addon\", \"AddOn\" and \"ADDON\" in the repository and for SuSE Linux Enterprise Server installations append the proper \"addon='path-to-addon-dir' to the kernel parameters of the grub boot loader.\n\nUsage:\n\nThis script expects no command line arguments, but the following argument(s) can optionally be specified:\n    --kernel_arguments=KERNEL_ARGUMENTS\n                        a string of arguments that will be passed to the OS\n                        installer kernel\n    --disableWarning    Do not show warnings of old hpsa_netconfig format\n\nPrerequisites:\n- Target server runs a maintenance Linux OS.\n- The files in the grub.zip archive must be extracted in /tmp.\n- The \"Create Stub Partition\" step must have been executed. \n\nThis script is intended to be used only as a Build Plan step.",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-06-13T04:48:57.000Z",
            "version": {
                "versionLabel": "1",
                "createdBy": "opsware",
                "createdDate": "2015-06-13T04:48:57.000Z",
                "usage": "Installs and configures GRUB (GRand Unified Boot Loader) onto the stub partition of the boot disk on the target server in order to enable the booting into the Oracle Enterprise Linux installation image.\n\nThe step will also auto detect directories with the names \"addon\", \"AddOn\" and \"ADDON\" in the repository and for SuSE Linux Enterprise Server installations append the proper \"addon='path-to-addon-dir' to the kernel parameters of the grub boot loader.\n\nUsage:\n\nThis script expects no command line arguments, but the following argument(s) can optionally be specified:\n    --kernel_arguments=KERNEL_ARGUMENTS\n                        a string of arguments that will be passed to the OS\n                        installer kernel\n    --disableWarning    Do not show warnings of old hpsa_netconfig format\n\nPrerequisites:\n- Target server runs a maintenance Linux OS.\n- The files in the grub.zip archive must be extracted in /tmp.\n- The \"Create Stub Partition\" step must have been executed. \n\nThis script is intended to be used only as a Build Plan step.",
                "current": true
            },
            "source": "#!/opt/opsware/agent/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# lint_ignore=E501,I0011\n# Please do not change the two lines above. See PEP 8, PEP 263.\n\"\"\"\n    (C) Copyright 2013-2015 Hewlett-Packard Development Company, L.P.\n\n    This python script installs and configures Grub for BIOS and Grub2 for UEFI.\n\"\"\"\n\nimport os\nimport sys\nimport re\nimport glob\nimport shutil\nfrom cStringIO import StringIO\n\nfrom osprov.decorators import HandleShowErrorMessage\nfrom osprov.diskmgr.disk import LinuxDisk\nfrom osprov.networking.discovery import LinuxNetworkDiscovery\nfrom osprov.optparse_ext import OptionParser\nfrom osprov.osbp import logger\nfrom osprov.parsers.syslinux import Syslinux\nfrom osprov.util import process\nfrom osprov.errors import DiscoveryError, ShowErrorMessage, SetupError\nfrom osprov import helpers, media, netconfig\nfrom osprov.parsers.netconfig import SmartNetconfig, OLD_SYNTAX_WARNING\nfrom osprov.server.local import ThisLocalServer\nfrom osprov.constants import DEFAULT_INITRD_DIR, DEFAULT_SA_INITRD_MASK\nfrom osprov.wrappers.efibootmgr import EfiBootMgr, DiskBootEntry\nfrom osprov import ipaddr\n\nEC_INVALID_ARGS = 1\nEC_IG_FAILED = 5\nEC_GRUBMENU_FAILED = 6\nEC_NO_BOOTDISK = 7\n\nLOG = logger.getIt(\"install_configure_grub\")\n\n\n# for easier mocking\ndef _open(filepath, mode=\"r\"):\n    return open(filepath, mode)\n\n\ndef get_partition_name(device_name, partition_num):\n    \"\"\"Returns the partition with number partition_num for device_name\"\"\"\n    if not partition_num:\n        return device_name\n    base_name = os.path.basename(device_name)\n    if re.search(r\"c\\dd\\d\", base_name):\n        return device_name + \"p\" + str(partition_num)\n    return device_name + str(partition_num)\n\n\nclass Grub(object):\n    \"\"\" Helper class for configuring and installing the Grub boot loader. \"\"\"\n\n    MENU_PATHS = [\"boot/grub/menu.lst\"]\n    MODULES_PATH = \"boot/grub\"\n\n    def __init__(self, location):\n        self.location = location\n        self.grubinfo = self.validate()\n\n    def _getInfo(self):\n        info = {}\n        # first test for newer info.txt file\n        infofile = os.path.join(self.location, \"info.txt\")\n        if os.path.exists(infofile):\n            # get the path info from into.txt\n            execfile(infofile, info)\n            for value in [\"grub\", \"loaderfiles\"]:\n                if not info[value]:\n                    # expected value is missing\n                    return {}\n        else:\n            # set the required info values manually for older grub packages\n            info[\"grub\"] = \"sbin/grub\"\n            info[\"loaderfiles\"] = \"share/grub/i386-pc\"\n        return info\n\n    def validate(self):\n        \"\"\"    Performs some simple validation on the directory where GRUB is located.\n        info.txt can provide non default values for grub binary and loader files\n        and saves from hardcoding more paths in here.\n        info.txt should also contain version info for better tracking of versions.\n        required info entries are:\n                \"grub\"            - path to grub binary\n                \"loaderfiles\"   - path to loader files\n        \"\"\"\n        info = self._getInfo()\n        if not info:\n            return {}\n        # finally verify the paths\n        for path in [info[\"grub\"], info[\"loaderfiles\"]]:\n            if not os.path.exists(os.path.join(self.location, path)):\n                return {}\n        return info\n\n    def copyFilesTo(self, bootDiskMount):\n        \"\"\" Copies files to the location specified. \"\"\"\n        print(\"Copying Boot Loader files to runtime location\")\n        grubinfo = self.grubinfo\n        if not grubinfo:\n            raise ShowErrorMessage(\n                \"Failed to validate %s. A previous Build Plan step may be missing.\" % self.location)\n        targetLocation = os.path.join(bootDiskMount, self.MODULES_PATH)\n        helpers.makeDirs(targetLocation)\n        files = glob.glob(\"%s/*\" % os.path.join(self.location, grubinfo[\"loaderfiles\"]))\n        if not files:\n            raise ShowErrorMessage(\"No file to copy. A previous Build Plan step may be missing\")\n        for source in files:\n            destination = os.path.join(targetLocation, os.path.basename(source))\n            LOG.debug(\"Copying %s to %s\", source, destination)\n            shutil.copyfile(source, destination)\n\n    def install(self, bootDiskMount, bootDisk):\n        \"\"\"\n        Installs the files needed for GRuB on boot_disk.\n        Note that it will overwrite the Master Boot Record for boot_disk.\n        \"\"\"\n        self.copyFilesTo(bootDiskMount)\n        print(\"Preparing Boot Loader config script\")\n        config = list()\n        config.append(\"device (hd0) \" + bootDisk)\n        config.append(\"root (hd0,0)\")\n        config.append(\"install --stage2=%s/boot/grub/stage2 /boot/grub/stage1 d (hd0) \"\n                      \"/boot/grub/stage2 p /boot/grub/menu.lst\" % bootDiskMount)\n        config.append(\"quit\")\n        config_str = \"\\n\".join(config) + \"\\n\"\n\n        print(\"Installing Boot Loader\")\n        os.chmod(\"%s\" % os.path.join(self.location, self.grubinfo[\"grub\"]), 0777)\n        params = \"--batch --no-floppy --config-file=/boot/grub/menu.lst\"\n        process.runIt(\"%s %s\" %\n                      (os.path.join(self.location, self.grubinfo[\"grub\"]), params), input=config_str, quiet=True)\n        return config_str\n\n    def configureMenu(self, title, kernel, kernelArguments, initrds, keys):\n        \"\"\"    Creates a GRUB menu.lst configuration. \"\"\"\n        return \"\"\"\ndefault 0\ntimeout 5\ntitle %(title)s\nroot (hd0,0)\n\nkernel /%(kernel)s %(kernelArguments)s\ninitrd %(initrds)s\n\n\"\"\" % {\n            'title': title,\n            'kernel': kernel,\n            'kernelArguments': kernelArguments,\n            'initrds': ' '.join(initrds)\n        }\n\n\nclass Grub2(Grub):\n    BOOT_DIRECTORY = \"boot/\"\n    MENU_PATHS = [os.path.join(BOOT_DIRECTORY, \"grub/grub.cfg\"), os.path.join(BOOT_DIRECTORY, \"grub2/grub.cfg\")]\n    EFI_BOOT_DIR = \"EFI/BOOT/\"\n    EFI_BOOT_PATH = os.path.join(EFI_BOOT_DIR)\n    EFI_CMD_SUFFIX = \"\"\n\n    def _getInfo(self):\n        info = dict()\n        info[\"grub\"] = \"sbin/grub-install\"\n        info[\"loaderfiles\"] = \"lib/grub/x86_64-efi\"\n        return info\n\n    def install(self, bootDiskMount, bootDisk):\n        secureBootLoader = self.configureSecureBootLoader(bootDiskMount)\n        if not secureBootLoader:\n            process.runIt(\"%(grub-install)s --removable --efi-directory=%(bootDiskMount)s --boot-directory=%(bootDirectory)s %(bootDisk)s\"\n                          % {'grub-install': os.path.join(self.location, self.grubinfo['grub']),\n                             'bootDiskMount': bootDiskMount,\n                             'bootDirectory': os.path.join(bootDiskMount, self.BOOT_DIRECTORY),\n                             'bootDisk': bootDisk}, log=LOG, quiet=True)\n            # configure the UEFI boot entries\n            osInstallerBootEntry = DiskBootEntry(\"HPSA Assisted OS Installer\", disk=bootDisk)\n        else:\n            # configure the UEFI boot entries with specific path to loader\n            print(\"Found UEFI secure boot files in media\")\n            osInstallerBootEntry = DiskBootEntry(\"HPSA Assisted OS Installer\", disk=bootDisk, loader=secureBootLoader)\n        efibootmgr = EfiBootMgr(log=LOG)\n        efibootmgr.bootOneTime(osInstallerBootEntry)\n        print(\"Configured boot to: %s\" % osInstallerBootEntry)\n\n    def configureSecureBootLoader(self, bootDiskMount):\n        keys = helpers.getDataStore()\n        mediaFS = media.factor(keys.media.url, log=LOG)\n        bootEFIFiles = mediaFS.findFiles(path=self.EFI_BOOT_DIR)\n        secureBootFiles = {'boot': None, 'grub': None}\n        for boot in bootEFIFiles:\n            if re.match(\"bootx64\\.efi\", boot, re.IGNORECASE):\n                secureBootFiles['boot'] = boot\n            if re.match(\"grubx64\\.efi\", boot, re.IGNORECASE):\n                secureBootFiles['grub'] = boot\n        LOG.debug(\"Boot files for SecureBoot found in media : %s\" % str(bootEFIFiles))\n        if secureBootFiles['boot'] and secureBootFiles['grub']:\n            # create path on stub partition\n            os.makedirs(os.path.join(bootDiskMount, self.EFI_BOOT_PATH))\n            for boot in bootEFIFiles:\n                if boot and \".efi\" in boot.lower():\n                    mediaFS.copyTo(os.path.join(self.EFI_BOOT_DIR, boot), os.path.join(bootDiskMount, self.EFI_BOOT_PATH))\n            # add new path for grub.cfg and efi suffix\n            self.MENU_PATHS.append(os.path.join(self.EFI_BOOT_PATH, \"grub.cfg\"))\n            self.EFI_CMD_SUFFIX = \"efi\"\n            return os.path.join(\"/\", self.EFI_BOOT_PATH, secureBootFiles['boot']).replace(\"/\", \"\\\\\")\n        return None\n\n    def configureMenu(self, title, kernel, kernelArguments, initrds, keys):\n        \"\"\" Creates a GRUB2 grub.conf configuration \"\"\"\n        return \"\"\"\nset default=0\nset timeout=5\n\ninsmod all_video\n\nmenuentry '%(title)s' {\n    linux%(efi)s  /%(kernel)s %(kernelArguments)s\n    initrd%(efi)s %(initrds)s\n}\n\n\"\"\" % {\n            'efi': self.EFI_CMD_SUFFIX,\n            'title': title,\n            'kernel': kernel,\n            'kernelArguments': kernelArguments,\n            'initrds': ' '.join(initrds),\n            'device_uuid': keys.disk.device_uuid\n        }\n\n\ndef getGrub(bootDisk):\n    \"\"\" Factor a Grub or Grub2 object based on the partition table type of the boot disk \"\"\"\n    if bootDisk.partitionTableType == \"msdos\":\n        return Grub(\"/tmp/grub\")\n    else:\n        return Grub2(\"/tmp/grub2\")\n\n\ndef checkCompleteStaticNetData(netdata, ipv):\n    values = netdata.values()\n    if None in values or \"\" in values:\n        print \"WARNING: The provided %s static configuration is incomplete. The OS installer may fail.\" % ipv\n\n\ndef getIPv6NameServer():\n    lnd = LinuxNetworkDiscovery()\n    lnd.discover()\n    if lnd.netinfo.nics and lnd.netinfo.nics[0].ipv6DnsServers:\n        return lnd.netinfo.nics[0].ipv6DnsServers[0]\n    else:\n        return \"\"\n\n\ndef getNetworkingParams(mac, osdata, netconfig, isIPv6Managed):\n    try:\n        activeIface = [x for x in netconfig.nics if x.provisioning][0]\n    except IndexError:\n        raise SetupError(\"Found no provisioning interface\")\n\n    isRHEL7 = \"RHEL7\" == osdata[\"os_version\"]\n    ip_params = \"\"\n\n    if isIPv6Managed:\n        if activeIface.ipv6Autoconfig:\n            ip_params += \" \" + osdata[\"ip_config_auto6\"] % {'mac': mac}\n            # for RHEL7 on IPv6 we need to set the nameserver since dracut\n            # does not generate a proper dhcpv6 client config\n            # note that NetworkManager does eventually start after the squashfs.img is downloaded\n            # so it will overwrite what dracut configures\n            if \"RHEL7\" == osdata[\"os_version\"]:\n                ip_params += \" nameserver=%s\" % getIPv6NameServer()\n        elif activeIface.ipv6Networks:\n            net_data = {\n                \"ip\": (\"[%s]\" if isRHEL7 else \"%s\") % activeIface.ipv6Networks[0].ip,\n                \"mask\": activeIface.ipv6Networks[0].netmask,\n                \"prefix\": activeIface.ipv6Networks[0].prefixlen,\n                \"dns\": \"\",\n                \"gw\": \"\",\n                \"mac\": mac,\n            }\n            for dnsserv in activeIface.ipv6DnsServers:\n                net_data[\"dns\"] = dnsserv\n                break\n            for route in [x for x in netconfig.ipv6Routes if x.nic == activeIface]:\n                net_data[\"gw\"] = (\"[%s]\" if isRHEL7 else \"%s\") % route.gateway\n                break\n            # support for autoconf + static network in the installer\n            if isRHEL7 and activeIface.ipv6Autoconfig:\n                if not net_data[\"dns\"]:\n                    net_data[\"dns\"] = getIPv6NameServer()\n            ip_params += \" \" + (osdata[\"ip_config_static6\"] % net_data)\n            checkCompleteStaticNetData(net_data, \"IPv6\")\n        else:\n            print \"Can not complete network personalization. \" \\\n                  \"Auto configuration is turned off for IPv6 and there is no static address defined\"\n            sys.exit(37)\n    else:\n        if activeIface.ipv4Networks:\n            net_data = {\n                \"ip\": activeIface.ipv4Networks[0].ip,\n                \"mask\": activeIface.ipv4Networks[0].netmask,\n                \"dns\": \"\",\n                \"gw\": \"\",\n            }\n            for dnsserv in activeIface.dnsServers:\n                if isinstance(dnsserv, ipaddr.IPv4Address):\n                    net_data[\"dns\"] = dnsserv\n                    break\n            for route in [x for x in netconfig.ipv4Routes if x.nic == activeIface]:\n                net_data[\"gw\"] = route.gateway\n                break\n            ip_params += \" \" + (osdata[\"ip_config_static\"] % net_data)\n            checkCompleteStaticNetData(net_data, \"IPv4\")\n        elif activeIface.dhcpv4:\n            ip_params += \" \" + osdata[\"ip_config_dhcp\"]\n        else:\n            print \"Can not complete network personalization. \" \\\n                  \"DHCP is turned off for IPv4 and there is no static address defined\"\n            sys.exit(38)\n\n    return ip_params.strip()\n\n\ndef updateExecInstructions(params1=\"\", params2=\"\"):\n    \"\"\"If both params strings contain the exec argument, the method will remove it form second string and combine\n    the 2 instructions in to the first string\"\"\"\n    if params2.count(\"exec=\") and params1.count(\"exec=\"):\n        ip_param_exec = params2[params2.index(\"exec=\\\"\"):params2.index(\"\\\"\", params2.index(\"exec=\\\"\") + 6) + 1]\n        params2 = params2.replace(ip_param_exec, \"\")\n        if \"exec='\" in params1:\n            params1 = params1.replace(\"exec='\", \"exec='\" + ip_param_exec[6:-1] + \";\")\n        else:\n            params1 = params1.replace('exec=\"', 'exec=\"' + ip_param_exec[6:-1] + \";\")\n    return params1, params2\n\n\ndef configureKernelArguments(osdata, keys, netcfg_parser, kernel_arguments=\"\"):\n    \"\"\" Configures the kernel arguments \"\"\"\n    localServer = ThisLocalServer()\n    boot_disk = keys.disk.device_path\n    boot_disk_uuid = keys.disk.device_uuid\n    # to be used by install_params\n    root_partition = get_partition_name(boot_disk[5:], 1)\n    if \"SLES\" in osdata[\"os_version\"] and \"cciss\" in boot_disk:\n        boot_disk = \"%s//\" % boot_disk\n    # ALERT: do not remove lower(), SLES doesn't recognize a MAC address if upper\n    mac = localServer.getMACAddress().lower()\n    url = mediaUrl(keys)\n    arg_dict = {\n        \"mac\": mac,\n        \"boot_disk\": boot_disk,\n        \"root_partition\": root_partition,\n        \"boot_disk_uuid\": boot_disk_uuid,\n        \"url\": url.canonical(),\n        \"bootif\": netconfig.macToBootIf(mac)\n    }\n    kernel_params = osdata['install_params'] % arg_dict\n    if kernel_arguments:\n        print(\"Found kernel arguments: \" + kernel_arguments)\n        kernel_params = kernel_params + \" \" + kernel_arguments\n\n    # Handle TCP/IP settings to make sure that installers behave  ##\n    ip_params = getNetworkingParams(mac, osdata, netcfg_parser.info(), localServer.isIPv6Managed())\n    if ip_params:\n        print(\"Additional kernel arguments for network configuration: %s\" % ip_params)\n        kernel_params, ip_params = updateExecInstructions(params1=kernel_params, params2=ip_params)\n        kernel_params += \" \" + ip_params\n\n    # Limit ports only if we are doing NFS, sles 11 sp0 has issues with this setting\n    if url.scheme == \"nfs\":\n        # Make sure that the nfs client doesn't use the agent port\n        kernel_params += \" sunrpc.max_resvport=1000\"\n\n    # if present handle addonloc\n    if \"addonloc\" in osdata and osdata[\"addonloc\"]:\n        # Handle SLES addon sources (eg. by use of kISO content)\n        if \"SLES\" in osdata[\"os_version\"]:\n            if kernel_params.lower().find(\"addon=\") == -1:\n                # no addon parameter present - add it using the found location if any\n                print \"Boot Loader (SLES) auto appending kernel parameter \"\"addon=%s\"\" \" % osdata[\"addonloc\"]\n                kernel_params += \" addon=%s\" % osdata[\"addonloc\"]\n            else:\n                print \"Boot Loader (SLES) \"\"addon=\"\" parameter present - not auto appending\"\n\n    # tidy up the kernel_params to contain only one blank between and no trailing blanks\n    # required for SLES's picky addon parameter handler (would fail with nfs:// source)\n    kernel_params = ' '.join(kernel_params.split())\n\n    return kernel_params\n\n\ndef configureInitrds(osdata, keys):\n    # start with the default initrd\n    initrdlist = [\"/%s\" % osdata[\"initrd\"]]\n\n    discoverLocalRds(osdata, root=keys.disk.device_mount)\n\n    # if present add supplemental local initrds\n    if \"localrds\" in osdata:\n        for eachrd in osdata[\"localrds\"]:\n            initrdlist.append(eachrd)\n        # max number of initrds that can be handled is limited by the line length\n        # limit of grubs menu.lst: 1500 chars.\n        if len(initrdlist) > (1500 - 1):\n            raise DiscoveryError(\"INITRD parameter: Maximum parameter length (1500) exceeded! \"\n                                 \"- Too many additional initrd files found.\")\n    return initrdlist\n\n\ndef discoverLocalRds(osdata, root):\n    \"\"\" Get initrd files from /localrds directory \"\"\"\n    rds = helpers.findFiles(\n        path=os.path.join(root, DEFAULT_INITRD_DIR), mask=DEFAULT_SA_INITRD_MASK)\n    if rds:\n        rdlist = []\n        # add the local path to make it suitable for grub\n        for eachrd in rds:\n            rdlist.append(os.path.join(os.path.sep, DEFAULT_INITRD_DIR, eachrd))\n        osdata[\"localrds\"] = helpers.numericalSort(rdlist)\n    return\n\n\ndef discoverOsdata(osdata, keys):\n    \"\"\" Discover the kernel and initrd to use based on the media \"\"\"\n    # the copy boot media step should have run by now, so we work with the\n    # stub partition. This is just so we don't access the media twice\n    stub_path = keys.disk.device_mount\n    if not stub_path:\n        raise DiscoveryError(\"Cannot discover boot disk mount point. \"\n                             \"Was the stub partition created?\")\n    isocfg = Syslinux.readonly(_open(os.path.join(stub_path, \"isolinux.cfg\")))\n    isocfg_label = isocfg.info()[\"label \" + isocfg.first_non_local_label()]\n    # discover the kernel\n    osdata[\"kernel\"] = os.path.basename(isocfg_label[\"kernel\"])\n    # discover the initrd\n    append = isocfg_label[\"append\"].split(' ')\n    for each in append:\n        if '=' in each:\n            key, value = [x.strip() for x in each.split('=', 1)]\n            if key == \"initrd\":\n                osdata[\"initrd\"] = os.path.basename(value)\n    if \"initrd\" not in osdata:\n        raise DiscoveryError(\"Failed to discover the initrd\")\n\n    # verify the files are there otherwise the boot loader will fail to find them\n    kernel = os.path.join(stub_path, osdata[\"kernel\"])\n    initrd = os.path.join(stub_path, osdata[\"initrd\"])\n    if not os.path.exists(kernel) or not os.path.exists(initrd):\n        raise DiscoveryError(\"Failed to discover the boot kernel or initrd\")\n\n\ndef discoverSlesAddon(osdata, keys):\n    \"\"\" Discover addon directories for\n            SLES: kISO formatted media w/ \"addon\" directory\n    \"\"\"\n    url = mediaUrl(keys)\n    thismedia = media.factor(str(url))\n    # for SLES check for addon directory in the repository\n    SLES_ADDON_LOCATIONS = [\n        # common names for SLES addon directory\n        \"addon/\", \"ADDON/\", \"AddOn/\"\n    ]\n    for each_file in SLES_ADDON_LOCATIONS:\n        if thismedia.exists(each_file):\n            osdata[\"addonloc\"] = url.canonical() + \"/\" + each_file\n            print \"Boot Loader (SLES) ADDON directory found in source location: %s\" % osdata[\"addonloc\"]\n            return\n\n\ndef mediaUrl(keys):\n    \"\"\" determine the media server and path \"\"\"\n    url = keys.media.url\n    if not url:\n        # Fall back in case of old NFS mount script\n        mediaServer = _open(\"/tmp/osbp_info/media_server\", \"r\").read().strip()\n        mediaPath = _open(\"/tmp/osbp_info/media_path\", \"r\").read().strip()\n        mediaMount = _open(\"/tmp/osbp_info/media_mount\", \"r\").read().strip()\n        url = \"nfs://%s:%s/#%s\" % (mediaServer, mediaPath, mediaMount)\n    return media.parseUrl(url)\n\n\nclass InstallConfigureGrubOptionParser(OptionParser):\n    def defineOptions(self):\n        self.add_option(\"--kernel_arguments\", default=\"\",\n                        help=\"a string of arguments that will be passed to the OS installer kernel\")\n        self.add_option(\"--disableWarning\", dest=\"disableWarning\", action=\"store_true\",\n                        default=False,\n                        help=\"Do not show warnings of old hpsa_netconfig format\")\n\n\n@HandleShowErrorMessage(\"install and configure bootloader\", log=LOG)\ndef main():\n    options, remainingArgs = InstallConfigureGrubOptionParser().parse_args()\n    del remainingArgs\n\n    localServer = ThisLocalServer()\n    parser = SmartNetconfig.readwrite(\n        StringIO(HPSA_NETCONFIG),\n        activeMacAddress=localServer.getMACAddress(),\n        ipv6default=localServer.isIPv6Managed(),\n        log=LOG\n    )\n    if parser.info().oldSyntax and not options.disableWarning:\n        newFormat = parser.format()\n        print OLD_SYNTAX_WARNING + \"\\n%s\" % str(newFormat)\n\n    typosList = parser.getTyposList()\n    if typosList:\n        print(\"The following keys were not recognized in the netconfig CA and could be typos: %s\" % typosList)\n\n    keys = helpers.getDataStore()\n\n    bootDiskMount = keys.disk.device_mount\n    if not bootDiskMount:\n        raise DiscoveryError(\"Discovery of the boot disk mount point failed. \"\n                             \"Was the stub partition created?\", EC_NO_BOOTDISK)\n\n    bootDisk = LinuxDisk(keys.disk.device_path, None, None)\n    grub = getGrub(bootDisk)\n    try:\n        grub.install(bootDiskMount, bootDisk.getDeviceFilePath())\n    except (OSError, IOError), why:\n        print \"Installing GRuB failed. %s\" % why\n        return EC_IG_FAILED\n\n    # build.py will perform the needed substitutions here\n    osdata = dict()\n    osdata[\"os_display_name\"] = 'Oracle Enterprise Linux'\n    osdata[\"os_version\"] = 'OEL'\n    osdata[\"install_params\"] = 'ks=file:/user.ks.cfg  ksdevice=%(mac)s'\n    osdata[\"ip_config_static\"] = 'ip=%(ip)s gateway=%(gw)s netmask=%(mask)s'\n    osdata[\"ip_config_static6\"] = 'ip=%(ip)s gateway=%(gw)s netmask=%(mask)s'\n    osdata[\"ip_config_dhcp\"] = 'ip=dhcp noipv6'\n    osdata[\"ip_config_auto6\"] = 'ipv6=auto noipv4'\n\n    discoverOsdata(osdata, keys)\n    if \"SLES\" in osdata[\"os_version\"]:\n        discoverSlesAddon(osdata, keys)\n\n    title = 'HP SA assisted %s installer' % osdata['os_display_name']\n    kernelArguments = configureKernelArguments(osdata, keys, parser,\n                                               kernel_arguments=options.kernel_arguments + \" hpsa_monitoring_agent=1\")\n    initrds = configureInitrds(osdata, keys)\n\n    menu = grub.configureMenu(title,\n                              osdata['kernel'], kernelArguments,\n                              initrds, keys)\n    for menuPath in grub.MENU_PATHS:\n        if not os.path.exists(os.path.join(bootDiskMount, os.path.dirname(menuPath))):\n            os.makedirs(os.path.join(bootDiskMount, os.path.dirname(menuPath)))\n        _open(os.path.join(bootDiskMount, menuPath), \"w\").write(menu)\n\n    return 0\n\nHPSA_NETCONFIG = \"\"\"@hpsa_netconfig@\"\"\"\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n",
            "description": "Installs and configures GRUB (GRand Unified Boot Loader) onto the stub partition of the boot disk on the target server in order to enable the booting into the Oracle Enterprise Linux installation image.\n\nThe step will also auto detect directories with the names \"addon\", \"AddOn\" and \"ADDON\" in the repository and for SuSE Linux Enterprise Server installations append the proper \"addon='path-to-addon-dir' to the kernel parameters of the grub boot loader.\n\nUsage:\n\nThis script expects no command line arguments, but the following argument(s) can optionally be specified:\n    --kernel_arguments=KERNEL_ARGUMENTS\n                        a string of arguments that will be passed to the OS\n                        installer kernel\n    --disableWarning    Do not show warnings of old hpsa_netconfig format\n\nPrerequisites:\n- Target server runs a maintenance Linux OS.\n- The files in the grub.zip archive must be extracted in /tmp.\n- The \"Create Stub Partition\" step must have been executed. \n\nThis script is intended to be used only as a Build Plan step.",
            "status": null,
            "name": "Install bootloader for Oracle Enterprise Linux",
            "state": null,
            "eTag": "2015-06-13T04:48:57.000Z",
            "modified": "2015-06-13T04:48:57.000Z",
            "created": "2015-06-13T04:48:56.000Z",
            "category": "os-deployment-server-scripts",
            "uri": "/rest/os-deployment-server-scripts/730001"
        },
        {
            "runAsSuperUser": true,
            "serverChanging": true,
            "codeType": "SH",
            "displayCodeType": "Unix",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "1",
                    "createdBy": "opsware",
                    "createdDate": "2015-06-13T04:48:57.000Z",
                    "usage": "Installs and configures GRUB (GRand Unified Boot Loader) onto the stub partition of the boot disk on the target server in order to enable the booting into the RedHat Enterprise Linux 7 Server installation image.\n\nThe step will also auto detect directories with the names \"addon\", \"AddOn\" and \"ADDON\" in the repository and for SuSE Linux Enterprise Server installations append the proper \"addon='path-to-addon-dir' to the kernel parameters of the grub boot loader.\n\nUsage:\n\nThis script expects no command line arguments, but the following argument(s) can optionally be specified:\n    --kernel_arguments=KERNEL_ARGUMENTS\n                        a string of arguments that will be passed to the OS\n                        installer kernel\n    --disableWarning    Do not show warnings of old hpsa_netconfig format\n\nPrerequisites:\n- Target server runs a maintenance Linux OS.\n- The files in the grub.zip archive must be extracted in /tmp.\n- The \"Create Stub Partition\" step must have been executed. \n\nThis script is intended to be used only as a Build Plan step.",
                    "current": false
                },
                {
                    "versionLabel": "2",
                    "createdBy": "opsware",
                    "createdDate": "2015-08-04T07:30:21.000Z",
                    "usage": "Installs and configures GRUB (GRand Unified Boot Loader) onto the stub partition of the boot disk on the target server in order to enable the booting into the RedHat Enterprise Linux 7 Server installation image.\n\nThe step will also auto detect directories with the names \"addon\", \"AddOn\" and \"ADDON\" in the repository and for SuSE Linux Enterprise Server installations append the proper \"addon='path-to-addon-dir' to the kernel parameters of the grub boot loader.\n\nUsage:\n\nThis script expects no command line arguments, but the following argument(s) can optionally be specified:\n    --kernel_arguments=KERNEL_ARGUMENTS\n                        a string of arguments that will be passed to the OS\n                        installer kernel\n    --disableWarning    Do not show warnings of old hpsa_netconfig format\n\nPrerequisites:\n- Target server runs a maintenance Linux OS.\n- The files in the grub.zip archive must be extracted in /tmp.\n- The \"Create Stub Partition\" step must have been executed. \n\nThis script is intended to be used only as a Build Plan step.",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-08-04T07:30:21.000Z",
            "version": {
                "versionLabel": "2",
                "createdBy": "opsware",
                "createdDate": "2015-08-04T07:30:21.000Z",
                "usage": "Installs and configures GRUB (GRand Unified Boot Loader) onto the stub partition of the boot disk on the target server in order to enable the booting into the RedHat Enterprise Linux 7 Server installation image.\n\nThe step will also auto detect directories with the names \"addon\", \"AddOn\" and \"ADDON\" in the repository and for SuSE Linux Enterprise Server installations append the proper \"addon='path-to-addon-dir' to the kernel parameters of the grub boot loader.\n\nUsage:\n\nThis script expects no command line arguments, but the following argument(s) can optionally be specified:\n    --kernel_arguments=KERNEL_ARGUMENTS\n                        a string of arguments that will be passed to the OS\n                        installer kernel\n    --disableWarning    Do not show warnings of old hpsa_netconfig format\n\nPrerequisites:\n- Target server runs a maintenance Linux OS.\n- The files in the grub.zip archive must be extracted in /tmp.\n- The \"Create Stub Partition\" step must have been executed. \n\nThis script is intended to be used only as a Build Plan step.",
                "current": true
            },
            "source": "#!/opt/opsware/agent/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# lint_ignore=E501,I0011\n# Please do not change the two lines above. See PEP 8, PEP 263.\n\"\"\"\n    (C) Copyright 2013-2015 Hewlett-Packard Development Company, L.P.\n\n    This python script installs and configures Grub for BIOS and Grub2 for UEFI.\n\"\"\"\n\nimport os\nimport sys\nimport re\nimport glob\nimport shutil\nfrom cStringIO import StringIO\n\nfrom osprov.decorators import HandleShowErrorMessage\nfrom osprov.diskmgr.disk import LinuxDisk\nfrom osprov.networking.discovery import LinuxNetworkDiscovery\nfrom osprov.optparse_ext import OptionParser\nfrom osprov.osbp import logger\nfrom osprov.parsers.syslinux import Syslinux\nfrom osprov.util import process\nfrom osprov.errors import DiscoveryError, ShowErrorMessage, SetupError\nfrom osprov import helpers, media, netconfig\nfrom osprov.parsers.netconfig import SmartNetconfig, OLD_SYNTAX_WARNING\nfrom osprov.server.local import ThisLocalServer\nfrom osprov.constants import DEFAULT_INITRD_DIR, DEFAULT_SA_INITRD_MASK\nfrom osprov.wrappers.efibootmgr import EfiBootMgr, DiskBootEntry\nfrom osprov import ipaddr\n\nEC_INVALID_ARGS = 1\nEC_IG_FAILED = 5\nEC_GRUBMENU_FAILED = 6\nEC_NO_BOOTDISK = 7\n\nLOG = logger.getIt(\"install_configure_grub\")\n\n\n# for easier mocking\ndef _open(filepath, mode=\"r\"):\n    return open(filepath, mode)\n\n\ndef get_partition_name(device_name, partition_num):\n    \"\"\"Returns the partition with number partition_num for device_name\"\"\"\n    if not partition_num:\n        return device_name\n    base_name = os.path.basename(device_name)\n    if re.search(r\"c\\dd\\d\", base_name):\n        return device_name + \"p\" + str(partition_num)\n    return device_name + str(partition_num)\n\n\nclass Grub(object):\n    \"\"\" Helper class for configuring and installing the Grub boot loader. \"\"\"\n\n    MENU_PATHS = [\"boot/grub/menu.lst\"]\n    MODULES_PATH = \"boot/grub\"\n\n    def __init__(self, location):\n        self.location = location\n        self.grubinfo = self.validate()\n\n    def _getInfo(self):\n        info = {}\n        # first test for newer info.txt file\n        infofile = os.path.join(self.location, \"info.txt\")\n        if os.path.exists(infofile):\n            # get the path info from into.txt\n            execfile(infofile, info)\n            for value in [\"grub\", \"loaderfiles\"]:\n                if not info[value]:\n                    # expected value is missing\n                    return {}\n        else:\n            # set the required info values manually for older grub packages\n            info[\"grub\"] = \"sbin/grub\"\n            info[\"loaderfiles\"] = \"share/grub/i386-pc\"\n        return info\n\n    def validate(self):\n        \"\"\"    Performs some simple validation on the directory where GRUB is located.\n        info.txt can provide non default values for grub binary and loader files\n        and saves from hardcoding more paths in here.\n        info.txt should also contain version info for better tracking of versions.\n        required info entries are:\n                \"grub\"            - path to grub binary\n                \"loaderfiles\"   - path to loader files\n        \"\"\"\n        info = self._getInfo()\n        if not info:\n            return {}\n        # finally verify the paths\n        for path in [info[\"grub\"], info[\"loaderfiles\"]]:\n            if not os.path.exists(os.path.join(self.location, path)):\n                return {}\n        return info\n\n    def copyFilesTo(self, bootDiskMount):\n        \"\"\" Copies files to the location specified. \"\"\"\n        print(\"Copying Boot Loader files to runtime location\")\n        grubinfo = self.grubinfo\n        if not grubinfo:\n            raise ShowErrorMessage(\n                \"Failed to validate %s. A previous Build Plan step may be missing.\" % self.location)\n        targetLocation = os.path.join(bootDiskMount, self.MODULES_PATH)\n        helpers.makeDirs(targetLocation)\n        files = glob.glob(\"%s/*\" % os.path.join(self.location, grubinfo[\"loaderfiles\"]))\n        if not files:\n            raise ShowErrorMessage(\"No file to copy. A previous Build Plan step may be missing\")\n        for source in files:\n            destination = os.path.join(targetLocation, os.path.basename(source))\n            LOG.debug(\"Copying %s to %s\", source, destination)\n            shutil.copyfile(source, destination)\n\n    def install(self, bootDiskMount, bootDisk):\n        \"\"\"\n        Installs the files needed for GRuB on boot_disk.\n        Note that it will overwrite the Master Boot Record for boot_disk.\n        \"\"\"\n        self.copyFilesTo(bootDiskMount)\n        print(\"Preparing Boot Loader config script\")\n        config = list()\n        config.append(\"device (hd0) \" + bootDisk)\n        config.append(\"root (hd0,0)\")\n        config.append(\"install --stage2=%s/boot/grub/stage2 /boot/grub/stage1 d (hd0) \"\n                      \"/boot/grub/stage2 p /boot/grub/menu.lst\" % bootDiskMount)\n        config.append(\"quit\")\n        config_str = \"\\n\".join(config) + \"\\n\"\n\n        print(\"Installing Boot Loader\")\n        os.chmod(\"%s\" % os.path.join(self.location, self.grubinfo[\"grub\"]), 0777)\n        params = \"--batch --no-floppy --config-file=/boot/grub/menu.lst\"\n        process.runIt(\"%s %s\" %\n                      (os.path.join(self.location, self.grubinfo[\"grub\"]), params), input=config_str, quiet=True)\n        return config_str\n\n    def configureMenu(self, title, kernel, kernelArguments, initrds, keys):\n        \"\"\"    Creates a GRUB menu.lst configuration. \"\"\"\n        return \"\"\"\ndefault 0\ntimeout 5\ntitle %(title)s\nroot (hd0,0)\n\nkernel /%(kernel)s %(kernelArguments)s\ninitrd %(initrds)s\n\n\"\"\" % {\n            'title': title,\n            'kernel': kernel,\n            'kernelArguments': kernelArguments,\n            'initrds': ' '.join(initrds)\n        }\n\n\nclass Grub2(Grub):\n    BOOT_DIRECTORY = \"boot/\"\n    MENU_PATHS = [os.path.join(BOOT_DIRECTORY, \"grub/grub.cfg\"), os.path.join(BOOT_DIRECTORY, \"grub2/grub.cfg\")]\n    EFI_BOOT_DIR = \"EFI/BOOT/\"\n    EFI_BOOT_PATH = os.path.join(EFI_BOOT_DIR)\n    EFI_CMD_SUFFIX = \"\"\n\n    def _getInfo(self):\n        info = dict()\n        info[\"grub\"] = \"sbin/grub-install\"\n        info[\"loaderfiles\"] = \"lib/grub/x86_64-efi\"\n        return info\n\n    def install(self, bootDiskMount, bootDisk):\n        secureBootLoader = self.configureSecureBootLoader(bootDiskMount)\n        if not secureBootLoader:\n            process.runIt(\"%(grub-install)s --removable --efi-directory=%(bootDiskMount)s --boot-directory=%(bootDirectory)s %(bootDisk)s\"\n                          % {'grub-install': os.path.join(self.location, self.grubinfo['grub']),\n                             'bootDiskMount': bootDiskMount,\n                             'bootDirectory': os.path.join(bootDiskMount, self.BOOT_DIRECTORY),\n                             'bootDisk': bootDisk}, log=LOG, quiet=True)\n            # configure the UEFI boot entries\n            osInstallerBootEntry = DiskBootEntry(\"HPSA Assisted OS Installer\", disk=bootDisk)\n        else:\n            # configure the UEFI boot entries with specific path to loader\n            print(\"Found UEFI secure boot files in media\")\n            osInstallerBootEntry = DiskBootEntry(\"HPSA Assisted OS Installer\", disk=bootDisk, loader=secureBootLoader)\n        efibootmgr = EfiBootMgr(log=LOG)\n        efibootmgr.bootOneTime(osInstallerBootEntry)\n        print(\"Configured boot to: %s\" % osInstallerBootEntry)\n\n    def configureSecureBootLoader(self, bootDiskMount):\n        keys = helpers.getDataStore()\n        mediaFS = media.factor(keys.media.url, log=LOG)\n        bootEFIFiles = mediaFS.findFiles(path=self.EFI_BOOT_DIR)\n        secureBootFiles = {'boot': None, 'grub': None}\n        for boot in bootEFIFiles:\n            if re.match(\"bootx64\\.efi\", boot, re.IGNORECASE):\n                secureBootFiles['boot'] = boot\n            if re.match(\"grub(x64)?\\.efi\", boot, re.IGNORECASE):\n                secureBootFiles['grub'] = boot\n        LOG.debug(\"Boot files for SecureBoot found in media : %s\" % str(bootEFIFiles))\n        if secureBootFiles['boot'] and secureBootFiles['grub']:\n            # create path on stub partition\n            os.makedirs(os.path.join(bootDiskMount, self.EFI_BOOT_PATH))\n            for boot in bootEFIFiles:\n                if boot and \".efi\" in boot.lower():\n                    mediaFS.copyTo(os.path.join(self.EFI_BOOT_DIR, boot), os.path.join(bootDiskMount, self.EFI_BOOT_PATH))\n            # add new path for grub.cfg and efi suffix\n            self.MENU_PATHS.append(os.path.join(self.EFI_BOOT_PATH, \"grub.cfg\"))\n            self.EFI_CMD_SUFFIX = \"efi\"\n            return os.path.join(\"/\", self.EFI_BOOT_PATH, secureBootFiles['boot']).replace(\"/\", \"\\\\\")\n        return None\n\n    def configureMenu(self, title, kernel, kernelArguments, initrds, keys):\n        \"\"\" Creates a GRUB2 grub.conf configuration \"\"\"\n        return \"\"\"\nset default=0\nset timeout=5\n\ninsmod all_video\n\nmenuentry '%(title)s' {\n    linux%(efi)s  /%(kernel)s %(kernelArguments)s\n    initrd%(efi)s %(initrds)s\n}\n\n\"\"\" % {\n            'efi': self.EFI_CMD_SUFFIX,\n            'title': title,\n            'kernel': kernel,\n            'kernelArguments': kernelArguments,\n            'initrds': ' '.join(initrds),\n            'device_uuid': keys.disk.device_uuid\n        }\n\n\ndef getGrub(bootDisk):\n    \"\"\" Factor a Grub or Grub2 object based on the partition table type of the boot disk \"\"\"\n    if bootDisk.partitionTableType == \"msdos\":\n        return Grub(\"/tmp/grub\")\n    else:\n        return Grub2(\"/tmp/grub2\")\n\n\ndef checkCompleteStaticNetData(netdata, ipv):\n    values = netdata.values()\n    if None in values or \"\" in values:\n        print \"WARNING: The provided %s static configuration is incomplete. The OS installer may fail.\" % ipv\n\n\ndef getIPv6NameServer():\n    lnd = LinuxNetworkDiscovery()\n    lnd.discover()\n    if lnd.netinfo.nics and lnd.netinfo.nics[0].ipv6DnsServers:\n        return lnd.netinfo.nics[0].ipv6DnsServers[0]\n    else:\n        return \"\"\n\n\ndef getNetworkingParams(mac, osdata, netconfig, isIPv6Managed):\n    try:\n        activeIface = [x for x in netconfig.nics if x.provisioning][0]\n    except IndexError:\n        raise SetupError(\"Found no provisioning interface\")\n\n    isRHEL7 = \"RHEL7\" == osdata[\"os_version\"]\n    ip_params = \"\"\n\n    if isIPv6Managed:\n        if activeIface.ipv6Autoconfig:\n            ip_params += \" \" + osdata[\"ip_config_auto6\"] % {'mac': mac}\n            # for RHEL7 on IPv6 we need to set the nameserver since dracut\n            # does not generate a proper dhcpv6 client config\n            # note that NetworkManager does eventually start after the squashfs.img is downloaded\n            # so it will overwrite what dracut configures\n            if \"RHEL7\" == osdata[\"os_version\"]:\n                ip_params += \" nameserver=%s\" % getIPv6NameServer()\n        elif activeIface.ipv6Networks:\n            net_data = {\n                \"ip\": (\"[%s]\" if isRHEL7 else \"%s\") % activeIface.ipv6Networks[0].ip,\n                \"mask\": activeIface.ipv6Networks[0].netmask,\n                \"prefix\": activeIface.ipv6Networks[0].prefixlen,\n                \"dns\": \"\",\n                \"gw\": \"\",\n                \"mac\": mac,\n            }\n            for dnsserv in activeIface.ipv6DnsServers:\n                net_data[\"dns\"] = dnsserv\n                break\n            for route in [x for x in netconfig.ipv6Routes if x.nic == activeIface]:\n                net_data[\"gw\"] = (\"[%s]\" if isRHEL7 else \"%s\") % route.gateway\n                break\n            # support for autoconf + static network in the installer\n            if isRHEL7 and activeIface.ipv6Autoconfig:\n                if not net_data[\"dns\"]:\n                    net_data[\"dns\"] = getIPv6NameServer()\n            ip_params += \" \" + (osdata[\"ip_config_static6\"] % net_data)\n            checkCompleteStaticNetData(net_data, \"IPv6\")\n        else:\n            print \"Can not complete network personalization. \" \\\n                  \"Auto configuration is turned off for IPv6 and there is no static address defined\"\n            sys.exit(37)\n    else:\n        if activeIface.ipv4Networks:\n            net_data = {\n                \"ip\": activeIface.ipv4Networks[0].ip,\n                \"mask\": activeIface.ipv4Networks[0].netmask,\n                \"dns\": \"\",\n                \"gw\": \"\",\n            }\n            for dnsserv in activeIface.dnsServers:\n                if isinstance(dnsserv, ipaddr.IPv4Address):\n                    net_data[\"dns\"] = dnsserv\n                    break\n            for route in [x for x in netconfig.ipv4Routes if x.nic == activeIface]:\n                net_data[\"gw\"] = route.gateway\n                break\n            ip_params += \" \" + (osdata[\"ip_config_static\"] % net_data)\n            checkCompleteStaticNetData(net_data, \"IPv4\")\n        elif activeIface.dhcpv4:\n            ip_params += \" \" + osdata[\"ip_config_dhcp\"]\n        else:\n            print \"Can not complete network personalization. \" \\\n                  \"DHCP is turned off for IPv4 and there is no static address defined\"\n            sys.exit(38)\n\n    return ip_params.strip()\n\n\ndef updateExecInstructions(params1=\"\", params2=\"\"):\n    \"\"\"If both params strings contain the exec argument, the method will remove it form second string and combine\n    the 2 instructions in to the first string\"\"\"\n    if params2.count(\"exec=\") and params1.count(\"exec=\"):\n        ip_param_exec = params2[params2.index(\"exec=\\\"\"):params2.index(\"\\\"\", params2.index(\"exec=\\\"\") + 6) + 1]\n        params2 = params2.replace(ip_param_exec, \"\")\n        if \"exec='\" in params1:\n            params1 = params1.replace(\"exec='\", \"exec='\" + ip_param_exec[6:-1] + \";\")\n        else:\n            params1 = params1.replace('exec=\"', 'exec=\"' + ip_param_exec[6:-1] + \";\")\n    return params1, params2\n\n\ndef configureKernelArguments(osdata, keys, netcfg_parser, kernel_arguments=\"\"):\n    \"\"\" Configures the kernel arguments \"\"\"\n    localServer = ThisLocalServer()\n    boot_disk = keys.disk.device_path\n    boot_disk_uuid = keys.disk.device_uuid\n    # to be used by install_params\n    root_partition = get_partition_name(boot_disk[5:], 1)\n    if \"SLES\" in osdata[\"os_version\"] and \"cciss\" in boot_disk:\n        boot_disk = \"%s//\" % boot_disk\n    # ALERT: do not remove lower(), SLES doesn't recognize a MAC address if upper\n    mac = localServer.getMACAddress().lower()\n    url = mediaUrl(keys)\n    arg_dict = {\n        \"mac\": mac,\n        \"boot_disk\": boot_disk,\n        \"root_partition\": root_partition,\n        \"boot_disk_uuid\": boot_disk_uuid,\n        \"url\": url.canonical(),\n        \"bootif\": netconfig.macToBootIf(mac)\n    }\n    kernel_params = osdata['install_params'] % arg_dict\n    if kernel_arguments:\n        print(\"Found kernel arguments: \" + kernel_arguments)\n        kernel_params = kernel_params + \" \" + kernel_arguments\n\n    # Handle TCP/IP settings to make sure that installers behave  ##\n    ip_params = getNetworkingParams(mac, osdata, netcfg_parser.info(), localServer.isIPv6Managed())\n    if ip_params:\n        print(\"Additional kernel arguments for network configuration: %s\" % ip_params)\n        kernel_params, ip_params = updateExecInstructions(params1=kernel_params, params2=ip_params)\n        kernel_params += \" \" + ip_params\n\n    # Limit ports only if we are doing NFS, sles 11 sp0 has issues with this setting\n    if url.scheme == \"nfs\":\n        # Make sure that the nfs client doesn't use the agent port\n        kernel_params += \" sunrpc.max_resvport=1000\"\n\n    # if present handle addonloc\n    if \"addonloc\" in osdata and osdata[\"addonloc\"]:\n        # Handle SLES addon sources (eg. by use of kISO content)\n        if \"SLES\" in osdata[\"os_version\"]:\n            if kernel_params.lower().find(\"addon=\") == -1:\n                # no addon parameter present - add it using the found location if any\n                print \"Boot Loader (SLES) auto appending kernel parameter \"\"addon=%s\"\" \" % osdata[\"addonloc\"]\n                kernel_params += \" addon=%s\" % osdata[\"addonloc\"]\n            else:\n                print \"Boot Loader (SLES) \"\"addon=\"\" parameter present - not auto appending\"\n\n    # tidy up the kernel_params to contain only one blank between and no trailing blanks\n    # required for SLES's picky addon parameter handler (would fail with nfs:// source)\n    kernel_params = ' '.join(kernel_params.split())\n\n    return kernel_params\n\n\ndef configureInitrds(osdata, keys):\n    # start with the default initrd\n    initrdlist = [\"/%s\" % osdata[\"initrd\"]]\n\n    discoverLocalRds(osdata, root=keys.disk.device_mount)\n\n    # if present add supplemental local initrds\n    if \"localrds\" in osdata:\n        for eachrd in osdata[\"localrds\"]:\n            initrdlist.append(eachrd)\n        # max number of initrds that can be handled is limited by the line length\n        # limit of grubs menu.lst: 1500 chars.\n        if len(initrdlist) > (1500 - 1):\n            raise DiscoveryError(\"INITRD parameter: Maximum parameter length (1500) exceeded! \"\n                                 \"- Too many additional initrd files found.\")\n    return initrdlist\n\n\ndef discoverLocalRds(osdata, root):\n    \"\"\" Get initrd files from /localrds directory \"\"\"\n    rds = helpers.findFiles(\n        path=os.path.join(root, DEFAULT_INITRD_DIR), mask=DEFAULT_SA_INITRD_MASK)\n    if rds:\n        rdlist = []\n        # add the local path to make it suitable for grub\n        for eachrd in rds:\n            rdlist.append(os.path.join(os.path.sep, DEFAULT_INITRD_DIR, eachrd))\n        osdata[\"localrds\"] = helpers.numericalSort(rdlist)\n    return\n\n\ndef discoverOsdata(osdata, keys):\n    \"\"\" Discover the kernel and initrd to use based on the media \"\"\"\n    # the copy boot media step should have run by now, so we work with the\n    # stub partition. This is just so we don't access the media twice\n    stub_path = keys.disk.device_mount\n    if not stub_path:\n        raise DiscoveryError(\"Cannot discover boot disk mount point. \"\n                             \"Was the stub partition created?\")\n    isocfg = Syslinux.readonly(_open(os.path.join(stub_path, \"isolinux.cfg\")))\n    isocfg_label = isocfg.info()[\"label \" + isocfg.first_non_local_label()]\n    # discover the kernel\n    osdata[\"kernel\"] = os.path.basename(isocfg_label[\"kernel\"])\n    # discover the initrd\n    append = isocfg_label[\"append\"].split(' ')\n    for each in append:\n        if '=' in each:\n            key, value = [x.strip() for x in each.split('=', 1)]\n            if key == \"initrd\":\n                osdata[\"initrd\"] = os.path.basename(value)\n    if \"initrd\" not in osdata:\n        raise DiscoveryError(\"Failed to discover the initrd\")\n\n    # verify the files are there otherwise the boot loader will fail to find them\n    kernel = os.path.join(stub_path, osdata[\"kernel\"])\n    initrd = os.path.join(stub_path, osdata[\"initrd\"])\n    if not os.path.exists(kernel) or not os.path.exists(initrd):\n        raise DiscoveryError(\"Failed to discover the boot kernel or initrd\")\n\n\ndef discoverSlesAddon(osdata, keys):\n    \"\"\" Discover addon directories for\n            SLES: kISO formatted media w/ \"addon\" directory\n    \"\"\"\n    url = mediaUrl(keys)\n    thismedia = media.factor(str(url))\n    # for SLES check for addon directory in the repository\n    SLES_ADDON_LOCATIONS = [\n        # common names for SLES addon directory\n        \"addon/\", \"ADDON/\", \"AddOn/\"\n    ]\n    for each_file in SLES_ADDON_LOCATIONS:\n        if thismedia.exists(each_file):\n            osdata[\"addonloc\"] = url.canonical() + \"/\" + each_file\n            print \"Boot Loader (SLES) ADDON directory found in source location: %s\" % osdata[\"addonloc\"]\n            return\n\n\ndef mediaUrl(keys):\n    \"\"\" determine the media server and path \"\"\"\n    url = keys.media.url\n    if not url:\n        # Fall back in case of old NFS mount script\n        mediaServer = _open(\"/tmp/osbp_info/media_server\", \"r\").read().strip()\n        mediaPath = _open(\"/tmp/osbp_info/media_path\", \"r\").read().strip()\n        mediaMount = _open(\"/tmp/osbp_info/media_mount\", \"r\").read().strip()\n        url = \"nfs://%s:%s/#%s\" % (mediaServer, mediaPath, mediaMount)\n    return media.parseUrl(url)\n\n\nclass InstallConfigureGrubOptionParser(OptionParser):\n    def defineOptions(self):\n        self.add_option(\"--kernel_arguments\", default=\"\",\n                        help=\"a string of arguments that will be passed to the OS installer kernel\")\n        self.add_option(\"--disableWarning\", dest=\"disableWarning\", action=\"store_true\",\n                        default=False,\n                        help=\"Do not show warnings of old hpsa_netconfig format\")\n\n\n@HandleShowErrorMessage(\"install and configure bootloader\", log=LOG)\ndef main():\n    options, remainingArgs = InstallConfigureGrubOptionParser().parse_args()\n    del remainingArgs\n\n    localServer = ThisLocalServer()\n    parser = SmartNetconfig.readwrite(\n        StringIO(HPSA_NETCONFIG),\n        activeMacAddress=localServer.getMACAddress(),\n        ipv6default=localServer.isIPv6Managed(),\n        log=LOG\n    )\n    if parser.info().oldSyntax and not options.disableWarning:\n        newFormat = parser.format()\n        print OLD_SYNTAX_WARNING + \"\\n%s\" % str(newFormat)\n\n    typosList = parser.getTyposList()\n    if typosList:\n        print(\"The following keys were not recognized in the netconfig CA and could be typos: %s\" % typosList)\n\n    keys = helpers.getDataStore()\n\n    bootDiskMount = keys.disk.device_mount\n    if not bootDiskMount:\n        raise DiscoveryError(\"Discovery of the boot disk mount point failed. \"\n                             \"Was the stub partition created?\", EC_NO_BOOTDISK)\n\n    bootDisk = LinuxDisk(keys.disk.device_path, None, None)\n    grub = getGrub(bootDisk)\n    try:\n        grub.install(bootDiskMount, bootDisk.getDeviceFilePath())\n    except (OSError, IOError), why:\n        print \"Installing GRuB failed. %s\" % why\n        return EC_IG_FAILED\n\n    # build.py will perform the needed substitutions here\n    osdata = dict()\n    osdata[\"os_display_name\"] = 'RedHat Enterprise Linux 7 Server'\n    osdata[\"os_version\"] = 'RHEL7'\n    osdata[\"install_params\"] = 'ks=file:/user.ks.cfg'\n    osdata[\"ip_config_static\"] = ''\n    osdata[\"ip_config_static6\"] = 'ifname=provisioning:%(mac)s bootdev=provisioning ip=%(ip)s::%(gw)s:%(prefix)s::provisioning:none: nameserver=%(dns)s'\n    osdata[\"ip_config_dhcp\"] = ''\n    osdata[\"ip_config_auto6\"] = 'ifname=provisioning:%(mac)s bootdev=provisioning ip=provisioning:auto6'\n\n    discoverOsdata(osdata, keys)\n    if \"SLES\" in osdata[\"os_version\"]:\n        discoverSlesAddon(osdata, keys)\n\n    title = 'HP SA assisted %s installer' % osdata['os_display_name']\n    kernelArguments = configureKernelArguments(osdata, keys, parser,\n                                               kernel_arguments=options.kernel_arguments + \" hpsa_monitoring_agent=1\")\n    initrds = configureInitrds(osdata, keys)\n\n    menu = grub.configureMenu(title,\n                              osdata['kernel'], kernelArguments,\n                              initrds, keys)\n    for menuPath in grub.MENU_PATHS:\n        if not os.path.exists(os.path.join(bootDiskMount, os.path.dirname(menuPath))):\n            os.makedirs(os.path.join(bootDiskMount, os.path.dirname(menuPath)))\n        _open(os.path.join(bootDiskMount, menuPath), \"w\").write(menu)\n\n    return 0\n\nHPSA_NETCONFIG = \"\"\"@hpsa_netconfig@\"\"\"\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n",
            "description": "Installs and configures GRUB (GRand Unified Boot Loader) onto the stub partition of the boot disk on the target server in order to enable the booting into the RedHat Enterprise Linux 7 Server installation image.\n\nThe step will also auto detect directories with the names \"addon\", \"AddOn\" and \"ADDON\" in the repository and for SuSE Linux Enterprise Server installations append the proper \"addon='path-to-addon-dir' to the kernel parameters of the grub boot loader.\n\nUsage:\n\nThis script expects no command line arguments, but the following argument(s) can optionally be specified:\n    --kernel_arguments=KERNEL_ARGUMENTS\n                        a string of arguments that will be passed to the OS\n                        installer kernel\n    --disableWarning    Do not show warnings of old hpsa_netconfig format\n\nPrerequisites:\n- Target server runs a maintenance Linux OS.\n- The files in the grub.zip archive must be extracted in /tmp.\n- The \"Create Stub Partition\" step must have been executed. \n\nThis script is intended to be used only as a Build Plan step.",
            "status": null,
            "name": "Install bootloader for RedHat Enterprise Linux 7 Server",
            "state": null,
            "eTag": "2015-08-04T07:30:21.000Z",
            "modified": "2015-08-04T07:30:21.000Z",
            "created": "2015-06-13T04:48:57.000Z",
            "category": "os-deployment-server-scripts",
            "uri": "/rest/os-deployment-server-scripts/740001"
        },
        {
            "runAsSuperUser": true,
            "serverChanging": true,
            "codeType": "PY2",
            "displayCodeType": "Python",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "1",
                    "createdBy": "opsware",
                    "createdDate": "2015-06-13T04:48:59.000Z",
                    "usage": "This script erases the partition table on all detected disk drives.\nThe first 1 MBytes of each disk are zero-ed out.\n\n** THIS CAUSES DATA LOSS **\n\nPrerequisites:\n- Target server runs a Linux OS.\n\nThis script is intended to be used only as a Build Plan step.",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-06-13T04:48:59.000Z",
            "version": {
                "versionLabel": "1",
                "createdBy": "opsware",
                "createdDate": "2015-06-13T04:48:59.000Z",
                "usage": "This script erases the partition table on all detected disk drives.\nThe first 1 MBytes of each disk are zero-ed out.\n\n** THIS CAUSES DATA LOSS **\n\nPrerequisites:\n- Target server runs a Linux OS.\n\nThis script is intended to be used only as a Build Plan step.",
                "current": true
            },
            "source": "#!/opt/opsware/agent/bin/python\n\"\"\"\n    (C) Copyright 2013-2015 Hewlett-Packard Development Company, L.P.\n\n    This script runs dd on all the devices on the server where it's run to\n    erase the partition table\n\"\"\"\n\nimport re\nimport sys\nimport subprocess\nfrom osprov.diskmgr.diskmanager import DiskManager\nfrom osprov.errors import ProcessExecutionError\nfrom osprov.osbp import logger\nfrom osprov.decorators import HandleShowErrorMessage\nfrom osprov.util import process\n\nLOG = logger.getIt(\"clean_server_disks\")\n\n\ndef scan():\n    \"\"\"\n    Get the list of (partitioned) hard drives on this server.\n    Uses 'parted -lm', which requires superuser permission.\n    @return: list of disks w/o Gaius flash media.\n    \"\"\"\n    validdisks = []\n    cmd = [\"parted\", \"--list\", \"--machine\"]\n    # /dev/sda:36.4GB:scsi:512:512:msdos:HP LOGICAL VOLUME;\n    regex = re.compile(r\"^(/dev/[hs]d\\w+):.*:.*:\\d+:\\d+:.*:(.*);$\")\n    devlist = process.getStdout(cmd)\n    for line in devlist.split('\\n'):\n        match = regex.match(line)\n        if match:\n            dev = match.group(1)\n            name = match.group(2)\n            if \"HP iLO LUN\" in name:\n                continue    # skip Gaius flash media\n            validdisks.append(dev)\n    return validdisks\n\ndef erasedisk(disklist, log=LOG):\n    \"\"\"\n    Get the list of hard drives on this server and run dd on it\n    to zero out the first 1M bytes.\n    @param disklist: List of available hd devices\n    @param log: logger\n    @return: nothing.\n    \"\"\"\n    for disk in disklist:\n        # For each device name returned, run dd on it\n        cmd = \"dd if=/dev/zero of=\" + disk + \" bs=8k count=128\"\n        process.runIt(cmd, log=log, quiet=True)\n        print \"Successfully erased disk \" + disk\n\n\n\n@HandleShowErrorMessage(\"Clean server disks\", log=LOG)\ndef main():\n    \"\"\" main function:\n     scan for valid disks and remove partition info on all of them\n     \"\"\"\n\n    dm = DiskManager(log=LOG)\n    dm.disable_automount()\n    dm.unmountOurs()\n    dm.unmountDisks(skipUsb=True)\n\n    inventory_disks = dm.get_disk_inventory()\n    disks = []\n    hdlist = scan()\n\n    # filtering out Gaius flash media from disk inventory\n    for temp_disk in inventory_disks:\n        if temp_disk.getDeviceFilePath() in hdlist:\n            disks.append(temp_disk)\n\n    # un-mount disks\n    for temp_disk in disks:\n        temp_disk.releaseAndUnload()\n\n    # remove partition info\n    erasedisk(hdlist)\n\n    # refreshing kernel partition table\n    for temp_disk in disks:\n        try:\n            temp_disk.rescan()\n        except ProcessExecutionError, why:\n            print \"Warning : Rereading partition table for %s failed : %s. \" \\\n                  \"Reboot to refresh partition table.\" % (temp_disk.getDeviceFilePath(), why)\n    return 0\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n",
            "description": "This script erases the partition table on all detected disk drives.\nThe first 1 MBytes of each disk are zero-ed out.\n\n** THIS CAUSES DATA LOSS **\n\nPrerequisites:\n- Target server runs a Linux OS.\n\nThis script is intended to be used only as a Build Plan step.",
            "status": null,
            "name": "Clean all Disks",
            "state": null,
            "eTag": "2015-06-13T04:48:59.000Z",
            "modified": "2015-06-13T04:48:59.000Z",
            "created": "2015-06-13T04:48:59.000Z",
            "category": "os-deployment-server-scripts",
            "uri": "/rest/os-deployment-server-scripts/790001"
        },
        {
            "runAsSuperUser": true,
            "serverChanging": true,
            "codeType": "PY2",
            "displayCodeType": "Python",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "1",
                    "createdBy": "opsware",
                    "createdDate": "2015-06-13T04:49:01.000Z",
                    "usage": "Will install grub on the stub partition and the MBR of its containing\ndisk. Also it will install a default menu.lst file.\n\nusage: install_grub.py [options]\n\noptions:\n  -h, --help            show this help message and exit\n  -o VERSION, --os-version=VERSION\n                        The Solaris OS version, valid values are: '11.1', '11 11/11', '10'\n\nPrerequisites:\n\n- This script must be run as part of a Build Plan under a Solaris Service OS on x86\n- This script must be run after 'Create Solaris Stub Partition'",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-06-13T04:49:01.000Z",
            "version": {
                "versionLabel": "1",
                "createdBy": "opsware",
                "createdDate": "2015-06-13T04:49:01.000Z",
                "usage": "Will install grub on the stub partition and the MBR of its containing\ndisk. Also it will install a default menu.lst file.\n\nusage: install_grub.py [options]\n\noptions:\n  -h, --help            show this help message and exit\n  -o VERSION, --os-version=VERSION\n                        The Solaris OS version, valid values are: '11.1', '11 11/11', '10'\n\nPrerequisites:\n\n- This script must be run as part of a Build Plan under a Solaris Service OS on x86\n- This script must be run after 'Create Solaris Stub Partition'",
                "current": true
            },
            "source": "#!/opt/opsware/agent/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n\"\"\"\n    (C) Copyright 2013-2015 Hewlett-Packard Development Company, L.P.\n\n    This program will install grub on the stub partition and the MBR of its containing\n    disk. Also it will install a default grub.cfg file depending on the OS.\n\"\"\"\n\nimport os\nimport sys\n\nfrom osprov import helpers\nfrom osprov.util import process\nfrom osprov.optparse_ext import OptionParser, OptionValueError\nfrom osprov.decorators import HandleShowErrorMessage\nfrom osprov.errors import NotSupportedError, DiscoveryError\nfrom osprov.osbp import logger\nfrom osprov.server.local import ThisLocalServer\n\nGRUB_CFG_DEST = \"boot/grub/grub.cfg\"\n\nSOLARIS10_GRUB_CFG_TEMPLATE = \"\"\"\nset timeout=10\nset default=\"0\"\n\nmenuentry \"HPSA assisted Oracle Solaris %(osVersion)s install\" {\n    search --no-floppy --file --set=root /@/sol-x86/multiboot\n    set mod=/@/sol-x86/x86.miniroot\n    set kern=/@/sol-x86/multiboot\n    echo -n \"Loading (${root})$kern:\"\n    multiboot $kern $kern kernel/unix - install dhcp file:///jumpstart/config.tar\n    echo -n \"Loading $mod:\"\n    module $mod $mod\n}\n\"\"\"\n\nSOLARIS11_GRUB_CFG_TEMPLATE = \"\"\"set timeout=10\nset default=\"0\"\n\nmenuentry \"HPSA assisted Oracle Solaris %(osVersion)s install\" {\n    search --no-floppy --file --set=root /@/platform/i86pc/kernel/amd64/unix\n    set kern=/@/platform/i86pc/kernel/amd64/unix\n    echo -n \"Loading (${root})$kern: \"\n    multiboot $kern $kern -B install=true,install_media=,install_service=,install_svc_address=,hpsaagw=%(gwIpPort)s,livemode=text\n    echo -n \"Loading (${root})/platform/i86pc/amd64/boot_archive: \"\n    module /@/platform/i86pc/amd64/boot_archive\n}\n\"\"\"\n\nLOG = logger.getIt(\"Install Solaris Grub\")\n\n\nclass InstallSolarisGrubOptionParser (OptionParser):\n\n    def defineOptions(self):\n        self.add_option(\"-o\", \"--os-version\", dest=\"version\",\n                        help=\"The Solaris OS version, valid values are: '10', '11.1', '11 11/11'\")\n\n    def validateArgs(self, opt, args):\n        if not opt.version:\n            raise OptionValueError(\"Must specify an OS version argument\")\n        elif not opt.version.startswith(\"11\") and not opt.version.startswith(\"10\"):\n            raise OptionValueError(\"Only Solaris 10 and Solaris 11 are supported\")\n\n\ndef getGrubTemplate(osVersion):\n    \"\"\"Return GRUB template for the specified OS Version.\"\"\"\n    if osVersion.startswith(\"10\"):\n        return SOLARIS10_GRUB_CFG_TEMPLATE\n    if osVersion.startswith(\"11\"):\n        return SOLARIS11_GRUB_CFG_TEMPLATE\n\n\ndef writeGrubCfg(opts, agw, grubCfgDest):\n    LOG.info(\"Writing final grub.cfg file.\")\n    g = open(grubCfgDest, \"w\")\n    g.write(getGrubTemplate(opts.version) % {\n            'osVersion': opts.version,\n            'gwIpPort': agw\n            })\n    g.close()\n\n\n@HandleShowErrorMessage(\"Install Solaris Grub\", LOG)\ndef main():\n    \"\"\"Installs grub on stub partition.\"\"\"\n\n    if not os.uname()[-1].startswith(\"i86\"):\n        raise NotSupportedError(\"Installing grub is not supported on SPARC.\")\n\n    opts, args = InstallSolarisGrubOptionParser().parse_args()\n\n    keys = helpers.getDataStore()\n    rawDevpath = keys.disk.device_path\n    stubMountpoint = keys.disk.device_mount\n    grubCfgDest = os.path.join(stubMountpoint, GRUB_CFG_DEST)\n    grubCfgDir = os.path.dirname(grubCfgDest)\n\n    if not os.path.isdir(grubCfgDir):\n        os.makedirs(grubCfgDir)\n\n    LOG.info(\"Determining Agent Gateway.\")\n    agwIpPort = ThisLocalServer().getRandomAgentGateway()\n    if agwIpPort is None:\n        raise DiscoveryError(\"Could not determine the agent gateway\")\n\n    grubCmd = \"/usr/lib/grub2/bios/sbin/grub-install --grub-directory=%s --recheck --force --force-mbr %s\" % (\n        grubCfgDir, rawDevpath)\n    process.runIt(grubCmd, log=LOG)\n\n    writeGrubCfg(opts, agwIpPort, grubCfgDest)\n\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n",
            "description": "Will install grub on the stub partition and the MBR of its containing\ndisk. Also it will install a default menu.lst file.\n\nusage: install_grub.py [options]\n\noptions:\n  -h, --help            show this help message and exit\n  -o VERSION, --os-version=VERSION\n                        The Solaris OS version, valid values are: '11.1', '11 11/11', '10'\n\nPrerequisites:\n\n- This script must be run as part of a Build Plan under a Solaris Service OS on x86\n- This script must be run after 'Create Solaris Stub Partition'",
            "status": null,
            "name": "Install Solaris Grub",
            "state": null,
            "eTag": "2015-06-13T04:49:01.000Z",
            "modified": "2015-06-13T04:49:01.000Z",
            "created": "2015-06-13T04:49:01.000Z",
            "category": "os-deployment-server-scripts",
            "uri": "/rest/os-deployment-server-scripts/830001"
        },
        {
            "runAsSuperUser": false,
            "serverChanging": true,
            "codeType": "PY2",
            "displayCodeType": "Python",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "1",
                    "createdBy": "opsware",
                    "createdDate": "2015-06-13T04:49:02.000Z",
                    "usage": "Updates existing agent with new MID, crypto, and gateway information.\n\nPrerequisites:\n- Target server runs a maintenance Linux or Windows PE OS.\n\nThis script is intended to be used only as an OS Build Plan step.",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-06-13T04:49:02.000Z",
            "version": {
                "versionLabel": "1",
                "createdBy": "opsware",
                "createdDate": "2015-06-13T04:49:02.000Z",
                "usage": "Updates existing agent with new MID, crypto, and gateway information.\n\nPrerequisites:\n- Target server runs a maintenance Linux or Windows PE OS.\n\nThis script is intended to be used only as an OS Build Plan step.",
                "current": true
            },
            "source": "#!/usr/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n#\n\"\"\"\n    (C) Copyright 2012-2015 Hewlett-Packard Development Company, L.P.\n\n    Integrates the HP SA Agent into a server\n\n    This consists of:\n\n    * Copying the MID and crypto into place\n    * Updating the gateway information\n\"\"\"\nimport glob\nimport optparse\nimport os\nimport stat\nimport shutil\nimport string\nimport sys\nimport time\nimport stat\n\nfrom osprov import constants, helpers\nfrom osprov.server.local import ThisLocalServer\nfrom osprov.errors import ShowErrorMessage\nfrom osprov.errors import NotFoundError\nfrom osprov.server.local import linux, winpe\nfrom coglib import platform\n\nLOCAL_SERVER = ThisLocalServer()\n\n# backup timestamp\nBACKUP_TIMESTAMP = string.replace(time.ctime(time.time()), ':', '-')\n\n\ndef backupAndReplaceFile(sourceFile, destFile):\n\n    if not os.path.exists(sourceFile):\n        raise NotFoundError(\"Unable to find HP SA Agent file (\" + sourceFile +\n                            \").  Guest Customization is only supported when HP SA Agent is previously installed.\")\n\n    # backup and delete existing file\n    if os.path.exists(destFile):\n        # chmod to writable\n        os.chmod(destFile, stat.S_IWRITE | stat.S_IREAD)\n        shutil.copy(destFile, destFile + \".backup_\" + BACKUP_TIMESTAMP)\n        os.remove(destFile)\n\n    # copy new file\n    shutil.copy(sourceFile, destFile)\n    print \"Copy \" + sourceFile + \" to \" + destFile\n\n    if os.stat(destFile)[stat.ST_SIZE] == 0:\n        raise ShowErrorMessage(\"file %s copied over was size 0\" % destFile)\n\n\ndef copyMidCryptoGateway():\n    \"\"\"Copies the essential identity files from the OGFS Agent to the real OS filesystem.\n\n    Server is expected to already be agent-managed.\n\n    This include the unique machine identifier (MID) and the device-specific\n    crypto certificates.\n    \"\"\"\n\n    sourceMidFile = LOCAL_SERVER.MID_FILE\n    sourceGatewayFile = os.path.join(os.path.dirname(sourceMidFile), \"opswgw.args\")\n    sourceCryptoDir = LOCAL_SERVER.CRYPTO_DIR\n\n    #QC183457: Create a flag to indicate that the server requires sofware reg.\n    if isinstance(LOCAL_SERVER, linux.LinuxSOSLocalServer):\n        agent_folder_file_path =  constants.OGFS_SYSTEM_ROOT + platform.Platform().var_lc_path\n        open(os.path.join(agent_folder_file_path,\"agent\", \"no_sw_reg_requested\"), \"w+\").close()\n        mountPath = constants.OGFS_SYSTEM_ROOT\n        destMidFile = mountPath + sourceMidFile\n        destGatewayFile = mountPath + sourceGatewayFile\n        destCryptoDir = mountPath + sourceCryptoDir\n    else:\n        mountPath = helpers.getSystemDrive(\"@SystemPartition:C@\")\n        destMidFile = mountPath + sourceMidFile[1:]\n        destGatewayFile = mountPath + sourceGatewayFile[1:]\n        destCryptoDir = mountPath + sourceCryptoDir[1:]\n\n    backupAndReplaceFile(sourceMidFile, destMidFile)\n    backupAndReplaceFile(sourceGatewayFile, destGatewayFile)\n\n    # replace old crypto files with new crypto files\n    for srcCryptoFile in glob.glob(sourceCryptoDir + \"/*.*\"):\n        dstCryptoFile = destCryptoDir + \"/\" + os.path.basename(srcCryptoFile)\n        backupAndReplaceFile(srcCryptoFile, dstCryptoFile)\n\n    print \"This server's unique MID and crypto material successfully installed, and gateway value updated\"\n\n\ndef error(message):\n    sys.stderr.write(message + \"\\n\")\n\nif __name__ == \"__main__\":\n    try:\n        copyMidCryptoGateway()\n    except ShowErrorMessage, ex:\n        error(ex.args[0])\n        sys.exit(ex.args[1])\n",
            "description": "Updates existing agent with new MID, crypto, and gateway information.\n\nPrerequisites:\n- Target server runs a maintenance Linux or Windows PE OS.\n\nThis script is intended to be used only as an OS Build Plan step.",
            "status": null,
            "name": "Update HP SA Agent Information",
            "state": null,
            "eTag": "2015-06-13T04:49:02.000Z",
            "modified": "2015-06-13T04:49:02.000Z",
            "created": "2015-06-13T04:49:02.000Z",
            "category": "os-deployment-server-scripts",
            "uri": "/rest/os-deployment-server-scripts/850001"
        },
        {
            "runAsSuperUser": false,
            "serverChanging": true,
            "codeType": "SH",
            "displayCodeType": "Unix",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "1",
                    "createdBy": "opsware",
                    "createdDate": "2015-06-13T04:49:02.000Z",
                    "usage": "Create an ESXi module and add it to the list of modules to boot with.\n\nPrerequisites:\n- Target server runs a Linux OS.\n\nThis script is intended to be used only as a Build Plan step.",
                    "current": false
                },
                {
                    "versionLabel": "2",
                    "createdBy": "opsware",
                    "createdDate": "2015-08-04T07:29:56.000Z",
                    "usage": "Create an ESXi module and add it to the list of modules to boot with.\n\nPrerequisites:\n- Target server runs a Linux OS.\n\nThis script is intended to be used only as a Build Plan step.",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-08-04T07:29:56.000Z",
            "version": {
                "versionLabel": "2",
                "createdBy": "opsware",
                "createdDate": "2015-08-04T07:29:56.000Z",
                "usage": "Create an ESXi module and add it to the list of modules to boot with.\n\nPrerequisites:\n- Target server runs a Linux OS.\n\nThis script is intended to be used only as a Build Plan step.",
                "current": true
            },
            "source": "#!/opt/opsware/agent/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n\"\"\"\n    (C) Copyright 2009-2015 Hewlett-Packard Development Company, L.P.\n\n    Create a new ESXi module that will be picked up by the ESXi boot configuration\n\"\"\"\n\nimport sys\nimport optparse\nimport os\nfrom osprov.osbp import logger\nfrom osprov.util import process\nfrom osprov.errors import DiscoveryError\nfrom osprov import helpers\n\nLOG = logger.getIt('add ESXi module')\n\nTAR_CMD = \"tar -chz --format=gnu -f {archive} {source}\"\n\n\ndef discoverTarget():\n    \"\"\" discover the target partition \"\"\"\n    target = helpers.getDataStore().disk.device_mount\n    if not target:\n        raise DiscoveryError(\"Cannot determine target destination. \"\n                             \"Was the stub partition created?\")\n    return target\n\n\ndef findUnusedName():\n    \"\"\" Get a name that isn't used \"\"\"\n    start = 0\n    moduleDir = os.path.join(discoverTarget(), \"usermod\")\n    if not os.path.exists(moduleDir):\n        os.makedirs(moduleDir)\n    while os.path.exists(\"%s/mod%d\" % (moduleDir, start)):\n        start += 1\n    return \"%s/mod%d\" % (moduleDir, start)\n\n\ndef embed(opt):\n    \"\"\" Create an ESXi module from a file or directory \"\"\"\n    source = opt.source\n    target = findUnusedName()\n    modRoot = os.path.join(\"/tmp/_modroot\", os.path.basename(target))\n    alias_dir = os.path.join(modRoot, \"usr\")\n    alias_base = os.path.basename(source)\n    if opt.alias:\n        alias_base = opt.alias\n    alias = os.path.join(alias_dir, alias_base)\n    if not os.path.exists(alias_dir):\n        os.makedirs(alias_dir)\n    if os.path.exists(alias):\n        os.remove(alias)\n    os.symlink(source, alias)\n    if opt.double:\n        first = os.path.join(modRoot, alias_base + \".tar.gz\")\n        process.runIt(TAR_CMD.format(archive=first, source=\"usr\"),\n                      cwd=modRoot, quiet=True, log=LOG)\n        process.runIt(TAR_CMD.format(archive=target, source=alias_base + \".tar.gz\"),\n                      cwd=modRoot, quiet=True, log=LOG)\n        os.remove(first)\n    else:\n        process.runIt(TAR_CMD.format(archive=target, source=\"usr\"),\n                      cwd=modRoot, quiet=True, log=LOG)\n    print \"Adding %s to ESXi module\" % opt.source\n\n\ndef parseArgs(args):\n    \"\"\"Parse the command line arguments\"\"\"\n    parser = optparse.OptionParser(description=__doc__)\n    parser.add_option('-s', '--source',\n                      help=\"A file or directory to create a module from\",\n                      metavar=\"SOURCE\")\n    parser.add_option('-a', '--alias',\n                      help=\"Alias the file or directory\",\n                      metavar=\"ALIAS\")\n    parser.add_option('-d', '--double',\n                      help=\"Create a tar in tar image to get around VMware's vgz format\",\n                      action=\"store_true\", default=False)\n    opt, args = parser.parse_args(args)\n    if args:\n        parser.error(\"Additional positional arguments are not supported\")\n    if not opt.source:\n        parser.error(\"A source needs to be present\")\n    return opt\n\n\ndef main():\n    \"\"\" main entry point on the cmdline \"\"\"\n    opt = parseArgs(sys.argv[1:])\n    embed(opt)\n    return 0\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n",
            "description": "Create an ESXi module and add it to the list of modules to boot with.\n\nPrerequisites:\n- Target server runs a Linux OS.\n\nThis script is intended to be used only as a Build Plan step.",
            "status": null,
            "name": "Add ESXi Module",
            "state": null,
            "eTag": "2015-08-04T07:29:56.000Z",
            "modified": "2015-08-04T07:29:56.000Z",
            "created": "2015-06-13T04:49:02.000Z",
            "category": "os-deployment-server-scripts",
            "uri": "/rest/os-deployment-server-scripts/860001"
        },
        {
            "runAsSuperUser": true,
            "serverChanging": true,
            "codeType": "SH",
            "displayCodeType": "Unix",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "1",
                    "createdBy": "opsware",
                    "createdDate": "2015-06-13T04:49:03.000Z",
                    "usage": "Deploy an agent ( production or osprov ) to the target server.\n\nusage: deploy_from_agent_cache.py [options]\n\noptions:\n  -h, --help            show this help message and exit\n  -n NAME, --name=NAME  The name of the file to download\n  -d DEST, --dest=DEST  Where to download the agent. This can be both a file\n                        or a directory, absolute or relative. Directories will\n                        be created if they don't exist. The default is to\n                        create a file in the current directory with the same\n                        name. Directories that don't exist will be created,\n                        note however that the basename will be considered as a\n                        file\n  -g SERVER, --gateway=SERVER\n                        Optional server to download from. If not present the\n                        agent config will be used to determine a valid gateway\n\nPrerequisites:\n- Target server runs a Linux or Windows OS or a maintenance Linux or Windows PE OS.\n\nThis script is intended to be used only as a Build Plan step.",
                    "current": false
                },
                {
                    "versionLabel": "2",
                    "createdBy": "opsware",
                    "createdDate": "2015-08-04T07:30:01.000Z",
                    "usage": "Deploy an agent ( production or osprov ) to the target server.\n\nusage: deploy_from_agent_cache.py [options]\n\noptions:\n  -h, --help            show this help message and exit\n  -n NAME, --name=NAME  The name of the file to download\n  -d DEST, --dest=DEST  Where to download the agent. This can be both a file\n                        or a directory, absolute or relative. Directories will\n                        be created if they don't exist. The default is to\n                        create a file in the current directory with the same\n                        name. Directories that don't exist will be created,\n                        note however that the basename will be considered as a\n                        file\n  -g SERVER, --gateway=SERVER\n                        Optional server to download from. If not present the\n                        agent config will be used to determine a valid gateway\n\nPrerequisites:\n- Target server runs a Linux or Windows OS or a maintenance Linux or Windows PE OS.\n\nThis script is intended to be used only as a Build Plan step.",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-08-04T07:30:01.000Z",
            "version": {
                "versionLabel": "2",
                "createdBy": "opsware",
                "createdDate": "2015-08-04T07:30:01.000Z",
                "usage": "Deploy an agent ( production or osprov ) to the target server.\n\nusage: deploy_from_agent_cache.py [options]\n\noptions:\n  -h, --help            show this help message and exit\n  -n NAME, --name=NAME  The name of the file to download\n  -d DEST, --dest=DEST  Where to download the agent. This can be both a file\n                        or a directory, absolute or relative. Directories will\n                        be created if they don't exist. The default is to\n                        create a file in the current directory with the same\n                        name. Directories that don't exist will be created,\n                        note however that the basename will be considered as a\n                        file\n  -g SERVER, --gateway=SERVER\n                        Optional server to download from. If not present the\n                        agent config will be used to determine a valid gateway\n\nPrerequisites:\n- Target server runs a Linux or Windows OS or a maintenance Linux or Windows PE OS.\n\nThis script is intended to be used only as a Build Plan step.",
                "current": true
            },
            "source": "#!/opt/opsware/agent/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n\"\"\" \n    (C) Copyright 2009-2015 Hewlett-Packard Development Company, L.P.\n\n    Server script to download unit from the agent cache\n\"\"\"\nimport sys\nimport os\nimport socket\n\nfrom httplib import HTTPConnection\nfrom optparse import OptionParser\n\nfrom osprov.errors import ShowErrorMessage, DiscoveryError\nfrom osprov.osbp import logger\nfrom osprov.server.local import ThisLocalServer\nfrom osprov.util import process\nfrom osprov import helpers\nfrom osprov import sa\n\n# pylint: disable=E0611,F0401\nfrom pytwist.com.opsware.search import Filter\n# pylint: enable=E0611,F0401\n\nLOG = logger.getIt(\"deploy agent\")\n\n\ndef getShortName(platformName):\n    \"\"\" Translate platform name into the short form used to identify the agent \"\"\"\n    twistServer = sa.getTwistServer()\n    unitFilter = Filter()\n    unitFilter.setObjectType(\"platform\")\n    # Customer ID 15 is \"Opsware\"\n    unitFilter.setExpression(\"platform_name EQUAL_TO \\\"%s\\\"\" % platformName)\n    refs = twistServer.device.PlatformService.findPlatformRefs(unitFilter)\n    if not refs:\n        raise ShowErrorMessage(\"Unable to find HP SA Agent Installer package \"\n                               \"for platform '%s'. Most likely your platform name is incorrect or\"\n                               \" misspelled.\" % platformName)\n    platformVO = twistServer.device.PlatformService.getPlatformVO(refs[0])\n    return \"%s-%s\" % (platformVO.shortName, platformVO.version)\n\n\ndef getAgentName(platform, name):\n    \"\"\" Get the name of the agent given the platform short name \"\"\"\n    if not name:\n        name = \"osprov_ogfs_agent\"\n    platform = getShortName(platform)\n    return \"%s-%s\" % (name, platform)\n\n\ndef getGateway():\n    \"\"\" Use the agent configuration to determine valid gateway\n        If more GWs are present, one will be chosen by random.choice\n    \"\"\"\n    localServer = ThisLocalServer(log=LOG)\n    return localServer.getRandomAgentGateway()\n\n\ndef discoverPlatform():\n    \"\"\" Discover the platform of the agent that needs downloading\"\"\"\n    platform = helpers.getDataStore().platform.full_name\n    if not platform:\n        raise DiscoveryError(\"Failed to discover the needed platform.\")\n    return platform\n\n\ndef parseArgs(args):\n    \"\"\" parse and normalise arguments for the script \"\"\"\n    parser = OptionParser()\n    parser.add_option(\"-n\", \"--name\", metavar=\"NAME\",\n                      help=\"The name of the agent to retrieve\")\n    parser.add_option(\"-p\", \"--platform\", metavar=\"PLATFORM\",\n                      help=\"The platform for the agent\")\n    parser.add_option(\"-d\", \"--dest\", metavar=\"DEST\", default=None,\n                      help=\"Where to download the agent. This needs to be a full or relative \"\n                      \"path to a file. Directories along the path will be created if they don't \"\n                      \"exist.\")\n    parser.add_option(\"-g\", \"--gateway\",\n                      help=\"Optional server to download from. If not present the agents \"\n                            \"configuration will be used to determine a valid gateway\",\n                      metavar=\"SERVER\", default=None)\n    parser.add_option(\"-u\", \"--unzip\",\n                      help=\"Unzip and delete the agent in the directory where it was downloaded\",\n                      action=\"store_true\", default=False)\n    options, args = parser.parse_args(args)\n    if args:\n        parser.error(\"Additional positional arguments are not supported\")\n    if not options.dest:\n        parser.error(\"A destination must be provided\")\n    if not options.platform:\n        options.platform = discoverPlatform()\n    options.name = getAgentName(options.platform, options.name)\n    if not options.gateway:\n        gw = getGateway()\n        if not gw:\n            parser.error(\"Can't determine gateway. Please provide one.\")\n        options.gateway = gw\n    options.dest = os.path.abspath(options.dest)\n    return options\n\n\ndef download(server, unitName, dest):\n    \"\"\" Download the file from the Agent cache \"\"\"\n    dirname = os.path.dirname(dest)\n    if not os.path.exists(dirname):\n        os.makedirs(dirname)\n    conn = HTTPConnection(server)\n    conn.set_tunnel(\"127.0.0.1:8081\")\n    conn.connect()\n    conn.request(\"GET\", \"/%s\" % unitName)\n    resp = conn.getresponse()\n    if resp.status == 200:\n        dfile = open(dest, \"w\")\n        dfile.write(resp.read())\n        dfile.close()\n    else:\n        raise ShowErrorMessage(\"Download failed: %s %s\" % (resp.status, resp.reason))\n\n\ndef unzip(dest):\n    \"\"\" Unzip the agent \"\"\"\n    # we can't use zipfile.extractall(os.path.dirname(dest))\n    # since our python is old\n    process.runIt(\"/opt/opsware/agent/bin/unzip -d %s -o %s\" %\n                 (os.path.dirname(dest), dest),\n                  log=LOG, quiet=True, quieterr=True)\n    os.remove(dest)\n\n\ndef main():\n    options = parseArgs(sys.argv[1:])\n    try:\n        download(options.gateway, options.name, options.dest)\n        if options.unzip:\n            unzip(options.dest)\n            print \"Downloaded and extracted %s to %s\" % \\\n                (options.name, os.path.dirname(options.dest))\n        else:\n            print \"Downloaded %s to %s\" % (options.name, options.dest)\n    except socket.error, why:\n        LOG.exception(why)\n        print \"Cannot connect to %s : %s\" % (options.gateway, why)\n        return 1\n    except ShowErrorMessage, why:\n        print why\n        return 1\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n",
            "description": "Deploy an agent ( production or osprov ) to the target server.\n\nusage: deploy_from_agent_cache.py [options]\n\noptions:\n  -h, --help            show this help message and exit\n  -n NAME, --name=NAME  The name of the file to download\n  -d DEST, --dest=DEST  Where to download the agent. This can be both a file\n                        or a directory, absolute or relative. Directories will\n                        be created if they don't exist. The default is to\n                        create a file in the current directory with the same\n                        name. Directories that don't exist will be created,\n                        note however that the basename will be considered as a\n                        file\n  -g SERVER, --gateway=SERVER\n                        Optional server to download from. If not present the\n                        agent config will be used to determine a valid gateway\n\nPrerequisites:\n- Target server runs a Linux or Windows OS or a maintenance Linux or Windows PE OS.\n\nThis script is intended to be used only as a Build Plan step.",
            "status": null,
            "name": "Deploy Agent",
            "state": null,
            "eTag": "2015-08-04T07:30:01.000Z",
            "modified": "2015-08-04T07:30:01.000Z",
            "created": "2015-06-13T04:49:02.000Z",
            "category": "os-deployment-server-scripts",
            "uri": "/rest/os-deployment-server-scripts/870001"
        },
        {
            "runAsSuperUser": true,
            "serverChanging": true,
            "codeType": "BAT",
            "displayCodeType": "Windows .BAT",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "1",
                    "createdBy": "opsware",
                    "createdDate": "2015-06-13T04:49:03.000Z",
                    "usage": "Installs Windows 8.1 x64 from OS Media. Requires full path to setup.exe from the installation media.",
                    "current": false
                },
                {
                    "versionLabel": "2",
                    "createdBy": "opsware",
                    "createdDate": "2015-08-04T07:29:43.000Z",
                    "usage": "Installs Windows 8.1 x64 from OS Media. Requires full path to setup.exe from the installation media.",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-08-04T07:29:43.000Z",
            "version": {
                "versionLabel": "2",
                "createdBy": "opsware",
                "createdDate": "2015-08-04T07:29:43.000Z",
                "usage": "Installs Windows 8.1 x64 from OS Media. Requires full path to setup.exe from the installation media.",
                "current": true
            },
            "source": "@echo off\nsetlocal\nset SIG=WINPE64\nset ANSWER=X:\\Windows\\Temp\\Unattend.xml\nset ARGS=/noreboot /unattend:%ANSWER%\nset | find \"opswbasig=%SIG%\" > NUL\nif %ERRORLEVEL% NEQ 0 (\n    echo ERROR: Target server must be running %SIG% but it is not\n    exit /B 1\n)\nif X%1==X (\n    set SETUP=z:\\i386\\winnt32.exe\n) else (\n    set SETUP=%1\n)\nif not exist %SETUP% (\n    echo %SETUP% missing! Cannot install Windows.\n    exit /B 2\n)\nif not exist %ANSWER% (\n    echo %ANSWER% missing! Cannot install Windows.\n    exit /B 3\n)\n\n%SETUP% %ARGS%\n\nif %ERRORLEVEL% == 0 (\n    echo Windows setup completed successfully\n    exit\n) else (\n    echo ERROR: Windows setup exited status %ERRORLEVEL%\n    exit /B %ERRORLEVEL%\n)\n",
            "description": "Installs Windows 8.1 x64 from OS Media. Requires full path to setup.exe from the installation media.",
            "status": null,
            "name": "Run Windows 8.1 x64 Setup",
            "state": null,
            "eTag": "2015-08-04T07:29:43.000Z",
            "modified": "2015-08-04T07:29:43.000Z",
            "created": "2015-06-13T04:49:03.000Z",
            "category": "os-deployment-server-scripts",
            "uri": "/rest/os-deployment-server-scripts/880001"
        },
        {
            "runAsSuperUser": true,
            "serverChanging": true,
            "codeType": "PY2",
            "displayCodeType": "Python",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "1",
                    "createdBy": "opsware",
                    "createdDate": "2015-06-13T04:49:05.000Z",
                    "usage": "This program will copy the kernel and boot archive to the stub partition,\ncreating any necessary directory structure along the way.\n\nUsage: deploy_boot_files.py\n\nThis script expects no command line arguments.\n\nPrerequisites:\n\n- This script must be run as part of a Build Plan under a Solaris Service OS\n- This script must be run after 'Modify Boot Archive'",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-06-13T04:49:05.000Z",
            "version": {
                "versionLabel": "1",
                "createdBy": "opsware",
                "createdDate": "2015-06-13T04:49:05.000Z",
                "usage": "This program will copy the kernel and boot archive to the stub partition,\ncreating any necessary directory structure along the way.\n\nUsage: deploy_boot_files.py\n\nThis script expects no command line arguments.\n\nPrerequisites:\n\n- This script must be run as part of a Build Plan under a Solaris Service OS\n- This script must be run after 'Modify Boot Archive'",
                "current": true
            },
            "source": "#!/opt/opsware/agent/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n\"\"\"\n    (C) Copyright 2013-2015 Hewlett-Packard Development Company, L.P.\n\n    This program will copy the kernel and boot archive to the stub partition,\n    creating any necessary directory structure along the way.\n\"\"\"\n\nimport os\nimport sys\nimport shutil\n\nfrom osprov import helpers\nfrom osprov.osbp import logger\nfrom osprov.errors import NotSupportedError\nfrom osprov.decorators import HandleShowErrorMessage\n\n\ndef getOsStructs():\n    if os.uname()[-1].startswith(\"i86\"):\n        platform = os.uname()[-1]\n        return \"platform/%s/kernel/amd64/\" % platform, \"platform/%s/amd64/\" % platform\n    else:\n        raise NotSupportedError(\"Module not available yet on SPARC.\")\n\nLOG = logger.getIt(\"Install Boot Files\")\n\n\n@HandleShowErrorMessage(\"Install Solaris Boot Files\", LOG)\ndef main():\n    \"\"\"Main function to run when the module is executed as a script.\"\"\"\n\n    kernelDirStruct, baDirStruct = getOsStructs()\n\n    keys = helpers.getDataStore()\n    stub_path = keys.disk.device_mount\n    bootfiles_dir = os.path.join(stub_path, \"bootfiles\")\n\n    LOG.info(\"Creating directory structure for the boot files.\")\n    kernel_dir = os.path.join(stub_path, kernelDirStruct)\n    ba_dir = os.path.join(stub_path, baDirStruct)\n    helpers.makeDirs(kernel_dir)\n    helpers.makeDirs(ba_dir)\n\n    LOG.info(\"Copying the kernel and the boot archive to the stub partition.\")\n    shutil.copy2(os.path.join(bootfiles_dir, \"unix\"), kernel_dir)\n    shutil.copy2(os.path.join(bootfiles_dir, \"boot_archive\"), ba_dir)\n\n    LOG.info(\"Cleaning up the rest of the boot files.\")\n    shutil.rmtree(bootfiles_dir, ignore_errors=True)\n\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n",
            "description": "This program will copy the kernel and boot archive to the stub partition,\ncreating any necessary directory structure along the way.\n\nUsage: deploy_boot_files.py\n\nThis script expects no command line arguments.\n\nPrerequisites:\n\n- This script must be run as part of a Build Plan under a Solaris Service OS\n- This script must be run after 'Modify Boot Archive'",
            "status": null,
            "name": "Deploy Solaris Boot Files",
            "state": null,
            "eTag": "2015-06-13T04:49:05.000Z",
            "modified": "2015-06-13T04:49:05.000Z",
            "created": "2015-06-13T04:49:05.000Z",
            "category": "os-deployment-server-scripts",
            "uri": "/rest/os-deployment-server-scripts/920001"
        },
        {
            "runAsSuperUser": false,
            "serverChanging": true,
            "codeType": "SH",
            "displayCodeType": "Unix",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "1",
                    "createdBy": "opsware",
                    "createdDate": "2015-06-13T04:49:05.000Z",
                    "usage": "Installs a boot loader and configures it to boot into the ESXi installer.\n\nFor legacy BIOS the high level steps are\n1. Writing the EXTLINUX Master Boot Record to the boot disk\n2. Installing the EXTLINUX boot loader\n3. Creating the extlinux.conf configuration file\n\nFor UEFI the boot loader files are deployed from the ESXi OS media.\n\nThis script does not reboot the target server, but when this script completes,\nthe target server may be rebooted and the ESXi scripted install will begin.\n\nUsage:\n\n install_esxi_bootloader.sh [--kernel_arguments='args']\n\n\t--kernel_arguments :\n\t\t Pass on kernel arguments\n    --disableWarning :\n         Do not show warnings of old hpsa_netconfig format\n\nPrerequisites:\n- Target server runs a maintenance Linux OS.\n- The \"Create Stub Partition\" step has run.\n- The \"Set Media Source\" step has run.\n- The \"Copy Boot Media\" step has run.\n- For legacy BIOS the following must be available in /tmp:\n - /tmp/extlinux, the EXTLINUX bootloader installer\n - /tmp/mbr.bin, the EXTLINUX Master Boot Record binary image\n - /tmp/ks.cfg, the end user's Kickstart configuration file\n\nThis script is intended to be used only as a Build Plan step.",
                    "current": false
                },
                {
                    "versionLabel": "2",
                    "createdBy": "opsware",
                    "createdDate": "2015-08-04T07:30:13.000Z",
                    "usage": "Installs a boot loader and configures it to boot into the ESXi installer.\n\nFor legacy BIOS the high level steps are\n1. Writing the EXTLINUX Master Boot Record to the boot disk\n2. Installing the EXTLINUX boot loader\n3. Creating the extlinux.conf configuration file\n\nFor UEFI the boot loader files are deployed from the ESXi OS media.\n\nThis script does not reboot the target server, but when this script completes,\nthe target server may be rebooted and the ESXi scripted install will begin.\n\nUsage:\n\n install_esxi_bootloader.sh [--kernel_arguments='args']\n\n\t--kernel_arguments :\n\t\t Pass on kernel arguments\n    --disableWarning :\n         Do not show warnings of old hpsa_netconfig format\n\nPrerequisites:\n- Target server runs a maintenance Linux OS.\n- The \"Create Stub Partition\" step has run.\n- The \"Set Media Source\" step has run.\n- The \"Copy Boot Media\" step has run.\n- For legacy BIOS the following must be available in /tmp:\n - /tmp/extlinux, the EXTLINUX bootloader installer\n - /tmp/mbr.bin, the EXTLINUX Master Boot Record binary image\n - /tmp/ks.cfg, the end user's Kickstart configuration file\n\nThis script is intended to be used only as a Build Plan step.",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-08-04T07:30:13.000Z",
            "version": {
                "versionLabel": "2",
                "createdBy": "opsware",
                "createdDate": "2015-08-04T07:30:13.000Z",
                "usage": "Installs a boot loader and configures it to boot into the ESXi installer.\n\nFor legacy BIOS the high level steps are\n1. Writing the EXTLINUX Master Boot Record to the boot disk\n2. Installing the EXTLINUX boot loader\n3. Creating the extlinux.conf configuration file\n\nFor UEFI the boot loader files are deployed from the ESXi OS media.\n\nThis script does not reboot the target server, but when this script completes,\nthe target server may be rebooted and the ESXi scripted install will begin.\n\nUsage:\n\n install_esxi_bootloader.sh [--kernel_arguments='args']\n\n\t--kernel_arguments :\n\t\t Pass on kernel arguments\n    --disableWarning :\n         Do not show warnings of old hpsa_netconfig format\n\nPrerequisites:\n- Target server runs a maintenance Linux OS.\n- The \"Create Stub Partition\" step has run.\n- The \"Set Media Source\" step has run.\n- The \"Copy Boot Media\" step has run.\n- For legacy BIOS the following must be available in /tmp:\n - /tmp/extlinux, the EXTLINUX bootloader installer\n - /tmp/mbr.bin, the EXTLINUX Master Boot Record binary image\n - /tmp/ks.cfg, the end user's Kickstart configuration file\n\nThis script is intended to be used only as a Build Plan step.",
                "current": true
            },
            "source": "#!/opt/opsware/agent/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# lint_ignore=E501,I0011,C0301\n# Please do not change the two lines above. See PEP 8, PEP 263.\n\"\"\" \n    (C) Copyright 2013-2015 Hewlett-Packard Development Company, L.P.\n\n    For legacy BIOS it installs extlinux boot loader needed by ESXi to boot off a local disk.\n    For UEFI it deploys the boot loader from the ESXi OS media.\n\"\"\"\nimport os\nimport shutil\nimport sys\nfrom cStringIO import StringIO\nfrom optparse import OptionParser\n\nfrom osprov import helpers, ipaddr\nfrom osprov.decorators import HandleShowErrorMessage\nfrom osprov.diskmgr.disk import LinuxDisk\nfrom osprov.osbp import logger\nfrom osprov.parsers.syslinux import Syslinux\nfrom osprov.errors import DiscoveryError\nfrom osprov.util import process\nfrom osprov.server.local import ThisLocalServer\nfrom osprov.wrappers.efibootmgr import EfiBootMgr, DiskBootEntry\nfrom osprov.parsers.netconfig import SmartNetconfig, OLD_SYNTAX_WARNING\n\nLOG = logger.getIt(\"install ESXi bootloader\")\n\n\ndef _open(filePath, mode='r'):\n    return open(filePath, mode)\n\n\nclass InstallEsxiBootloader(object):\n\n    \"\"\" Install the extlinux boot loader   \"\"\"\n\n    def __init__(self, log=LOG):\n        \"\"\" Init the class \"\"\"\n        self.log = log\n        keys = helpers.getDataStore()\n        self.target = keys.disk.device_mount\n        if not self.target:\n            raise DiscoveryError(\"Cannot discover boot disk. \"\n                                 \"Was the stub partition created?\")\n        self.bootDisk = keys.disk.device_path\n\n    def installExtlinux(self):\n        \"\"\" Install the mbr \"\"\"\n        mbr = \"/tmp/mbr.bin\"\n        if not os.path.exists(mbr):\n            raise DiscoveryError(\"Cannot find the ESXi utilities. Was the zip installed?\")\n        disko = _open(self.bootDisk, \"wb\")\n        mbro = _open(mbr, \"rb\")\n        disko.write(mbro.read())\n        disko.close()\n        mbro.close()\n        ext = \"/tmp/extlinux\"\n        os.chmod(ext, 0755)\n        process.runIt(\"/tmp/extlinux --install %s\" % self.target, log=self.log, quiet=True)\n\n    def discoverAdditionalModules(self):\n        return [os.path.join(\"/usermod\", x) for x in (os.listdir(os.path.join(self.target, \"usermod\")))]\n\n    def discoverBootCfg(self, isocfgLabel):\n        \"\"\" Returns the path to boot.cfg on the stub partition \"\"\"\n        try:\n            where = isocfgLabel[\"append\"].find(\"-c\")\n        except KeyError:\n            raise DiscoveryError(\"Failed to discover boot modules\")\n        if where >= 0:\n            bootCfg = isocfgLabel[\"append\"][where + 2:].strip().split(' ', 1)[0]\n            bootCfg = os.path.join(self.target, bootCfg)\n        else:\n            bootCfg = None\n        return bootCfg\n\n    def configureExtlinux(self, isocfgLabel, additionalModules, kernelArguments, withBootCfg):\n        \"\"\" Configure the bootloader  \"\"\"\n        extcfg = Syslinux.readwrite(\n            _open(os.path.join(self.target, \"extlinux.conf\"), \"w+b\"), writeback=True)\n        extcfg.info()[\"default\"] = \"esxi\"\n        extcfg.info()[\"prompt\"] = 0\n        extcfg.info()[\"timeout\"] = 100\n        kernelArguments = \" \" + kernelArguments.strip()\n        if not withBootCfg:\n            modules = isocfgLabel[\"append\"].split(\" --- \")\n            modules.extend(additionalModules)\n            modules[0] += kernelArguments\n            isocfgLabel[\"append\"] = \" --- \".join(modules)\n        extcfg.info()[\"label esxi\"] = isocfgLabel\n        return extcfg\n\n    def configureBootCfg(self, bootCfg, additionalModules=[], kernelopts=\"\"):\n        bootcfg = Syslinux.Bootcfg.readwrite(bootCfg, writeback=True)\n        bootcfg.info()[\"modules\"].extend(additionalModules)\n        bootcfg.info()[\"kernelopt\"] += \" \" + kernelopts\n        return bootcfg\n\n    def defaultKernelArguments(self, netinfo, isIPv6Managed):\n        \"\"\" Compute default kernel arguments  \"\"\"\n        provisioningNIC = [x for x in netinfo.nics if x.provisioning][0]\n\n        provisioningRoutes = [iproute for iproute in (netinfo.ipv6Routes if isIPv6Managed else netinfo.ipv4Routes)\n                              if iproute.nic == provisioningNIC]\n\n        kernelArguments = [\"ks=file:///usr/ks.cfg\"]\n        # ESXi 4.1 works with BOOTIF for DHCP, but static fails without the workaround\n        # ESXi 5 works with both BOOTIF and netdevice for DHCP and static\n        kernelArguments.append(\"BOOTIF=%s\" % provisioningNIC.macAddress.asBootIf())\n        for ipNetwork in provisioningNIC.ipv6Networks if isIPv6Managed else provisioningNIC.ipv4Networks:\n            print \"Configuring network: %s\" % ipNetwork\n            kernelArguments.append(\"ip=%s\" % ipNetwork.ip)\n            if isinstance(ipNetwork, ipaddr.IPv6Network):\n                kernelArguments.append(\"netmask=%s\" % ipNetwork.prefixlen)\n            else:\n                kernelArguments.append(\"netmask=%s\" % ipNetwork.netmask)\n            break\n        # use the stack-aware DNS server, if any\n        for dnsServer in provisioningNIC.ipv6DnsServers if isIPv6Managed else provisioningNIC.ipv4DnsServers:\n            kernelArguments.append(\"nameserver=%s\" % dnsServer)\n            break\n        if provisioningRoutes:\n            kernelArguments.append(\"gateway=%s\" % provisioningRoutes[0].gateway)\n        if provisioningNIC.vlan_id is not None:\n            kernelArguments.append(\"vlanid=%s\" % provisioningNIC.vlan_id)\n        # make weasel more verbose\n        # kernelArguments.append(\"debug\")\n        self.log.debug(\"Computed kernel arguments are: %s\" % kernelArguments)\n        return \" \".join(kernelArguments)\n\n    def parseArgs(self, args):\n        parser = OptionParser()\n        parser.add_option(\"-k\", \"--kernel_arguments\", dest=\"kernel_args\", default=\"\",\n                          help=\"add additional kernel arguments FILE\", metavar=\"FILE\")\n        parser.add_option(\"--disableWarning\", dest=\"disableWarning\", action=\"store_true\",\n                        default=False,\n                        help=\"Do not show warnings of old hpsa_netconfig format\")\n\n        options, rest = parser.parse_args(args)\n        return options\n\n    @HandleShowErrorMessage(\"install ESXi boot loader\", log=LOG)\n    def main(self, args):\n        options = self.parseArgs(args)\n\n        print \"Installing boot loader on %s\" % self.bootDisk\n\n        isocfg = Syslinux.readonly(_open(os.path.join(self.target, \"isolinux.cfg\")))\n        isocfgLabel = isocfg.info()[(\"label %s\" % isocfg.first_non_local_label())]\n        additionalModules = self.discoverAdditionalModules()\n\n        localServer = ThisLocalServer()\n        isIPv6Managed = localServer.isIPv6Managed()\n\n        netconfigParser = SmartNetconfig.readwrite(\n            StringIO(HPSA_NETCONFIG),\n            activeMacAddress=localServer.getMACAddress(),\n            ipv6default=isIPv6Managed,\n            log=LOG\n        )\n        netinfo = netconfigParser.info()\n        if netinfo.oldSyntax and not options.disableWarning:\n            newFormat = netconfigParser.format()\n            print OLD_SYNTAX_WARNING + \"\\n%s\" % str(newFormat)\n\n        typosList = netconfigParser.getTyposList()\n        if typosList:\n            print(\"The following keys were not recognized in the netconfig CA and could be typos: %s\" % typosList)\n\n        kernelArguments = \"%s %s\" % (self.defaultKernelArguments(netinfo, isIPv6Managed), options.kernel_args)\n\n        # ESXi5+ uses another boot loader + a boot.cfg file\n        bootCfgPath = self.discoverBootCfg(isocfgLabel)\n        if bootCfgPath:\n            self.configureBootCfg(_open(bootCfgPath), additionalModules, kernelArguments).save()\n\n        if \"msdos\" == LinuxDisk(self.bootDisk).partitionTableType:\n            print \"Found msdos partition table, configuring for BIOS boot\"\n            self.installExtlinux()\n            extlinuxConfig = self.configureExtlinux(\n                isocfgLabel, additionalModules, kernelArguments, bootCfgPath is not None\n            )\n            extlinuxConfig.save()\n        else:\n            print \"Found gpt partition table, configuring for UEFI boot\"\n            bootLoaderPath = os.path.join(self.target, \"bootx64.efi\")\n            if not bootCfgPath or not os.path.isfile(bootCfgPath) or not os.path.isfile(bootLoaderPath):\n                raise DiscoveryError(\"Failed to discover ESXi boot files.\"\n                                     \"This media is not suitable for a UEFI installation.\")\n            # deploy the files for UEFI boot\n            bootDir = os.path.join(self.target, \"efi/boot\")\n            helpers.makeDirs(bootDir)\n            shutil.copy2(bootCfgPath, bootDir)\n            shutil.copy2(bootLoaderPath, bootDir)\n            # configure the UEFI boot entries\n            osInstallerBootEntry = DiskBootEntry(\"HPSA Assisted OS Installer\", disk=self.bootDisk)\n            efibootmgr = EfiBootMgr(log=LOG)\n            efibootmgr.bootOneTime(osInstallerBootEntry)\n            print \"Configured boot to: %s\" % osInstallerBootEntry\n\n        print \"Successfully installed the boot loader\"\n\nHPSA_NETCONFIG = \"\"\"@hpsa_netconfig@\"\"\"\n\nif __name__ == \"__main__\":\n    sys.exit(InstallEsxiBootloader().main(sys.argv))\n",
            "description": "Installs a boot loader and configures it to boot into the ESXi installer.\n\nFor legacy BIOS the high level steps are\n1. Writing the EXTLINUX Master Boot Record to the boot disk\n2. Installing the EXTLINUX boot loader\n3. Creating the extlinux.conf configuration file\n\nFor UEFI the boot loader files are deployed from the ESXi OS media.\n\nThis script does not reboot the target server, but when this script completes,\nthe target server may be rebooted and the ESXi scripted install will begin.\n\nUsage:\n\n install_esxi_bootloader.sh [--kernel_arguments='args']\n\n\t--kernel_arguments :\n\t\t Pass on kernel arguments\n    --disableWarning :\n         Do not show warnings of old hpsa_netconfig format\n\nPrerequisites:\n- Target server runs a maintenance Linux OS.\n- The \"Create Stub Partition\" step has run.\n- The \"Set Media Source\" step has run.\n- The \"Copy Boot Media\" step has run.\n- For legacy BIOS the following must be available in /tmp:\n - /tmp/extlinux, the EXTLINUX bootloader installer\n - /tmp/mbr.bin, the EXTLINUX Master Boot Record binary image\n - /tmp/ks.cfg, the end user's Kickstart configuration file\n\nThis script is intended to be used only as a Build Plan step.",
            "status": null,
            "name": "Install bootloader for ESXi",
            "state": null,
            "eTag": "2015-08-04T07:30:13.000Z",
            "modified": "2015-08-04T07:30:13.000Z",
            "created": "2015-06-13T04:49:05.000Z",
            "category": "os-deployment-server-scripts",
            "uri": "/rest/os-deployment-server-scripts/930001"
        },
        {
            "runAsSuperUser": true,
            "serverChanging": true,
            "codeType": "PY2",
            "displayCodeType": "Python",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "1",
                    "createdBy": "opsware",
                    "createdDate": "2015-06-13T04:49:07.000Z",
                    "usage": "usage: [options] URL\n\noptions:\n--resolve-hostname Forces DNS resolution at this time. \n\nURL can be any of the supported schemes:\n\t-nfs: in the form of: nfs://server/path/to/media[#/path/to/mount/point]\n\t  if the mount point is omitted, it defaults to /mnt/media\n\t-smb: in the form of: smb://server/path/to/media[#X:]\n\t  if the mount drive is omitted, the default one is Z:\n\n-For HTTP the URL is http[s]://[username[:password]@]server/path\n-For NFS the URL is nfs://server/path[?nfs,mount,opts][#path/to/mount/point][?option=value]\n-For SMB the URL is smb://[[domain\\]username[:password]@]server/path[#X:]\n-For SMB under Linux the URL is smb://[[domain\\]username[:password]@]server/path[#/path/to/mount/point][?option=value]\n\nThe following limitations apply:\n- the character : is not supported in the username\n- the character @ is not supported in the network location (server)\n- the characters # and @ are not supported in the query\n- the characters ?#@ are not supported in the mount point\n- the characters \"' are allowed in the URL only if escaped or encoded\n- the space character is only allowed if escaped or encoded or if the URL is between single or double quotes\n\nPrerequisites:\n- Target server runs a Linux or Windows OS or a maintenance Linux or Windows PE OS.\nThis script is intended to be used only as a Build Plan step.",
                    "current": false
                },
                {
                    "versionLabel": "2",
                    "createdBy": "opsware",
                    "createdDate": "2015-08-04T07:30:03.000Z",
                    "usage": "usage: [options] URL\n\noptions:\n--resolve-hostname Forces DNS resolution at this time. \n\nURL can be any of the supported schemes:\n\t-nfs: in the form of: nfs://server/path/to/media[#/path/to/mount/point]\n\t  if the mount point is omitted, it defaults to /mnt/media\n\t-smb: in the form of: smb://server/path/to/media[#X:]\n\t  if the mount drive is omitted, the default one is Z:\n\n-For HTTP the URL is http[s]://[username[:password]@]server/path\n-For NFS the URL is nfs://server/path[?nfs,mount,opts][#path/to/mount/point][?option=value]\n-For SMB the URL is smb://[[domain\\]username[:password]@]server/path[#X:]\n-For SMB under Linux the URL is smb://[[domain\\]username[:password]@]server/path[#/path/to/mount/point][?option=value]\n\nThe following limitations apply:\n- the character : is not supported in the username\n- the character @ is not supported in the network location (server)\n- the characters # and @ are not supported in the query\n- the characters ?#@ are not supported in the mount point\n- the characters \"' are allowed in the URL only if escaped or encoded\n- the space character is only allowed if escaped or encoded or if the URL is between single or double quotes\n\nPrerequisites:\n- Target server runs a Linux or Windows OS or a maintenance Linux or Windows PE OS.\nThis script is intended to be used only as a Build Plan step.",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-08-04T07:30:03.000Z",
            "version": {
                "versionLabel": "2",
                "createdBy": "opsware",
                "createdDate": "2015-08-04T07:30:03.000Z",
                "usage": "usage: [options] URL\n\noptions:\n--resolve-hostname Forces DNS resolution at this time. \n\nURL can be any of the supported schemes:\n\t-nfs: in the form of: nfs://server/path/to/media[#/path/to/mount/point]\n\t  if the mount point is omitted, it defaults to /mnt/media\n\t-smb: in the form of: smb://server/path/to/media[#X:]\n\t  if the mount drive is omitted, the default one is Z:\n\n-For HTTP the URL is http[s]://[username[:password]@]server/path\n-For NFS the URL is nfs://server/path[?nfs,mount,opts][#path/to/mount/point][?option=value]\n-For SMB the URL is smb://[[domain\\]username[:password]@]server/path[#X:]\n-For SMB under Linux the URL is smb://[[domain\\]username[:password]@]server/path[#/path/to/mount/point][?option=value]\n\nThe following limitations apply:\n- the character : is not supported in the username\n- the character @ is not supported in the network location (server)\n- the characters # and @ are not supported in the query\n- the characters ?#@ are not supported in the mount point\n- the characters \"' are allowed in the URL only if escaped or encoded\n- the space character is only allowed if escaped or encoded or if the URL is between single or double quotes\n\nPrerequisites:\n- Target server runs a Linux or Windows OS or a maintenance Linux or Windows PE OS.\nThis script is intended to be used only as a Build Plan step.",
                "current": true
            },
            "source": "#!/opt/opsware/agent/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n\"\"\"\n    (C) Copyright 2009-2015 Hewlett-Packard Development Company, L.P.\n\n    Server script to set the media source to be used\n\"\"\"\nimport sys\nimport time\nimport socket\nfrom osprov.optparse_ext import OptionParser\n\nfrom osprov import helpers\nfrom osprov import media\nfrom osprov.util import process\nfrom osprov.errors import ShowErrorMessage\nfrom osprov.decorators import HandleShowErrorMessage\nfrom osprov.server.local import ThisLocalServer, ResolveNameException\nfrom osprov.osbp import logger\n\nLOG = logger.getIt(\"set_media_source\")\n\n\nclass CustomParser(OptionParser):\n\n    \"\"\" local, custom parser \"\"\"\n\n    def __init__(self, *args, **kwargs):\n        OptionParser.__init__(self, *args, **kwargs)\n\n    def defineOptions(self):\n        self.add_option(\"--resolve-hostname\", default=False, action=\"store_true\",\n                        dest=\"doDNS\",\n                        help=\"Forces DNS resolution at this time. Useful with installers with DNS issues.\"\n                        )\n\n    def validateArgs(self, opt, args):\n        if not args:\n            self.error(\"The URL is mandatory\")\n\n\ndef resolveHostname(parsedUrl):\n    \"\"\" Resolve the hostname in the URL to an IP address \"\"\"\n    server = ThisLocalServer()\n    if not parsedUrl.hostname:\n        raise ResolveNameException(\"Invalid url: %s\" % str(parsedUrl))\n    try:\n        hostname = server.firstIpByName(parsedUrl.hostname)\n    except ResolveNameException:\n        if helpers.isSolaris():\n            process.runIt('svcadm refresh name-service/switch', log=LOG)\n            time.sleep(1)\n            hostname = server.firstIpByName(parsedUrl.hostname)\n        else:\n            raise\n    port = parsedUrl.port\n    if hostname != parsedUrl.hostname:\n        print \"Resolved %s to %s\" % (parsedUrl.hostname, hostname)\n    if port:\n        parsedUrl.netloc = \"%s:%s\" % (hostname, port)\n    else:\n        parsedUrl.netloc = hostname\n\n\n@HandleShowErrorMessage(\"Set Media Source\", LOG)\ndef main():\n    \"\"\" Entry point if called form the cli  \"\"\"\n    parser = CustomParser(\"usage: %prog [options] url\")\n    options, args = parser.parse_args()\n    url = media.parseUrl(args[0])\n    if options.doDNS:\n        resolveHostname(url)\n    mediaObj = media.factor(str(url), log=LOG)\n    datastore = helpers.getDataStore()\n    datastore.media.url = str(url)\n    helpers.putDataStore(datastore)\n    print \"Successfully set media source %s\" % mediaObj\n\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n",
            "description": "usage: [options] URL\n\noptions:\n--resolve-hostname Forces DNS resolution at this time. \n\nURL can be any of the supported schemes:\n\t-nfs: in the form of: nfs://server/path/to/media[#/path/to/mount/point]\n\t  if the mount point is omitted, it defaults to /mnt/media\n\t-smb: in the form of: smb://server/path/to/media[#X:]\n\t  if the mount drive is omitted, the default one is Z:\n\n-For HTTP the URL is http[s]://[username[:password]@]server/path\n-For NFS the URL is nfs://server/path[?nfs,mount,opts][#path/to/mount/point][?option=value]\n-For SMB the URL is smb://[[domain\\]username[:password]@]server/path[#X:]\n-For SMB under Linux the URL is smb://[[domain\\]username[:password]@]server/path[#/path/to/mount/point][?option=value]\n\nThe following limitations apply:\n- the character : is not supported in the username\n- the character @ is not supported in the network location (server)\n- the characters # and @ are not supported in the query\n- the characters ?#@ are not supported in the mount point\n- the characters \"' are allowed in the URL only if escaped or encoded\n- the space character is only allowed if escaped or encoded or if the URL is between single or double quotes\n\nPrerequisites:\n- Target server runs a Linux or Windows OS or a maintenance Linux or Windows PE OS.\nThis script is intended to be used only as a Build Plan step.",
            "status": null,
            "name": "Set Media Source",
            "state": null,
            "eTag": "2015-08-04T07:30:03.000Z",
            "modified": "2015-08-04T07:30:03.000Z",
            "created": "2015-06-13T04:49:07.000Z",
            "category": "os-deployment-server-scripts",
            "uri": "/rest/os-deployment-server-scripts/970001"
        },
        {
            "runAsSuperUser": false,
            "serverChanging": false,
            "codeType": "SH",
            "displayCodeType": "Unix",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "1",
                    "createdBy": "opsware",
                    "createdDate": "2015-06-13T04:49:07.000Z",
                    "usage": "Syncs mounted filesystem to persist modified files",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-06-13T04:49:07.000Z",
            "version": {
                "versionLabel": "1",
                "createdBy": "opsware",
                "createdDate": "2015-06-13T04:49:07.000Z",
                "usage": "Syncs mounted filesystem to persist modified files",
                "current": true
            },
            "source": "#!/bin/sh\necho \"Syncing modified files in mounted filesystem\"\nsync",
            "description": "Syncs mounted filesystem to persist modified files",
            "status": null,
            "name": "Sync Mounted Filesystem (Linux)",
            "state": null,
            "eTag": "2015-06-13T04:49:07.000Z",
            "modified": "2015-06-13T04:49:07.000Z",
            "created": "2015-06-13T04:49:07.000Z",
            "category": "os-deployment-server-scripts",
            "uri": "/rest/os-deployment-server-scripts/980001"
        },
        {
            "runAsSuperUser": true,
            "serverChanging": true,
            "codeType": "SH",
            "displayCodeType": "Unix",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "1",
                    "createdBy": "opsware",
                    "createdDate": "2015-06-13T04:49:09.000Z",
                    "usage": "Installs and configures GRUB (GRand Unified Boot Loader) onto the stub partition of the boot disk on the target server in order to enable the booting into the SuSE Linux Enterprise Server installation image.\n\nThe step will also auto detect directories with the names \"addon\", \"AddOn\" and \"ADDON\" in the repository and for SuSE Linux Enterprise Server installations append the proper \"addon='path-to-addon-dir' to the kernel parameters of the grub boot loader.\n\nUsage:\n\nThis script expects no command line arguments, but the following argument(s) can optionally be specified:\n    --kernel_arguments=KERNEL_ARGUMENTS\n                        a string of arguments that will be passed to the OS\n                        installer kernel\n    --disableWarning    Do not show warnings of old hpsa_netconfig format\n\nPrerequisites:\n- Target server runs a maintenance Linux OS.\n- The files in the grub.zip archive must be extracted in /tmp.\n- The \"Create Stub Partition\" step must have been executed. \n\nThis script is intended to be used only as a Build Plan step.",
                    "current": false
                },
                {
                    "versionLabel": "2",
                    "createdBy": "opsware",
                    "createdDate": "2015-08-04T07:30:21.000Z",
                    "usage": "Installs and configures GRUB (GRand Unified Boot Loader) onto the stub partition of the boot disk on the target server in order to enable the booting into the SuSE Linux Enterprise Server installation image.\n\nThe step will also auto detect directories with the names \"addon\", \"AddOn\" and \"ADDON\" in the repository and for SuSE Linux Enterprise Server installations append the proper \"addon='path-to-addon-dir' to the kernel parameters of the grub boot loader.\n\nUsage:\n\nThis script expects no command line arguments, but the following argument(s) can optionally be specified:\n    --kernel_arguments=KERNEL_ARGUMENTS\n                        a string of arguments that will be passed to the OS\n                        installer kernel\n    --disableWarning    Do not show warnings of old hpsa_netconfig format\n\nPrerequisites:\n- Target server runs a maintenance Linux OS.\n- The files in the grub.zip archive must be extracted in /tmp.\n- The \"Create Stub Partition\" step must have been executed. \n\nThis script is intended to be used only as a Build Plan step.",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-08-04T07:30:21.000Z",
            "version": {
                "versionLabel": "2",
                "createdBy": "opsware",
                "createdDate": "2015-08-04T07:30:21.000Z",
                "usage": "Installs and configures GRUB (GRand Unified Boot Loader) onto the stub partition of the boot disk on the target server in order to enable the booting into the SuSE Linux Enterprise Server installation image.\n\nThe step will also auto detect directories with the names \"addon\", \"AddOn\" and \"ADDON\" in the repository and for SuSE Linux Enterprise Server installations append the proper \"addon='path-to-addon-dir' to the kernel parameters of the grub boot loader.\n\nUsage:\n\nThis script expects no command line arguments, but the following argument(s) can optionally be specified:\n    --kernel_arguments=KERNEL_ARGUMENTS\n                        a string of arguments that will be passed to the OS\n                        installer kernel\n    --disableWarning    Do not show warnings of old hpsa_netconfig format\n\nPrerequisites:\n- Target server runs a maintenance Linux OS.\n- The files in the grub.zip archive must be extracted in /tmp.\n- The \"Create Stub Partition\" step must have been executed. \n\nThis script is intended to be used only as a Build Plan step.",
                "current": true
            },
            "source": "#!/opt/opsware/agent/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# lint_ignore=E501,I0011\n# Please do not change the two lines above. See PEP 8, PEP 263.\n\"\"\"\n    (C) Copyright 2013-2015 Hewlett-Packard Development Company, L.P.\n\n    This python script installs and configures Grub for BIOS and Grub2 for UEFI.\n\"\"\"\n\nimport os\nimport sys\nimport re\nimport glob\nimport shutil\nfrom cStringIO import StringIO\n\nfrom osprov.decorators import HandleShowErrorMessage\nfrom osprov.diskmgr.disk import LinuxDisk\nfrom osprov.networking.discovery import LinuxNetworkDiscovery\nfrom osprov.optparse_ext import OptionParser\nfrom osprov.osbp import logger\nfrom osprov.parsers.syslinux import Syslinux\nfrom osprov.util import process\nfrom osprov.errors import DiscoveryError, ShowErrorMessage, SetupError\nfrom osprov import helpers, media, netconfig\nfrom osprov.parsers.netconfig import SmartNetconfig, OLD_SYNTAX_WARNING\nfrom osprov.server.local import ThisLocalServer\nfrom osprov.constants import DEFAULT_INITRD_DIR, DEFAULT_SA_INITRD_MASK\nfrom osprov.wrappers.efibootmgr import EfiBootMgr, DiskBootEntry\nfrom osprov import ipaddr\n\nEC_INVALID_ARGS = 1\nEC_IG_FAILED = 5\nEC_GRUBMENU_FAILED = 6\nEC_NO_BOOTDISK = 7\n\nLOG = logger.getIt(\"install_configure_grub\")\n\n\n# for easier mocking\ndef _open(filepath, mode=\"r\"):\n    return open(filepath, mode)\n\n\ndef get_partition_name(device_name, partition_num):\n    \"\"\"Returns the partition with number partition_num for device_name\"\"\"\n    if not partition_num:\n        return device_name\n    base_name = os.path.basename(device_name)\n    if re.search(r\"c\\dd\\d\", base_name):\n        return device_name + \"p\" + str(partition_num)\n    return device_name + str(partition_num)\n\n\nclass Grub(object):\n    \"\"\" Helper class for configuring and installing the Grub boot loader. \"\"\"\n\n    MENU_PATHS = [\"boot/grub/menu.lst\"]\n    MODULES_PATH = \"boot/grub\"\n\n    def __init__(self, location):\n        self.location = location\n        self.grubinfo = self.validate()\n\n    def _getInfo(self):\n        info = {}\n        # first test for newer info.txt file\n        infofile = os.path.join(self.location, \"info.txt\")\n        if os.path.exists(infofile):\n            # get the path info from into.txt\n            execfile(infofile, info)\n            for value in [\"grub\", \"loaderfiles\"]:\n                if not info[value]:\n                    # expected value is missing\n                    return {}\n        else:\n            # set the required info values manually for older grub packages\n            info[\"grub\"] = \"sbin/grub\"\n            info[\"loaderfiles\"] = \"share/grub/i386-pc\"\n        return info\n\n    def validate(self):\n        \"\"\"    Performs some simple validation on the directory where GRUB is located.\n        info.txt can provide non default values for grub binary and loader files\n        and saves from hardcoding more paths in here.\n        info.txt should also contain version info for better tracking of versions.\n        required info entries are:\n                \"grub\"            - path to grub binary\n                \"loaderfiles\"   - path to loader files\n        \"\"\"\n        info = self._getInfo()\n        if not info:\n            return {}\n        # finally verify the paths\n        for path in [info[\"grub\"], info[\"loaderfiles\"]]:\n            if not os.path.exists(os.path.join(self.location, path)):\n                return {}\n        return info\n\n    def copyFilesTo(self, bootDiskMount):\n        \"\"\" Copies files to the location specified. \"\"\"\n        print(\"Copying Boot Loader files to runtime location\")\n        grubinfo = self.grubinfo\n        if not grubinfo:\n            raise ShowErrorMessage(\n                \"Failed to validate %s. A previous Build Plan step may be missing.\" % self.location)\n        targetLocation = os.path.join(bootDiskMount, self.MODULES_PATH)\n        helpers.makeDirs(targetLocation)\n        files = glob.glob(\"%s/*\" % os.path.join(self.location, grubinfo[\"loaderfiles\"]))\n        if not files:\n            raise ShowErrorMessage(\"No file to copy. A previous Build Plan step may be missing\")\n        for source in files:\n            destination = os.path.join(targetLocation, os.path.basename(source))\n            LOG.debug(\"Copying %s to %s\", source, destination)\n            shutil.copyfile(source, destination)\n\n    def install(self, bootDiskMount, bootDisk):\n        \"\"\"\n        Installs the files needed for GRuB on boot_disk.\n        Note that it will overwrite the Master Boot Record for boot_disk.\n        \"\"\"\n        self.copyFilesTo(bootDiskMount)\n        print(\"Preparing Boot Loader config script\")\n        config = list()\n        config.append(\"device (hd0) \" + bootDisk)\n        config.append(\"root (hd0,0)\")\n        config.append(\"install --stage2=%s/boot/grub/stage2 /boot/grub/stage1 d (hd0) \"\n                      \"/boot/grub/stage2 p /boot/grub/menu.lst\" % bootDiskMount)\n        config.append(\"quit\")\n        config_str = \"\\n\".join(config) + \"\\n\"\n\n        print(\"Installing Boot Loader\")\n        os.chmod(\"%s\" % os.path.join(self.location, self.grubinfo[\"grub\"]), 0777)\n        params = \"--batch --no-floppy --config-file=/boot/grub/menu.lst\"\n        process.runIt(\"%s %s\" %\n                      (os.path.join(self.location, self.grubinfo[\"grub\"]), params), input=config_str, quiet=True)\n        return config_str\n\n    def configureMenu(self, title, kernel, kernelArguments, initrds, keys):\n        \"\"\"    Creates a GRUB menu.lst configuration. \"\"\"\n        return \"\"\"\ndefault 0\ntimeout 5\ntitle %(title)s\nroot (hd0,0)\n\nkernel /%(kernel)s %(kernelArguments)s\ninitrd %(initrds)s\n\n\"\"\" % {\n            'title': title,\n            'kernel': kernel,\n            'kernelArguments': kernelArguments,\n            'initrds': ' '.join(initrds)\n        }\n\n\nclass Grub2(Grub):\n    BOOT_DIRECTORY = \"boot/\"\n    MENU_PATHS = [os.path.join(BOOT_DIRECTORY, \"grub/grub.cfg\"), os.path.join(BOOT_DIRECTORY, \"grub2/grub.cfg\")]\n    EFI_BOOT_DIR = \"EFI/BOOT/\"\n    EFI_BOOT_PATH = os.path.join(EFI_BOOT_DIR)\n    EFI_CMD_SUFFIX = \"\"\n\n    def _getInfo(self):\n        info = dict()\n        info[\"grub\"] = \"sbin/grub-install\"\n        info[\"loaderfiles\"] = \"lib/grub/x86_64-efi\"\n        return info\n\n    def install(self, bootDiskMount, bootDisk):\n        secureBootLoader = self.configureSecureBootLoader(bootDiskMount)\n        if not secureBootLoader:\n            process.runIt(\"%(grub-install)s --removable --efi-directory=%(bootDiskMount)s --boot-directory=%(bootDirectory)s %(bootDisk)s\"\n                          % {'grub-install': os.path.join(self.location, self.grubinfo['grub']),\n                             'bootDiskMount': bootDiskMount,\n                             'bootDirectory': os.path.join(bootDiskMount, self.BOOT_DIRECTORY),\n                             'bootDisk': bootDisk}, log=LOG, quiet=True)\n            # configure the UEFI boot entries\n            osInstallerBootEntry = DiskBootEntry(\"HPSA Assisted OS Installer\", disk=bootDisk)\n        else:\n            # configure the UEFI boot entries with specific path to loader\n            print(\"Found UEFI secure boot files in media\")\n            osInstallerBootEntry = DiskBootEntry(\"HPSA Assisted OS Installer\", disk=bootDisk, loader=secureBootLoader)\n        efibootmgr = EfiBootMgr(log=LOG)\n        efibootmgr.bootOneTime(osInstallerBootEntry)\n        print(\"Configured boot to: %s\" % osInstallerBootEntry)\n\n    def configureSecureBootLoader(self, bootDiskMount):\n        keys = helpers.getDataStore()\n        mediaFS = media.factor(keys.media.url, log=LOG)\n        bootEFIFiles = mediaFS.findFiles(path=self.EFI_BOOT_DIR)\n        secureBootFiles = {'boot': None, 'grub': None}\n        for boot in bootEFIFiles:\n            if re.match(\"bootx64\\.efi\", boot, re.IGNORECASE):\n                secureBootFiles['boot'] = boot\n            if re.match(\"grub(x64)?\\.efi\", boot, re.IGNORECASE):\n                secureBootFiles['grub'] = boot\n        LOG.debug(\"Boot files for SecureBoot found in media : %s\" % str(bootEFIFiles))\n        if secureBootFiles['boot'] and secureBootFiles['grub']:\n            # create path on stub partition\n            os.makedirs(os.path.join(bootDiskMount, self.EFI_BOOT_PATH))\n            for boot in bootEFIFiles:\n                if boot and \".efi\" in boot.lower():\n                    mediaFS.copyTo(os.path.join(self.EFI_BOOT_DIR, boot), os.path.join(bootDiskMount, self.EFI_BOOT_PATH))\n            # add new path for grub.cfg and efi suffix\n            self.MENU_PATHS.append(os.path.join(self.EFI_BOOT_PATH, \"grub.cfg\"))\n            self.EFI_CMD_SUFFIX = \"efi\"\n            return os.path.join(\"/\", self.EFI_BOOT_PATH, secureBootFiles['boot']).replace(\"/\", \"\\\\\")\n        return None\n\n    def configureMenu(self, title, kernel, kernelArguments, initrds, keys):\n        \"\"\" Creates a GRUB2 grub.conf configuration \"\"\"\n        return \"\"\"\nset default=0\nset timeout=5\n\ninsmod all_video\n\nmenuentry '%(title)s' {\n    linux%(efi)s  /%(kernel)s %(kernelArguments)s\n    initrd%(efi)s %(initrds)s\n}\n\n\"\"\" % {\n            'efi': self.EFI_CMD_SUFFIX,\n            'title': title,\n            'kernel': kernel,\n            'kernelArguments': kernelArguments,\n            'initrds': ' '.join(initrds),\n            'device_uuid': keys.disk.device_uuid\n        }\n\n\ndef getGrub(bootDisk):\n    \"\"\" Factor a Grub or Grub2 object based on the partition table type of the boot disk \"\"\"\n    if bootDisk.partitionTableType == \"msdos\":\n        return Grub(\"/tmp/grub\")\n    else:\n        return Grub2(\"/tmp/grub2\")\n\n\ndef checkCompleteStaticNetData(netdata, ipv):\n    values = netdata.values()\n    if None in values or \"\" in values:\n        print \"WARNING: The provided %s static configuration is incomplete. The OS installer may fail.\" % ipv\n\n\ndef getIPv6NameServer():\n    lnd = LinuxNetworkDiscovery()\n    lnd.discover()\n    if lnd.netinfo.nics and lnd.netinfo.nics[0].ipv6DnsServers:\n        return lnd.netinfo.nics[0].ipv6DnsServers[0]\n    else:\n        return \"\"\n\n\ndef getNetworkingParams(mac, osdata, netconfig, isIPv6Managed):\n    try:\n        activeIface = [x for x in netconfig.nics if x.provisioning][0]\n    except IndexError:\n        raise SetupError(\"Found no provisioning interface\")\n\n    isRHEL7 = \"RHEL7\" == osdata[\"os_version\"]\n    ip_params = \"\"\n\n    if isIPv6Managed:\n        if activeIface.ipv6Autoconfig:\n            ip_params += \" \" + osdata[\"ip_config_auto6\"] % {'mac': mac}\n            # for RHEL7 on IPv6 we need to set the nameserver since dracut\n            # does not generate a proper dhcpv6 client config\n            # note that NetworkManager does eventually start after the squashfs.img is downloaded\n            # so it will overwrite what dracut configures\n            if \"RHEL7\" == osdata[\"os_version\"]:\n                ip_params += \" nameserver=%s\" % getIPv6NameServer()\n        elif activeIface.ipv6Networks:\n            net_data = {\n                \"ip\": (\"[%s]\" if isRHEL7 else \"%s\") % activeIface.ipv6Networks[0].ip,\n                \"mask\": activeIface.ipv6Networks[0].netmask,\n                \"prefix\": activeIface.ipv6Networks[0].prefixlen,\n                \"dns\": \"\",\n                \"gw\": \"\",\n                \"mac\": mac,\n            }\n            for dnsserv in activeIface.ipv6DnsServers:\n                net_data[\"dns\"] = dnsserv\n                break\n            for route in [x for x in netconfig.ipv6Routes if x.nic == activeIface]:\n                net_data[\"gw\"] = (\"[%s]\" if isRHEL7 else \"%s\") % route.gateway\n                break\n            # support for autoconf + static network in the installer\n            if isRHEL7 and activeIface.ipv6Autoconfig:\n                if not net_data[\"dns\"]:\n                    net_data[\"dns\"] = getIPv6NameServer()\n            ip_params += \" \" + (osdata[\"ip_config_static6\"] % net_data)\n            checkCompleteStaticNetData(net_data, \"IPv6\")\n        else:\n            print \"Can not complete network personalization. \" \\\n                  \"Auto configuration is turned off for IPv6 and there is no static address defined\"\n            sys.exit(37)\n    else:\n        if activeIface.ipv4Networks:\n            net_data = {\n                \"ip\": activeIface.ipv4Networks[0].ip,\n                \"mask\": activeIface.ipv4Networks[0].netmask,\n                \"dns\": \"\",\n                \"gw\": \"\",\n            }\n            for dnsserv in activeIface.dnsServers:\n                if isinstance(dnsserv, ipaddr.IPv4Address):\n                    net_data[\"dns\"] = dnsserv\n                    break\n            for route in [x for x in netconfig.ipv4Routes if x.nic == activeIface]:\n                net_data[\"gw\"] = route.gateway\n                break\n            ip_params += \" \" + (osdata[\"ip_config_static\"] % net_data)\n            checkCompleteStaticNetData(net_data, \"IPv4\")\n        elif activeIface.dhcpv4:\n            ip_params += \" \" + osdata[\"ip_config_dhcp\"]\n        else:\n            print \"Can not complete network personalization. \" \\\n                  \"DHCP is turned off for IPv4 and there is no static address defined\"\n            sys.exit(38)\n\n    return ip_params.strip()\n\n\ndef updateExecInstructions(params1=\"\", params2=\"\"):\n    \"\"\"If both params strings contain the exec argument, the method will remove it form second string and combine\n    the 2 instructions in to the first string\"\"\"\n    if params2.count(\"exec=\") and params1.count(\"exec=\"):\n        ip_param_exec = params2[params2.index(\"exec=\\\"\"):params2.index(\"\\\"\", params2.index(\"exec=\\\"\") + 6) + 1]\n        params2 = params2.replace(ip_param_exec, \"\")\n        if \"exec='\" in params1:\n            params1 = params1.replace(\"exec='\", \"exec='\" + ip_param_exec[6:-1] + \";\")\n        else:\n            params1 = params1.replace('exec=\"', 'exec=\"' + ip_param_exec[6:-1] + \";\")\n    return params1, params2\n\n\ndef configureKernelArguments(osdata, keys, netcfg_parser, kernel_arguments=\"\"):\n    \"\"\" Configures the kernel arguments \"\"\"\n    localServer = ThisLocalServer()\n    boot_disk = keys.disk.device_path\n    boot_disk_uuid = keys.disk.device_uuid\n    # to be used by install_params\n    root_partition = get_partition_name(boot_disk[5:], 1)\n    if \"SLES\" in osdata[\"os_version\"] and \"cciss\" in boot_disk:\n        boot_disk = \"%s//\" % boot_disk\n    # ALERT: do not remove lower(), SLES doesn't recognize a MAC address if upper\n    mac = localServer.getMACAddress().lower()\n    url = mediaUrl(keys)\n    arg_dict = {\n        \"mac\": mac,\n        \"boot_disk\": boot_disk,\n        \"root_partition\": root_partition,\n        \"boot_disk_uuid\": boot_disk_uuid,\n        \"url\": url.canonical(),\n        \"bootif\": netconfig.macToBootIf(mac)\n    }\n    kernel_params = osdata['install_params'] % arg_dict\n    if kernel_arguments:\n        print(\"Found kernel arguments: \" + kernel_arguments)\n        kernel_params = kernel_params + \" \" + kernel_arguments\n\n    # Handle TCP/IP settings to make sure that installers behave  ##\n    ip_params = getNetworkingParams(mac, osdata, netcfg_parser.info(), localServer.isIPv6Managed())\n    if ip_params:\n        print(\"Additional kernel arguments for network configuration: %s\" % ip_params)\n        kernel_params, ip_params = updateExecInstructions(params1=kernel_params, params2=ip_params)\n        kernel_params += \" \" + ip_params\n\n    # Limit ports only if we are doing NFS, sles 11 sp0 has issues with this setting\n    if url.scheme == \"nfs\":\n        # Make sure that the nfs client doesn't use the agent port\n        kernel_params += \" sunrpc.max_resvport=1000\"\n\n    # if present handle addonloc\n    if \"addonloc\" in osdata and osdata[\"addonloc\"]:\n        # Handle SLES addon sources (eg. by use of kISO content)\n        if \"SLES\" in osdata[\"os_version\"]:\n            if kernel_params.lower().find(\"addon=\") == -1:\n                # no addon parameter present - add it using the found location if any\n                print \"Boot Loader (SLES) auto appending kernel parameter \"\"addon=%s\"\" \" % osdata[\"addonloc\"]\n                kernel_params += \" addon=%s\" % osdata[\"addonloc\"]\n            else:\n                print \"Boot Loader (SLES) \"\"addon=\"\" parameter present - not auto appending\"\n\n    # tidy up the kernel_params to contain only one blank between and no trailing blanks\n    # required for SLES's picky addon parameter handler (would fail with nfs:// source)\n    kernel_params = ' '.join(kernel_params.split())\n\n    return kernel_params\n\n\ndef configureInitrds(osdata, keys):\n    # start with the default initrd\n    initrdlist = [\"/%s\" % osdata[\"initrd\"]]\n\n    discoverLocalRds(osdata, root=keys.disk.device_mount)\n\n    # if present add supplemental local initrds\n    if \"localrds\" in osdata:\n        for eachrd in osdata[\"localrds\"]:\n            initrdlist.append(eachrd)\n        # max number of initrds that can be handled is limited by the line length\n        # limit of grubs menu.lst: 1500 chars.\n        if len(initrdlist) > (1500 - 1):\n            raise DiscoveryError(\"INITRD parameter: Maximum parameter length (1500) exceeded! \"\n                                 \"- Too many additional initrd files found.\")\n    return initrdlist\n\n\ndef discoverLocalRds(osdata, root):\n    \"\"\" Get initrd files from /localrds directory \"\"\"\n    rds = helpers.findFiles(\n        path=os.path.join(root, DEFAULT_INITRD_DIR), mask=DEFAULT_SA_INITRD_MASK)\n    if rds:\n        rdlist = []\n        # add the local path to make it suitable for grub\n        for eachrd in rds:\n            rdlist.append(os.path.join(os.path.sep, DEFAULT_INITRD_DIR, eachrd))\n        osdata[\"localrds\"] = helpers.numericalSort(rdlist)\n    return\n\n\ndef discoverOsdata(osdata, keys):\n    \"\"\" Discover the kernel and initrd to use based on the media \"\"\"\n    # the copy boot media step should have run by now, so we work with the\n    # stub partition. This is just so we don't access the media twice\n    stub_path = keys.disk.device_mount\n    if not stub_path:\n        raise DiscoveryError(\"Cannot discover boot disk mount point. \"\n                             \"Was the stub partition created?\")\n    isocfg = Syslinux.readonly(_open(os.path.join(stub_path, \"isolinux.cfg\")))\n    isocfg_label = isocfg.info()[\"label \" + isocfg.first_non_local_label()]\n    # discover the kernel\n    osdata[\"kernel\"] = os.path.basename(isocfg_label[\"kernel\"])\n    # discover the initrd\n    append = isocfg_label[\"append\"].split(' ')\n    for each in append:\n        if '=' in each:\n            key, value = [x.strip() for x in each.split('=', 1)]\n            if key == \"initrd\":\n                osdata[\"initrd\"] = os.path.basename(value)\n    if \"initrd\" not in osdata:\n        raise DiscoveryError(\"Failed to discover the initrd\")\n\n    # verify the files are there otherwise the boot loader will fail to find them\n    kernel = os.path.join(stub_path, osdata[\"kernel\"])\n    initrd = os.path.join(stub_path, osdata[\"initrd\"])\n    if not os.path.exists(kernel) or not os.path.exists(initrd):\n        raise DiscoveryError(\"Failed to discover the boot kernel or initrd\")\n\n\ndef discoverSlesAddon(osdata, keys):\n    \"\"\" Discover addon directories for\n            SLES: kISO formatted media w/ \"addon\" directory\n    \"\"\"\n    url = mediaUrl(keys)\n    thismedia = media.factor(str(url))\n    # for SLES check for addon directory in the repository\n    SLES_ADDON_LOCATIONS = [\n        # common names for SLES addon directory\n        \"addon/\", \"ADDON/\", \"AddOn/\"\n    ]\n    for each_file in SLES_ADDON_LOCATIONS:\n        if thismedia.exists(each_file):\n            osdata[\"addonloc\"] = url.canonical() + \"/\" + each_file\n            print \"Boot Loader (SLES) ADDON directory found in source location: %s\" % osdata[\"addonloc\"]\n            return\n\n\ndef mediaUrl(keys):\n    \"\"\" determine the media server and path \"\"\"\n    url = keys.media.url\n    if not url:\n        # Fall back in case of old NFS mount script\n        mediaServer = _open(\"/tmp/osbp_info/media_server\", \"r\").read().strip()\n        mediaPath = _open(\"/tmp/osbp_info/media_path\", \"r\").read().strip()\n        mediaMount = _open(\"/tmp/osbp_info/media_mount\", \"r\").read().strip()\n        url = \"nfs://%s:%s/#%s\" % (mediaServer, mediaPath, mediaMount)\n    return media.parseUrl(url)\n\n\nclass InstallConfigureGrubOptionParser(OptionParser):\n    def defineOptions(self):\n        self.add_option(\"--kernel_arguments\", default=\"\",\n                        help=\"a string of arguments that will be passed to the OS installer kernel\")\n        self.add_option(\"--disableWarning\", dest=\"disableWarning\", action=\"store_true\",\n                        default=False,\n                        help=\"Do not show warnings of old hpsa_netconfig format\")\n\n\n@HandleShowErrorMessage(\"install and configure bootloader\", log=LOG)\ndef main():\n    options, remainingArgs = InstallConfigureGrubOptionParser().parse_args()\n    del remainingArgs\n\n    localServer = ThisLocalServer()\n    parser = SmartNetconfig.readwrite(\n        StringIO(HPSA_NETCONFIG),\n        activeMacAddress=localServer.getMACAddress(),\n        ipv6default=localServer.isIPv6Managed(),\n        log=LOG\n    )\n    if parser.info().oldSyntax and not options.disableWarning:\n        newFormat = parser.format()\n        print OLD_SYNTAX_WARNING + \"\\n%s\" % str(newFormat)\n\n    typosList = parser.getTyposList()\n    if typosList:\n        print(\"The following keys were not recognized in the netconfig CA and could be typos: %s\" % typosList)\n\n    keys = helpers.getDataStore()\n\n    bootDiskMount = keys.disk.device_mount\n    if not bootDiskMount:\n        raise DiscoveryError(\"Discovery of the boot disk mount point failed. \"\n                             \"Was the stub partition created?\", EC_NO_BOOTDISK)\n\n    bootDisk = LinuxDisk(keys.disk.device_path, None, None)\n    grub = getGrub(bootDisk)\n    try:\n        grub.install(bootDiskMount, bootDisk.getDeviceFilePath())\n    except (OSError, IOError), why:\n        print \"Installing GRuB failed. %s\" % why\n        return EC_IG_FAILED\n\n    # build.py will perform the needed substitutions here\n    osdata = dict()\n    osdata[\"os_display_name\"] = 'SuSE Linux Enterprise Server'\n    osdata[\"os_version\"] = 'SLES'\n    osdata[\"install_params\"] = 'install=%(url)s autoyast=file:///user.autoinst.xml textmode=1 netdevice=%(mac)s'\n    osdata[\"ip_config_static\"] = 'hostip=%(ip)s gateway=%(gw)s netmask=%(mask)s nameserver=%(dns)s exec=\"echo net.ipv6.conf.all.disable_ipv6=1 >> /etc/sysctl.conf\"'\n    osdata[\"ip_config_static6\"] = 'hostip=%(ip)s gateway=%(gw)s netmask=%(mask)s nameserver=%(dns)s ipv6only=1'\n    osdata[\"ip_config_dhcp\"] = 'exec=\"echo net.ipv6.conf.all.disable_ipv6=1 >> /etc/sysctl.conf\"'\n    osdata[\"ip_config_auto6\"] = 'ipv6only=1 ifcfg=%(mac)s=dhcp6,DHCLIENT6_MODE=managed'\n\n    discoverOsdata(osdata, keys)\n    if \"SLES\" in osdata[\"os_version\"]:\n        discoverSlesAddon(osdata, keys)\n\n    title = 'HP SA assisted %s installer' % osdata['os_display_name']\n    kernelArguments = configureKernelArguments(osdata, keys, parser,\n                                               kernel_arguments=options.kernel_arguments + \" hpsa_monitoring_agent=1\")\n    initrds = configureInitrds(osdata, keys)\n\n    menu = grub.configureMenu(title,\n                              osdata['kernel'], kernelArguments,\n                              initrds, keys)\n    for menuPath in grub.MENU_PATHS:\n        if not os.path.exists(os.path.join(bootDiskMount, os.path.dirname(menuPath))):\n            os.makedirs(os.path.join(bootDiskMount, os.path.dirname(menuPath)))\n        _open(os.path.join(bootDiskMount, menuPath), \"w\").write(menu)\n\n    return 0\n\nHPSA_NETCONFIG = \"\"\"@hpsa_netconfig@\"\"\"\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n",
            "description": "Installs and configures GRUB (GRand Unified Boot Loader) onto the stub partition of the boot disk on the target server in order to enable the booting into the SuSE Linux Enterprise Server installation image.\n\nThe step will also auto detect directories with the names \"addon\", \"AddOn\" and \"ADDON\" in the repository and for SuSE Linux Enterprise Server installations append the proper \"addon='path-to-addon-dir' to the kernel parameters of the grub boot loader.\n\nUsage:\n\nThis script expects no command line arguments, but the following argument(s) can optionally be specified:\n    --kernel_arguments=KERNEL_ARGUMENTS\n                        a string of arguments that will be passed to the OS\n                        installer kernel\n    --disableWarning    Do not show warnings of old hpsa_netconfig format\n\nPrerequisites:\n- Target server runs a maintenance Linux OS.\n- The files in the grub.zip archive must be extracted in /tmp.\n- The \"Create Stub Partition\" step must have been executed. \n\nThis script is intended to be used only as a Build Plan step.",
            "status": null,
            "name": "Install bootloader for SuSE Linux Enterprise Server",
            "state": null,
            "eTag": "2015-08-04T07:30:21.000Z",
            "modified": "2015-08-04T07:30:21.000Z",
            "created": "2015-06-13T04:49:09.000Z",
            "category": "os-deployment-server-scripts",
            "uri": "/rest/os-deployment-server-scripts/1030001"
        },
        {
            "runAsSuperUser": true,
            "serverChanging": true,
            "codeType": "PY2",
            "displayCodeType": "Python",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "1",
                    "createdBy": "opsware",
                    "createdDate": "2015-06-13T04:49:10.000Z",
                    "usage": "This script is used to deploy a .WIM image file using ImageX tool.\n\nUsage: windows_image_deploy.py [options]\n\nOptions:\n-h, --help : show this help message and exit\n--bootMode=BOOTMODE : boot mode of the server, can be UEFI or Legacy (boot mode is autodetected if this parameter is not passed).\n--systemDiskNumber=SYSTEMDISKNUMBER : system disk number where Windows will be deployed (default disk number is '0').\n--systemPartitionLabel=SYSTEMPARTITIONLABEL : label of partition where Windows will be deployed (default partition label is 'System').\n--wimFilePath=WIMFILEPATH : path where to get WIM file (Currently using CA 'WimFileName' to provide WIM file name).\n\nExample: windows_image_capture.py --wimFilePath=\"Z:\\@WimFileName@\" [--bootMode=UEFI] [--systemDiskNumber=0] [--systemPartitionLabel=System]\n\nFor more details please consult:\nhttp://technet.microsoft.com/en-us/library/cc722145(v=ws.10)\nhttp://technet.microsoft.com/en-us/library/cc749447(v=ws.10)\n\nPrerequisites:\n- Target server runs a maintenance Windows PE OS.\n- Must be run as part of a build plan.\n- Must be run after 'Set Media Source' and after 'Validate ImageX Package Contents' steps.",
                    "current": false
                },
                {
                    "versionLabel": "2",
                    "createdBy": "opsware",
                    "createdDate": "2015-08-04T07:30:30.000Z",
                    "usage": "This script is used to deploy a .WIM image file using ImageX tool.\n\nUsage: windows_image_deploy.py [options]\n\nOptions:\n-h, --help : show this help message and exit\n--bootMode=BOOTMODE : boot mode of the server, can be UEFI or Legacy (boot mode is autodetected if this parameter is not passed).\n--systemDiskNumber=SYSTEMDISKNUMBER : system disk number where Windows will be deployed (default disk number is '0').\n--systemPartitionLabel=SYSTEMPARTITIONLABEL : label of partition where Windows will be deployed (default partition label is 'System').\n--wimFilePath=WIMFILEPATH : path where to get WIM file (Currently using CA 'WimFileName' to provide WIM file name).\n\nExample: windows_image_capture.py --wimFilePath=\"Z:\\@WimFileName@\" [--bootMode=UEFI] [--systemDiskNumber=0] [--systemPartitionLabel=System]\n\nFor more details please consult:\nhttp://technet.microsoft.com/en-us/library/cc722145(v=ws.10)\nhttp://technet.microsoft.com/en-us/library/cc749447(v=ws.10)\n\nPrerequisites:\n- Target server runs a maintenance Windows PE OS.\n- Must be run as part of a build plan.\n- Must be run after 'Set Media Source' and after 'Validate ImageX Package Contents' steps.",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-08-04T07:30:30.000Z",
            "version": {
                "versionLabel": "2",
                "createdBy": "opsware",
                "createdDate": "2015-08-04T07:30:30.000Z",
                "usage": "This script is used to deploy a .WIM image file using ImageX tool.\n\nUsage: windows_image_deploy.py [options]\n\nOptions:\n-h, --help : show this help message and exit\n--bootMode=BOOTMODE : boot mode of the server, can be UEFI or Legacy (boot mode is autodetected if this parameter is not passed).\n--systemDiskNumber=SYSTEMDISKNUMBER : system disk number where Windows will be deployed (default disk number is '0').\n--systemPartitionLabel=SYSTEMPARTITIONLABEL : label of partition where Windows will be deployed (default partition label is 'System').\n--wimFilePath=WIMFILEPATH : path where to get WIM file (Currently using CA 'WimFileName' to provide WIM file name).\n\nExample: windows_image_capture.py --wimFilePath=\"Z:\\@WimFileName@\" [--bootMode=UEFI] [--systemDiskNumber=0] [--systemPartitionLabel=System]\n\nFor more details please consult:\nhttp://technet.microsoft.com/en-us/library/cc722145(v=ws.10)\nhttp://technet.microsoft.com/en-us/library/cc749447(v=ws.10)\n\nPrerequisites:\n- Target server runs a maintenance Windows PE OS.\n- Must be run as part of a build plan.\n- Must be run after 'Set Media Source' and after 'Validate ImageX Package Contents' steps.",
                "current": true
            },
            "source": "#!/usr/bin/python\r\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\r\n# ex: set tabstop=4 :\r\n# Please do not change the two lines above. See PEP 8, PEP 263.\r\n\"\"\"\r\n    (C) Copyright 2013-2015 Hewlett-Packard Development Company, L.P.\r\n\"\"\"\r\n\r\nimport sys\r\nimport os\r\nimport shutil\r\nfrom optparse import OptionError\r\nfrom osprov.optparse_ext import OptionParser\r\nfrom osprov.scripts import bootmode\r\nfrom osprov.osbp import logger\r\nfrom osprov.util import process\r\nfrom osprov.decorators import HandleShowErrorMessage\r\nfrom osprov import diskmgr\r\nfrom osprov.diskmgr import const, disk, diskmanager, partition\r\nfrom osprov.server.local import ThisLocalServer\r\nfrom osprov.errors import ProcessExecutionError\r\n\r\nLOG = logger.getIt(\"windows_image_deploy\")\r\n\r\n\r\nclass WindowsImageDeployOptionParser(OptionParser):\r\n\r\n    \"\"\" Option parser for this step \"\"\"\r\n\r\n    def defineOptions(self):\r\n        self.add_option(\"--bootMode\", type=\"string\",\r\n                        help=\"boot mode of the server, can be UEFI or Legacy\")\r\n        self.add_option(\"--systemDiskNumber\", type=\"int\", default=0,\r\n                        help=\"system disk number where Windows will be deployed (default disk number is '0').\")\r\n        self.add_option(\"--systemPartitionLabel\", type=\"string\", default=\"System\",\r\n                        help=\"label of partition where Windows will be deployed\")\r\n        self.add_option(\"--wimFilePath\", type=\"string\",\r\n                        help=\"path where to get WIM file\")\r\n\r\n    def validateArgs(self, opt, args):\r\n        if opt.bootMode and not opt.bootMode.lower() in [x.lower() for x in bootmode.SUPPORTED_BOOT_MODES]:\r\n            raise OptionError(\"Invalid boot mode: \" + opt.bootMode, \"bootMode\")\r\n        if not opt.wimFilePath:\r\n            raise OptionError(\"Missing parameter: --wimFilePath\", \"wimFilePath\")\r\n\r\n\r\ndef deployPartition(driveLetter, wimFilePath, log=LOG):\r\n    process.runIt(\"imagex /check /verify /apply \\\"%s\\\" 1 %s:\\\\\" %\r\n                  (wimFilePath, driveLetter), checkExitCode=(0,), log=log)\r\n\r\n\r\ndef runAndIgnoreResult(cmdLine, log=LOG):\r\n    try:\r\n        process.runIt(cmdLine, checkExitCode=(0,1), log=log)\r\n    except ProcessExecutionError:\r\n        pass\r\n\r\ndef updateBCDForLegacy(windowsDriveLetter, log=LOG):\r\n    bcdbootPath = windowsDriveLetter + \":\\\\Windows\\\\System32\\\\bcdboot.exe\"\r\n    if os.path.isfile(bcdbootPath):\r\n        shutil.copyfile(bcdbootPath, \"\\\\Windows\\\\Temp\\\\bcdboot.exe\")\r\n        updateBcdLine = \"\\\\Windows\\\\Temp\\\\bcdboot.exe %s:\\\\Windows /s %s:\" % (windowsDriveLetter, windowsDriveLetter)\r\n        try:\r\n            process.runIt(updateBcdLine, checkExitCode=(0,), log=log)\r\n            runAndIgnoreResult(updateBcdLine+\" /f BIOS\", log=log)\r\n            return\r\n        except ProcessExecutionError:\r\n            print \"OS bcdboot failed to run, will retry using the WinPE bcdboot\"\r\n            pass\r\n\r\n    updateBcdLine = \"bcdboot.exe %s:\\\\Windows /s %s:\" % (windowsDriveLetter, windowsDriveLetter)\r\n    process.runIt(updateBcdLine, checkExitCode=(0,), log=log)\r\n    runAndIgnoreResult(updateBcdLine+\" /f BIOS\", log=log)\r\n\r\ndef updateBCDForUefi(espDriveLetter, windowsDriveLetter, log=LOG):\r\n    process.runIt(\"bcdedit /set {bootmgr} device partition=%s:\" %\r\n                  espDriveLetter, checkExitCode=(0,), log=log)\r\n    process.runIt(\"bcdedit /set {memdiag} device partition=%s:\" %\r\n                  espDriveLetter, checkExitCode=(0,), log=log)\r\n    process.runIt(\"bcdedit /set {default} device partition=%s:\" %\r\n                  windowsDriveLetter, checkExitCode=(0,), log=log)\r\n    process.runIt(\"bcdedit /set {default} osdevice partition=%s:\" %\r\n                  windowsDriveLetter, checkExitCode=(0,), log=log)\r\n    process.runIt(\r\n        \"bcdedit /set {FWbootmgr} displayorder {Bootmgr} /addfirst\", checkExitCode=(0,), log=log)\r\n\r\n@HandleShowErrorMessage(\"Windows Image Deploy\", LOG)\r\ndef main():\r\n\r\n    # get and parse arguments\r\n    options, remainingArgs = WindowsImageDeployOptionParser().parse_args()\r\n    wimFilePath = options.wimFilePath.strip()\r\n    systemDiskNumber = options.systemDiskNumber\r\n    # get bootmode (legacy bios or uefi)\r\n    if options.bootMode:\r\n        bootMode = options.bootMode\r\n    else:\r\n        bootMode = bootmode.getCurrentBootMode(ThisLocalServer(), log=LOG)\r\n\r\n    windowsDriveLetter = disk.WindowsDisk(systemDiskNumber).getPartitionWithLabel(\r\n        options.systemPartitionLabel).letter\r\n\r\n    partitionTable = diskmgr.getPartitionTable(bootMode)\r\n    if const.PARTITION_TABLE_MBR == partitionTable:\r\n        print \"Deploy Windows Image based on Legacy Windows Partitioning Schema\"\r\n        deployPartition(windowsDriveLetter, wimFilePath)\r\n        updateBCDForLegacy(windowsDriveLetter)\r\n\r\n    elif const.PARTITION_TABLE_GPT == partitionTable:\r\n        print \"Deploy Windows Image based on Uefi Windows Partitioning Schema\"\r\n        freeLetter = diskmanager.WindowsDiskManager().findFirstAvailableDriveLetter()\r\n        partition.WindowsPartition(systemDiskNumber, 1).setPartitionLetter(freeLetter)\r\n        deployPartition(freeLetter, wimFilePath + \"_ESP\")\r\n        deployPartition(windowsDriveLetter, wimFilePath)\r\n        updateBCDForUefi(freeLetter, windowsDriveLetter)\r\n\r\nif __name__ == \"__main__\":\r\n    sys.exit(main())\r\n",
            "description": "This script is used to deploy a .WIM image file using ImageX tool.\n\nUsage: windows_image_deploy.py [options]\n\nOptions:\n-h, --help : show this help message and exit\n--bootMode=BOOTMODE : boot mode of the server, can be UEFI or Legacy (boot mode is autodetected if this parameter is not passed).\n--systemDiskNumber=SYSTEMDISKNUMBER : system disk number where Windows will be deployed (default disk number is '0').\n--systemPartitionLabel=SYSTEMPARTITIONLABEL : label of partition where Windows will be deployed (default partition label is 'System').\n--wimFilePath=WIMFILEPATH : path where to get WIM file (Currently using CA 'WimFileName' to provide WIM file name).\n\nExample: windows_image_capture.py --wimFilePath=\"Z:\\@WimFileName@\" [--bootMode=UEFI] [--systemDiskNumber=0] [--systemPartitionLabel=System]\n\nFor more details please consult:\nhttp://technet.microsoft.com/en-us/library/cc722145(v=ws.10)\nhttp://technet.microsoft.com/en-us/library/cc749447(v=ws.10)\n\nPrerequisites:\n- Target server runs a maintenance Windows PE OS.\n- Must be run as part of a build plan.\n- Must be run after 'Set Media Source' and after 'Validate ImageX Package Contents' steps.",
            "status": null,
            "name": "Windows Image Deploy",
            "state": null,
            "eTag": "2015-08-04T07:30:30.000Z",
            "modified": "2015-08-04T07:30:30.000Z",
            "created": "2015-06-13T04:49:10.000Z",
            "category": "os-deployment-server-scripts",
            "uri": "/rest/os-deployment-server-scripts/1040001"
        },
        {
            "runAsSuperUser": false,
            "serverChanging": true,
            "codeType": "PY2",
            "displayCodeType": "Python",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "1",
                    "createdBy": "opsware",
                    "createdDate": "2015-06-13T04:49:10.000Z",
                    "usage": "Cleans up files which refer to MAC of source VM",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-06-13T04:49:10.000Z",
            "version": {
                "versionLabel": "1",
                "createdBy": "opsware",
                "createdDate": "2015-06-13T04:49:10.000Z",
                "usage": "Cleans up files which refer to MAC of source VM",
                "current": true
            },
            "source": "#!/usr/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n#\n\"\"\"\n    (C) Copyright 2012-2015 Hewlett-Packard Development Company, L.P.\n\n    Clean up old MAC addresses from source VM\n\"\"\"\n\nimport os\nimport sys\n\nfrom osprov.osbp import logger\nfrom osprov import constants\n\nLOG = logger.getIt(\"cleanup_old_macs\")\n\n\ndef main():\n    # clean up files with old MAC addresses while still in maintenance mode\n    net_rules_path = constants.OGFS_SYSTEM_ROOT + '/etc/udev/rules.d/70-persistent-net.rules'\n    if os.path.exists(net_rules_path):\n        LOG.debug(\"Cleaning up file with old MAC address: \" + net_rules_path)\n        os.unlink(net_rules_path)\n\nif __name__ == \"__main__\":\n    main()\n",
            "description": "Cleans up files which refer to MAC of source VM",
            "status": null,
            "name": "Clean up old MAC Addresses (Linux)",
            "state": null,
            "eTag": "2015-06-13T04:49:10.000Z",
            "modified": "2015-06-13T04:49:10.000Z",
            "created": "2015-06-13T04:49:10.000Z",
            "category": "os-deployment-server-scripts",
            "uri": "/rest/os-deployment-server-scripts/1050001"
        },
        {
            "runAsSuperUser": true,
            "serverChanging": true,
            "codeType": "BAT",
            "displayCodeType": "Windows .BAT",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "1",
                    "createdBy": "opsware",
                    "createdDate": "2015-06-13T04:49:11.000Z",
                    "usage": "Installs Windows 2008 from OS Media. Requires full path to  setup.exe from the installation media.",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-06-13T04:49:11.000Z",
            "version": {
                "versionLabel": "1",
                "createdBy": "opsware",
                "createdDate": "2015-06-13T04:49:11.000Z",
                "usage": "Installs Windows 2008 from OS Media. Requires full path to  setup.exe from the installation media.",
                "current": true
            },
            "source": "@echo off\nsetlocal\nset SIG=WINPE32\nset ANSWER=X:\\Windows\\Temp\\Unattend.xml\nset ARGS=/noreboot /unattend:%ANSWER%\nset | find \"opswbasig=%SIG%\" > NUL\nif %ERRORLEVEL% NEQ 0 (\n    echo ERROR: Target server must be running %SIG% but it is not\n    exit /B 1\n)\nif X%1==X (\n    set SETUP=z:\\i386\\winnt32.exe\n) else (\n    set SETUP=%1\n)\nif not exist %SETUP% (\n    echo %SETUP% missing! Cannot install Windows.\n    exit /B 2\n)\nif not exist %ANSWER% (\n    echo %ANSWER% missing! Cannot install Windows.\n    exit /B 3\n)\n\n%SETUP% %ARGS%\n\nif %ERRORLEVEL% == 0 (\n    echo Windows setup completed successfully\n    exit\n) else (\n    echo ERROR: Windows setup exited status %ERRORLEVEL%\n    exit /B %ERRORLEVEL%\n)\n",
            "description": "Installs Windows 2008 from OS Media. Requires full path to  setup.exe from the installation media.",
            "status": null,
            "name": "Run Windows 2008 Setup",
            "state": null,
            "eTag": "2015-06-13T04:49:11.000Z",
            "modified": "2015-06-13T04:49:11.000Z",
            "created": "2015-06-13T04:49:11.000Z",
            "category": "os-deployment-server-scripts",
            "uri": "/rest/os-deployment-server-scripts/1060001"
        },
        {
            "runAsSuperUser": true,
            "serverChanging": true,
            "codeType": "BAT",
            "displayCodeType": "Windows .BAT",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "1",
                    "createdBy": "opsware",
                    "createdDate": "2015-06-13T04:49:12.000Z",
                    "usage": "This script is used to capture a Windows installation to a .WIM image file using ImageX tool\n\nUsage: capture_windows_image.cmd path_to_wim_file captured_drive [path_to_wimscript.ini]\n\nScript takes 3 parameters (first 2 are mandatory):\n 1. path where .wim image file will be saved (path + .wim image name)\n 2. drive which will be captured\n 3. path to wimscript.ini file. If this parameter is not provided this script will generate a wimscript.ini file used to exclude SA Opsware Agent from new .wim image and it will extend an existing wimscript.ini file to do the same (exclude SA Opsware Agent)\n \nExample: capture_windows_image.cmd Z:\\media\\newWimFile.wim C: [Z:\\configs\\wimscript.ini]\n\nFor more details please consult:\nhttp://technet.microsoft.com/en-us/library/cc722145(v=ws.10)\nhttp://technet.microsoft.com/en-us/library/cc749447(v=ws.10)\n\n Prerequisites:\n - Target server runs a Windows or Windows PE maintenance OS.",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-06-13T04:49:12.000Z",
            "version": {
                "versionLabel": "1",
                "createdBy": "opsware",
                "createdDate": "2015-06-13T04:49:12.000Z",
                "usage": "This script is used to capture a Windows installation to a .WIM image file using ImageX tool\n\nUsage: capture_windows_image.cmd path_to_wim_file captured_drive [path_to_wimscript.ini]\n\nScript takes 3 parameters (first 2 are mandatory):\n 1. path where .wim image file will be saved (path + .wim image name)\n 2. drive which will be captured\n 3. path to wimscript.ini file. If this parameter is not provided this script will generate a wimscript.ini file used to exclude SA Opsware Agent from new .wim image and it will extend an existing wimscript.ini file to do the same (exclude SA Opsware Agent)\n \nExample: capture_windows_image.cmd Z:\\media\\newWimFile.wim C: [Z:\\configs\\wimscript.ini]\n\nFor more details please consult:\nhttp://technet.microsoft.com/en-us/library/cc722145(v=ws.10)\nhttp://technet.microsoft.com/en-us/library/cc749447(v=ws.10)\n\n Prerequisites:\n - Target server runs a Windows or Windows PE maintenance OS.",
                "current": true
            },
            "source": "@echo off\n\nREM # %1 - .wim image file \nREM # %2 - drive to be captured (C:)\nREM # %3 - path to wimscript.ini file [optional parameter]\n\nREM # if mandatory parameters are not provided, the script will return error\nif \"%2\"==\"\" (\n  echo Not enough parameters provided\n  exit /B 1\n)\n\nif \"%2\"==\"C:\" goto have_targetdrive\nif \"%2\"==\"c:\" goto have_targetdrive\necho WARNING: Only C: drive capture is supported\n\n:have_targetdrive\n\nset wimscript=%SYSTEMDRIVE%\\wimscript%RANDOM%.ini\nset excepted=0\nset wimFilePath=%1\nset drive=%2\n\nREM # no wimscript, we generate one\nif \"%3\"==\"\" (\n  copy nul %wimscript%\n  echo [ExclusionList]>> %wimscript%\n  call:InsertExclusionList\n  call:CaptureImage\n)\n\nREM # we have a wimscript: add -OR- insert to [ExclusionList]\ncopy nul %wimscript%\nfor /f \"tokens=1* delims= \" %%a in (%3) do (\n  echo %%a %%b>> %wimscript%\n  if \"%%a\"==\"[ExclusionList]\" (\n        call:InsertExclusionList\n        set excepted=1\n  )\n)\n\nREM # if exception wasn't inserted yet, we append it to end\nif \"%excepted%\"==\"0\" (\n  echo.>> %wimscript%\n  echo [ExclusionList]>> %wimscript%\n  call:InsertExclusionList\n)\n\ncall:CaptureImage\n\nREM # function definitions\n:CaptureImage\necho execute: imagex.exe /config %wimscript% /capture %drive% \"%wimFilePath%\" \"OS\"\nimagex.exe /config %wimscript% /check /verify /capture %drive% \"%wimFilePath%\" \"OS\"\nexit %errorlevel%\ngoto:eof\n\n:InsertExclusionList\necho \"\\Program Files\\Opsware\">> %wimscript%\necho \"\\Program Files\\Common Files\\Opsware\">> %wimscript%\ngoto:eof\n\n",
            "description": "This script is used to capture a Windows installation to a .WIM image file using ImageX tool\n\nUsage: capture_windows_image.cmd path_to_wim_file captured_drive [path_to_wimscript.ini]\n\nScript takes 3 parameters (first 2 are mandatory):\n 1. path where .wim image file will be saved (path + .wim image name)\n 2. drive which will be captured\n 3. path to wimscript.ini file. If this parameter is not provided this script will generate a wimscript.ini file used to exclude SA Opsware Agent from new .wim image and it will extend an existing wimscript.ini file to do the same (exclude SA Opsware Agent)\n \nExample: capture_windows_image.cmd Z:\\media\\newWimFile.wim C: [Z:\\configs\\wimscript.ini]\n\nFor more details please consult:\nhttp://technet.microsoft.com/en-us/library/cc722145(v=ws.10)\nhttp://technet.microsoft.com/en-us/library/cc749447(v=ws.10)\n\n Prerequisites:\n - Target server runs a Windows or Windows PE maintenance OS.",
            "status": null,
            "name": "Capture Windows Image",
            "state": null,
            "eTag": "2015-06-13T04:49:12.000Z",
            "modified": "2015-06-13T04:49:12.000Z",
            "created": "2015-06-13T04:49:12.000Z",
            "category": "os-deployment-server-scripts",
            "uri": "/rest/os-deployment-server-scripts/1090001"
        },
        {
            "runAsSuperUser": false,
            "serverChanging": true,
            "codeType": "SH",
            "displayCodeType": "Unix",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "1",
                    "createdBy": "opsware",
                    "createdDate": "2015-06-13T04:49:14.000Z",
                    "usage": "Add files to the initial RAM disk. \nConsult the online help for more information.\n\nUsage: [-s source:destination]*\n  -s source:destination\n    files found at <source> to be embedded at <destination>\n    parameter needs to be present at least once and can be given multiple times\n    int: Internally  \"cp -a\" command is used while preparing the initrd. This means subdirectories are copied recursivley into the destination directory</dd>\n\nExamples:\n    -s /tmp/drivers:/\n      The directory /tmp/drivers including all files and subdirectories will be added to a initrd and placed into the \"/driver\" directory \n      and as such the root of the runnig installation OS.\n    -s /tmp/rootfiles/.:/  \n      Note the dot after the last / before the separator \":\" \n      All files and subdirectories found at /tmp/rootfiles will be added to the root (\"/\") directory of the initrd, \n      and as such the root of the runnig installation OS.\n\nPrerequisites:\n- Target server runs a Linux OS.\n\nThis script is intended to be used only as a Build Plan step.",
                    "current": false
                },
                {
                    "versionLabel": "2",
                    "createdBy": "opsware",
                    "createdDate": "2015-08-04T07:30:18.000Z",
                    "usage": "Add files to the initial RAM disk. \nConsult the online help for more information.\n\nUsage: [-s source:destination]*\n  -s source:destination\n    files found at <source> to be embedded at <destination>\n    parameter needs to be present at least once and can be given multiple times\n    int: Internally  \"cp -a\" command is used while preparing the initrd. This means subdirectories are copied recursivley into the destination directory</dd>\n\nExamples:\n    -s /tmp/drivers:/\n      The directory /tmp/drivers including all files and subdirectories will be added to a initrd and placed into the \"/driver\" directory \n      and as such the root of the runnig installation OS.\n    -s /tmp/rootfiles/.:/  \n      Note the dot after the last / before the separator \":\" \n      All files and subdirectories found at /tmp/rootfiles will be added to the root (\"/\") directory of the initrd, \n      and as such the root of the runnig installation OS.\n\nPrerequisites:\n- Target server runs a Linux OS.\n\nThis script is intended to be used only as a Build Plan step.",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-08-04T07:30:18.000Z",
            "version": {
                "versionLabel": "2",
                "createdBy": "opsware",
                "createdDate": "2015-08-04T07:30:18.000Z",
                "usage": "Add files to the initial RAM disk. \nConsult the online help for more information.\n\nUsage: [-s source:destination]*\n  -s source:destination\n    files found at <source> to be embedded at <destination>\n    parameter needs to be present at least once and can be given multiple times\n    int: Internally  \"cp -a\" command is used while preparing the initrd. This means subdirectories are copied recursivley into the destination directory</dd>\n\nExamples:\n    -s /tmp/drivers:/\n      The directory /tmp/drivers including all files and subdirectories will be added to a initrd and placed into the \"/driver\" directory \n      and as such the root of the runnig installation OS.\n    -s /tmp/rootfiles/.:/  \n      Note the dot after the last / before the separator \":\" \n      All files and subdirectories found at /tmp/rootfiles will be added to the root (\"/\") directory of the initrd, \n      and as such the root of the runnig installation OS.\n\nPrerequisites:\n- Target server runs a Linux OS.\n\nThis script is intended to be used only as a Build Plan step.",
                "current": true
            },
            "source": "#!/opt/opsware/agent/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n\"\"\"\n    (C) Copyright 2014-2015 Hewlett-Packard Development Company, L.P.\n\n    OS Build Plan Step used to embed a list of files in the initrd image.\n\"\"\"\n\nimport sys\nimport optparse\nimport os\nimport shutil\nimport tempfile\n\nfrom osprov.osbp import logger\nfrom osprov.util import process\nfrom osprov import helpers\nfrom osprov.constants import DEFAULT_SA_INITRD_MASK\nfrom osprov.constants import DEFAULT_INITRD_DIR\nfrom osprov.decorators import HandleShowErrorMessage\n\nLOG = logger.getIt('embed to initrd')\n\nMKE2FS = \"/opt/opsware/agent/osprov/bin/mke2fs\"\n\ndef generateSeqFileName(path=\"\", mask=\"*_file\"):\n    \"\"\"\n    Generate a new file name with (next) unique sequence number.\n\n    If mask does not contain an asterix the sequence gets prepended\n    to make the resulting filename unique.\n\n    Try not to get confused with existing files having numbers\n    with less than digits and without leading zeros.\n\n    As 3 digits are used this is limited to 999 files.\n    \"\"\"\n    if not '*' in mask:\n        mask = \"*_%s\" % mask\n    files = helpers.findFiles(path=path, mask=mask)\n    if not files:\n        newfilename = mask.replace(\"*\", \"000\")\n    else:\n        files = helpers.numericalSort(files)\n        lastname = os.path.basename(files[-1])\n        version = helpers.splitAtNumber(lastname[mask.find(\"*\"):])[0]\n        # increment the version found and replace it\n        newfilename = mask.replace(\"*\", \"%.3d\" % (int(version) + 1))\n    return os.path.join(path, newfilename)\n\n\ndef embed(sources, initrd):\n    \"\"\" Embed a list of files or directories into an initrd image or\n    append to an existing initrd.\n    \"\"\"\n    helpers.makeDirs(os.path.dirname(initrd))\n    # use a temporary folder in the ramdisk to avoid issues with symlinks\n    tmpimgfile = tempfile.mktemp(dir=os.path.dirname(initrd))\n    tmpfolder = tempfile.mkdtemp()\n    # Creating a sparse image file to use for a temporary ext3 filesystem where to assemble the content for initrd\n    # The image file can expand up to 1 GB\n    process.runIt(\"sync && \"\n                  \"dd if=/dev/zero of={tmpimgfile} bs=4M seek=255 count=1 && \"\n                  \"{mke2fs} -F -t ext3 -q {tmpimgfile} && \"\n                  \"mount -o loop {tmpimgfile} {tmpfolder} && \"\n                  \"sync\".format(mke2fs=MKE2FS, tmpfolder=tmpfolder, tmpimgfile=tmpimgfile),\n                  log=LOG, quiet=True, shell=True)\n\n    # copy all sources to the staging area\n    for source in sources:\n        source, destination = source.split(\":\")\n        print \"Adding to intrd %s : source %s -> destination: %s\" % (initrd, source, destination)\n        tmpdest = \"%s/%s\" % (tmpfolder, destination)\n        # add the target dir unless it exists already\n        if not os.path.exists(tmpdest):\n            os.makedirs(tmpdest)\n        process.runIt(\"cp -a %s %s\" % (source, tmpdest), checkExitCode=(0,), log = LOG)\n\n    # create or append to initrd\n    process.runIt(\"cd {tmpfolder} && find . -print0 | cpio -0 --format=newc -ov | gzip -9 >> {initrd}\".format(\n                  tmpfolder=tmpfolder, initrd=initrd),\n                  log=LOG, quiet=True, shell=True)\n\n    # remove the tmpfolder to cleanup and save space\n    process.runIt(\"umount {tmpfolder}\".format(tmpfolder=tmpfolder))\n    shutil.rmtree(tmpfolder)\n    os.remove(tmpimgfile)\n\n\ndef parseArgs(args):\n    \"\"\"Parse the command line arguments\"\"\"\n    parser = optparse.OptionParser(description=__doc__)\n    parser.add_option('-s', '--source',\n                      help=\"Path to add to initrd. Can be repeated multiple times \",\n                      action=\"append\")\n    parser.add_option('-n', '--name',\n                      help=\"the base name of the new initrd file to be created. \"\n                      \"If this parameter is not present a default name will be used \"\n                      \"also a version number is added and incremented if required to \"\n                      \"make the filename unique and to indicate the sequence of creation.\"\n                      \"Defaults to '%s'\" % DEFAULT_SA_INITRD_MASK,\n                      default=DEFAULT_SA_INITRD_MASK)\n    opt, args = parser.parse_args(args)\n    if args:\n        parser.error(\"Additional positional arguments are not supported\")\n    if not opt.source:\n        parser.error(\"At least one source needs to be present\")\n    for source in opt.source:\n        if \":\" not in source:\n            parser.error(\"Invalid source parameter: needs \\\":\\\" to separate <source>:<destination-dir>.\")\n        if source.endswith(\":\"):\n            parser.error(\"Invalid source parameter: needs <destination-dir> after \\\":\\\".\")\n    return opt\n\n\n@HandleShowErrorMessage(\"Embed Files into Initrd\")\ndef main():\n    opt = parseArgs(sys.argv[1:])\n\n    root_location = helpers.getDataStore().disk.device_mount\n\n    initrdfile = generateSeqFileName(path=os.path.join(root_location, DEFAULT_INITRD_DIR),\n                                     mask=opt.name)\n    embed(opt.source, initrdfile)\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n",
            "description": "Add files to the initial RAM disk. \nConsult the online help for more information.\n\nUsage: [-s source:destination]*\n  -s source:destination\n    files found at <source> to be embedded at <destination>\n    parameter needs to be present at least once and can be given multiple times\n    int: Internally  \"cp -a\" command is used while preparing the initrd. This means subdirectories are copied recursivley into the destination directory</dd>\n\nExamples:\n    -s /tmp/drivers:/\n      The directory /tmp/drivers including all files and subdirectories will be added to a initrd and placed into the \"/driver\" directory \n      and as such the root of the runnig installation OS.\n    -s /tmp/rootfiles/.:/  \n      Note the dot after the last / before the separator \":\" \n      All files and subdirectories found at /tmp/rootfiles will be added to the root (\"/\") directory of the initrd, \n      and as such the root of the runnig installation OS.\n\nPrerequisites:\n- Target server runs a Linux OS.\n\nThis script is intended to be used only as a Build Plan step.",
            "status": null,
            "name": "Embed files initrd",
            "state": null,
            "eTag": "2015-08-04T07:30:18.000Z",
            "modified": "2015-08-04T07:30:18.000Z",
            "created": "2015-06-13T04:49:13.000Z",
            "category": "os-deployment-server-scripts",
            "uri": "/rest/os-deployment-server-scripts/1120001"
        },
        {
            "runAsSuperUser": true,
            "serverChanging": true,
            "codeType": "PY2",
            "displayCodeType": "Python",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "1",
                    "createdBy": "opsware",
                    "createdDate": "2015-06-13T04:49:14.000Z",
                    "usage": "Will inject the personalization settings into the necessary configuration files from the default jumpstart.\n\nusage: install_jumpstart_personalization.py\n\noptions:\n  -b BOOTOPTIONS, --bootOptions=BOOTOPTIONS\n                        Specifies Solaris kernel arguments\nPrerequisites:\n\n- This script must be run as part of a Build Plan under a Solaris Service OS on x86\n- This script must be run after 'Create Solaris Stub Partition', 'Configure Solaris 10 Default Jumpstart', 'Inject Required Jumpstart Settings'",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-06-13T04:49:14.000Z",
            "version": {
                "versionLabel": "1",
                "createdBy": "opsware",
                "createdDate": "2015-06-13T04:49:14.000Z",
                "usage": "Will inject the personalization settings into the necessary configuration files from the default jumpstart.\n\nusage: install_jumpstart_personalization.py\n\noptions:\n  -b BOOTOPTIONS, --bootOptions=BOOTOPTIONS\n                        Specifies Solaris kernel arguments\nPrerequisites:\n\n- This script must be run as part of a Build Plan under a Solaris Service OS on x86\n- This script must be run after 'Create Solaris Stub Partition', 'Configure Solaris 10 Default Jumpstart', 'Inject Required Jumpstart Settings'",
                "current": true
            },
            "source": "#!/opt/opsware/agent/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n\"\"\"\n    (C) Copyright 2013-2015 Hewlett-Packard Development Company, L.P.\n\n    Will inject the personalization settings into the necessary\n    configuration files from the default jumpstart.\n\"\"\"\n\nimport os\nimport sys\nfrom osprov import helpers, media\nfrom osprov.decorators import HandleShowErrorMessage\nfrom osprov.errors import DiscoveryError\nfrom osprov.osbp import logger\nfrom osprov.parsers.jumpstart import JumpstartParser\nfrom osprov.optparse_ext import OptionParser\n\nLOG = logger.getIt(\"Inject Jumpstart Personalization Settings\")\n\n\nclass InjectPersonalizationJumpstartOptionParser(OptionParser):\n\n    def defineOptions(self):\n        self.add_option(\"-b\", \"--bootOptions\", dest=\"boot_options\",\n                        default=\"\", help=\"Specifies Solaris kernel arguments\")\n\n\ndef injectBootOptions(jumpstartDir, bootOptions, jumpstartParser):\n    \"\"\"Injecting the Solaris kernel parameters\"\"\"\n    finishFilePath = os.path.join(jumpstartDir, \"finish\")\n    if not os.path.exists(finishFilePath):\n        raise DiscoveryError(\n            \"The post-installation script was not found! There was a problem injecting the required settings.\")\n    jumpstartParser.data[\"finish\"] = jumpstartParser.data[\"finish\"].replace(\n        \"\"\"BOOT_OPTS=\"kernel/unix\\\"\"\"\", \"\"\"BOOT_OPTS=\"kernel/unix %s\\\"\"\"\" % bootOptions)\n    writeToFile(finishFilePath, jumpstartParser.toString(\"finish\"))\n\n\ndef writeToFile(pathToFile, content):\n    fd = open(pathToFile, \"wb+\")\n    fd.write(content)\n    fd.close()\n    LOG.debug(\"File %s : \\n%s\" % (pathToFile, content))\n\n\n@HandleShowErrorMessage(\"Inject Jumpstart Personalization Settings\", LOG)\ndef main():\n    \"\"\"Injecting personalized settings for installer and production Solaris10\"\"\"\n    options, args = InjectPersonalizationJumpstartOptionParser().parse_args()\n    keys = helpers.getDataStore()\n    stubMountpoint = keys.disk.device_mount\n    jumpstartDir = os.path.join(stubMountpoint, \"jumpstart\")\n    if not os.path.exists(jumpstartDir):\n        raise DiscoveryError(\n            \"Jumpstart target location was not found! There was a problem injecting the required settings.\")\n\n    defaultJumpstart = \"/tmp/default_jumpstart.txt\"\n    jumpstartParser = JumpstartParser.readonly(open(defaultJumpstart))\n    jumpstartParser.info()\n    injectBootOptions(jumpstartDir=jumpstartDir,\n                      bootOptions=options.boot_options, jumpstartParser=jumpstartParser)\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n",
            "description": "Will inject the personalization settings into the necessary configuration files from the default jumpstart.\n\nusage: install_jumpstart_personalization.py\n\noptions:\n  -b BOOTOPTIONS, --bootOptions=BOOTOPTIONS\n                        Specifies Solaris kernel arguments\nPrerequisites:\n\n- This script must be run as part of a Build Plan under a Solaris Service OS on x86\n- This script must be run after 'Create Solaris Stub Partition', 'Configure Solaris 10 Default Jumpstart', 'Inject Required Jumpstart Settings'",
            "status": null,
            "name": "Inject Jumpstart Personalization Settings",
            "state": null,
            "eTag": "2015-06-13T04:49:14.000Z",
            "modified": "2015-06-13T04:49:14.000Z",
            "created": "2015-06-13T04:49:14.000Z",
            "category": "os-deployment-server-scripts",
            "uri": "/rest/os-deployment-server-scripts/1140001"
        },
        {
            "runAsSuperUser": true,
            "serverChanging": true,
            "codeType": "BAT",
            "displayCodeType": "Windows .BAT",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "1",
                    "createdBy": "opsware",
                    "createdDate": "2015-06-13T04:49:15.000Z",
                    "usage": "This is a simple wrapper script to apply a WIM image using the imagex program.  \n\nUsage: IMAGEPATH [IMAGENUMBER] [TARGETDRIVE]\n\nParameters:\n  IMAGEPATH:  Required. Full local path to the WIM file to apply.\n IMAGENUMBER: image number within the WIM to apply. Default is 1.\n TARGETDRIVE: drive letter where WIM should be applied. \n              Default is \"C\" or the value of the @SystemDrive@ custom attribute.  \n\t\t\t  This should be a single letter corresponding to a valid windows drive. \n\t\t\t  Do not include a trailing colon.\n\nExample:\n apply_wim_image.cmd z:\\windows\\images\\2008.wim\n\n Prerequisites:\n - Target server runs a Windows or Windows PE maintenance OS.",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-06-13T04:49:15.000Z",
            "version": {
                "versionLabel": "1",
                "createdBy": "opsware",
                "createdDate": "2015-06-13T04:49:15.000Z",
                "usage": "This is a simple wrapper script to apply a WIM image using the imagex program.  \n\nUsage: IMAGEPATH [IMAGENUMBER] [TARGETDRIVE]\n\nParameters:\n  IMAGEPATH:  Required. Full local path to the WIM file to apply.\n IMAGENUMBER: image number within the WIM to apply. Default is 1.\n TARGETDRIVE: drive letter where WIM should be applied. \n              Default is \"C\" or the value of the @SystemDrive@ custom attribute.  \n\t\t\t  This should be a single letter corresponding to a valid windows drive. \n\t\t\t  Do not include a trailing colon.\n\nExample:\n apply_wim_image.cmd z:\\windows\\images\\2008.wim\n\n Prerequisites:\n - Target server runs a Windows or Windows PE maintenance OS.",
                "current": true
            },
            "source": "@echo off\n::Usage: apply_wim_image.cmd IMAGEPATH [IMAGENUMBER] [TARGETDRIVE]\nset SIG=WINPE\nset IMAGENUMBER=1\nset TARGETDRIVE=@SystemDrive:C@\n\nset | find \"opswbasig=%SIG%\" > NUL\nif %ERRORLEVEL% NEQ 0 (\n    echo ERROR: Target server must be running %SIG% but it is not\n    exit /B 1\n)\nif not exist %1 (\n    echo image file %1 missing! Cannot apply image.\n\texit /B 2\n)\nif not X%2==X (\n    set IMAGENUMBER=%2\n)\nif not X%3==X (\n    set TARGETDRIVE=%3\n)\n\nif \"%TARGETDRIVE%\"==\"C\" goto have_targetdrive\nif \"%TARGETDRIVE%\"==\"c\" goto have_targetdrive\necho Only C: drive deploy is supported\n\n:have_targetdrive\n\n::start \"Applying WIM Image\" /wait cmd /c imagex /verify /scroll /apply %1 %IMAGENUMBER% %TARGETDRIVE%:\necho Applying WIM Image %1 to drive %TARGETDRIVE%: (Image Number %IMAGENUMBER%)\nimagex /check /verify /scroll /apply %1 %IMAGENUMBER% %TARGETDRIVE%:\n\nif %ERRORLEVEL% == 0 (\n    echo Image applied successfully\n) else (\n    echo ERROR: imagex exited status %ERRORLEVEL%\n    exit /B %ERRORLEVEL%\n)\n\nif exist %TARGETDRIVE%:\\Windows\\System32\\bcdboot.exe (\n\techo Running bcdboot against %TARGETDRIVE%:\\Windows\n\tcopy %TARGETDRIVE%:\\Windows\\System32\\bcdboot.exe %temp%\n    %temp%\\bcdboot.exe %TARGETDRIVE%:\\Windows /s %TARGETDRIVE%:\n)\n",
            "description": "This is a simple wrapper script to apply a WIM image using the imagex program.  \n\nUsage: IMAGEPATH [IMAGENUMBER] [TARGETDRIVE]\n\nParameters:\n  IMAGEPATH:  Required. Full local path to the WIM file to apply.\n IMAGENUMBER: image number within the WIM to apply. Default is 1.\n TARGETDRIVE: drive letter where WIM should be applied. \n              Default is \"C\" or the value of the @SystemDrive@ custom attribute.  \n\t\t\t  This should be a single letter corresponding to a valid windows drive. \n\t\t\t  Do not include a trailing colon.\n\nExample:\n apply_wim_image.cmd z:\\windows\\images\\2008.wim\n\n Prerequisites:\n - Target server runs a Windows or Windows PE maintenance OS.",
            "status": null,
            "name": "Apply WIM Image",
            "state": null,
            "eTag": "2015-06-13T04:49:15.000Z",
            "modified": "2015-06-13T04:49:15.000Z",
            "created": "2015-06-13T04:49:15.000Z",
            "category": "os-deployment-server-scripts",
            "uri": "/rest/os-deployment-server-scripts/1150001"
        },
        {
            "runAsSuperUser": true,
            "serverChanging": true,
            "codeType": "BAT",
            "displayCodeType": "Windows .BAT",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "1",
                    "createdBy": "opsware",
                    "createdDate": "2015-06-13T04:49:15.000Z",
                    "usage": "This is a basic diskpart partitioning script that makes a single partition on\nthe first disk using the entire available space and assigning drive letter C.\nThis script does not need any command line parameters.  It will reference the\n@SystemDrive@ and @SystemDiskNumber@ custom attributes if\nthey exist. @SystemDrive@ specifies the drive letter to assign to the\nsystem disk.  This defaults to \"C\" and should be a single letter that\ncorresponds to an available valid windows drive letter.\n@SystemDiskNumber@ is an integer indicating which disk (as seen by\ndiskpart) should be formatted.  This defaults to 0.",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-06-13T04:49:15.000Z",
            "version": {
                "versionLabel": "1",
                "createdBy": "opsware",
                "createdDate": "2015-06-13T04:49:15.000Z",
                "usage": "This is a basic diskpart partitioning script that makes a single partition on\nthe first disk using the entire available space and assigning drive letter C.\nThis script does not need any command line parameters.  It will reference the\n@SystemDrive@ and @SystemDiskNumber@ custom attributes if\nthey exist. @SystemDrive@ specifies the drive letter to assign to the\nsystem disk.  This defaults to \"C\" and should be a single letter that\ncorresponds to an available valid windows drive letter.\n@SystemDiskNumber@ is an integer indicating which disk (as seen by\ndiskpart) should be formatted.  This defaults to 0.",
                "current": true
            },
            "source": "@echo off\r\necho rescan > X:\\diskpart.txt\r\necho select disk @SystemDiskNumber:0@ >> X:\\diskpart.txt\r\necho clean >> X:\\diskpart.txt\r\necho create partition primary >> X:\\diskpart.txt\r\necho select partition=1 >> X:\\diskpart.txt\r\necho assign letter=@SystemDrive:C@ >> X:\\diskpart.txt\r\necho active >> X:\\diskpart.txt\r\necho format FS=NTFS LABEL=\"OS\" REVISION=\"6.00\" quick >> X:\\diskpart.txt\r\necho exit >> X:\\diskpart.txt\r\necho  >> X:\\diskpart.txt\r\necho  >> X:\\diskpart.txt\r\ndiskpart.exe /s X:\\diskpart.txt > %TEMP%\\diskpart.out 2>&1\r\nif %ERRORLEVEL% == 0 (\r\n    echo diskpart completed successfully\r\n    find /V \"0 percent completed\" %TEMP%\\diskpart.out\r\n    exit\r\n) else (\r\n    echo ERROR: diskpart exited status %ERRORLEVEL%\r\n    find /V \"0 percent completed\" %TEMP%\\diskpart.out\r\n    exit /B %ERRORLEVEL%\r\n)\r\n    ",
            "description": "This is a basic diskpart partitioning script that makes a single partition on\nthe first disk using the entire available space and assigning drive letter C.\nThis script does not need any command line parameters.  It will reference the\n@SystemDrive@ and @SystemDiskNumber@ custom attributes if\nthey exist. @SystemDrive@ specifies the drive letter to assign to the\nsystem disk.  This defaults to \"C\" and should be a single letter that\ncorresponds to an available valid windows drive letter.\n@SystemDiskNumber@ is an integer indicating which disk (as seen by\ndiskpart) should be formatted.  This defaults to 0.",
            "status": null,
            "name": "Partition and format the system disk",
            "state": null,
            "eTag": "2015-06-13T04:49:15.000Z",
            "modified": "2015-06-13T04:49:15.000Z",
            "created": "2015-06-13T04:49:15.000Z",
            "category": "os-deployment-server-scripts",
            "uri": "/rest/os-deployment-server-scripts/1160001"
        },
        {
            "runAsSuperUser": true,
            "serverChanging": true,
            "codeType": "SH",
            "displayCodeType": "Unix",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "1",
                    "createdBy": "opsware",
                    "createdDate": "2015-06-13T04:49:16.000Z",
                    "usage": "Creates a 1GB stub partition so we can load the installer boot media from the local disk.\nBy default the boot disk is identified as the first disk in /proc/partitions,\nbut can be overridden using the boot_disk custom attribute.\n\nThe newly created stub partition will be mounted under /mnt/root.\n\nUsage: create_stub_partition.py [options]\n\noptions:\n  --bootMode=BOOTMODE  boot mode of the server, can be UEFI or Legacy (case insensitive);\n                       if not selected the boot mode will be decided based on the service OS booted mode\n                       this also influences how the partition table will be created:\n                         - for UEFI, a GPT partition table with 1\n                           fat32 formatted partition of 1GB\n                         - for Legacy, a MBR partition table with 1\n                           ext3 formatted partition of 1GB\n  --bootDisk=BOOTDISK  Create the stub partition on BOOTDISK instead of autodetermining\n\nPrerequisites:\n- Target server runs a maintenance Linux Service OS.\n- Existing file systems on the boot disk, if mounted, must be unmountable. For example, interactive sessions cannot have the present working\n  directory beneath the mount point. Any partitions on the boot disk that are currently mounted will be unmounted.",
                    "current": false
                },
                {
                    "versionLabel": "2",
                    "createdBy": "opsware",
                    "createdDate": "2015-08-04T07:29:58.000Z",
                    "usage": "Creates a 1GB stub partition so we can load the installer boot media from the local disk.\nBy default the boot disk is identified as the first disk in /proc/partitions,\nbut can be overridden using the boot_disk custom attribute.\n\nThe newly created stub partition will be mounted under /mnt/root.\n\nUsage: create_stub_partition.py [options]\n\noptions:\n  --bootMode=BOOTMODE  boot mode of the server, can be UEFI or Legacy (case insensitive);\n                       if not selected the boot mode will be decided based on the service OS booted mode\n                       this also influences how the partition table will be created:\n                         - for UEFI, a GPT partition table with 1\n                           fat32 formatted partition of 1GB\n                         - for Legacy, a MBR partition table with 1\n                           ext3 formatted partition of 1GB\n  --bootDisk=BOOTDISK  Create the stub partition on BOOTDISK instead of autodetermining\n\nPrerequisites:\n- Target server runs a maintenance Linux Service OS.\n- Existing file systems on the boot disk, if mounted, must be unmountable. For example, interactive sessions cannot have the present working\n  directory beneath the mount point. Any partitions on the boot disk that are currently mounted will be unmounted.",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-08-04T07:29:58.000Z",
            "version": {
                "versionLabel": "2",
                "createdBy": "opsware",
                "createdDate": "2015-08-04T07:29:58.000Z",
                "usage": "Creates a 1GB stub partition so we can load the installer boot media from the local disk.\nBy default the boot disk is identified as the first disk in /proc/partitions,\nbut can be overridden using the boot_disk custom attribute.\n\nThe newly created stub partition will be mounted under /mnt/root.\n\nUsage: create_stub_partition.py [options]\n\noptions:\n  --bootMode=BOOTMODE  boot mode of the server, can be UEFI or Legacy (case insensitive);\n                       if not selected the boot mode will be decided based on the service OS booted mode\n                       this also influences how the partition table will be created:\n                         - for UEFI, a GPT partition table with 1\n                           fat32 formatted partition of 1GB\n                         - for Legacy, a MBR partition table with 1\n                           ext3 formatted partition of 1GB\n  --bootDisk=BOOTDISK  Create the stub partition on BOOTDISK instead of autodetermining\n\nPrerequisites:\n- Target server runs a maintenance Linux Service OS.\n- Existing file systems on the boot disk, if mounted, must be unmountable. For example, interactive sessions cannot have the present working\n  directory beneath the mount point. Any partitions on the boot disk that are currently mounted will be unmounted.",
                "current": true
            },
            "source": "#!/opt/opsware/agent/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n#\n\"\"\"\n    (C) Copyright 2013-2015 Hewlett-Packard Development Company, L.P.\n\n    This program will repartition the target server's boot disk and create a\n    (1 GB) \"stub\" partition.\n\n    The boot disk by default is computed as the first hard drive listed in\n    /proc/partitions, but can be overridden using the boot_disk custom attribute.\n\n    WARNING:\n    The boot disk's partition table, master boot record, and all existing file systems\n    are PERMANENTLY ERASED by this operation.\n\"\"\"\nfrom optparse import OptionError\n\nimport sys\nimport types\n\nfrom osprov.decorators import HandleShowErrorMessage\nfrom osprov.optparse_ext import OptionParser\nfrom osprov.osbp import logger\nfrom osprov.diskmgr.diskmanager import LinuxDiskManager\nfrom osprov.diskmgr.disk import Disk\nfrom osprov import helpers\nfrom osprov import diskmgr\nfrom osprov.scripts import bootmode\nfrom osprov.server.local import ThisLocalServer\n\nEC_SUCCESS = 0\nEC_NO_BOOT_DISK = 10\n\nBOOT_DISK = \"@boot_disk@\"  # will be replaced with the custom attribute value at run time\n\nLOG = logger.getIt(\"osprov.diskmgr\")\n\n\nclass CreateStubPartitionOptionsParser(OptionParser):\n\n    \"\"\" An option parser for this step. \"\"\"\n\n    def defineOptions(self):\n        self.add_option(\"--bootMode\", type=types.StringType,\n                        help=\"boot mode of the server, can be UEFI or Legacy (case insensitive);\"\n                        \"this also influences how the partition table will be created: \"\n                        \" - for UEFI, a GPT partition table with 1 fat32 formatted partition of 1GB \"\n                        \" - for Legacy, a MBR partition table with 1 ext3 formatted partition of 1GB\")\n        self.add_option(\n            \"--bootDisk\", help=\"Create the stub partition on BOOTDISK instead of auto determining\")\n\n    def validateArgs(self, opt, args):\n        if opt.bootMode and not bootmode.isBootModeSupported(opt.bootMode):\n            raise OptionError(\"invalid boot mode: \" + opt.bootMode, \"bootMode\")\n\n\n@HandleShowErrorMessage(\"create stub partition\", log=LOG)\ndef main():\n    options, remainingArgs = CreateStubPartitionOptionsParser().parse_args()\n\n    dm = LinuxDiskManager(log=LOG)\n    dm.disable_automount()\n    dm.unmountOurs()\n    dm.unmountDisks(skipUsb=True)\n\n    if BOOT_DISK and not \"@\" in BOOT_DISK:\n        bootDisk = Disk(BOOT_DISK)\n    elif options.bootDisk:\n        bootDisk = Disk(options.bootDisk)\n    else:\n        bootDisk = None\n    bootDisk = dm.getSystemBootDisk(bootDisk)\n\n    if options.bootMode:\n        bootMode = options.bootMode\n    else:\n        bootMode = bootmode.getCurrentBootMode(targetServer=ThisLocalServer(), log=LOG)\n\n    stubPartition = bootDisk.createStubPartition(partitionTable=diskmgr.getPartitionTable(bootMode))\n    print \"Boot disk partitioned. Stub partition filesystem is on %s.\" % stubPartition.getDeviceFilePath()\n\n    stubPartition.mount()\n    print \"Successfully mounted stub partition filesystem on %s.\" % stubPartition.getMountPoint()\n\n    keys = helpers.getDataStore()\n    keys.disk.device_path = bootDisk.getDeviceFilePath()\n    keys.disk.device_uuid = bootDisk.getDeviceUuid()\n    keys.disk.device_mount = stubPartition.getMountPoint()\n    helpers.putDataStore(keys)\n\n    return EC_SUCCESS\n\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n",
            "description": "Creates a 1GB stub partition so we can load the installer boot media from the local disk.\nBy default the boot disk is identified as the first disk in /proc/partitions,\nbut can be overridden using the boot_disk custom attribute.\n\nThe newly created stub partition will be mounted under /mnt/root.\n\nUsage: create_stub_partition.py [options]\n\noptions:\n  --bootMode=BOOTMODE  boot mode of the server, can be UEFI or Legacy (case insensitive);\n                       if not selected the boot mode will be decided based on the service OS booted mode\n                       this also influences how the partition table will be created:\n                         - for UEFI, a GPT partition table with 1\n                           fat32 formatted partition of 1GB\n                         - for Legacy, a MBR partition table with 1\n                           ext3 formatted partition of 1GB\n  --bootDisk=BOOTDISK  Create the stub partition on BOOTDISK instead of autodetermining\n\nPrerequisites:\n- Target server runs a maintenance Linux Service OS.\n- Existing file systems on the boot disk, if mounted, must be unmountable. For example, interactive sessions cannot have the present working\n  directory beneath the mount point. Any partitions on the boot disk that are currently mounted will be unmounted.",
            "status": null,
            "name": "Create Stub Partition",
            "state": null,
            "eTag": "2015-08-04T07:29:58.000Z",
            "modified": "2015-08-04T07:29:58.000Z",
            "created": "2015-06-13T04:49:16.000Z",
            "category": "os-deployment-server-scripts",
            "uri": "/rest/os-deployment-server-scripts/1170001"
        },
        {
            "runAsSuperUser": true,
            "serverChanging": true,
            "codeType": "SH",
            "displayCodeType": "Unix",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "1",
                    "createdBy": "opsware",
                    "createdDate": "2015-06-13T04:49:16.000Z",
                    "usage": "Installs and configures GRUB (GRand Unified Boot Loader) onto the stub partition of the boot disk on the target server in order to enable the booting into the Oracle Linux 7 installation image.\n\nThe step will also auto detect directories with the names \"addon\", \"AddOn\" and \"ADDON\" in the repository and for SuSE Linux Enterprise Server installations append the proper \"addon='path-to-addon-dir' to the kernel parameters of the grub boot loader.\n\nUsage:\n\nThis script expects no command line arguments, but the following argument(s) can optionally be specified:\n    --kernel_arguments=KERNEL_ARGUMENTS\n                        a string of arguments that will be passed to the OS\n                        installer kernel\n    --disableWarning    Do not show warnings of old hpsa_netconfig format\n\nPrerequisites:\n- Target server runs a maintenance Linux OS.\n- The files in the grub.zip archive must be extracted in /tmp.\n- The \"Create Stub Partition\" step must have been executed. \n\nThis script is intended to be used only as a Build Plan step.",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-06-13T04:49:16.000Z",
            "version": {
                "versionLabel": "1",
                "createdBy": "opsware",
                "createdDate": "2015-06-13T04:49:16.000Z",
                "usage": "Installs and configures GRUB (GRand Unified Boot Loader) onto the stub partition of the boot disk on the target server in order to enable the booting into the Oracle Linux 7 installation image.\n\nThe step will also auto detect directories with the names \"addon\", \"AddOn\" and \"ADDON\" in the repository and for SuSE Linux Enterprise Server installations append the proper \"addon='path-to-addon-dir' to the kernel parameters of the grub boot loader.\n\nUsage:\n\nThis script expects no command line arguments, but the following argument(s) can optionally be specified:\n    --kernel_arguments=KERNEL_ARGUMENTS\n                        a string of arguments that will be passed to the OS\n                        installer kernel\n    --disableWarning    Do not show warnings of old hpsa_netconfig format\n\nPrerequisites:\n- Target server runs a maintenance Linux OS.\n- The files in the grub.zip archive must be extracted in /tmp.\n- The \"Create Stub Partition\" step must have been executed. \n\nThis script is intended to be used only as a Build Plan step.",
                "current": true
            },
            "source": "#!/opt/opsware/agent/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# lint_ignore=E501,I0011\n# Please do not change the two lines above. See PEP 8, PEP 263.\n\"\"\"\n    (C) Copyright 2013-2015 Hewlett-Packard Development Company, L.P.\n\n    This python script installs and configures Grub for BIOS and Grub2 for UEFI.\n\"\"\"\n\nimport os\nimport sys\nimport re\nimport glob\nimport shutil\nfrom cStringIO import StringIO\n\nfrom osprov.decorators import HandleShowErrorMessage\nfrom osprov.diskmgr.disk import LinuxDisk\nfrom osprov.networking.discovery import LinuxNetworkDiscovery\nfrom osprov.optparse_ext import OptionParser\nfrom osprov.osbp import logger\nfrom osprov.parsers.syslinux import Syslinux\nfrom osprov.util import process\nfrom osprov.errors import DiscoveryError, ShowErrorMessage, SetupError\nfrom osprov import helpers, media, netconfig\nfrom osprov.parsers.netconfig import SmartNetconfig, OLD_SYNTAX_WARNING\nfrom osprov.server.local import ThisLocalServer\nfrom osprov.constants import DEFAULT_INITRD_DIR, DEFAULT_SA_INITRD_MASK\nfrom osprov.wrappers.efibootmgr import EfiBootMgr, DiskBootEntry\nfrom osprov import ipaddr\n\nEC_INVALID_ARGS = 1\nEC_IG_FAILED = 5\nEC_GRUBMENU_FAILED = 6\nEC_NO_BOOTDISK = 7\n\nLOG = logger.getIt(\"install_configure_grub\")\n\n\n# for easier mocking\ndef _open(filepath, mode=\"r\"):\n    return open(filepath, mode)\n\n\ndef get_partition_name(device_name, partition_num):\n    \"\"\"Returns the partition with number partition_num for device_name\"\"\"\n    if not partition_num:\n        return device_name\n    base_name = os.path.basename(device_name)\n    if re.search(r\"c\\dd\\d\", base_name):\n        return device_name + \"p\" + str(partition_num)\n    return device_name + str(partition_num)\n\n\nclass Grub(object):\n    \"\"\" Helper class for configuring and installing the Grub boot loader. \"\"\"\n\n    MENU_PATHS = [\"boot/grub/menu.lst\"]\n    MODULES_PATH = \"boot/grub\"\n\n    def __init__(self, location):\n        self.location = location\n        self.grubinfo = self.validate()\n\n    def _getInfo(self):\n        info = {}\n        # first test for newer info.txt file\n        infofile = os.path.join(self.location, \"info.txt\")\n        if os.path.exists(infofile):\n            # get the path info from into.txt\n            execfile(infofile, info)\n            for value in [\"grub\", \"loaderfiles\"]:\n                if not info[value]:\n                    # expected value is missing\n                    return {}\n        else:\n            # set the required info values manually for older grub packages\n            info[\"grub\"] = \"sbin/grub\"\n            info[\"loaderfiles\"] = \"share/grub/i386-pc\"\n        return info\n\n    def validate(self):\n        \"\"\"    Performs some simple validation on the directory where GRUB is located.\n        info.txt can provide non default values for grub binary and loader files\n        and saves from hardcoding more paths in here.\n        info.txt should also contain version info for better tracking of versions.\n        required info entries are:\n                \"grub\"            - path to grub binary\n                \"loaderfiles\"   - path to loader files\n        \"\"\"\n        info = self._getInfo()\n        if not info:\n            return {}\n        # finally verify the paths\n        for path in [info[\"grub\"], info[\"loaderfiles\"]]:\n            if not os.path.exists(os.path.join(self.location, path)):\n                return {}\n        return info\n\n    def copyFilesTo(self, bootDiskMount):\n        \"\"\" Copies files to the location specified. \"\"\"\n        print(\"Copying Boot Loader files to runtime location\")\n        grubinfo = self.grubinfo\n        if not grubinfo:\n            raise ShowErrorMessage(\n                \"Failed to validate %s. A previous Build Plan step may be missing.\" % self.location)\n        targetLocation = os.path.join(bootDiskMount, self.MODULES_PATH)\n        helpers.makeDirs(targetLocation)\n        files = glob.glob(\"%s/*\" % os.path.join(self.location, grubinfo[\"loaderfiles\"]))\n        if not files:\n            raise ShowErrorMessage(\"No file to copy. A previous Build Plan step may be missing\")\n        for source in files:\n            destination = os.path.join(targetLocation, os.path.basename(source))\n            LOG.debug(\"Copying %s to %s\", source, destination)\n            shutil.copyfile(source, destination)\n\n    def install(self, bootDiskMount, bootDisk):\n        \"\"\"\n        Installs the files needed for GRuB on boot_disk.\n        Note that it will overwrite the Master Boot Record for boot_disk.\n        \"\"\"\n        self.copyFilesTo(bootDiskMount)\n        print(\"Preparing Boot Loader config script\")\n        config = list()\n        config.append(\"device (hd0) \" + bootDisk)\n        config.append(\"root (hd0,0)\")\n        config.append(\"install --stage2=%s/boot/grub/stage2 /boot/grub/stage1 d (hd0) \"\n                      \"/boot/grub/stage2 p /boot/grub/menu.lst\" % bootDiskMount)\n        config.append(\"quit\")\n        config_str = \"\\n\".join(config) + \"\\n\"\n\n        print(\"Installing Boot Loader\")\n        os.chmod(\"%s\" % os.path.join(self.location, self.grubinfo[\"grub\"]), 0777)\n        params = \"--batch --no-floppy --config-file=/boot/grub/menu.lst\"\n        process.runIt(\"%s %s\" %\n                      (os.path.join(self.location, self.grubinfo[\"grub\"]), params), input=config_str, quiet=True)\n        return config_str\n\n    def configureMenu(self, title, kernel, kernelArguments, initrds, keys):\n        \"\"\"    Creates a GRUB menu.lst configuration. \"\"\"\n        return \"\"\"\ndefault 0\ntimeout 5\ntitle %(title)s\nroot (hd0,0)\n\nkernel /%(kernel)s %(kernelArguments)s\ninitrd %(initrds)s\n\n\"\"\" % {\n            'title': title,\n            'kernel': kernel,\n            'kernelArguments': kernelArguments,\n            'initrds': ' '.join(initrds)\n        }\n\n\nclass Grub2(Grub):\n    BOOT_DIRECTORY = \"boot/\"\n    MENU_PATHS = [os.path.join(BOOT_DIRECTORY, \"grub/grub.cfg\"), os.path.join(BOOT_DIRECTORY, \"grub2/grub.cfg\")]\n    EFI_BOOT_DIR = \"EFI/BOOT/\"\n    EFI_BOOT_PATH = os.path.join(EFI_BOOT_DIR)\n    EFI_CMD_SUFFIX = \"\"\n\n    def _getInfo(self):\n        info = dict()\n        info[\"grub\"] = \"sbin/grub-install\"\n        info[\"loaderfiles\"] = \"lib/grub/x86_64-efi\"\n        return info\n\n    def install(self, bootDiskMount, bootDisk):\n        secureBootLoader = self.configureSecureBootLoader(bootDiskMount)\n        if not secureBootLoader:\n            process.runIt(\"%(grub-install)s --removable --efi-directory=%(bootDiskMount)s --boot-directory=%(bootDirectory)s %(bootDisk)s\"\n                          % {'grub-install': os.path.join(self.location, self.grubinfo['grub']),\n                             'bootDiskMount': bootDiskMount,\n                             'bootDirectory': os.path.join(bootDiskMount, self.BOOT_DIRECTORY),\n                             'bootDisk': bootDisk}, log=LOG, quiet=True)\n            # configure the UEFI boot entries\n            osInstallerBootEntry = DiskBootEntry(\"HPSA Assisted OS Installer\", disk=bootDisk)\n        else:\n            # configure the UEFI boot entries with specific path to loader\n            print(\"Found UEFI secure boot files in media\")\n            osInstallerBootEntry = DiskBootEntry(\"HPSA Assisted OS Installer\", disk=bootDisk, loader=secureBootLoader)\n        efibootmgr = EfiBootMgr(log=LOG)\n        efibootmgr.bootOneTime(osInstallerBootEntry)\n        print(\"Configured boot to: %s\" % osInstallerBootEntry)\n\n    def configureSecureBootLoader(self, bootDiskMount):\n        keys = helpers.getDataStore()\n        mediaFS = media.factor(keys.media.url, log=LOG)\n        bootEFIFiles = mediaFS.findFiles(path=self.EFI_BOOT_DIR)\n        secureBootFiles = {'boot': None, 'grub': None}\n        for boot in bootEFIFiles:\n            if re.match(\"bootx64\\.efi\", boot, re.IGNORECASE):\n                secureBootFiles['boot'] = boot\n            if re.match(\"grubx64\\.efi\", boot, re.IGNORECASE):\n                secureBootFiles['grub'] = boot\n        LOG.debug(\"Boot files for SecureBoot found in media : %s\" % str(bootEFIFiles))\n        if secureBootFiles['boot'] and secureBootFiles['grub']:\n            # create path on stub partition\n            os.makedirs(os.path.join(bootDiskMount, self.EFI_BOOT_PATH))\n            for boot in bootEFIFiles:\n                if boot and \".efi\" in boot.lower():\n                    mediaFS.copyTo(os.path.join(self.EFI_BOOT_DIR, boot), os.path.join(bootDiskMount, self.EFI_BOOT_PATH))\n            # add new path for grub.cfg and efi suffix\n            self.MENU_PATHS.append(os.path.join(self.EFI_BOOT_PATH, \"grub.cfg\"))\n            self.EFI_CMD_SUFFIX = \"efi\"\n            return os.path.join(\"/\", self.EFI_BOOT_PATH, secureBootFiles['boot']).replace(\"/\", \"\\\\\")\n        return None\n\n    def configureMenu(self, title, kernel, kernelArguments, initrds, keys):\n        \"\"\" Creates a GRUB2 grub.conf configuration \"\"\"\n        return \"\"\"\nset default=0\nset timeout=5\n\ninsmod all_video\n\nmenuentry '%(title)s' {\n    linux%(efi)s  /%(kernel)s %(kernelArguments)s\n    initrd%(efi)s %(initrds)s\n}\n\n\"\"\" % {\n            'efi': self.EFI_CMD_SUFFIX,\n            'title': title,\n            'kernel': kernel,\n            'kernelArguments': kernelArguments,\n            'initrds': ' '.join(initrds),\n            'device_uuid': keys.disk.device_uuid\n        }\n\n\ndef getGrub(bootDisk):\n    \"\"\" Factor a Grub or Grub2 object based on the partition table type of the boot disk \"\"\"\n    if bootDisk.partitionTableType == \"msdos\":\n        return Grub(\"/tmp/grub\")\n    else:\n        return Grub2(\"/tmp/grub2\")\n\n\ndef checkCompleteStaticNetData(netdata, ipv):\n    values = netdata.values()\n    if None in values or \"\" in values:\n        print \"WARNING: The provided %s static configuration is incomplete. The OS installer may fail.\" % ipv\n\n\ndef getIPv6NameServer():\n    lnd = LinuxNetworkDiscovery()\n    lnd.discover()\n    if lnd.netinfo.nics and lnd.netinfo.nics[0].ipv6DnsServers:\n        return lnd.netinfo.nics[0].ipv6DnsServers[0]\n    else:\n        return \"\"\n\n\ndef getNetworkingParams(mac, osdata, netconfig, isIPv6Managed):\n    try:\n        activeIface = [x for x in netconfig.nics if x.provisioning][0]\n    except IndexError:\n        raise SetupError(\"Found no provisioning interface\")\n\n    isRHEL7 = \"RHEL7\" == osdata[\"os_version\"]\n    ip_params = \"\"\n\n    if isIPv6Managed:\n        if activeIface.ipv6Autoconfig:\n            ip_params += \" \" + osdata[\"ip_config_auto6\"] % {'mac': mac}\n            # for RHEL7 on IPv6 we need to set the nameserver since dracut\n            # does not generate a proper dhcpv6 client config\n            # note that NetworkManager does eventually start after the squashfs.img is downloaded\n            # so it will overwrite what dracut configures\n            if \"RHEL7\" == osdata[\"os_version\"]:\n                ip_params += \" nameserver=%s\" % getIPv6NameServer()\n        elif activeIface.ipv6Networks:\n            net_data = {\n                \"ip\": (\"[%s]\" if isRHEL7 else \"%s\") % activeIface.ipv6Networks[0].ip,\n                \"mask\": activeIface.ipv6Networks[0].netmask,\n                \"prefix\": activeIface.ipv6Networks[0].prefixlen,\n                \"dns\": \"\",\n                \"gw\": \"\",\n                \"mac\": mac,\n            }\n            for dnsserv in activeIface.ipv6DnsServers:\n                net_data[\"dns\"] = dnsserv\n                break\n            for route in [x for x in netconfig.ipv6Routes if x.nic == activeIface]:\n                net_data[\"gw\"] = (\"[%s]\" if isRHEL7 else \"%s\") % route.gateway\n                break\n            # support for autoconf + static network in the installer\n            if isRHEL7 and activeIface.ipv6Autoconfig:\n                if not net_data[\"dns\"]:\n                    net_data[\"dns\"] = getIPv6NameServer()\n            ip_params += \" \" + (osdata[\"ip_config_static6\"] % net_data)\n            checkCompleteStaticNetData(net_data, \"IPv6\")\n        else:\n            print \"Can not complete network personalization. \" \\\n                  \"Auto configuration is turned off for IPv6 and there is no static address defined\"\n            sys.exit(37)\n    else:\n        if activeIface.ipv4Networks:\n            net_data = {\n                \"ip\": activeIface.ipv4Networks[0].ip,\n                \"mask\": activeIface.ipv4Networks[0].netmask,\n                \"dns\": \"\",\n                \"gw\": \"\",\n            }\n            for dnsserv in activeIface.dnsServers:\n                if isinstance(dnsserv, ipaddr.IPv4Address):\n                    net_data[\"dns\"] = dnsserv\n                    break\n            for route in [x for x in netconfig.ipv4Routes if x.nic == activeIface]:\n                net_data[\"gw\"] = route.gateway\n                break\n            ip_params += \" \" + (osdata[\"ip_config_static\"] % net_data)\n            checkCompleteStaticNetData(net_data, \"IPv4\")\n        elif activeIface.dhcpv4:\n            ip_params += \" \" + osdata[\"ip_config_dhcp\"]\n        else:\n            print \"Can not complete network personalization. \" \\\n                  \"DHCP is turned off for IPv4 and there is no static address defined\"\n            sys.exit(38)\n\n    return ip_params.strip()\n\n\ndef updateExecInstructions(params1=\"\", params2=\"\"):\n    \"\"\"If both params strings contain the exec argument, the method will remove it form second string and combine\n    the 2 instructions in to the first string\"\"\"\n    if params2.count(\"exec=\") and params1.count(\"exec=\"):\n        ip_param_exec = params2[params2.index(\"exec=\\\"\"):params2.index(\"\\\"\", params2.index(\"exec=\\\"\") + 6) + 1]\n        params2 = params2.replace(ip_param_exec, \"\")\n        if \"exec='\" in params1:\n            params1 = params1.replace(\"exec='\", \"exec='\" + ip_param_exec[6:-1] + \";\")\n        else:\n            params1 = params1.replace('exec=\"', 'exec=\"' + ip_param_exec[6:-1] + \";\")\n    return params1, params2\n\n\ndef configureKernelArguments(osdata, keys, netcfg_parser, kernel_arguments=\"\"):\n    \"\"\" Configures the kernel arguments \"\"\"\n    localServer = ThisLocalServer()\n    boot_disk = keys.disk.device_path\n    boot_disk_uuid = keys.disk.device_uuid\n    # to be used by install_params\n    root_partition = get_partition_name(boot_disk[5:], 1)\n    if \"SLES\" in osdata[\"os_version\"] and \"cciss\" in boot_disk:\n        boot_disk = \"%s//\" % boot_disk\n    # ALERT: do not remove lower(), SLES doesn't recognize a MAC address if upper\n    mac = localServer.getMACAddress().lower()\n    url = mediaUrl(keys)\n    arg_dict = {\n        \"mac\": mac,\n        \"boot_disk\": boot_disk,\n        \"root_partition\": root_partition,\n        \"boot_disk_uuid\": boot_disk_uuid,\n        \"url\": url.canonical(),\n        \"bootif\": netconfig.macToBootIf(mac)\n    }\n    kernel_params = osdata['install_params'] % arg_dict\n    if kernel_arguments:\n        print(\"Found kernel arguments: \" + kernel_arguments)\n        kernel_params = kernel_params + \" \" + kernel_arguments\n\n    # Handle TCP/IP settings to make sure that installers behave  ##\n    ip_params = getNetworkingParams(mac, osdata, netcfg_parser.info(), localServer.isIPv6Managed())\n    if ip_params:\n        print(\"Additional kernel arguments for network configuration: %s\" % ip_params)\n        kernel_params, ip_params = updateExecInstructions(params1=kernel_params, params2=ip_params)\n        kernel_params += \" \" + ip_params\n\n    # Limit ports only if we are doing NFS, sles 11 sp0 has issues with this setting\n    if url.scheme == \"nfs\":\n        # Make sure that the nfs client doesn't use the agent port\n        kernel_params += \" sunrpc.max_resvport=1000\"\n\n    # if present handle addonloc\n    if \"addonloc\" in osdata and osdata[\"addonloc\"]:\n        # Handle SLES addon sources (eg. by use of kISO content)\n        if \"SLES\" in osdata[\"os_version\"]:\n            if kernel_params.lower().find(\"addon=\") == -1:\n                # no addon parameter present - add it using the found location if any\n                print \"Boot Loader (SLES) auto appending kernel parameter \"\"addon=%s\"\" \" % osdata[\"addonloc\"]\n                kernel_params += \" addon=%s\" % osdata[\"addonloc\"]\n            else:\n                print \"Boot Loader (SLES) \"\"addon=\"\" parameter present - not auto appending\"\n\n    # tidy up the kernel_params to contain only one blank between and no trailing blanks\n    # required for SLES's picky addon parameter handler (would fail with nfs:// source)\n    kernel_params = ' '.join(kernel_params.split())\n\n    return kernel_params\n\n\ndef configureInitrds(osdata, keys):\n    # start with the default initrd\n    initrdlist = [\"/%s\" % osdata[\"initrd\"]]\n\n    discoverLocalRds(osdata, root=keys.disk.device_mount)\n\n    # if present add supplemental local initrds\n    if \"localrds\" in osdata:\n        for eachrd in osdata[\"localrds\"]:\n            initrdlist.append(eachrd)\n        # max number of initrds that can be handled is limited by the line length\n        # limit of grubs menu.lst: 1500 chars.\n        if len(initrdlist) > (1500 - 1):\n            raise DiscoveryError(\"INITRD parameter: Maximum parameter length (1500) exceeded! \"\n                                 \"- Too many additional initrd files found.\")\n    return initrdlist\n\n\ndef discoverLocalRds(osdata, root):\n    \"\"\" Get initrd files from /localrds directory \"\"\"\n    rds = helpers.findFiles(\n        path=os.path.join(root, DEFAULT_INITRD_DIR), mask=DEFAULT_SA_INITRD_MASK)\n    if rds:\n        rdlist = []\n        # add the local path to make it suitable for grub\n        for eachrd in rds:\n            rdlist.append(os.path.join(os.path.sep, DEFAULT_INITRD_DIR, eachrd))\n        osdata[\"localrds\"] = helpers.numericalSort(rdlist)\n    return\n\n\ndef discoverOsdata(osdata, keys):\n    \"\"\" Discover the kernel and initrd to use based on the media \"\"\"\n    # the copy boot media step should have run by now, so we work with the\n    # stub partition. This is just so we don't access the media twice\n    stub_path = keys.disk.device_mount\n    if not stub_path:\n        raise DiscoveryError(\"Cannot discover boot disk mount point. \"\n                             \"Was the stub partition created?\")\n    isocfg = Syslinux.readonly(_open(os.path.join(stub_path, \"isolinux.cfg\")))\n    isocfg_label = isocfg.info()[\"label \" + isocfg.first_non_local_label()]\n    # discover the kernel\n    osdata[\"kernel\"] = os.path.basename(isocfg_label[\"kernel\"])\n    # discover the initrd\n    append = isocfg_label[\"append\"].split(' ')\n    for each in append:\n        if '=' in each:\n            key, value = [x.strip() for x in each.split('=', 1)]\n            if key == \"initrd\":\n                osdata[\"initrd\"] = os.path.basename(value)\n    if \"initrd\" not in osdata:\n        raise DiscoveryError(\"Failed to discover the initrd\")\n\n    # verify the files are there otherwise the boot loader will fail to find them\n    kernel = os.path.join(stub_path, osdata[\"kernel\"])\n    initrd = os.path.join(stub_path, osdata[\"initrd\"])\n    if not os.path.exists(kernel) or not os.path.exists(initrd):\n        raise DiscoveryError(\"Failed to discover the boot kernel or initrd\")\n\n\ndef discoverSlesAddon(osdata, keys):\n    \"\"\" Discover addon directories for\n            SLES: kISO formatted media w/ \"addon\" directory\n    \"\"\"\n    url = mediaUrl(keys)\n    thismedia = media.factor(str(url))\n    # for SLES check for addon directory in the repository\n    SLES_ADDON_LOCATIONS = [\n        # common names for SLES addon directory\n        \"addon/\", \"ADDON/\", \"AddOn/\"\n    ]\n    for each_file in SLES_ADDON_LOCATIONS:\n        if thismedia.exists(each_file):\n            osdata[\"addonloc\"] = url.canonical() + \"/\" + each_file\n            print \"Boot Loader (SLES) ADDON directory found in source location: %s\" % osdata[\"addonloc\"]\n            return\n\n\ndef mediaUrl(keys):\n    \"\"\" determine the media server and path \"\"\"\n    url = keys.media.url\n    if not url:\n        # Fall back in case of old NFS mount script\n        mediaServer = _open(\"/tmp/osbp_info/media_server\", \"r\").read().strip()\n        mediaPath = _open(\"/tmp/osbp_info/media_path\", \"r\").read().strip()\n        mediaMount = _open(\"/tmp/osbp_info/media_mount\", \"r\").read().strip()\n        url = \"nfs://%s:%s/#%s\" % (mediaServer, mediaPath, mediaMount)\n    return media.parseUrl(url)\n\n\nclass InstallConfigureGrubOptionParser(OptionParser):\n    def defineOptions(self):\n        self.add_option(\"--kernel_arguments\", default=\"\",\n                        help=\"a string of arguments that will be passed to the OS installer kernel\")\n        self.add_option(\"--disableWarning\", dest=\"disableWarning\", action=\"store_true\",\n                        default=False,\n                        help=\"Do not show warnings of old hpsa_netconfig format\")\n\n\n@HandleShowErrorMessage(\"install and configure bootloader\", log=LOG)\ndef main():\n    options, remainingArgs = InstallConfigureGrubOptionParser().parse_args()\n    del remainingArgs\n\n    localServer = ThisLocalServer()\n    parser = SmartNetconfig.readwrite(\n        StringIO(HPSA_NETCONFIG),\n        activeMacAddress=localServer.getMACAddress(),\n        ipv6default=localServer.isIPv6Managed(),\n        log=LOG\n    )\n    if parser.info().oldSyntax and not options.disableWarning:\n        newFormat = parser.format()\n        print OLD_SYNTAX_WARNING + \"\\n%s\" % str(newFormat)\n\n    typosList = parser.getTyposList()\n    if typosList:\n        print(\"The following keys were not recognized in the netconfig CA and could be typos: %s\" % typosList)\n\n    keys = helpers.getDataStore()\n\n    bootDiskMount = keys.disk.device_mount\n    if not bootDiskMount:\n        raise DiscoveryError(\"Discovery of the boot disk mount point failed. \"\n                             \"Was the stub partition created?\", EC_NO_BOOTDISK)\n\n    bootDisk = LinuxDisk(keys.disk.device_path, None, None)\n    grub = getGrub(bootDisk)\n    try:\n        grub.install(bootDiskMount, bootDisk.getDeviceFilePath())\n    except (OSError, IOError), why:\n        print \"Installing GRuB failed. %s\" % why\n        return EC_IG_FAILED\n\n    # build.py will perform the needed substitutions here\n    osdata = dict()\n    osdata[\"os_display_name\"] = 'Oracle Linux 7'\n    osdata[\"os_version\"] = 'RHEL7'\n    osdata[\"install_params\"] = 'ks=file:/user.ks.cfg'\n    osdata[\"ip_config_static\"] = ''\n    osdata[\"ip_config_static6\"] = 'ifname=provisioning:%(mac)s bootdev=provisioning ip=%(ip)s::%(gw)s:%(prefix)s::provisioning:none: nameserver=%(dns)s'\n    osdata[\"ip_config_dhcp\"] = ''\n    osdata[\"ip_config_auto6\"] = 'ifname=provisioning:%(mac)s bootdev=provisioning ip=provisioning:auto6'\n\n    discoverOsdata(osdata, keys)\n    if \"SLES\" in osdata[\"os_version\"]:\n        discoverSlesAddon(osdata, keys)\n\n    title = 'HP SA assisted %s installer' % osdata['os_display_name']\n    kernelArguments = configureKernelArguments(osdata, keys, parser,\n                                               kernel_arguments=options.kernel_arguments + \" hpsa_monitoring_agent=1\")\n    initrds = configureInitrds(osdata, keys)\n\n    menu = grub.configureMenu(title,\n                              osdata['kernel'], kernelArguments,\n                              initrds, keys)\n    for menuPath in grub.MENU_PATHS:\n        if not os.path.exists(os.path.join(bootDiskMount, os.path.dirname(menuPath))):\n            os.makedirs(os.path.join(bootDiskMount, os.path.dirname(menuPath)))\n        _open(os.path.join(bootDiskMount, menuPath), \"w\").write(menu)\n\n    return 0\n\nHPSA_NETCONFIG = \"\"\"@hpsa_netconfig@\"\"\"\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n",
            "description": "Installs and configures GRUB (GRand Unified Boot Loader) onto the stub partition of the boot disk on the target server in order to enable the booting into the Oracle Linux 7 installation image.\n\nThe step will also auto detect directories with the names \"addon\", \"AddOn\" and \"ADDON\" in the repository and for SuSE Linux Enterprise Server installations append the proper \"addon='path-to-addon-dir' to the kernel parameters of the grub boot loader.\n\nUsage:\n\nThis script expects no command line arguments, but the following argument(s) can optionally be specified:\n    --kernel_arguments=KERNEL_ARGUMENTS\n                        a string of arguments that will be passed to the OS\n                        installer kernel\n    --disableWarning    Do not show warnings of old hpsa_netconfig format\n\nPrerequisites:\n- Target server runs a maintenance Linux OS.\n- The files in the grub.zip archive must be extracted in /tmp.\n- The \"Create Stub Partition\" step must have been executed. \n\nThis script is intended to be used only as a Build Plan step.",
            "status": null,
            "name": "Install bootloader for Oracle Linux 7",
            "state": null,
            "eTag": "2015-06-13T04:49:16.000Z",
            "modified": "2015-06-13T04:49:16.000Z",
            "created": "2015-06-13T04:49:16.000Z",
            "category": "os-deployment-server-scripts",
            "uri": "/rest/os-deployment-server-scripts/1180001"
        },
        {
            "runAsSuperUser": true,
            "serverChanging": true,
            "codeType": "BAT",
            "displayCodeType": "Windows .BAT",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "1",
                    "createdBy": "opsware",
                    "createdDate": "2015-06-13T04:49:17.000Z",
                    "usage": "Installs Windows 2008 x64 from OS Media. Requires full path to  setup.exe from the installation media.",
                    "current": false
                },
                {
                    "versionLabel": "2",
                    "createdBy": "opsware",
                    "createdDate": "2015-08-04T07:30:25.000Z",
                    "usage": "Installs Windows 2008 x64 from OS Media. Requires full path to  setup.exe from the installation media.",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-08-04T07:30:25.000Z",
            "version": {
                "versionLabel": "2",
                "createdBy": "opsware",
                "createdDate": "2015-08-04T07:30:25.000Z",
                "usage": "Installs Windows 2008 x64 from OS Media. Requires full path to  setup.exe from the installation media.",
                "current": true
            },
            "source": "@echo off\nsetlocal\nset SIG=WINPE64\nset ANSWER=X:\\Windows\\Temp\\Unattend.xml\nset ARGS=/noreboot /unattend:%ANSWER%\nset | find \"opswbasig=%SIG%\" > NUL\nif %ERRORLEVEL% NEQ 0 (\n    echo ERROR: Target server must be running %SIG% but it is not\n    exit /B 1\n)\nif X%1==X (\n    set SETUP=z:\\i386\\winnt32.exe\n) else (\n    set SETUP=%1\n)\nif not exist %SETUP% (\n    echo %SETUP% missing! Cannot install Windows.\n    exit /B 2\n)\nif not exist %ANSWER% (\n    echo %ANSWER% missing! Cannot install Windows.\n    exit /B 3\n)\n\n%SETUP% %ARGS%\n\nif %ERRORLEVEL% == 0 (\n    echo Windows setup completed successfully\n    exit\n) else (\n    echo ERROR: Windows setup exited status %ERRORLEVEL%\n    exit /B %ERRORLEVEL%\n)\n",
            "description": "Installs Windows 2008 x64 from OS Media. Requires full path to  setup.exe from the installation media.",
            "status": null,
            "name": "Run Windows 2008 x64 Setup",
            "state": null,
            "eTag": "2015-08-04T07:30:25.000Z",
            "modified": "2015-08-04T07:30:25.000Z",
            "created": "2015-06-13T04:49:17.000Z",
            "category": "os-deployment-server-scripts",
            "uri": "/rest/os-deployment-server-scripts/1190001"
        },
        {
            "runAsSuperUser": true,
            "serverChanging": true,
            "codeType": "PY2",
            "displayCodeType": "Python",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "1",
                    "createdBy": "opsware",
                    "createdDate": "2015-06-13T04:49:17.000Z",
                    "usage": "Creates a stub ramdisk so we can load the Linux and initrd images from the network.\nThe ramdisk will not be able to expand.\n\nUsage:\n  -h, --help            show this help message and exit\n  -s SIZE, --size=SIZE  The size of the ramdisk to be created (measured in MB)\n  -m MOUNT_POINT, --mountPoint=MOUNT_POINT\n                        The path where the ramdisk will be mounted\n\nBy default the ramdisk will be mounted in \"/mnt/root\".\nBy default the ramdisk will be 1 GB in size.\n\nThis script expects no command line arguments.\n\nPrerequisites:\n- Target server runs a maintenance Linux OS.\n\nThis script is intended to be used only as a Build Plan step.",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-06-13T04:49:17.000Z",
            "version": {
                "versionLabel": "1",
                "createdBy": "opsware",
                "createdDate": "2015-06-13T04:49:17.000Z",
                "usage": "Creates a stub ramdisk so we can load the Linux and initrd images from the network.\nThe ramdisk will not be able to expand.\n\nUsage:\n  -h, --help            show this help message and exit\n  -s SIZE, --size=SIZE  The size of the ramdisk to be created (measured in MB)\n  -m MOUNT_POINT, --mountPoint=MOUNT_POINT\n                        The path where the ramdisk will be mounted\n\nBy default the ramdisk will be mounted in \"/mnt/root\".\nBy default the ramdisk will be 1 GB in size.\n\nThis script expects no command line arguments.\n\nPrerequisites:\n- Target server runs a maintenance Linux OS.\n\nThis script is intended to be used only as a Build Plan step.",
                "current": true
            },
            "source": "#!/opt/opsware/agent/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n\"\"\"\n    (C) Copyright 2013-2015 Hewlett-Packard Development Company, L.P.\n\n    This program will create a stub ramdisk (default 1 gB) and mount, default mount point /mnt/root\n\"\"\"\nimport sys\n\nfrom osprov.osbp import logger\nfrom osprov.util import process\nfrom osprov.optparse_ext import OptionParser\nfrom osprov.decorators import HandleShowErrorMessage\nfrom optparse import OptionValueError\nfrom osprov.errors import ShowErrorMessage\nfrom osprov import helpers\nfrom osprov.server.local import ThisLocalServer\n\nLOG = logger.getIt(\"Create stub ramdisk\")\n\nEC_SUCCESS = 0\nEC_NOT_ENOUGH_MEMORY = 10\nEC_MOUNT_POINT_EXISTS = 183\n\n\nclass MemoryException(ShowErrorMessage):\n    DEFAULT_EC = EC_NOT_ENOUGH_MEMORY\n\n\nclass MountException(ShowErrorMessage):\n    DEFAULT_EC = EC_MOUNT_POINT_EXISTS\n\n\nclass CreateAndMountStubRamdiskStepOptionsParser(OptionParser):\n\n    \"\"\" An options' parser for this step. \"\"\"\n\n    def defineOptions(self):\n        self.add_option(\n            \"-s\", \"--size\", type=\"int\", dest=\"size\", metavar=\"SIZE\", default=1024,\n            help=\"The size of the ramdisk to be created (measured in mB)\")\n        self.add_option(\n            \"-m\", \"--mountPoint\", type=\"string\", dest=\"mountPoint\", metavar=\"MOUNT_POINT\", default=\"/mnt/root\",\n            help=\"The path where the ramdisk will be mounted\")\n\n    def validateArgs(self, opt, args):\n        if args:\n            raise OptionValueError(\"Additional positional arguments are not supported\")\n        if opt.size < 1:\n            raise OptionValueError(\"Ramdisk size must be a positive, non zero integer\")\n\n\ndef checkMounts(mounts, mountPoint):\n    for key, values in mounts.items():\n        for mpoint in values:\n            if mountPoint in mpoint:\n                raise MountException(\n                    \"There is already a device (%s) mounted at %s\", (key, mountPoint))\n\n\ndef checkIfMounted(mountPoint):\n    checkMounts(ThisLocalServer().sysinfo.mounts, mountPoint)\n\n\ndef createAndMountRamDisk(size, mountPoint):\n    \"\"\"\n            Creates a ramdisk of size \"size\" and mounts it at \"mountPoint\"\n    \"\"\"\n    freeRam = ThisLocalServer().sysinfo.freeRamkB\n\n    if not freeRam > size * 1024:\n        raise MemoryException(\n            \"Not enough memory on system! Requested %i but only %i Mb available\" % (size, freeRam / 1024))\n    else:\n        checkIfMounted(mountPoint)\n\n    helpers.makeDirs(mountPoint)\n    process.runIt(\"mount -t tmpfs -o size=%sm tmpfs %s\" % (size, mountPoint), log=LOG)\n\n    # Save relevant information in the datastore\n    LOG.info(\"savind mount point: %s\" % mountPoint)\n    keys = helpers.getDataStore()\n    if keys.disk.device_mount == None:\n        keys.disk.device_mount = mountPoint\n        helpers.putDataStore(keys)\n\n\n@HandleShowErrorMessage(\"create stub ramdisk step\", LOG)\ndef main():\n    \"\"\"Main entry point when executed as a script from the command line\"\"\"\n    parser = CreateAndMountStubRamdiskStepOptionsParser()\n    options, args = parser.parse_args()\n\n    createAndMountRamDisk(options.size, options.mountPoint)\n\n    return EC_SUCCESS\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n",
            "description": "Creates a stub ramdisk so we can load the Linux and initrd images from the network.\nThe ramdisk will not be able to expand.\n\nUsage:\n  -h, --help            show this help message and exit\n  -s SIZE, --size=SIZE  The size of the ramdisk to be created (measured in MB)\n  -m MOUNT_POINT, --mountPoint=MOUNT_POINT\n                        The path where the ramdisk will be mounted\n\nBy default the ramdisk will be mounted in \"/mnt/root\".\nBy default the ramdisk will be 1 GB in size.\n\nThis script expects no command line arguments.\n\nPrerequisites:\n- Target server runs a maintenance Linux OS.\n\nThis script is intended to be used only as a Build Plan step.",
            "status": null,
            "name": "Create and Mount Ramdisk",
            "state": null,
            "eTag": "2015-06-13T04:49:17.000Z",
            "modified": "2015-06-13T04:49:17.000Z",
            "created": "2015-06-13T04:49:17.000Z",
            "category": "os-deployment-server-scripts",
            "uri": "/rest/os-deployment-server-scripts/1200001"
        },
        {
            "runAsSuperUser": true,
            "serverChanging": true,
            "codeType": "PY2",
            "displayCodeType": "Python",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "1",
                    "createdBy": "opsware",
                    "createdDate": "2015-06-13T04:49:18.000Z",
                    "usage": "Creates a small stub partition so we can load the Solaris build image from local disk.\nBy default the boot disk is identified as the first disk in lshal.\nA single 2 GB partition will be created with a ZFS filesystem on slice 0.\n\nThe partition will be mounted under /mnt/root.\n\nUsage: create_stub_partition.py\n\nThis script expects no command line arguments.\nBoot drive selection can be overridden using the 'boot_disk' custom attribute, valid values are Solaris whole-disk device names, such as c3t0d0p0.\n\nPrerequisites:\n\n- This script must be run as part of a Build Plan under a Solaris Service OS\n- No additional filesystems must be mounted on the target drive",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-06-13T04:49:18.000Z",
            "version": {
                "versionLabel": "1",
                "createdBy": "opsware",
                "createdDate": "2015-06-13T04:49:18.000Z",
                "usage": "Creates a small stub partition so we can load the Solaris build image from local disk.\nBy default the boot disk is identified as the first disk in lshal.\nA single 2 GB partition will be created with a ZFS filesystem on slice 0.\n\nThe partition will be mounted under /mnt/root.\n\nUsage: create_stub_partition.py\n\nThis script expects no command line arguments.\nBoot drive selection can be overridden using the 'boot_disk' custom attribute, valid values are Solaris whole-disk device names, such as c3t0d0p0.\n\nPrerequisites:\n\n- This script must be run as part of a Build Plan under a Solaris Service OS\n- No additional filesystems must be mounted on the target drive",
                "current": true
            },
            "source": "#!/opt/opsware/agent/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n\"\"\"\n    (C) Copyright 2013-2015 Hewlett-Packard Development Company, L.P.\n\n    This program will repartition the target server's boot disk and create a\n    small (2 GB) \"stub\" ZFS filesystem.\n\n    The boot disk by default is the first hard drive as listed in lshal.\n\n    WARNING!\n\n    The disk's partition table, master boot record, and all existing file systems\n    are PERMANENTLY ERASED by this operation.\n\"\"\"\n\nimport sys\n\nfrom osprov.osbp import logger\nfrom osprov.diskmgr.diskmanager import DiskManager\nfrom osprov.diskmgr.disk import Disk\nfrom osprov import helpers\nfrom osprov.decorators import HandleShowErrorMessage\n\n\nBOOT_DISK = \"@boot_disk@\"  # ScriptWeaver will parametrize this data at run time\n\nLOG = logger.getIt(\"Create Solaris Stub Partition\")\n\n\n@HandleShowErrorMessage(\"Create Solaris Stub Partition\", LOG)\ndef main():\n    \"\"\"Main entry point when executed as a script from the command line\"\"\"\n\n    dm = DiskManager(log=LOG)\n    dm.disable_automount()\n    dm.unmountOurs()\n\n    if BOOT_DISK and \"@\" not in BOOT_DISK:\n        bootDisk = Disk(BOOT_DISK)\n    else:\n        bootDisk = None\n\n    bootDisk = dm.getSystemBootDisk(bootDisk)\n\n    stubPartition = bootDisk.createStubPartition()\n    print \"Boot disk partitioned. Stub filesystem is on %s\" % \\\n        stubPartition.getDeviceFilePath()\n\n    # ZFS auto-mounts filesystems, so just setting the mount point suffices\n    stubPartition.setMountPoint(\"/mnt/root\")\n\n    # Save relevant information in the datastore\n    keys = helpers.getDataStore()\n    keys.disk.device_path = stubPartition.getRawFilePath()\n    keys.disk.device_mount = \"/mnt/root\"\n    helpers.putDataStore(keys)\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n",
            "description": "Creates a small stub partition so we can load the Solaris build image from local disk.\nBy default the boot disk is identified as the first disk in lshal.\nA single 2 GB partition will be created with a ZFS filesystem on slice 0.\n\nThe partition will be mounted under /mnt/root.\n\nUsage: create_stub_partition.py\n\nThis script expects no command line arguments.\nBoot drive selection can be overridden using the 'boot_disk' custom attribute, valid values are Solaris whole-disk device names, such as c3t0d0p0.\n\nPrerequisites:\n\n- This script must be run as part of a Build Plan under a Solaris Service OS\n- No additional filesystems must be mounted on the target drive",
            "status": null,
            "name": "Create Solaris Stub Partition",
            "state": null,
            "eTag": "2015-06-13T04:49:18.000Z",
            "modified": "2015-06-13T04:49:18.000Z",
            "created": "2015-06-13T04:49:18.000Z",
            "category": "os-deployment-server-scripts",
            "uri": "/rest/os-deployment-server-scripts/1220001"
        },
        {
            "runAsSuperUser": true,
            "serverChanging": true,
            "codeType": "SH",
            "displayCodeType": "Unix",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "1",
                    "createdBy": "opsware",
                    "createdDate": "2015-06-13T04:49:19.000Z",
                    "usage": "Installs and configures GRUB (GRand Unified Boot Loader) onto the stub partition of the boot disk on the target server in order to enable the booting into the CentOS installation image.\n\nThe step will also auto detect directories with the names \"addon\", \"AddOn\" and \"ADDON\" in the repository and for SuSE Linux Enterprise Server installations append the proper \"addon='path-to-addon-dir' to the kernel parameters of the grub boot loader.\n\nUsage:\n\nThis script expects no command line arguments, but the following argument(s) can optionally be specified:\n    --kernel_arguments=KERNEL_ARGUMENTS\n                        a string of arguments that will be passed to the OS\n                        installer kernel\n    --disableWarning    Do not show warnings of old hpsa_netconfig format\n\nPrerequisites:\n- Target server runs a maintenance Linux OS.\n- The files in the grub.zip archive must be extracted in /tmp.\n- The \"Create Stub Partition\" step must have been executed. \n\nThis script is intended to be used only as a Build Plan step.",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-06-13T04:49:19.000Z",
            "version": {
                "versionLabel": "1",
                "createdBy": "opsware",
                "createdDate": "2015-06-13T04:49:19.000Z",
                "usage": "Installs and configures GRUB (GRand Unified Boot Loader) onto the stub partition of the boot disk on the target server in order to enable the booting into the CentOS installation image.\n\nThe step will also auto detect directories with the names \"addon\", \"AddOn\" and \"ADDON\" in the repository and for SuSE Linux Enterprise Server installations append the proper \"addon='path-to-addon-dir' to the kernel parameters of the grub boot loader.\n\nUsage:\n\nThis script expects no command line arguments, but the following argument(s) can optionally be specified:\n    --kernel_arguments=KERNEL_ARGUMENTS\n                        a string of arguments that will be passed to the OS\n                        installer kernel\n    --disableWarning    Do not show warnings of old hpsa_netconfig format\n\nPrerequisites:\n- Target server runs a maintenance Linux OS.\n- The files in the grub.zip archive must be extracted in /tmp.\n- The \"Create Stub Partition\" step must have been executed. \n\nThis script is intended to be used only as a Build Plan step.",
                "current": true
            },
            "source": "#!/opt/opsware/agent/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# lint_ignore=E501,I0011\n# Please do not change the two lines above. See PEP 8, PEP 263.\n\"\"\"\n    (C) Copyright 2013-2015 Hewlett-Packard Development Company, L.P.\n\n    This python script installs and configures Grub for BIOS and Grub2 for UEFI.\n\"\"\"\n\nimport os\nimport sys\nimport re\nimport glob\nimport shutil\nfrom cStringIO import StringIO\n\nfrom osprov.decorators import HandleShowErrorMessage\nfrom osprov.diskmgr.disk import LinuxDisk\nfrom osprov.networking.discovery import LinuxNetworkDiscovery\nfrom osprov.optparse_ext import OptionParser\nfrom osprov.osbp import logger\nfrom osprov.parsers.syslinux import Syslinux\nfrom osprov.util import process\nfrom osprov.errors import DiscoveryError, ShowErrorMessage, SetupError\nfrom osprov import helpers, media, netconfig\nfrom osprov.parsers.netconfig import SmartNetconfig, OLD_SYNTAX_WARNING\nfrom osprov.server.local import ThisLocalServer\nfrom osprov.constants import DEFAULT_INITRD_DIR, DEFAULT_SA_INITRD_MASK\nfrom osprov.wrappers.efibootmgr import EfiBootMgr, DiskBootEntry\nfrom osprov import ipaddr\n\nEC_INVALID_ARGS = 1\nEC_IG_FAILED = 5\nEC_GRUBMENU_FAILED = 6\nEC_NO_BOOTDISK = 7\n\nLOG = logger.getIt(\"install_configure_grub\")\n\n\n# for easier mocking\ndef _open(filepath, mode=\"r\"):\n    return open(filepath, mode)\n\n\ndef get_partition_name(device_name, partition_num):\n    \"\"\"Returns the partition with number partition_num for device_name\"\"\"\n    if not partition_num:\n        return device_name\n    base_name = os.path.basename(device_name)\n    if re.search(r\"c\\dd\\d\", base_name):\n        return device_name + \"p\" + str(partition_num)\n    return device_name + str(partition_num)\n\n\nclass Grub(object):\n    \"\"\" Helper class for configuring and installing the Grub boot loader. \"\"\"\n\n    MENU_PATHS = [\"boot/grub/menu.lst\"]\n    MODULES_PATH = \"boot/grub\"\n\n    def __init__(self, location):\n        self.location = location\n        self.grubinfo = self.validate()\n\n    def _getInfo(self):\n        info = {}\n        # first test for newer info.txt file\n        infofile = os.path.join(self.location, \"info.txt\")\n        if os.path.exists(infofile):\n            # get the path info from into.txt\n            execfile(infofile, info)\n            for value in [\"grub\", \"loaderfiles\"]:\n                if not info[value]:\n                    # expected value is missing\n                    return {}\n        else:\n            # set the required info values manually for older grub packages\n            info[\"grub\"] = \"sbin/grub\"\n            info[\"loaderfiles\"] = \"share/grub/i386-pc\"\n        return info\n\n    def validate(self):\n        \"\"\"    Performs some simple validation on the directory where GRUB is located.\n        info.txt can provide non default values for grub binary and loader files\n        and saves from hardcoding more paths in here.\n        info.txt should also contain version info for better tracking of versions.\n        required info entries are:\n                \"grub\"            - path to grub binary\n                \"loaderfiles\"   - path to loader files\n        \"\"\"\n        info = self._getInfo()\n        if not info:\n            return {}\n        # finally verify the paths\n        for path in [info[\"grub\"], info[\"loaderfiles\"]]:\n            if not os.path.exists(os.path.join(self.location, path)):\n                return {}\n        return info\n\n    def copyFilesTo(self, bootDiskMount):\n        \"\"\" Copies files to the location specified. \"\"\"\n        print(\"Copying Boot Loader files to runtime location\")\n        grubinfo = self.grubinfo\n        if not grubinfo:\n            raise ShowErrorMessage(\n                \"Failed to validate %s. A previous Build Plan step may be missing.\" % self.location)\n        targetLocation = os.path.join(bootDiskMount, self.MODULES_PATH)\n        helpers.makeDirs(targetLocation)\n        files = glob.glob(\"%s/*\" % os.path.join(self.location, grubinfo[\"loaderfiles\"]))\n        if not files:\n            raise ShowErrorMessage(\"No file to copy. A previous Build Plan step may be missing\")\n        for source in files:\n            destination = os.path.join(targetLocation, os.path.basename(source))\n            LOG.debug(\"Copying %s to %s\", source, destination)\n            shutil.copyfile(source, destination)\n\n    def install(self, bootDiskMount, bootDisk):\n        \"\"\"\n        Installs the files needed for GRuB on boot_disk.\n        Note that it will overwrite the Master Boot Record for boot_disk.\n        \"\"\"\n        self.copyFilesTo(bootDiskMount)\n        print(\"Preparing Boot Loader config script\")\n        config = list()\n        config.append(\"device (hd0) \" + bootDisk)\n        config.append(\"root (hd0,0)\")\n        config.append(\"install --stage2=%s/boot/grub/stage2 /boot/grub/stage1 d (hd0) \"\n                      \"/boot/grub/stage2 p /boot/grub/menu.lst\" % bootDiskMount)\n        config.append(\"quit\")\n        config_str = \"\\n\".join(config) + \"\\n\"\n\n        print(\"Installing Boot Loader\")\n        os.chmod(\"%s\" % os.path.join(self.location, self.grubinfo[\"grub\"]), 0777)\n        params = \"--batch --no-floppy --config-file=/boot/grub/menu.lst\"\n        process.runIt(\"%s %s\" %\n                      (os.path.join(self.location, self.grubinfo[\"grub\"]), params), input=config_str, quiet=True)\n        return config_str\n\n    def configureMenu(self, title, kernel, kernelArguments, initrds, keys):\n        \"\"\"    Creates a GRUB menu.lst configuration. \"\"\"\n        return \"\"\"\ndefault 0\ntimeout 5\ntitle %(title)s\nroot (hd0,0)\n\nkernel /%(kernel)s %(kernelArguments)s\ninitrd %(initrds)s\n\n\"\"\" % {\n            'title': title,\n            'kernel': kernel,\n            'kernelArguments': kernelArguments,\n            'initrds': ' '.join(initrds)\n        }\n\n\nclass Grub2(Grub):\n    BOOT_DIRECTORY = \"boot/\"\n    MENU_PATHS = [os.path.join(BOOT_DIRECTORY, \"grub/grub.cfg\"), os.path.join(BOOT_DIRECTORY, \"grub2/grub.cfg\")]\n    EFI_BOOT_DIR = \"EFI/BOOT/\"\n    EFI_BOOT_PATH = os.path.join(EFI_BOOT_DIR)\n    EFI_CMD_SUFFIX = \"\"\n\n    def _getInfo(self):\n        info = dict()\n        info[\"grub\"] = \"sbin/grub-install\"\n        info[\"loaderfiles\"] = \"lib/grub/x86_64-efi\"\n        return info\n\n    def install(self, bootDiskMount, bootDisk):\n        secureBootLoader = self.configureSecureBootLoader(bootDiskMount)\n        if not secureBootLoader:\n            process.runIt(\"%(grub-install)s --removable --efi-directory=%(bootDiskMount)s --boot-directory=%(bootDirectory)s %(bootDisk)s\"\n                          % {'grub-install': os.path.join(self.location, self.grubinfo['grub']),\n                             'bootDiskMount': bootDiskMount,\n                             'bootDirectory': os.path.join(bootDiskMount, self.BOOT_DIRECTORY),\n                             'bootDisk': bootDisk}, log=LOG, quiet=True)\n            # configure the UEFI boot entries\n            osInstallerBootEntry = DiskBootEntry(\"HPSA Assisted OS Installer\", disk=bootDisk)\n        else:\n            # configure the UEFI boot entries with specific path to loader\n            print(\"Found UEFI secure boot files in media\")\n            osInstallerBootEntry = DiskBootEntry(\"HPSA Assisted OS Installer\", disk=bootDisk, loader=secureBootLoader)\n        efibootmgr = EfiBootMgr(log=LOG)\n        efibootmgr.bootOneTime(osInstallerBootEntry)\n        print(\"Configured boot to: %s\" % osInstallerBootEntry)\n\n    def configureSecureBootLoader(self, bootDiskMount):\n        keys = helpers.getDataStore()\n        mediaFS = media.factor(keys.media.url, log=LOG)\n        bootEFIFiles = mediaFS.findFiles(path=self.EFI_BOOT_DIR)\n        secureBootFiles = {'boot': None, 'grub': None}\n        for boot in bootEFIFiles:\n            if re.match(\"bootx64\\.efi\", boot, re.IGNORECASE):\n                secureBootFiles['boot'] = boot\n            if re.match(\"grubx64\\.efi\", boot, re.IGNORECASE):\n                secureBootFiles['grub'] = boot\n        LOG.debug(\"Boot files for SecureBoot found in media : %s\" % str(bootEFIFiles))\n        if secureBootFiles['boot'] and secureBootFiles['grub']:\n            # create path on stub partition\n            os.makedirs(os.path.join(bootDiskMount, self.EFI_BOOT_PATH))\n            for boot in bootEFIFiles:\n                if boot and \".efi\" in boot.lower():\n                    mediaFS.copyTo(os.path.join(self.EFI_BOOT_DIR, boot), os.path.join(bootDiskMount, self.EFI_BOOT_PATH))\n            # add new path for grub.cfg and efi suffix\n            self.MENU_PATHS.append(os.path.join(self.EFI_BOOT_PATH, \"grub.cfg\"))\n            self.EFI_CMD_SUFFIX = \"efi\"\n            return os.path.join(\"/\", self.EFI_BOOT_PATH, secureBootFiles['boot']).replace(\"/\", \"\\\\\")\n        return None\n\n    def configureMenu(self, title, kernel, kernelArguments, initrds, keys):\n        \"\"\" Creates a GRUB2 grub.conf configuration \"\"\"\n        return \"\"\"\nset default=0\nset timeout=5\n\ninsmod all_video\n\nmenuentry '%(title)s' {\n    linux%(efi)s  /%(kernel)s %(kernelArguments)s\n    initrd%(efi)s %(initrds)s\n}\n\n\"\"\" % {\n            'efi': self.EFI_CMD_SUFFIX,\n            'title': title,\n            'kernel': kernel,\n            'kernelArguments': kernelArguments,\n            'initrds': ' '.join(initrds),\n            'device_uuid': keys.disk.device_uuid\n        }\n\n\ndef getGrub(bootDisk):\n    \"\"\" Factor a Grub or Grub2 object based on the partition table type of the boot disk \"\"\"\n    if bootDisk.partitionTableType == \"msdos\":\n        return Grub(\"/tmp/grub\")\n    else:\n        return Grub2(\"/tmp/grub2\")\n\n\ndef checkCompleteStaticNetData(netdata, ipv):\n    values = netdata.values()\n    if None in values or \"\" in values:\n        print \"WARNING: The provided %s static configuration is incomplete. The OS installer may fail.\" % ipv\n\n\ndef getIPv6NameServer():\n    lnd = LinuxNetworkDiscovery()\n    lnd.discover()\n    if lnd.netinfo.nics and lnd.netinfo.nics[0].ipv6DnsServers:\n        return lnd.netinfo.nics[0].ipv6DnsServers[0]\n    else:\n        return \"\"\n\n\ndef getNetworkingParams(mac, osdata, netconfig, isIPv6Managed):\n    try:\n        activeIface = [x for x in netconfig.nics if x.provisioning][0]\n    except IndexError:\n        raise SetupError(\"Found no provisioning interface\")\n\n    isRHEL7 = \"RHEL7\" == osdata[\"os_version\"]\n    ip_params = \"\"\n\n    if isIPv6Managed:\n        if activeIface.ipv6Autoconfig:\n            ip_params += \" \" + osdata[\"ip_config_auto6\"] % {'mac': mac}\n            # for RHEL7 on IPv6 we need to set the nameserver since dracut\n            # does not generate a proper dhcpv6 client config\n            # note that NetworkManager does eventually start after the squashfs.img is downloaded\n            # so it will overwrite what dracut configures\n            if \"RHEL7\" == osdata[\"os_version\"]:\n                ip_params += \" nameserver=%s\" % getIPv6NameServer()\n        elif activeIface.ipv6Networks:\n            net_data = {\n                \"ip\": (\"[%s]\" if isRHEL7 else \"%s\") % activeIface.ipv6Networks[0].ip,\n                \"mask\": activeIface.ipv6Networks[0].netmask,\n                \"prefix\": activeIface.ipv6Networks[0].prefixlen,\n                \"dns\": \"\",\n                \"gw\": \"\",\n                \"mac\": mac,\n            }\n            for dnsserv in activeIface.ipv6DnsServers:\n                net_data[\"dns\"] = dnsserv\n                break\n            for route in [x for x in netconfig.ipv6Routes if x.nic == activeIface]:\n                net_data[\"gw\"] = (\"[%s]\" if isRHEL7 else \"%s\") % route.gateway\n                break\n            # support for autoconf + static network in the installer\n            if isRHEL7 and activeIface.ipv6Autoconfig:\n                if not net_data[\"dns\"]:\n                    net_data[\"dns\"] = getIPv6NameServer()\n            ip_params += \" \" + (osdata[\"ip_config_static6\"] % net_data)\n            checkCompleteStaticNetData(net_data, \"IPv6\")\n        else:\n            print \"Can not complete network personalization. \" \\\n                  \"Auto configuration is turned off for IPv6 and there is no static address defined\"\n            sys.exit(37)\n    else:\n        if activeIface.ipv4Networks:\n            net_data = {\n                \"ip\": activeIface.ipv4Networks[0].ip,\n                \"mask\": activeIface.ipv4Networks[0].netmask,\n                \"dns\": \"\",\n                \"gw\": \"\",\n            }\n            for dnsserv in activeIface.dnsServers:\n                if isinstance(dnsserv, ipaddr.IPv4Address):\n                    net_data[\"dns\"] = dnsserv\n                    break\n            for route in [x for x in netconfig.ipv4Routes if x.nic == activeIface]:\n                net_data[\"gw\"] = route.gateway\n                break\n            ip_params += \" \" + (osdata[\"ip_config_static\"] % net_data)\n            checkCompleteStaticNetData(net_data, \"IPv4\")\n        elif activeIface.dhcpv4:\n            ip_params += \" \" + osdata[\"ip_config_dhcp\"]\n        else:\n            print \"Can not complete network personalization. \" \\\n                  \"DHCP is turned off for IPv4 and there is no static address defined\"\n            sys.exit(38)\n\n    return ip_params.strip()\n\n\ndef updateExecInstructions(params1=\"\", params2=\"\"):\n    \"\"\"If both params strings contain the exec argument, the method will remove it form second string and combine\n    the 2 instructions in to the first string\"\"\"\n    if params2.count(\"exec=\") and params1.count(\"exec=\"):\n        ip_param_exec = params2[params2.index(\"exec=\\\"\"):params2.index(\"\\\"\", params2.index(\"exec=\\\"\") + 6) + 1]\n        params2 = params2.replace(ip_param_exec, \"\")\n        if \"exec='\" in params1:\n            params1 = params1.replace(\"exec='\", \"exec='\" + ip_param_exec[6:-1] + \";\")\n        else:\n            params1 = params1.replace('exec=\"', 'exec=\"' + ip_param_exec[6:-1] + \";\")\n    return params1, params2\n\n\ndef configureKernelArguments(osdata, keys, netcfg_parser, kernel_arguments=\"\"):\n    \"\"\" Configures the kernel arguments \"\"\"\n    localServer = ThisLocalServer()\n    boot_disk = keys.disk.device_path\n    boot_disk_uuid = keys.disk.device_uuid\n    # to be used by install_params\n    root_partition = get_partition_name(boot_disk[5:], 1)\n    if \"SLES\" in osdata[\"os_version\"] and \"cciss\" in boot_disk:\n        boot_disk = \"%s//\" % boot_disk\n    # ALERT: do not remove lower(), SLES doesn't recognize a MAC address if upper\n    mac = localServer.getMACAddress().lower()\n    url = mediaUrl(keys)\n    arg_dict = {\n        \"mac\": mac,\n        \"boot_disk\": boot_disk,\n        \"root_partition\": root_partition,\n        \"boot_disk_uuid\": boot_disk_uuid,\n        \"url\": url.canonical(),\n        \"bootif\": netconfig.macToBootIf(mac)\n    }\n    kernel_params = osdata['install_params'] % arg_dict\n    if kernel_arguments:\n        print(\"Found kernel arguments: \" + kernel_arguments)\n        kernel_params = kernel_params + \" \" + kernel_arguments\n\n    # Handle TCP/IP settings to make sure that installers behave  ##\n    ip_params = getNetworkingParams(mac, osdata, netcfg_parser.info(), localServer.isIPv6Managed())\n    if ip_params:\n        print(\"Additional kernel arguments for network configuration: %s\" % ip_params)\n        kernel_params, ip_params = updateExecInstructions(params1=kernel_params, params2=ip_params)\n        kernel_params += \" \" + ip_params\n\n    # Limit ports only if we are doing NFS, sles 11 sp0 has issues with this setting\n    if url.scheme == \"nfs\":\n        # Make sure that the nfs client doesn't use the agent port\n        kernel_params += \" sunrpc.max_resvport=1000\"\n\n    # if present handle addonloc\n    if \"addonloc\" in osdata and osdata[\"addonloc\"]:\n        # Handle SLES addon sources (eg. by use of kISO content)\n        if \"SLES\" in osdata[\"os_version\"]:\n            if kernel_params.lower().find(\"addon=\") == -1:\n                # no addon parameter present - add it using the found location if any\n                print \"Boot Loader (SLES) auto appending kernel parameter \"\"addon=%s\"\" \" % osdata[\"addonloc\"]\n                kernel_params += \" addon=%s\" % osdata[\"addonloc\"]\n            else:\n                print \"Boot Loader (SLES) \"\"addon=\"\" parameter present - not auto appending\"\n\n    # tidy up the kernel_params to contain only one blank between and no trailing blanks\n    # required for SLES's picky addon parameter handler (would fail with nfs:// source)\n    kernel_params = ' '.join(kernel_params.split())\n\n    return kernel_params\n\n\ndef configureInitrds(osdata, keys):\n    # start with the default initrd\n    initrdlist = [\"/%s\" % osdata[\"initrd\"]]\n\n    discoverLocalRds(osdata, root=keys.disk.device_mount)\n\n    # if present add supplemental local initrds\n    if \"localrds\" in osdata:\n        for eachrd in osdata[\"localrds\"]:\n            initrdlist.append(eachrd)\n        # max number of initrds that can be handled is limited by the line length\n        # limit of grubs menu.lst: 1500 chars.\n        if len(initrdlist) > (1500 - 1):\n            raise DiscoveryError(\"INITRD parameter: Maximum parameter length (1500) exceeded! \"\n                                 \"- Too many additional initrd files found.\")\n    return initrdlist\n\n\ndef discoverLocalRds(osdata, root):\n    \"\"\" Get initrd files from /localrds directory \"\"\"\n    rds = helpers.findFiles(\n        path=os.path.join(root, DEFAULT_INITRD_DIR), mask=DEFAULT_SA_INITRD_MASK)\n    if rds:\n        rdlist = []\n        # add the local path to make it suitable for grub\n        for eachrd in rds:\n            rdlist.append(os.path.join(os.path.sep, DEFAULT_INITRD_DIR, eachrd))\n        osdata[\"localrds\"] = helpers.numericalSort(rdlist)\n    return\n\n\ndef discoverOsdata(osdata, keys):\n    \"\"\" Discover the kernel and initrd to use based on the media \"\"\"\n    # the copy boot media step should have run by now, so we work with the\n    # stub partition. This is just so we don't access the media twice\n    stub_path = keys.disk.device_mount\n    if not stub_path:\n        raise DiscoveryError(\"Cannot discover boot disk mount point. \"\n                             \"Was the stub partition created?\")\n    isocfg = Syslinux.readonly(_open(os.path.join(stub_path, \"isolinux.cfg\")))\n    isocfg_label = isocfg.info()[\"label \" + isocfg.first_non_local_label()]\n    # discover the kernel\n    osdata[\"kernel\"] = os.path.basename(isocfg_label[\"kernel\"])\n    # discover the initrd\n    append = isocfg_label[\"append\"].split(' ')\n    for each in append:\n        if '=' in each:\n            key, value = [x.strip() for x in each.split('=', 1)]\n            if key == \"initrd\":\n                osdata[\"initrd\"] = os.path.basename(value)\n    if \"initrd\" not in osdata:\n        raise DiscoveryError(\"Failed to discover the initrd\")\n\n    # verify the files are there otherwise the boot loader will fail to find them\n    kernel = os.path.join(stub_path, osdata[\"kernel\"])\n    initrd = os.path.join(stub_path, osdata[\"initrd\"])\n    if not os.path.exists(kernel) or not os.path.exists(initrd):\n        raise DiscoveryError(\"Failed to discover the boot kernel or initrd\")\n\n\ndef discoverSlesAddon(osdata, keys):\n    \"\"\" Discover addon directories for\n            SLES: kISO formatted media w/ \"addon\" directory\n    \"\"\"\n    url = mediaUrl(keys)\n    thismedia = media.factor(str(url))\n    # for SLES check for addon directory in the repository\n    SLES_ADDON_LOCATIONS = [\n        # common names for SLES addon directory\n        \"addon/\", \"ADDON/\", \"AddOn/\"\n    ]\n    for each_file in SLES_ADDON_LOCATIONS:\n        if thismedia.exists(each_file):\n            osdata[\"addonloc\"] = url.canonical() + \"/\" + each_file\n            print \"Boot Loader (SLES) ADDON directory found in source location: %s\" % osdata[\"addonloc\"]\n            return\n\n\ndef mediaUrl(keys):\n    \"\"\" determine the media server and path \"\"\"\n    url = keys.media.url\n    if not url:\n        # Fall back in case of old NFS mount script\n        mediaServer = _open(\"/tmp/osbp_info/media_server\", \"r\").read().strip()\n        mediaPath = _open(\"/tmp/osbp_info/media_path\", \"r\").read().strip()\n        mediaMount = _open(\"/tmp/osbp_info/media_mount\", \"r\").read().strip()\n        url = \"nfs://%s:%s/#%s\" % (mediaServer, mediaPath, mediaMount)\n    return media.parseUrl(url)\n\n\nclass InstallConfigureGrubOptionParser(OptionParser):\n    def defineOptions(self):\n        self.add_option(\"--kernel_arguments\", default=\"\",\n                        help=\"a string of arguments that will be passed to the OS installer kernel\")\n        self.add_option(\"--disableWarning\", dest=\"disableWarning\", action=\"store_true\",\n                        default=False,\n                        help=\"Do not show warnings of old hpsa_netconfig format\")\n\n\n@HandleShowErrorMessage(\"install and configure bootloader\", log=LOG)\ndef main():\n    options, remainingArgs = InstallConfigureGrubOptionParser().parse_args()\n    del remainingArgs\n\n    localServer = ThisLocalServer()\n    parser = SmartNetconfig.readwrite(\n        StringIO(HPSA_NETCONFIG),\n        activeMacAddress=localServer.getMACAddress(),\n        ipv6default=localServer.isIPv6Managed(),\n        log=LOG\n    )\n    if parser.info().oldSyntax and not options.disableWarning:\n        newFormat = parser.format()\n        print OLD_SYNTAX_WARNING + \"\\n%s\" % str(newFormat)\n\n    typosList = parser.getTyposList()\n    if typosList:\n        print(\"The following keys were not recognized in the netconfig CA and could be typos: %s\" % typosList)\n\n    keys = helpers.getDataStore()\n\n    bootDiskMount = keys.disk.device_mount\n    if not bootDiskMount:\n        raise DiscoveryError(\"Discovery of the boot disk mount point failed. \"\n                             \"Was the stub partition created?\", EC_NO_BOOTDISK)\n\n    bootDisk = LinuxDisk(keys.disk.device_path, None, None)\n    grub = getGrub(bootDisk)\n    try:\n        grub.install(bootDiskMount, bootDisk.getDeviceFilePath())\n    except (OSError, IOError), why:\n        print \"Installing GRuB failed. %s\" % why\n        return EC_IG_FAILED\n\n    # build.py will perform the needed substitutions here\n    osdata = dict()\n    osdata[\"os_display_name\"] = 'CentOS'\n    osdata[\"os_version\"] = 'CentOS'\n    osdata[\"install_params\"] = 'ks=file:/user.ks.cfg  ksdevice=%(mac)s'\n    osdata[\"ip_config_static\"] = 'ip=%(ip)s gateway=%(gw)s netmask=%(mask)s'\n    osdata[\"ip_config_static6\"] = 'ip=%(ip)s gateway=%(gw)s netmask=%(mask)s'\n    osdata[\"ip_config_dhcp\"] = 'ip=dhcp noipv6'\n    osdata[\"ip_config_auto6\"] = 'ipv6=auto noipv4'\n\n    discoverOsdata(osdata, keys)\n    if \"SLES\" in osdata[\"os_version\"]:\n        discoverSlesAddon(osdata, keys)\n\n    title = 'HP SA assisted %s installer' % osdata['os_display_name']\n    kernelArguments = configureKernelArguments(osdata, keys, parser,\n                                               kernel_arguments=options.kernel_arguments + \" hpsa_monitoring_agent=1\")\n    initrds = configureInitrds(osdata, keys)\n\n    menu = grub.configureMenu(title,\n                              osdata['kernel'], kernelArguments,\n                              initrds, keys)\n    for menuPath in grub.MENU_PATHS:\n        if not os.path.exists(os.path.join(bootDiskMount, os.path.dirname(menuPath))):\n            os.makedirs(os.path.join(bootDiskMount, os.path.dirname(menuPath)))\n        _open(os.path.join(bootDiskMount, menuPath), \"w\").write(menu)\n\n    return 0\n\nHPSA_NETCONFIG = \"\"\"@hpsa_netconfig@\"\"\"\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n",
            "description": "Installs and configures GRUB (GRand Unified Boot Loader) onto the stub partition of the boot disk on the target server in order to enable the booting into the CentOS installation image.\n\nThe step will also auto detect directories with the names \"addon\", \"AddOn\" and \"ADDON\" in the repository and for SuSE Linux Enterprise Server installations append the proper \"addon='path-to-addon-dir' to the kernel parameters of the grub boot loader.\n\nUsage:\n\nThis script expects no command line arguments, but the following argument(s) can optionally be specified:\n    --kernel_arguments=KERNEL_ARGUMENTS\n                        a string of arguments that will be passed to the OS\n                        installer kernel\n    --disableWarning    Do not show warnings of old hpsa_netconfig format\n\nPrerequisites:\n- Target server runs a maintenance Linux OS.\n- The files in the grub.zip archive must be extracted in /tmp.\n- The \"Create Stub Partition\" step must have been executed. \n\nThis script is intended to be used only as a Build Plan step.",
            "status": null,
            "name": "Install bootloader for CentOS",
            "state": null,
            "eTag": "2015-06-13T04:49:19.000Z",
            "modified": "2015-06-13T04:49:19.000Z",
            "created": "2015-06-13T04:49:19.000Z",
            "category": "os-deployment-server-scripts",
            "uri": "/rest/os-deployment-server-scripts/1240001"
        },
        {
            "runAsSuperUser": false,
            "serverChanging": false,
            "codeType": "SH",
            "displayCodeType": "Unix",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "1",
                    "createdBy": "opsware",
                    "createdDate": "2015-06-13T04:49:20.000Z",
                    "usage": "This script injects the device name in the <partitioning><drive></drive></partitioning> needed for\nSuSE multipath installations. \n\nPrerequisites:\n- Target server runs a maintenance Linux OS.\n- YaST autoinst profile present in /tmp/user.autoinst.xml\n- The \"Create Stub Partition\" step was executed\n\nThis script is intended to be used only as a Build Plan step.",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-06-13T04:49:20.000Z",
            "version": {
                "versionLabel": "1",
                "createdBy": "opsware",
                "createdDate": "2015-06-13T04:49:20.000Z",
                "usage": "This script injects the device name in the <partitioning><drive></drive></partitioning> needed for\nSuSE multipath installations. \n\nPrerequisites:\n- Target server runs a maintenance Linux OS.\n- YaST autoinst profile present in /tmp/user.autoinst.xml\n- The \"Create Stub Partition\" step was executed\n\nThis script is intended to be used only as a Build Plan step.",
                "current": true
            },
            "source": "#!/opt/opsware/agent/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n\"\"\" \n    (C) Copyright 2009-2015 Hewlett-Packard Development Company, L.P.\n\n    Inject multipath settings into the autoyast profile\n\"\"\"\n\nimport re\nimport sys\nfrom osprov.profile import AutoYaST, ProfileError\nfrom osprov.util import process\nfrom osprov.osbp import ThisTargetServer, logger\nfrom osprov.errors import ShowErrorMessage\nfrom osprov import helpers\n\nLOG = logger.getIt(\"inject_multipath\")\n\nBASE_AY_FILE = \"/tmp/user.autoinst.xml\"\n\ndevice_mapper_command = \"/mnt/runtime/lib/udev/scsi_id -g -u %s\"\n\n\ndef initAutoYast(baseFile):\n    \"\"\" Initializes an autoyast object\"\"\"\n    return AutoYaST(baseFile)\n\n\ndef injectMultipath(keys, ayobj):\n    \"\"\" Modifies the partitioning section by injecting the device mapper\"\"\"\n\n    partitioning = ayobj.createPath(\"profile/partitioning\")\n    partitioning.setAttribute(\"config:type\", \"list\")\n\n    # find the devices sections. If there exist devices we leave the configuration as is\n    drives = [drive for drive in partitioning.childNodes if drive.nodeName == \"drive\"]\n    devices = []\n    for drive in drives:\n        devices += [device for device in drive.childNodes if device.nodeName == \"device\"]\n    if len(devices) > 0:\n        pattern = re.compile('^/dev/mapper/[0-9a-f]+$')\n        valid = True\n        for device in devices:\n            match = pattern.match(device.childNodes[0].data)\n            if not match:\n                print \"Device %s does not have a valid format!\" % device.childNodes[0].data\n                valid = False\n                break\n        if valid:\n            print \"Devices are in the correct format\"\n        return valid\n\n    # find the drives section and configure the devices\n    # If there is just one drive use that to configure the device\n    # If there is more than one, do not do anything\n    if len(drives) > 1:\n        print \"More than one drive section found. The profile will not be modified!\"\n        return False\n    elif len(drives) == 0:\n        drive = ayobj.document.createElement(\"drive\")\n        useall = ayobj.document.createElement(\"use\")\n        ayobj.setNodeTextValue(useall, \"all\")\n        drive.appendChild(useall)\n        partitioning.appendChild(drive)\n    else:\n        drive = drives[0]\n\n    scsi_id = process.getStdout(device_mapper_command % keys.disk.device_path).split(\"\\n\")[0]\n    device = ayobj.createPath(\"profile/partitioning/drive/device\")\n    ayobj.setNodeTextValue(device, \"/dev/mapper/%s\" % scsi_id)\n    return True\n\n\ndef main():\n    \"\"\" Do the injection of the device mapper in the autoyast \"\"\"\n    try:\n        ayobj = initAutoYast(BASE_AY_FILE)\n        keys = helpers.getDataStore()\n        injectMultipath(keys, ayobj)\n        open(BASE_AY_FILE, \"w\").write(str(ayobj))\n        print \"Successfully injected required settings\"\n    except (IOError, OSError, ShowErrorMessage, ProfileError), why:\n        LOG.exception(why)\n        sys.stderr.write(\"Failed to inject multipath settings.%s\\n\" % why)\n        sys.exit(1)\n\nif __name__ == \"__main__\":\n    main()\n",
            "description": "This script injects the device name in the <partitioning><drive></drive></partitioning> needed for\nSuSE multipath installations. \n\nPrerequisites:\n- Target server runs a maintenance Linux OS.\n- YaST autoinst profile present in /tmp/user.autoinst.xml\n- The \"Create Stub Partition\" step was executed\n\nThis script is intended to be used only as a Build Plan step.",
            "status": null,
            "name": "Inject Multipath AutoYaST Settings",
            "state": null,
            "eTag": "2015-06-13T04:49:20.000Z",
            "modified": "2015-06-13T04:49:20.000Z",
            "created": "2015-06-13T04:49:20.000Z",
            "category": "os-deployment-server-scripts",
            "uri": "/rest/os-deployment-server-scripts/1270001"
        },
        {
            "runAsSuperUser": true,
            "serverChanging": true,
            "codeType": "SH",
            "displayCodeType": "Unix",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "1",
                    "createdBy": "opsware",
                    "createdDate": "2015-06-13T04:49:21.000Z",
                    "usage": "Installs and configures GRUB (GRand Unified Boot Loader) onto the stub partition of the boot disk on the target server in order to enable the booting into the Ubuntu Server installation image.\n\nThe step will also auto detect directories with the names \"addon\", \"AddOn\" and \"ADDON\" in the repository and for SuSE Linux Enterprise Server installations append the proper \"addon='path-to-addon-dir' to the kernel parameters of the grub boot loader.\n\nUsage:\n\nThis script expects no command line arguments, but the following argument(s) can optionally be specified:\n    --kernel_arguments=KERNEL_ARGUMENTS\n                        a string of arguments that will be passed to the OS\n                        installer kernel\n    --disableWarning    Do not show warnings of old hpsa_netconfig format\n\nPrerequisites:\n- Target server runs a maintenance Linux OS.\n- The files in the grub.zip archive must be extracted in /tmp.\n- The \"Create Stub Partition\" step must have been executed. \n\nThis script is intended to be used only as a Build Plan step.",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-06-13T04:49:21.000Z",
            "version": {
                "versionLabel": "1",
                "createdBy": "opsware",
                "createdDate": "2015-06-13T04:49:21.000Z",
                "usage": "Installs and configures GRUB (GRand Unified Boot Loader) onto the stub partition of the boot disk on the target server in order to enable the booting into the Ubuntu Server installation image.\n\nThe step will also auto detect directories with the names \"addon\", \"AddOn\" and \"ADDON\" in the repository and for SuSE Linux Enterprise Server installations append the proper \"addon='path-to-addon-dir' to the kernel parameters of the grub boot loader.\n\nUsage:\n\nThis script expects no command line arguments, but the following argument(s) can optionally be specified:\n    --kernel_arguments=KERNEL_ARGUMENTS\n                        a string of arguments that will be passed to the OS\n                        installer kernel\n    --disableWarning    Do not show warnings of old hpsa_netconfig format\n\nPrerequisites:\n- Target server runs a maintenance Linux OS.\n- The files in the grub.zip archive must be extracted in /tmp.\n- The \"Create Stub Partition\" step must have been executed. \n\nThis script is intended to be used only as a Build Plan step.",
                "current": true
            },
            "source": "#!/opt/opsware/agent/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# lint_ignore=E501,I0011\n# Please do not change the two lines above. See PEP 8, PEP 263.\n\"\"\"\n    (C) Copyright 2013-2015 Hewlett-Packard Development Company, L.P.\n\n    This python script installs and configures Grub for BIOS and Grub2 for UEFI.\n\"\"\"\n\nimport os\nimport sys\nimport re\nimport glob\nimport shutil\nfrom cStringIO import StringIO\n\nfrom osprov.decorators import HandleShowErrorMessage\nfrom osprov.diskmgr.disk import LinuxDisk\nfrom osprov.networking.discovery import LinuxNetworkDiscovery\nfrom osprov.optparse_ext import OptionParser\nfrom osprov.osbp import logger\nfrom osprov.parsers.syslinux import Syslinux\nfrom osprov.util import process\nfrom osprov.errors import DiscoveryError, ShowErrorMessage, SetupError\nfrom osprov import helpers, media, netconfig\nfrom osprov.parsers.netconfig import SmartNetconfig, OLD_SYNTAX_WARNING\nfrom osprov.server.local import ThisLocalServer\nfrom osprov.constants import DEFAULT_INITRD_DIR, DEFAULT_SA_INITRD_MASK\nfrom osprov.wrappers.efibootmgr import EfiBootMgr, DiskBootEntry\nfrom osprov import ipaddr\n\nEC_INVALID_ARGS = 1\nEC_IG_FAILED = 5\nEC_GRUBMENU_FAILED = 6\nEC_NO_BOOTDISK = 7\n\nLOG = logger.getIt(\"install_configure_grub\")\n\n\n# for easier mocking\ndef _open(filepath, mode=\"r\"):\n    return open(filepath, mode)\n\n\ndef get_partition_name(device_name, partition_num):\n    \"\"\"Returns the partition with number partition_num for device_name\"\"\"\n    if not partition_num:\n        return device_name\n    base_name = os.path.basename(device_name)\n    if re.search(r\"c\\dd\\d\", base_name):\n        return device_name + \"p\" + str(partition_num)\n    return device_name + str(partition_num)\n\n\nclass Grub(object):\n    \"\"\" Helper class for configuring and installing the Grub boot loader. \"\"\"\n\n    MENU_PATHS = [\"boot/grub/menu.lst\"]\n    MODULES_PATH = \"boot/grub\"\n\n    def __init__(self, location):\n        self.location = location\n        self.grubinfo = self.validate()\n\n    def _getInfo(self):\n        info = {}\n        # first test for newer info.txt file\n        infofile = os.path.join(self.location, \"info.txt\")\n        if os.path.exists(infofile):\n            # get the path info from into.txt\n            execfile(infofile, info)\n            for value in [\"grub\", \"loaderfiles\"]:\n                if not info[value]:\n                    # expected value is missing\n                    return {}\n        else:\n            # set the required info values manually for older grub packages\n            info[\"grub\"] = \"sbin/grub\"\n            info[\"loaderfiles\"] = \"share/grub/i386-pc\"\n        return info\n\n    def validate(self):\n        \"\"\"    Performs some simple validation on the directory where GRUB is located.\n        info.txt can provide non default values for grub binary and loader files\n        and saves from hardcoding more paths in here.\n        info.txt should also contain version info for better tracking of versions.\n        required info entries are:\n                \"grub\"            - path to grub binary\n                \"loaderfiles\"   - path to loader files\n        \"\"\"\n        info = self._getInfo()\n        if not info:\n            return {}\n        # finally verify the paths\n        for path in [info[\"grub\"], info[\"loaderfiles\"]]:\n            if not os.path.exists(os.path.join(self.location, path)):\n                return {}\n        return info\n\n    def copyFilesTo(self, bootDiskMount):\n        \"\"\" Copies files to the location specified. \"\"\"\n        print(\"Copying Boot Loader files to runtime location\")\n        grubinfo = self.grubinfo\n        if not grubinfo:\n            raise ShowErrorMessage(\n                \"Failed to validate %s. A previous Build Plan step may be missing.\" % self.location)\n        targetLocation = os.path.join(bootDiskMount, self.MODULES_PATH)\n        helpers.makeDirs(targetLocation)\n        files = glob.glob(\"%s/*\" % os.path.join(self.location, grubinfo[\"loaderfiles\"]))\n        if not files:\n            raise ShowErrorMessage(\"No file to copy. A previous Build Plan step may be missing\")\n        for source in files:\n            destination = os.path.join(targetLocation, os.path.basename(source))\n            LOG.debug(\"Copying %s to %s\", source, destination)\n            shutil.copyfile(source, destination)\n\n    def install(self, bootDiskMount, bootDisk):\n        \"\"\"\n        Installs the files needed for GRuB on boot_disk.\n        Note that it will overwrite the Master Boot Record for boot_disk.\n        \"\"\"\n        self.copyFilesTo(bootDiskMount)\n        print(\"Preparing Boot Loader config script\")\n        config = list()\n        config.append(\"device (hd0) \" + bootDisk)\n        config.append(\"root (hd0,0)\")\n        config.append(\"install --stage2=%s/boot/grub/stage2 /boot/grub/stage1 d (hd0) \"\n                      \"/boot/grub/stage2 p /boot/grub/menu.lst\" % bootDiskMount)\n        config.append(\"quit\")\n        config_str = \"\\n\".join(config) + \"\\n\"\n\n        print(\"Installing Boot Loader\")\n        os.chmod(\"%s\" % os.path.join(self.location, self.grubinfo[\"grub\"]), 0777)\n        params = \"--batch --no-floppy --config-file=/boot/grub/menu.lst\"\n        process.runIt(\"%s %s\" %\n                      (os.path.join(self.location, self.grubinfo[\"grub\"]), params), input=config_str, quiet=True)\n        return config_str\n\n    def configureMenu(self, title, kernel, kernelArguments, initrds, keys):\n        \"\"\"    Creates a GRUB menu.lst configuration. \"\"\"\n        return \"\"\"\ndefault 0\ntimeout 5\ntitle %(title)s\nroot (hd0,0)\n\nkernel /%(kernel)s %(kernelArguments)s\ninitrd %(initrds)s\n\n\"\"\" % {\n            'title': title,\n            'kernel': kernel,\n            'kernelArguments': kernelArguments,\n            'initrds': ' '.join(initrds)\n        }\n\n\nclass Grub2(Grub):\n    BOOT_DIRECTORY = \"boot/\"\n    MENU_PATHS = [os.path.join(BOOT_DIRECTORY, \"grub/grub.cfg\"), os.path.join(BOOT_DIRECTORY, \"grub2/grub.cfg\")]\n    EFI_BOOT_DIR = \"EFI/BOOT/\"\n    EFI_BOOT_PATH = os.path.join(EFI_BOOT_DIR)\n    EFI_CMD_SUFFIX = \"\"\n\n    def _getInfo(self):\n        info = dict()\n        info[\"grub\"] = \"sbin/grub-install\"\n        info[\"loaderfiles\"] = \"lib/grub/x86_64-efi\"\n        return info\n\n    def install(self, bootDiskMount, bootDisk):\n        secureBootLoader = self.configureSecureBootLoader(bootDiskMount)\n        if not secureBootLoader:\n            process.runIt(\"%(grub-install)s --removable --efi-directory=%(bootDiskMount)s --boot-directory=%(bootDirectory)s %(bootDisk)s\"\n                          % {'grub-install': os.path.join(self.location, self.grubinfo['grub']),\n                             'bootDiskMount': bootDiskMount,\n                             'bootDirectory': os.path.join(bootDiskMount, self.BOOT_DIRECTORY),\n                             'bootDisk': bootDisk}, log=LOG, quiet=True)\n            # configure the UEFI boot entries\n            osInstallerBootEntry = DiskBootEntry(\"HPSA Assisted OS Installer\", disk=bootDisk)\n        else:\n            # configure the UEFI boot entries with specific path to loader\n            print(\"Found UEFI secure boot files in media\")\n            osInstallerBootEntry = DiskBootEntry(\"HPSA Assisted OS Installer\", disk=bootDisk, loader=secureBootLoader)\n        efibootmgr = EfiBootMgr(log=LOG)\n        efibootmgr.bootOneTime(osInstallerBootEntry)\n        print(\"Configured boot to: %s\" % osInstallerBootEntry)\n\n    def configureSecureBootLoader(self, bootDiskMount):\n        keys = helpers.getDataStore()\n        mediaFS = media.factor(keys.media.url, log=LOG)\n        bootEFIFiles = mediaFS.findFiles(path=self.EFI_BOOT_DIR)\n        secureBootFiles = {'boot': None, 'grub': None}\n        for boot in bootEFIFiles:\n            if re.match(\"bootx64\\.efi\", boot, re.IGNORECASE):\n                secureBootFiles['boot'] = boot\n            if re.match(\"grubx64\\.efi\", boot, re.IGNORECASE):\n                secureBootFiles['grub'] = boot\n        LOG.debug(\"Boot files for SecureBoot found in media : %s\" % str(bootEFIFiles))\n        if secureBootFiles['boot'] and secureBootFiles['grub']:\n            # create path on stub partition\n            os.makedirs(os.path.join(bootDiskMount, self.EFI_BOOT_PATH))\n            for boot in bootEFIFiles:\n                if boot and \".efi\" in boot.lower():\n                    mediaFS.copyTo(os.path.join(self.EFI_BOOT_DIR, boot), os.path.join(bootDiskMount, self.EFI_BOOT_PATH))\n            # add new path for grub.cfg and efi suffix\n            self.MENU_PATHS.append(os.path.join(self.EFI_BOOT_PATH, \"grub.cfg\"))\n            self.EFI_CMD_SUFFIX = \"efi\"\n            return os.path.join(\"/\", self.EFI_BOOT_PATH, secureBootFiles['boot']).replace(\"/\", \"\\\\\")\n        return None\n\n    def configureMenu(self, title, kernel, kernelArguments, initrds, keys):\n        \"\"\" Creates a GRUB2 grub.conf configuration \"\"\"\n        return \"\"\"\nset default=0\nset timeout=5\n\ninsmod all_video\n\nmenuentry '%(title)s' {\n    linux%(efi)s  /%(kernel)s %(kernelArguments)s\n    initrd%(efi)s %(initrds)s\n}\n\n\"\"\" % {\n            'efi': self.EFI_CMD_SUFFIX,\n            'title': title,\n            'kernel': kernel,\n            'kernelArguments': kernelArguments,\n            'initrds': ' '.join(initrds),\n            'device_uuid': keys.disk.device_uuid\n        }\n\n\ndef getGrub(bootDisk):\n    \"\"\" Factor a Grub or Grub2 object based on the partition table type of the boot disk \"\"\"\n    if bootDisk.partitionTableType == \"msdos\":\n        return Grub(\"/tmp/grub\")\n    else:\n        return Grub2(\"/tmp/grub2\")\n\n\ndef checkCompleteStaticNetData(netdata, ipv):\n    values = netdata.values()\n    if None in values or \"\" in values:\n        print \"WARNING: The provided %s static configuration is incomplete. The OS installer may fail.\" % ipv\n\n\ndef getIPv6NameServer():\n    lnd = LinuxNetworkDiscovery()\n    lnd.discover()\n    if lnd.netinfo.nics and lnd.netinfo.nics[0].ipv6DnsServers:\n        return lnd.netinfo.nics[0].ipv6DnsServers[0]\n    else:\n        return \"\"\n\n\ndef getNetworkingParams(mac, osdata, netconfig, isIPv6Managed):\n    try:\n        activeIface = [x for x in netconfig.nics if x.provisioning][0]\n    except IndexError:\n        raise SetupError(\"Found no provisioning interface\")\n\n    isRHEL7 = \"RHEL7\" == osdata[\"os_version\"]\n    ip_params = \"\"\n\n    if isIPv6Managed:\n        if activeIface.ipv6Autoconfig:\n            ip_params += \" \" + osdata[\"ip_config_auto6\"] % {'mac': mac}\n            # for RHEL7 on IPv6 we need to set the nameserver since dracut\n            # does not generate a proper dhcpv6 client config\n            # note that NetworkManager does eventually start after the squashfs.img is downloaded\n            # so it will overwrite what dracut configures\n            if \"RHEL7\" == osdata[\"os_version\"]:\n                ip_params += \" nameserver=%s\" % getIPv6NameServer()\n        elif activeIface.ipv6Networks:\n            net_data = {\n                \"ip\": (\"[%s]\" if isRHEL7 else \"%s\") % activeIface.ipv6Networks[0].ip,\n                \"mask\": activeIface.ipv6Networks[0].netmask,\n                \"prefix\": activeIface.ipv6Networks[0].prefixlen,\n                \"dns\": \"\",\n                \"gw\": \"\",\n                \"mac\": mac,\n            }\n            for dnsserv in activeIface.ipv6DnsServers:\n                net_data[\"dns\"] = dnsserv\n                break\n            for route in [x for x in netconfig.ipv6Routes if x.nic == activeIface]:\n                net_data[\"gw\"] = (\"[%s]\" if isRHEL7 else \"%s\") % route.gateway\n                break\n            # support for autoconf + static network in the installer\n            if isRHEL7 and activeIface.ipv6Autoconfig:\n                if not net_data[\"dns\"]:\n                    net_data[\"dns\"] = getIPv6NameServer()\n            ip_params += \" \" + (osdata[\"ip_config_static6\"] % net_data)\n            checkCompleteStaticNetData(net_data, \"IPv6\")\n        else:\n            print \"Can not complete network personalization. \" \\\n                  \"Auto configuration is turned off for IPv6 and there is no static address defined\"\n            sys.exit(37)\n    else:\n        if activeIface.ipv4Networks:\n            net_data = {\n                \"ip\": activeIface.ipv4Networks[0].ip,\n                \"mask\": activeIface.ipv4Networks[0].netmask,\n                \"dns\": \"\",\n                \"gw\": \"\",\n            }\n            for dnsserv in activeIface.dnsServers:\n                if isinstance(dnsserv, ipaddr.IPv4Address):\n                    net_data[\"dns\"] = dnsserv\n                    break\n            for route in [x for x in netconfig.ipv4Routes if x.nic == activeIface]:\n                net_data[\"gw\"] = route.gateway\n                break\n            ip_params += \" \" + (osdata[\"ip_config_static\"] % net_data)\n            checkCompleteStaticNetData(net_data, \"IPv4\")\n        elif activeIface.dhcpv4:\n            ip_params += \" \" + osdata[\"ip_config_dhcp\"]\n        else:\n            print \"Can not complete network personalization. \" \\\n                  \"DHCP is turned off for IPv4 and there is no static address defined\"\n            sys.exit(38)\n\n    return ip_params.strip()\n\n\ndef updateExecInstructions(params1=\"\", params2=\"\"):\n    \"\"\"If both params strings contain the exec argument, the method will remove it form second string and combine\n    the 2 instructions in to the first string\"\"\"\n    if params2.count(\"exec=\") and params1.count(\"exec=\"):\n        ip_param_exec = params2[params2.index(\"exec=\\\"\"):params2.index(\"\\\"\", params2.index(\"exec=\\\"\") + 6) + 1]\n        params2 = params2.replace(ip_param_exec, \"\")\n        if \"exec='\" in params1:\n            params1 = params1.replace(\"exec='\", \"exec='\" + ip_param_exec[6:-1] + \";\")\n        else:\n            params1 = params1.replace('exec=\"', 'exec=\"' + ip_param_exec[6:-1] + \";\")\n    return params1, params2\n\n\ndef configureKernelArguments(osdata, keys, netcfg_parser, kernel_arguments=\"\"):\n    \"\"\" Configures the kernel arguments \"\"\"\n    localServer = ThisLocalServer()\n    boot_disk = keys.disk.device_path\n    boot_disk_uuid = keys.disk.device_uuid\n    # to be used by install_params\n    root_partition = get_partition_name(boot_disk[5:], 1)\n    if \"SLES\" in osdata[\"os_version\"] and \"cciss\" in boot_disk:\n        boot_disk = \"%s//\" % boot_disk\n    # ALERT: do not remove lower(), SLES doesn't recognize a MAC address if upper\n    mac = localServer.getMACAddress().lower()\n    url = mediaUrl(keys)\n    arg_dict = {\n        \"mac\": mac,\n        \"boot_disk\": boot_disk,\n        \"root_partition\": root_partition,\n        \"boot_disk_uuid\": boot_disk_uuid,\n        \"url\": url.canonical(),\n        \"bootif\": netconfig.macToBootIf(mac)\n    }\n    kernel_params = osdata['install_params'] % arg_dict\n    if kernel_arguments:\n        print(\"Found kernel arguments: \" + kernel_arguments)\n        kernel_params = kernel_params + \" \" + kernel_arguments\n\n    # Handle TCP/IP settings to make sure that installers behave  ##\n    ip_params = getNetworkingParams(mac, osdata, netcfg_parser.info(), localServer.isIPv6Managed())\n    if ip_params:\n        print(\"Additional kernel arguments for network configuration: %s\" % ip_params)\n        kernel_params, ip_params = updateExecInstructions(params1=kernel_params, params2=ip_params)\n        kernel_params += \" \" + ip_params\n\n    # Limit ports only if we are doing NFS, sles 11 sp0 has issues with this setting\n    if url.scheme == \"nfs\":\n        # Make sure that the nfs client doesn't use the agent port\n        kernel_params += \" sunrpc.max_resvport=1000\"\n\n    # if present handle addonloc\n    if \"addonloc\" in osdata and osdata[\"addonloc\"]:\n        # Handle SLES addon sources (eg. by use of kISO content)\n        if \"SLES\" in osdata[\"os_version\"]:\n            if kernel_params.lower().find(\"addon=\") == -1:\n                # no addon parameter present - add it using the found location if any\n                print \"Boot Loader (SLES) auto appending kernel parameter \"\"addon=%s\"\" \" % osdata[\"addonloc\"]\n                kernel_params += \" addon=%s\" % osdata[\"addonloc\"]\n            else:\n                print \"Boot Loader (SLES) \"\"addon=\"\" parameter present - not auto appending\"\n\n    # tidy up the kernel_params to contain only one blank between and no trailing blanks\n    # required for SLES's picky addon parameter handler (would fail with nfs:// source)\n    kernel_params = ' '.join(kernel_params.split())\n\n    return kernel_params\n\n\ndef configureInitrds(osdata, keys):\n    # start with the default initrd\n    initrdlist = [\"/%s\" % osdata[\"initrd\"]]\n\n    discoverLocalRds(osdata, root=keys.disk.device_mount)\n\n    # if present add supplemental local initrds\n    if \"localrds\" in osdata:\n        for eachrd in osdata[\"localrds\"]:\n            initrdlist.append(eachrd)\n        # max number of initrds that can be handled is limited by the line length\n        # limit of grubs menu.lst: 1500 chars.\n        if len(initrdlist) > (1500 - 1):\n            raise DiscoveryError(\"INITRD parameter: Maximum parameter length (1500) exceeded! \"\n                                 \"- Too many additional initrd files found.\")\n    return initrdlist\n\n\ndef discoverLocalRds(osdata, root):\n    \"\"\" Get initrd files from /localrds directory \"\"\"\n    rds = helpers.findFiles(\n        path=os.path.join(root, DEFAULT_INITRD_DIR), mask=DEFAULT_SA_INITRD_MASK)\n    if rds:\n        rdlist = []\n        # add the local path to make it suitable for grub\n        for eachrd in rds:\n            rdlist.append(os.path.join(os.path.sep, DEFAULT_INITRD_DIR, eachrd))\n        osdata[\"localrds\"] = helpers.numericalSort(rdlist)\n    return\n\n\ndef discoverOsdata(osdata, keys):\n    \"\"\" Discover the kernel and initrd to use based on the media \"\"\"\n    # the copy boot media step should have run by now, so we work with the\n    # stub partition. This is just so we don't access the media twice\n    stub_path = keys.disk.device_mount\n    if not stub_path:\n        raise DiscoveryError(\"Cannot discover boot disk mount point. \"\n                             \"Was the stub partition created?\")\n    isocfg = Syslinux.readonly(_open(os.path.join(stub_path, \"isolinux.cfg\")))\n    isocfg_label = isocfg.info()[\"label \" + isocfg.first_non_local_label()]\n    # discover the kernel\n    osdata[\"kernel\"] = os.path.basename(isocfg_label[\"kernel\"])\n    # discover the initrd\n    append = isocfg_label[\"append\"].split(' ')\n    for each in append:\n        if '=' in each:\n            key, value = [x.strip() for x in each.split('=', 1)]\n            if key == \"initrd\":\n                osdata[\"initrd\"] = os.path.basename(value)\n    if \"initrd\" not in osdata:\n        raise DiscoveryError(\"Failed to discover the initrd\")\n\n    # verify the files are there otherwise the boot loader will fail to find them\n    kernel = os.path.join(stub_path, osdata[\"kernel\"])\n    initrd = os.path.join(stub_path, osdata[\"initrd\"])\n    if not os.path.exists(kernel) or not os.path.exists(initrd):\n        raise DiscoveryError(\"Failed to discover the boot kernel or initrd\")\n\n\ndef discoverSlesAddon(osdata, keys):\n    \"\"\" Discover addon directories for\n            SLES: kISO formatted media w/ \"addon\" directory\n    \"\"\"\n    url = mediaUrl(keys)\n    thismedia = media.factor(str(url))\n    # for SLES check for addon directory in the repository\n    SLES_ADDON_LOCATIONS = [\n        # common names for SLES addon directory\n        \"addon/\", \"ADDON/\", \"AddOn/\"\n    ]\n    for each_file in SLES_ADDON_LOCATIONS:\n        if thismedia.exists(each_file):\n            osdata[\"addonloc\"] = url.canonical() + \"/\" + each_file\n            print \"Boot Loader (SLES) ADDON directory found in source location: %s\" % osdata[\"addonloc\"]\n            return\n\n\ndef mediaUrl(keys):\n    \"\"\" determine the media server and path \"\"\"\n    url = keys.media.url\n    if not url:\n        # Fall back in case of old NFS mount script\n        mediaServer = _open(\"/tmp/osbp_info/media_server\", \"r\").read().strip()\n        mediaPath = _open(\"/tmp/osbp_info/media_path\", \"r\").read().strip()\n        mediaMount = _open(\"/tmp/osbp_info/media_mount\", \"r\").read().strip()\n        url = \"nfs://%s:%s/#%s\" % (mediaServer, mediaPath, mediaMount)\n    return media.parseUrl(url)\n\n\nclass InstallConfigureGrubOptionParser(OptionParser):\n    def defineOptions(self):\n        self.add_option(\"--kernel_arguments\", default=\"\",\n                        help=\"a string of arguments that will be passed to the OS installer kernel\")\n        self.add_option(\"--disableWarning\", dest=\"disableWarning\", action=\"store_true\",\n                        default=False,\n                        help=\"Do not show warnings of old hpsa_netconfig format\")\n\n\n@HandleShowErrorMessage(\"install and configure bootloader\", log=LOG)\ndef main():\n    options, remainingArgs = InstallConfigureGrubOptionParser().parse_args()\n    del remainingArgs\n\n    localServer = ThisLocalServer()\n    parser = SmartNetconfig.readwrite(\n        StringIO(HPSA_NETCONFIG),\n        activeMacAddress=localServer.getMACAddress(),\n        ipv6default=localServer.isIPv6Managed(),\n        log=LOG\n    )\n    if parser.info().oldSyntax and not options.disableWarning:\n        newFormat = parser.format()\n        print OLD_SYNTAX_WARNING + \"\\n%s\" % str(newFormat)\n\n    typosList = parser.getTyposList()\n    if typosList:\n        print(\"The following keys were not recognized in the netconfig CA and could be typos: %s\" % typosList)\n\n    keys = helpers.getDataStore()\n\n    bootDiskMount = keys.disk.device_mount\n    if not bootDiskMount:\n        raise DiscoveryError(\"Discovery of the boot disk mount point failed. \"\n                             \"Was the stub partition created?\", EC_NO_BOOTDISK)\n\n    bootDisk = LinuxDisk(keys.disk.device_path, None, None)\n    grub = getGrub(bootDisk)\n    try:\n        grub.install(bootDiskMount, bootDisk.getDeviceFilePath())\n    except (OSError, IOError), why:\n        print \"Installing GRuB failed. %s\" % why\n        return EC_IG_FAILED\n\n    # build.py will perform the needed substitutions here\n    osdata = dict()\n    osdata[\"os_display_name\"] = 'Ubuntu Server'\n    osdata[\"os_version\"] = 'UBUNTU'\n    osdata[\"install_params\"] = 'BOOTIF=%(bootif)s priority=critical'\n    osdata[\"ip_config_static\"] = ''\n    osdata[\"ip_config_static6\"] = ''\n    osdata[\"ip_config_dhcp\"] = ''\n    osdata[\"ip_config_auto6\"] = ''\n\n    discoverOsdata(osdata, keys)\n    if \"SLES\" in osdata[\"os_version\"]:\n        discoverSlesAddon(osdata, keys)\n\n    title = 'HP SA assisted %s installer' % osdata['os_display_name']\n    kernelArguments = configureKernelArguments(osdata, keys, parser,\n                                               kernel_arguments=options.kernel_arguments + \" hpsa_monitoring_agent=1\")\n    initrds = configureInitrds(osdata, keys)\n\n    menu = grub.configureMenu(title,\n                              osdata['kernel'], kernelArguments,\n                              initrds, keys)\n    for menuPath in grub.MENU_PATHS:\n        if not os.path.exists(os.path.join(bootDiskMount, os.path.dirname(menuPath))):\n            os.makedirs(os.path.join(bootDiskMount, os.path.dirname(menuPath)))\n        _open(os.path.join(bootDiskMount, menuPath), \"w\").write(menu)\n\n    return 0\n\nHPSA_NETCONFIG = \"\"\"@hpsa_netconfig@\"\"\"\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n",
            "description": "Installs and configures GRUB (GRand Unified Boot Loader) onto the stub partition of the boot disk on the target server in order to enable the booting into the Ubuntu Server installation image.\n\nThe step will also auto detect directories with the names \"addon\", \"AddOn\" and \"ADDON\" in the repository and for SuSE Linux Enterprise Server installations append the proper \"addon='path-to-addon-dir' to the kernel parameters of the grub boot loader.\n\nUsage:\n\nThis script expects no command line arguments, but the following argument(s) can optionally be specified:\n    --kernel_arguments=KERNEL_ARGUMENTS\n                        a string of arguments that will be passed to the OS\n                        installer kernel\n    --disableWarning    Do not show warnings of old hpsa_netconfig format\n\nPrerequisites:\n- Target server runs a maintenance Linux OS.\n- The files in the grub.zip archive must be extracted in /tmp.\n- The \"Create Stub Partition\" step must have been executed. \n\nThis script is intended to be used only as a Build Plan step.",
            "status": null,
            "name": "Install bootloader for Ubuntu Server",
            "state": null,
            "eTag": "2015-06-13T04:49:21.000Z",
            "modified": "2015-06-13T04:49:21.000Z",
            "created": "2015-06-13T04:49:20.000Z",
            "category": "os-deployment-server-scripts",
            "uri": "/rest/os-deployment-server-scripts/1280001"
        },
        {
            "runAsSuperUser": true,
            "serverChanging": true,
            "codeType": "PY2",
            "displayCodeType": "Python",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "1",
                    "createdBy": "opsware",
                    "createdDate": "2015-06-13T04:49:21.000Z",
                    "usage": "Post-install network personalization cross-platform\n\nThis consists of using the information parsed from hpsa_netconfig custom attribute\nto personalize the network settings of the server.\n\nusage: post_install_network_personalization.py [options]\n\noptions (Linux only):\n  --configureOnly    The new specified configuration will be configured but will\n                     only be applied after a reboot. By default the configuration \n                     will be applied if the systemRoot (see below) is /\n  --systemRoot       Root folder where the configuration will take place.\n                     Defaults to \"/\" on an installed OS, and /mnt/local_root in the \n                     step is ran on the service OS.\n  --disableWarning   Do not show warnings of old hpsa_netconfig format\n\nNote: The connection to the SA agent might be temporarily interrupted so not all output \nfrom the step will be visible, but all setting will be applied. A \"Wait for HP SA Agent\" \nstep should be added right after this step to make sure that the agent is operational \nbefore other steps can be executed.",
                    "current": false
                },
                {
                    "versionLabel": "2",
                    "createdBy": "opsware",
                    "createdDate": "2015-08-04T07:30:31.000Z",
                    "usage": "Post-install network personalization cross-platform\n\nThis consists of using the information parsed from hpsa_netconfig custom attribute\nto personalize the network settings of the server.\n\nusage: post_install_network_personalization.py [options]\n\noptions (Linux only):\n  --configureOnly    The new specified configuration will be configured but will\n                     only be applied after a reboot. By default the configuration \n                     will be applied if the systemRoot (see below) is /\n  --systemRoot       Root folder where the configuration will take place.\n                     Defaults to \"/\" on an installed OS, and /mnt/local_root in the \n                     step is ran on the service OS.\n  --disableWarning   Do not show warnings of old hpsa_netconfig format\n\nNote: The connection to the SA agent might be temporarily interrupted so not all output \nfrom the step will be visible, but all setting will be applied. A \"Wait for HP SA Agent\" \nstep should be added right after this step to make sure that the agent is operational \nbefore other steps can be executed.",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-08-04T07:30:31.000Z",
            "version": {
                "versionLabel": "2",
                "createdBy": "opsware",
                "createdDate": "2015-08-04T07:30:31.000Z",
                "usage": "Post-install network personalization cross-platform\n\nThis consists of using the information parsed from hpsa_netconfig custom attribute\nto personalize the network settings of the server.\n\nusage: post_install_network_personalization.py [options]\n\noptions (Linux only):\n  --configureOnly    The new specified configuration will be configured but will\n                     only be applied after a reboot. By default the configuration \n                     will be applied if the systemRoot (see below) is /\n  --systemRoot       Root folder where the configuration will take place.\n                     Defaults to \"/\" on an installed OS, and /mnt/local_root in the \n                     step is ran on the service OS.\n  --disableWarning   Do not show warnings of old hpsa_netconfig format\n\nNote: The connection to the SA agent might be temporarily interrupted so not all output \nfrom the step will be visible, but all setting will be applied. A \"Wait for HP SA Agent\" \nstep should be added right after this step to make sure that the agent is operational \nbefore other steps can be executed.",
                "current": true
            },
            "source": "#!/usr/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# lint_ignore=E501,I0011,C0301\n# Please do not change the two lines above. See PEP 8, PEP 263.\n#\n\"\"\"\n    (C) Copyright 2014-2015 Hewlett-Packard Development Company, L.P.\n\n    Post install network personalization cross-platform\n\n    This consists of taking the information parsed from hpsa_netconfig\n    and use it to do a custom personalization of the local server\n\n\"\"\"\nimport os\nimport sys\nimport time\n\nfrom cStringIO import StringIO\n\nfrom osprov import constants\nfrom osprov.osbp import logger\nfrom osprov.decorators import HandleShowErrorMessage\nfrom osprov.parsers.netconfig import SmartNetconfig, OLD_SYNTAX_WARNING\nfrom osprov.util import process\nfrom osprov.netconfig import NetconfigValidationError\nfrom osprov.networking import configuration\nfrom osprov.networking.configuration import NetworkConfigurationError\nfrom osprov.networking.utils import isIPv6Address, isIPv4Address\nfrom osprov.optparse_ext import OptionParser\nfrom osprov.server.local import ThisLocalServer\nfrom osprov.util.winpe import hasEnglishLanguage\nfrom osprov.helpers import isLinux, isWindows, isSolaris\nfrom osprov.errors import NotSupportedError, ProcessExecutionError, NotFoundError\n\n\nLOG = logger.getIt(\"post install network personalization\")\n\n\nclass PostNetworkConfigOptionParser(OptionParser):\n    def __init__(self, localServer, *args, **kwargs):\n        OptionParser.__init__(self, *args, **kwargs)\n        self.usage = \"Post install network personalization\"\n        self.localServer = localServer\n\n    def defineOptions(self):\n        self.set_defaults(applyImmediately=False, systemRoot=\"/\", disableWarning=False)\n        self.add_option(\"--configureOnly\", dest=\"applyImmediately\", action=\"store_false\",\n                        default=None,\n                        help=\"The new specified configuration will be immediately in effect.\")\n        self.add_option(\"--systemRoot\", type=\"string\", dest=\"systemRoot\", default=None,\n                        help=\"Root folder where the configuration will take place.\")\n        self.add_option(\"--disableWarning\", dest=\"disableWarning\", action=\"store_true\",\n                        default=None,\n                        help=\"Do not show warnings of old hpsa_netconfig format\")\n\n    def validateArgs(self, opt, args):\n        if opt.systemRoot is None:\n            if self.localServer.isMaintenance():\n                opt.systemRoot = constants.OGFS_SYSTEM_ROOT\n            else:\n                opt.systemRoot = \"/\"\n        if opt.applyImmediately is None:\n            opt.applyImmediately = opt.systemRoot == \"/\"\n\n\ndef discover_osVersion(localServer, systemRoot):\n    if localServer.isMaintenance():\n        LOG.debug(\"We are in maintenance. Trying to discover the OS version from local server.\")\n        if isLinux():\n            lsdir_etc = [etc_file.lower() for etc_file in os.listdir(os.path.join(systemRoot, \"etc/\"))]\n            for fileName, version in (\n                (\"suse-release\", \"suse\"),\n                (\"redhat-release\", \"redhat\"),\n                (\"debian_version\", \"ubuntu\")\n            ):\n                if fileName.lower() in lsdir_etc:\n                    return version\n            raise NotSupportedError(\"Could not determine version of the operating system mounted at: %s\" % systemRoot)\n    else:\n        return localServer.getServerVO().getOsVersion()\n\n\ndef serviceOpswareAgent(operation, waitAfter=0, retryMax=5, retryInterval=30):\n    if isWindows():\n        cmd = \"sc {} OpswareAgent\"\n    else:\n        cmd = \"/etc/init.d/opsware-agent {}\"\n    cmd = cmd.format(operation)\n    process.reRunIt(cmd, retryMax, retryInterval, log=LOG)\n    time.sleep(waitAfter)\n\n\ndef checkGatewayReachability(gateways, checker, attempts=30, sleep=2):\n    if not gateways:\n        return False\n    LOG.debug(\"Checking connection to: %s\" % gateways)\n    while attempts:\n        for gateway in gateways:\n            agwIp, agwPort = gateway\n            try:\n                checker(host=agwIp, port=agwPort)\n                LOG.debug(\"Succeeded in connecting to agent gateway %s\" % str(gateway))\n                return True\n            except NetconfigValidationError, why:\n                LOG.debug(\"Failed to connect to agent gateway. Reason: %s\" % why)\n                continue\n        attempts -= 1\n        time.sleep(sleep)\n    return False\n\n\ndef getAgentGateways(localServer, netinfo):\n    \"\"\" Return the relevant agent gateways based on netinfo,\n        i.e no IPv4 gateways if there is no NIC with an IPv4 configuration\n    \"\"\"\n    isIPv4 = False\n    isIPv6 = False\n    for nic in netinfo.nics:\n        if nic.ipv4Networks or nic.dhcpv4:\n            isIPv4 = True\n        if nic.ipv6Networks or nic.ipv6Autoconfig:\n            isIPv6 = True\n\n    agentgws = localServer.getAgentGWs(stackAware=False)\n    ipv6gws = set((gw, port) for gw, port in agentgws if isIPv6Address(gw)) if isIPv6 else []\n    ipv4gws = set((gw, port) for gw, port in agentgws if isIPv4Address(gw)) if isIPv4 else []\n\n    return ipv4gws, ipv6gws\n\n\ndef checkCoreConnectivity(localServer, netinfo):\n    \"\"\" Check connectivity with the core on both IPv4 and IPv6 agent gateways \"\"\"\n    checker = localServer.netconfig.Netconfig.checkTCPReachability\n    ipv4gws, ipv6gws = getAgentGateways(localServer, netinfo)\n    if ipv4gws and ipv6gws:\n        return checkGatewayReachability(ipv6gws, checker=checker) and checkGatewayReachability(ipv4gws, checker=checker)\n    elif ipv4gws:\n        return checkGatewayReachability(ipv4gws, checker=checker)\n    elif ipv6gws:\n        return checkGatewayReachability(ipv6gws, checker=checker)\n    else:\n        return False\n\n\ndef ThisPersistedNetworkingConfig(localServer, netinfo, version, options):\n    if localServer.isMaintenance() and options.applyImmediately:\n        raise NotSupportedError(\"Network personalization in a service OS is only supported with --configureOnly\")\n    if isWindows():\n        if not options.applyImmediately:\n            raise NotSupportedError(\n                \"Windows does not support configuration only mode. Setting need to be applied immediately.\\n\" +\n                \"Try running without the --configureOnly option. \")\n        return configuration.ConfigureWindowsNetworking(netinfo=netinfo, log=LOG)\n    elif isSolaris():\n        raise NotSupportedError(\"Solaris network personalization is not yet supported\")\n    elif isLinux():\n        if 'ubuntu' in version:\n            return configuration.ConfigurePersistedUbuntuNetworking(localServer=localServer, netinfo=netinfo, log=LOG,\n                                                                    applyImmediately=options.applyImmediately,\n                                                                    systemRoot=options.systemRoot)\n        elif 'suse' in version or 'sles' in version:\n            return configuration.ConfigurePersistedSLESNetworking(localServer=localServer, netinfo=netinfo, log=LOG,\n                                                                  applyImmediately=options.applyImmediately,\n                                                                  systemRoot=options.systemRoot)\n        elif 'redhat' in version or 'red hat' in version or (\"esx\" not in version and \"xen\" not in version):\n            return configuration.ConfigurePersistedRedHatNetworking(localServer=localServer, netinfo=netinfo, log=LOG,\n                                                                    applyImmediately=options.applyImmediately,\n                                                                    systemRoot=options.systemRoot)\n        else:\n            raise NotSupportedError(\"Network personalization does not support this Linux version:  %s\" % version)\n\n\ndef isIPv4Remaining(netinfo, interfaces):\n    IPv4Macs = [interface.hardwareAddress for interface in interfaces if isIPv4Address(interface.ipAddress)]\n    for nic in netinfo.nics:\n        if nic.macAddress in IPv4Macs and (not nic.ipv4Networks) and (not nic.dhcpv4):\n            return True\n\n    return False\n\n\ndef isIPv6Remaining(netinfo, interfaces):\n    IPv6Macs = [interface.hardwareAddress for interface in interfaces if isIPv6Address(interface.ipAddress)]\n    for nic in netinfo.nics:\n        if nic.macAddress in IPv6Macs and (not nic.ipv6Networks) and (not nic.ipv6Autoconfig):\n            return True\n\n    return False\n\n\ndef printToLog(text):\n    \"\"\" Writes messages to log file, so they will be recovered and printed to BPs status, after connection is lost with\n        the agent\n    \"\"\"\n    LOG.info(constants.LOG_START_TAG + text + constants.LOG_END_TAG)\n\n\n@HandleShowErrorMessage(\"perform post install network personalization\", LOG)\ndef main():\n    if not HPSA_NETCONFIG:\n        return\n\n    if isWindows() and not hasEnglishLanguage():\n        raise NotSupportedError(\"Network personalization of non English Windows servers is not yet supported\")\n\n    localServer = ThisLocalServer(log=LOG)\n    options, rargs = PostNetworkConfigOptionParser(localServer).parse_args()\n    del rargs\n\n    osVersion = discover_osVersion(localServer, options.systemRoot)\n    LOG.info(\"Discovered OS version: %s \", osVersion)\n\n    try:\n        activeMac = localServer.getMACAddress()\n    except NotFoundError as why:\n        LOG.info(\"Can not determine the active MAC address, will try regardless, exception follows\")\n        LOG.exception(why)\n        activeMac = None\n    netconfigParser = SmartNetconfig.readwrite(\n        StringIO(HPSA_NETCONFIG),\n        activeMacAddress=activeMac,\n        ipv6default=None,\n        log=LOG\n    )\n    netinfo = netconfigParser.info()\n\n    for nic in netinfo.nics:\n        if nic.ipv6Networks and nic.invalidIpv6Address:\n            print(\"Warning: Static configuration for interface with macaddress: %s contains invalid IPv6 address: %s\" % (nic.macAddress, str(nic.invalidIpv6Address).replace('IPv6Network', '').replace('(', '').replace(')', '')))\n\n    if netinfo.oldSyntax and not options.disableWarning:\n        newFormat = netconfigParser.format()\n        print(OLD_SYNTAX_WARNING + \"\\n%s\" % str(newFormat))\n\n    typosList = netconfigParser.getTyposList()\n    if typosList:\n        print(\"The following keys were not recognized in the hpsa_netconfig CA and could be typos: %s\" % typosList)\n\n    networkingClass = ThisPersistedNetworkingConfig(localServer, netinfo, osVersion.lower(), options)\n\n    if options.applyImmediately:\n        print(\"The HPSA agent will be stopped and started again after network personalization is done\")\n        sys.stdout.flush()\n        serviceOpswareAgent(\"stop\", waitAfter=5)\n        # note that the output after stopping the agent is lost since the framework will advance to the next step\n\n    try:\n        networkingClass.apply()\n    except NetworkConfigurationError, error:\n        LOG.exception(error)\n    finally:\n        if not checkCoreConnectivity(localServer, netinfo):\n            LOG.warning(\"A connection to the SA core could not be established. This might cause agent registration to fail.\")\n        if options.applyImmediately:\n            serviceOpswareAgent(\"start\")\n            localServer.registerHardware()\n            time.sleep(20)\n            interfaces = localServer.getServerHardwareVO(cached=False).getInterfaces()\n            # As after loosing connection with the agent the framework advances to the next step, all messages will be\n            # written to the log and recovered from there\n            if isIPv4Remaining(netinfo, interfaces):\n                printToLog(\"The old IPv4 addresses still remained, a reboot is required to flush the old addresses.\")\n            if isIPv6Remaining(netinfo, interfaces):\n                printToLog(\"The old IPv6 addresses still remained, a reboot is required to flush the old addresses.\")\n        else:\n            if not isWindows():\n                open(os.path.join(options.systemRoot, \"var/opt/opsware/agent/force_hwreg\"), \"w+\").close()\n                print(\"Hardware changes will be visible after reboot.\")\n\n\nHPSA_NETCONFIG = \"\"\"@hpsa_netconfig@\"\"\"\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n",
            "description": "Post-install network personalization cross-platform\n\nThis consists of using the information parsed from hpsa_netconfig custom attribute\nto personalize the network settings of the server.\n\nusage: post_install_network_personalization.py [options]\n\noptions (Linux only):\n  --configureOnly    The new specified configuration will be configured but will\n                     only be applied after a reboot. By default the configuration \n                     will be applied if the systemRoot (see below) is /\n  --systemRoot       Root folder where the configuration will take place.\n                     Defaults to \"/\" on an installed OS, and /mnt/local_root in the \n                     step is ran on the service OS.\n  --disableWarning   Do not show warnings of old hpsa_netconfig format\n\nNote: The connection to the SA agent might be temporarily interrupted so not all output \nfrom the step will be visible, but all setting will be applied. A \"Wait for HP SA Agent\" \nstep should be added right after this step to make sure that the agent is operational \nbefore other steps can be executed.",
            "status": null,
            "name": "Personalize Network Settings of Installed System",
            "state": null,
            "eTag": "2015-08-04T07:30:31.000Z",
            "modified": "2015-08-04T07:30:31.000Z",
            "created": "2015-06-13T04:49:21.000Z",
            "category": "os-deployment-server-scripts",
            "uri": "/rest/os-deployment-server-scripts/1290001"
        },
        {
            "runAsSuperUser": true,
            "serverChanging": false,
            "codeType": "PY2",
            "displayCodeType": "Python",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "1",
                    "createdBy": "opsware",
                    "createdDate": "2015-06-13T04:49:21.000Z",
                    "usage": "This program will modify the Automated Installer manifest files to inject personalization settings.\n\nUsage: inject_ai_personalization.py [options]\n\noptions:\n  -n HOSTNAME, --hostname=HOSTNAME\n                        Installed system hostname\n  -t TIMEZONE, --timezone=TIMEZONE\n                        Timezone for the installed system\n  -l LOCALE, --locale=LOCALE\n                        System language and locale, specified in POSIX format (eg. en_US.UTF-8)\n\nPrerequisites:\n\n- This script must be run as part of a Build Plan under a Solaris Service OS\n- This script must be run after ai.xml and sc.xml configuration files were deployed on the server",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-06-13T04:49:21.000Z",
            "version": {
                "versionLabel": "1",
                "createdBy": "opsware",
                "createdDate": "2015-06-13T04:49:21.000Z",
                "usage": "This program will modify the Automated Installer manifest files to inject personalization settings.\n\nUsage: inject_ai_personalization.py [options]\n\noptions:\n  -n HOSTNAME, --hostname=HOSTNAME\n                        Installed system hostname\n  -t TIMEZONE, --timezone=TIMEZONE\n                        Timezone for the installed system\n  -l LOCALE, --locale=LOCALE\n                        System language and locale, specified in POSIX format (eg. en_US.UTF-8)\n\nPrerequisites:\n\n- This script must be run as part of a Build Plan under a Solaris Service OS\n- This script must be run after ai.xml and sc.xml configuration files were deployed on the server",
                "current": true
            },
            "source": "#!/opt/opsware/agent/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n\"\"\"\n    (C) Copyright 2013-2015 Hewlett-Packard Development Company, L.P.\n\n    This program will modify the sc.xml manifest file to inject\n    the optional personalization settings for the final system.\n\n    This includes hostname, timezone and locale.\n\"\"\"\n\nimport sys\n\nfrom osprov.profile import SCManifest\nfrom osprov.decorators import HandleShowErrorMessage\nfrom osprov.optparse_ext import OptionParser\nfrom osprov.osbp import logger\n\nSC_XML_PATH = \"/tmp/sc.xml\"\n\nLOG = logger.getIt(\"Inject AI Personalization settings\")\n\n\nclass InjectOptionsParser(OptionParser):\n\n    def defineOptions(self):\n        self.add_option(\"-n\", \"--hostname\", help=\"Installed system hostname\")\n        self.add_option(\"-t\", \"--timezone\", help=\"Timezone for the installed system\")\n        self.add_option(\n            \"-l\", \"--locale\", help=\"System language and locale, specified in POSIX format (eg. en_US.UTF-8)\")\n\n\n@HandleShowErrorMessage(\"inject AI personalization\", LOG)\ndef main():\n    \"\"\"Inject AI Personalization settings.\"\"\"\n\n    opts, args = InjectOptionsParser().parse_args()\n\n    scFile = open(SC_XML_PATH, \"r\")\n    scManifest = SCManifest(scFile)\n\n    try:\n        if opts.hostname:\n            scManifest.hostname = opts.hostname\n        if opts.timezone:\n            scManifest.timezone = opts.timezone\n        if opts.locale:\n            scManifest.locale = opts.locale\n\n        scManifest.save()\n    finally:\n        scFile.close()\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n",
            "description": "This program will modify the Automated Installer manifest files to inject personalization settings.\n\nUsage: inject_ai_personalization.py [options]\n\noptions:\n  -n HOSTNAME, --hostname=HOSTNAME\n                        Installed system hostname\n  -t TIMEZONE, --timezone=TIMEZONE\n                        Timezone for the installed system\n  -l LOCALE, --locale=LOCALE\n                        System language and locale, specified in POSIX format (eg. en_US.UTF-8)\n\nPrerequisites:\n\n- This script must be run as part of a Build Plan under a Solaris Service OS\n- This script must be run after ai.xml and sc.xml configuration files were deployed on the server",
            "status": null,
            "name": "Inject AI Personalization Settings",
            "state": null,
            "eTag": "2015-06-13T04:49:21.000Z",
            "modified": "2015-06-13T04:49:21.000Z",
            "created": "2015-06-13T04:49:21.000Z",
            "category": "os-deployment-server-scripts",
            "uri": "/rest/os-deployment-server-scripts/1300001"
        },
        {
            "runAsSuperUser": true,
            "serverChanging": true,
            "codeType": "PY2",
            "displayCodeType": "Python",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "1",
                    "createdBy": "opsware",
                    "createdDate": "2015-06-13T04:49:23.000Z",
                    "usage": "Will create the necessary files and will aggregate them into a .tar file\nneeded in the Jumpstart installation process of Solaris 10 x86 over NFS.\nContents of these files is present in the default jumpstart configuration template.\n\nusage: install_required_jumpstart.py\n\nPrerequisites:\n\n- This script must be run as part of a Build Plan under a Solaris Service OS on x86\n- This script must be run after 'Create Solaris Stub Partition' and 'Configure Solaris 10 Default Jumpstart'",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-06-13T04:49:23.000Z",
            "version": {
                "versionLabel": "1",
                "createdBy": "opsware",
                "createdDate": "2015-06-13T04:49:23.000Z",
                "usage": "Will create the necessary files and will aggregate them into a .tar file\nneeded in the Jumpstart installation process of Solaris 10 x86 over NFS.\nContents of these files is present in the default jumpstart configuration template.\n\nusage: install_required_jumpstart.py\n\nPrerequisites:\n\n- This script must be run as part of a Build Plan under a Solaris Service OS on x86\n- This script must be run after 'Create Solaris Stub Partition' and 'Configure Solaris 10 Default Jumpstart'",
                "current": true
            },
            "source": "#!/opt/opsware/agent/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n\"\"\"\n    (C) Copyright 2013-2015 Hewlett-Packard Development Company, L.P.\n\n    Will install create the necessary files and will aggregate them into a .tar file\n    needed in the Jumpstart installation process of Solaris 10 x86 over NFS. Contents of these files\n    is present in the default jumpstart configuration template.\n\"\"\"\n\nimport os\nimport sys\nimport shutil\n\nfrom osprov import helpers, media\nfrom osprov.decorators import HandleShowErrorMessage\nfrom osprov.errors import NotSupportedError, DiscoveryError\nfrom osprov.osbp import logger\nfrom osprov.server.local import ThisLocalServer\nfrom osprov.parsers.jumpstart import JumpstartParser\nfrom osprov.netconfig.solaris import NetworkInterface\n\nLOG = logger.getIt(\"Inject Required Jumpstart\")\n\n\ndef createSysidcfg(jumpstartDir, sysidcfgDict, parserObj, targetServer):\n    \"\"\" Creates the sysidcfg file in the jumpstart directory on the mounted path \"\"\"\n    sysidcfgPath = os.path.join(jumpstartDir, \"sysidcfg\")\n    # verify that necessary items are in place & assemble file\n    mandatoryKeys = [\"network_interface\", \"system_locale\", \"timezone\", \"timeserver\", \"nfs4_domain\"]\n    for key in mandatoryKeys:\n        if not sysidcfgDict.has_key(key):\n            raise DiscoveryError(\n                \"The following setting : %s is needed in order for the installation to work\" % key)\n\n    # inject active network interface\n    macAddress = targetServer.getMACAddress()\n    networkIf = NetworkInterface(macAddress=macAddress)\n    deviceName = networkIf.getDeviceName()\n    LOG.debug(\"Discovered network interface %s with MAC address %s\" % (deviceName, macAddress))\n\n    # delete network_interface with value primary, this is not supported when\n    # configuring another specific interface\n    if parserObj.data[\"sysidcfg\"][\"network_interface\"].has_key('primary'):\n        LOG.debug(\"Discovered network_interface set to primary. Deleting it.\")\n        del parserObj.data[\"sysidcfg\"][\"network_interface\"]['primary']\n\n    # setting if a network interface is up the one used for communication\n    config = \"{dhcp protocol_ipv6=no}\\n\"\n    if not parserObj.data[\"sysidcfg\"][\"network_interface\"].has_key(deviceName):\n        parserObj.data[\"sysidcfg\"][\"network_interface\"][deviceName] = config\n    elif \"dhcp\" not in parserObj.data[\"sysidcfg\"][\"network_interface\"][deviceName]:\n        parserObj.data[\"sysidcfg\"][\"network_interface\"][deviceName] = config\n    LOG.debug(\"Configured interface %s with %s\" %\n              (deviceName, parserObj.data[\"sysidcfg\"][\"network_interface\"][deviceName]))\n\n    content = parserObj.toString(\"sysidcfg\")\n    writeToFile(sysidcfgPath, content)\n\n\ndef createProfile(jumpstartDir, profileDict, parserObj):\n    \"\"\" Creates the install.input file in the jumpstart directory on the mounted path \"\"\"\n    profilePath = os.path.join(jumpstartDir, \"install.input\")\n    # verify that necessary items are in place & assemble file\n    mandatoryKeys = [\"install_type\", \"partitioning\", \"system_type\"]\n    for key in mandatoryKeys:\n        if not profileDict.has_key(key):\n            raise DiscoveryError(\n                \"The following setting : %s is needed in order for the installation to work\" % key)\n    content = parserObj.toString(\"profile\")\n    writeToFile(profilePath, content)\n\n\ndef createRules(jumpstartDir):\n    \"\"\" Creates the rules file in the jumpstart directory on the mounted path \"\"\"\n    rules = os.path.join(jumpstartDir, \"rules\")\n    content = \"any - profile -\"\n    writeToFile(rules, content)\n\n\ndef createRulesok(jumpstartDir):\n    \"\"\" Creates the rules.ok file in the jumpstart directory on the mounted path \"\"\"\n    rulesok = os.path.join(jumpstartDir, \"rules.ok\")\n    content = \"\"\"probe arch\nprobe disks\nprobe domainname\nprobe hostaddress\nprobe hostname\nprobe installed\nprobe karch\nprobe memsize\nprobe model\nprobe network\nprobe osname\nprobe rootdisk\nprobe totaldisk\nany - begin = finish\n# version=2 checksum=20755\n\"\"\"\n    writeToFile(rulesok, content)\n\n\ndef injectReqToBeginScript(jumpstartDir, parserObj, injectedValues):\n    \"\"\" Creates the begin (pre-script) file in the jumpstart directory on the mounted path \"\"\"\n    begin = os.path.join(jumpstartDir, \"begin\")\n    content = \"\"\"#!/bin/sh\necho \"Copying install.input profile ...\"\ncp /jumpstart/install.input /tmp/install.input\necho \"Remounting root ...\"\nmount -o remount,rw /\necho \"Setting up dns ...\"\ncat %(dnsSource)s > /etc/resolv.conf\ncp /etc/nsswitch.dns /etc/nsswitch.conf\necho \"Mounting install media ...\"\nnfspath=%(mediaSource)s\nmount -F nfs -o ro,vers=2 $nfspath /cdrom\necho $nfspath > /tmp/.netmnt\necho \"Starting Opsware OS Provisioning agent ...\"\nagwIpPort=%(agwIpPort)s\necho \"Contacting agent gateway at $agwIpPort...\"\n/bin/sh /opt/opsware/agent/osprov/ogfs-agent-setup.sh $agwIpPort\necho \"Setup done, launching OGFS agent ...\"\necho \"coglib.platform.lc_path: /opt/opsware/agent\" >> /etc/opt/opsware/agent/agent.args\n/bin/sh /opt/opsware/agent/osprov/ogfs-agent-start.sh\necho \"\" > /tmp/finish.flag\n\"\"\" % injectedValues\n    content += \"\\n\" + parserObj.toString(\"begin\")\n    parserObj.data[\"begin\"] = content\n    writeToFile(begin, content)\n\n\ndef injectReqFinishScript(jumpstartDir, parserObj):\n    \"\"\" Creates the finish (post-script) file in the jumpstart directory on the mounted path \"\"\"\n    finish = os.path.join(jumpstartDir, \"finish\")\n    content = \"\"\"#!/bin/sh\necho \"Adding kernel/unix to boot parameters ...\"\nBASE=/a\nBOOT_OPTS=\"kernel/unix\"\nexport BOOT_OPTS\nif [ -f $BASE/boot/grub/menu.lst ]; then\n    perl -p -i -e 's#^kernel(.*)multiboot#kernel$1multiboot $ENV{\"BOOT_OPTS\"}#g' $BASE/boot/grub/menu.lst\nelse\n    grep -v \"setprop boot-file \" $BASE/boot/solaris/bootenv.rc > \\\n        /tmp/bootenv$$\n    echo \"setprop boot-file '$BOOT_OPTS'\" >> /tmp/bootenv$$\n    mv /tmp/bootenv$$ $BASE/boot/solaris/bootenv.rc\nfi\n\n%s\n\necho \"Stopping installation...\"\necho \"\" > /tmp/HPSAMonitoringStop.flag\nwhile [ -f /tmp/finish.flag ]; do sleep 1; done\n\"\"\" % parserObj.toString(\"finish\")\n    parserObj.data[\"finish\"] = content\n    writeToFile(finish, content)\n\n\ndef createDestAndValues(targetServer):\n    \"\"\" Creates the jumpstart directory on the mounted path and determines the necessary values that will be injected \"\"\"\n    keys = helpers.getDataStore()\n    stubMountpoint = keys.disk.device_mount\n    jumpstartDir = os.path.join(stubMountpoint, \"jumpstart\")\n    if not os.path.isdir(jumpstartDir):\n        os.makedirs(jumpstartDir)\n    LOG.debug(\"Jumpstart Configuration directory path : %s\" % str(jumpstartDir))\n\n    # finding dns values\n    resolv_file = os.path.join(jumpstartDir, \"resolv.conf\")\n    shutil.copyfile(\"/etc/resolv.conf\", resolv_file)\n\n    agwIpPort = targetServer.getRandomAgentGateway()\n    urlMedia = media.parseUrl(keys.media.url)\n    injectedValues = {\n        'mediaSource': '%s:%s' % (urlMedia.netloc, urlMedia.path),\n        'agwIpPort': agwIpPort,\n        'dnsSource': \"/jumpstart/resolv.conf\"\n    }\n    LOG.debug(\"Determined values that will be injected : %s\" % str(injectedValues))\n    return jumpstartDir, injectedValues\n\n\ndef writeToFile(pathToFile, content):\n    fd = open(pathToFile, \"wb+\")\n    fd.write(content)\n    fd.close()\n    LOG.debug(\"File %s : \\n%s\" % (pathToFile, content))\n\n\n@HandleShowErrorMessage(\"Inject Required Jumpstart\", LOG)\ndef main():\n    \"\"\"Creates necessary files for Jumpstart installation and injects required values\"\"\"\n    if not os.uname()[-1].startswith(\"i86\"):\n        raise NotSupportedError(\"Injecting required jumpstart is not supported on SPARC.\")\n\n    defaultJumpstart = \"/tmp/default_jumpstart.txt\"\n    targetServer = ThisLocalServer()\n\n    jumpstartParser = JumpstartParser.readonly(open(defaultJumpstart))\n    jumpstartData = jumpstartParser.info()\n    LOG.debug(\"Parsed default jumpstart: \\n%s\" % str(jumpstartData))\n\n    (jumpstartDir, injectedValues) = createDestAndValues(targetServer=targetServer)\n\n    createSysidcfg(jumpstartDir=jumpstartDir, sysidcfgDict=jumpstartData[\n                   \"sysidcfg\"], parserObj=jumpstartParser, targetServer=targetServer)\n    createProfile(jumpstartDir=jumpstartDir,\n                  profileDict=jumpstartData[\"profile\"], parserObj=jumpstartParser)\n\n    injectReqToBeginScript(\n        jumpstartDir=jumpstartDir, parserObj=jumpstartParser, injectedValues=injectedValues)\n    injectReqFinishScript(jumpstartDir=jumpstartDir, parserObj=jumpstartParser)\n\n    createRules(jumpstartDir=jumpstartDir)\n    createRulesok(jumpstartDir=jumpstartDir)\n\n    writeToFile(defaultJumpstart, jumpstartParser.extractFileContents())\n\n    LOG.info(\"Finished creating necessary files for Jumpstart installation\")\n\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n",
            "description": "Will create the necessary files and will aggregate them into a .tar file\nneeded in the Jumpstart installation process of Solaris 10 x86 over NFS.\nContents of these files is present in the default jumpstart configuration template.\n\nusage: install_required_jumpstart.py\n\nPrerequisites:\n\n- This script must be run as part of a Build Plan under a Solaris Service OS on x86\n- This script must be run after 'Create Solaris Stub Partition' and 'Configure Solaris 10 Default Jumpstart'",
            "status": null,
            "name": "Inject Required Jumpstart Settings",
            "state": null,
            "eTag": "2015-06-13T04:49:23.000Z",
            "modified": "2015-06-13T04:49:23.000Z",
            "created": "2015-06-13T04:49:23.000Z",
            "category": "os-deployment-server-scripts",
            "uri": "/rest/os-deployment-server-scripts/1340001"
        },
        {
            "runAsSuperUser": true,
            "serverChanging": true,
            "codeType": "BAT",
            "displayCodeType": "Windows .BAT",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "1",
                    "createdBy": "opsware",
                    "createdDate": "2015-06-13T04:49:25.000Z",
                    "usage": "Installs Windows 2008 R2 x64 from OS Media. Requires full path to  setup.exe from the installation media.",
                    "current": false
                },
                {
                    "versionLabel": "2",
                    "createdBy": "opsware",
                    "createdDate": "2015-08-04T07:30:08.000Z",
                    "usage": "Installs Windows 2008 R2 x64 from OS Media. Requires full path to  setup.exe from the installation media.",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-08-04T07:30:08.000Z",
            "version": {
                "versionLabel": "2",
                "createdBy": "opsware",
                "createdDate": "2015-08-04T07:30:08.000Z",
                "usage": "Installs Windows 2008 R2 x64 from OS Media. Requires full path to  setup.exe from the installation media.",
                "current": true
            },
            "source": "@echo off\nsetlocal\nset SIG=WINPE64\nset ANSWER=X:\\Windows\\Temp\\Unattend.xml\nset ARGS=/noreboot /unattend:%ANSWER%\nset | find \"opswbasig=%SIG%\" > NUL\nif %ERRORLEVEL% NEQ 0 (\n    echo ERROR: Target server must be running %SIG% but it is not\n    exit /B 1\n)\nif X%1==X (\n    set SETUP=z:\\i386\\winnt32.exe\n) else (\n    set SETUP=%1\n)\nif not exist %SETUP% (\n    echo %SETUP% missing! Cannot install Windows.\n    exit /B 2\n)\nif not exist %ANSWER% (\n    echo %ANSWER% missing! Cannot install Windows.\n    exit /B 3\n)\n\n%SETUP% %ARGS%\n\nif %ERRORLEVEL% == 0 (\n    echo Windows setup completed successfully\n    exit\n) else (\n    echo ERROR: Windows setup exited status %ERRORLEVEL%\n    exit /B %ERRORLEVEL%\n)\n",
            "description": "Installs Windows 2008 R2 x64 from OS Media. Requires full path to  setup.exe from the installation media.",
            "status": null,
            "name": "Run Windows 2008 R2 x64 Setup",
            "state": null,
            "eTag": "2015-08-04T07:30:08.000Z",
            "modified": "2015-08-04T07:30:08.000Z",
            "created": "2015-06-13T04:49:24.000Z",
            "category": "os-deployment-server-scripts",
            "uri": "/rest/os-deployment-server-scripts/1370001"
        },
        {
            "runAsSuperUser": true,
            "serverChanging": true,
            "codeType": "BAT",
            "displayCodeType": "Windows .BAT",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "1",
                    "createdBy": "opsware",
                    "createdDate": "2015-06-13T04:51:44.000Z",
                    "usage": "Script to clean the Oracle DbScanner on a managed server",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-06-13T04:51:44.000Z",
            "version": {
                "versionLabel": "1",
                "createdBy": "opsware",
                "createdDate": "2015-06-13T04:51:44.000Z",
                "usage": "Script to clean the Oracle DbScanner on a managed server",
                "current": true
            },
            "source": "set RMFOLDER=%ProgramFiles%\\Opsware\\dbscanner.oracle\nif exist \"%RMFOLDER%\" (rd /S /Q \"%RMFOLDER%\") ",
            "description": "Script to clean the Oracle DbScanner on a managed server",
            "status": null,
            "name": "post-uninstall script for Database scanner for Oracle (win)",
            "state": null,
            "eTag": "2015-06-13T04:51:44.000Z",
            "modified": "2015-06-13T04:51:44.000Z",
            "created": "2015-06-13T04:51:44.000Z",
            "category": "os-deployment-server-scripts",
            "uri": "/rest/os-deployment-server-scripts/1390001"
        },
        {
            "runAsSuperUser": true,
            "serverChanging": true,
            "codeType": "SH",
            "displayCodeType": "Unix",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "1",
                    "createdBy": "opsware",
                    "createdDate": "2015-06-13T04:51:45.000Z",
                    "usage": "Script to clean the Oracle DbScanner on a managed server",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-06-13T04:51:45.000Z",
            "version": {
                "versionLabel": "1",
                "createdBy": "opsware",
                "createdDate": "2015-06-13T04:51:45.000Z",
                "usage": "Script to clean the Oracle DbScanner on a managed server",
                "current": true
            },
            "source": "RMFOLDER=/opt/opsware/dbscanner.oracle\nif [ -d $RMFOLDER ]; then\n  rm -rf $RMFOLDER\nfi ",
            "description": "Script to clean the Oracle DbScanner on a managed server",
            "status": null,
            "name": "post-uninstall script for Database scanner for Oracle (unix)",
            "state": null,
            "eTag": "2015-06-13T04:51:45.000Z",
            "modified": "2015-06-13T04:51:45.000Z",
            "created": "2015-06-13T04:51:44.000Z",
            "category": "os-deployment-server-scripts",
            "uri": "/rest/os-deployment-server-scripts/1400001"
        },
        {
            "runAsSuperUser": true,
            "serverChanging": true,
            "codeType": "SH",
            "displayCodeType": "Unix",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "1",
                    "createdBy": "opsware",
                    "createdDate": "2015-06-13T04:57:00.000Z",
                    "usage": "'wrapper",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-06-13T04:57:00.000Z",
            "version": {
                "versionLabel": "1",
                "createdBy": "opsware",
                "createdDate": "2015-06-13T04:57:00.000Z",
                "usage": "'wrapper",
                "current": true
            },
            "source": "#!/bin/sh\n#\n# Wrapper to execute Ubuntu package importer\n# \n# Copyright (c) 2009 Hewlett-Packard Development Company, L.P.\n#\n\nuid=`id | sed 's/^[^=]*=\\([0-9]*\\).*/\\1/'`\n[ \"$uid\" = \"0\" ] || { \n  echo \"Only root may run this program.\"\n  exit 1\n}\n\nPATH=/opt/opsware/bin:$PATH\nexport PATH\n\nPYTHONPATH=/opt/opsware/pylibs27:/opt/opsware/patch_importer\nexport PYTHONPATH\n\n# Execute Ubuntu metadata importer\nexec python2.7 /opt/opsware/patch_importer/ubuntu_importer/ubuntu_importer_pkg/import_ubuntu_pkg.pyc \"$@\"\n",
            "description": "'wrapper",
            "status": null,
            "name": "Import Ubuntu Packages",
            "state": null,
            "eTag": "2015-06-13T04:57:00.000Z",
            "modified": "2015-06-13T04:57:00.000Z",
            "created": "2015-06-13T04:56:59.000Z",
            "category": "os-deployment-server-scripts",
            "uri": "/rest/os-deployment-server-scripts/1420001"
        },
        {
            "runAsSuperUser": true,
            "serverChanging": true,
            "codeType": "SH",
            "displayCodeType": "Unix",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "1",
                    "createdBy": "opsware",
                    "createdDate": "2015-06-13T04:57:00.000Z",
                    "usage": "'wrapper",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-06-13T04:57:01.000Z",
            "version": {
                "versionLabel": "1",
                "createdBy": "opsware",
                "createdDate": "2015-06-13T04:57:00.000Z",
                "usage": "'wrapper",
                "current": true
            },
            "source": "#!/bin/sh\n#\n# Wrapper to execute Ubuntu metadata importer\n# \n# Copyright (c) 2013 Hewlett-Packard Development Company, L.P.\n#\n\nuid=`id | sed 's/^[^=]*=\\([0-9]*\\).*/\\1/'`\n[ \"$uid\" = \"0\" ] || { \n  echo \"Only root may run this program.\"\n  exit 1\n}\n\nPATH=/opt/opsware/bin:$PATH\nexport PATH\n\nPYTHONPATH=/opt/opsware/pylibs27:/opt/opsware/patch_importer\nexport PYTHONPATH\n\n# Execute Ubuntu metadata importer\nexec python2.7 /opt/opsware/patch_importer/ubuntu_importer/ubuntu_importer_repo/import_ubuntu_metadata.pyc \"$@\"\n",
            "description": "'wrapper",
            "status": null,
            "name": "Import Ubuntu Metadata",
            "state": null,
            "eTag": "2015-06-13T04:57:01.000Z",
            "modified": "2015-06-13T04:57:01.000Z",
            "created": "2015-06-13T04:57:00.000Z",
            "category": "os-deployment-server-scripts",
            "uri": "/rest/os-deployment-server-scripts/1430001"
        },
        {
            "runAsSuperUser": true,
            "serverChanging": true,
            "codeType": "PS1",
            "displayCodeType": "Windows .PS1",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "1",
                    "createdBy": "opsware",
                    "createdDate": "2015-06-13T04:57:04.000Z",
                    "usage": "'Utility",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-06-13T04:57:05.000Z",
            "version": {
                "versionLabel": "1",
                "createdBy": "opsware",
                "createdDate": "2015-06-13T04:57:04.000Z",
                "usage": "'Utility",
                "current": true
            },
            "source": "# Function: Compile and install PowerCLI XmlSerializers\n# Purpose : Speed up the execution of the 1st PowerCLI cmdlet\n\n# Create an alias for ngen.exe\nSet-Alias ngen (Join-Path ([System.Runtime.InteropServices.RuntimeEnvironment]::GetRuntimeDirectory()) ngen.exe)\n   \n# Install all the PowerCLI XmlSerializers\nGet-ChildItem -Path $env:SystemRoot\\assembly\\GAC_MSIL\\VimService*.XmlSerializers | `\nForEach-Object {\n  if ($_) {\n    $Name = $_.Name\n    Get-ChildItem -Path $_\n  }\n} | `\nSelect-Object -Property @{N=\"Name\";E={$Name}},@{N=\"Version\";E={$_.Name.Split(\"_\")[0]}},@{N=\"PublicKeyToken\";E={$_.Name.Split(\"_\")[-1]}} | `\nForEach-Object {\n  if ($_) {\n    ngen install \"$($_.Name), Version=$($_.Version), Culture=neutral, PublicKeyToken=$($_.PublicKeyToken)\"\n  }\n}\n\nWrite-Host \"PowerCLI XmlSerializers native images installed\"\nWrite-Host \"Completed\"\n",
            "description": "'Utility",
            "status": null,
            "name": "install-powercli-xmlserializers.ps1",
            "state": null,
            "eTag": "2015-06-13T04:57:05.000Z",
            "modified": "2015-06-13T04:57:05.000Z",
            "created": "2015-06-13T04:57:04.000Z",
            "category": "os-deployment-server-scripts",
            "uri": "/rest/os-deployment-server-scripts/1440001"
        },
        {
            "runAsSuperUser": true,
            "serverChanging": true,
            "codeType": "PS1",
            "displayCodeType": "Windows .PS1",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "1",
                    "createdBy": "opsware",
                    "createdDate": "2015-06-13T04:57:05.000Z",
                    "usage": "'Utility",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-06-13T04:57:05.000Z",
            "version": {
                "versionLabel": "1",
                "createdBy": "opsware",
                "createdDate": "2015-06-13T04:57:05.000Z",
                "usage": "'Utility",
                "current": true
            },
            "source": "# Function: Uninstall PowerCLI XmlSerializers\n\n# Create an alias for ngen.exe\nSet-Alias ngen (Join-Path ([System.Runtime.InteropServices.RuntimeEnvironment]::GetRuntimeDirectory()) ngen.exe)\n   \n# Uninstall all the PowerCLI XmlSerializers\nGet-ChildItem -Path $env:SystemRoot\\assembly\\GAC_MSIL\\VimService*.XmlSerializers | `\nForEach-Object {\n  if ($_) {\n    $Name = $_.Name\n    Get-ChildItem -Path $_\n  }\n} | `\nSelect-Object -Property @{N=\"Name\";E={$Name}},@{N=\"Version\";E={$_.Name.Split(\"_\")[0]}},@{N=\"PublicKeyToken\";E={$_.Name.Split(\"_\")[-1]}} | `\nForEach-Object {\n  if ($_) {\n    ngen uninstall \"$($_.Name)\"\n  }\n}\n\nWrite-Host \"PowerCLI XmlSerializers native images uninstalled\"\nWrite-Host \"Completed\"",
            "description": "'Utility",
            "status": null,
            "name": "uninstall-powercli-xmlserializers.ps1",
            "state": null,
            "eTag": "2015-06-13T04:57:05.000Z",
            "modified": "2015-06-13T04:57:05.000Z",
            "created": "2015-06-13T04:57:05.000Z",
            "category": "os-deployment-server-scripts",
            "uri": "/rest/os-deployment-server-scripts/1450001"
        },
        {
            "runAsSuperUser": true,
            "serverChanging": true,
            "codeType": "SH",
            "displayCodeType": "Unix",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "7",
                    "createdBy": "opsware",
                    "createdDate": "2015-08-04T07:29:44.000Z",
                    "usage": "This manages configuration files for Proliant iLO.\nReads/Writes HP Manage iLO Configuration\n\nOptional Custom Attributes:\n- Capture parameters: -w ilooutput.xml\n- Deploy parameters: -f iloinput.xml",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-08-04T07:29:44.000Z",
            "version": {
                "versionLabel": "7",
                "createdBy": "opsware",
                "createdDate": "2015-08-04T07:29:44.000Z",
                "usage": "This manages configuration files for Proliant iLO.\nReads/Writes HP Manage iLO Configuration\n\nOptional Custom Attributes:\n- Capture parameters: -w ilooutput.xml\n- Deploy parameters: -f iloinput.xml",
                "current": true
            },
            "source": "#!/bin/sh\n\n# (C) Copyright 2013-2015 Hewlett-Packard Development Company, L.P.\n\n# ======================================================================\n# Reads/Writes HP Manage iLO Configuration\n#\n# Capture parameters: -w ilooutput.xml\n# Deploy parameters: -f iloinput.xml \n# ======================================================================\n\nUTIL=hponcfg\nDIR=\"/tmp/sstk\"\n\n# To check the arguments\n\nif [ $# -lt 2 ]; then\n  echo \"Missing Arguments\"\n  exit 1\nfi\nMODE=$1\nFILE=$2\nshift 2\n\nif [ -f $DIR/$UTIL ];then\n chmod +x $DIR/$UTIL\nelse\n echo \"Missing $DIR/$UTIL file\"\n exit 1\nfi\n\n#Run hponcfg\n\n\"$DIR/$UTIL\" \"$MODE\" \"$FILE\"\nrc=$?\n\ncase $rc in\n   0 )\n      echo \"$UTIL successful\";;\n   127 )\n      echo \"$UTIL failed ($rc): Missing library in automation\" 1>&2;;\n   134 )\n      echo \"$UTIL failed ($rc): Corrupted custom post message\" 1>&2 ;;\n   * )\n      echo \"$UTIL failed ($rc)\" 1>&2 ;;\nesac\nexit $rc\n",
            "description": "This manages configuration files for Proliant iLO.\nReads/Writes HP Manage iLO Configuration\n\nOptional Custom Attributes:\n- Capture parameters: -w ilooutput.xml\n- Deploy parameters: -f iloinput.xml",
            "status": null,
            "name": "Manage iLO Configuration",
            "state": null,
            "eTag": "2015-08-04T07:29:44.000Z",
            "modified": "2015-08-04T07:29:44.000Z",
            "created": "2015-08-04T07:29:44.000Z",
            "category": "os-deployment-server-scripts",
            "uri": "/rest/os-deployment-server-scripts/1470001"
        },
        {
            "runAsSuperUser": true,
            "serverChanging": true,
            "codeType": "SH",
            "displayCodeType": "Unix",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "10",
                    "createdBy": "opsware",
                    "createdDate": "2015-08-04T07:29:46.000Z",
                    "usage": "This script is intended to accompany the Insight Control server provisioning Capturing and Installing Linux System Images white paper. \n\nThis script repartitions the disk, creates logical volumes/groups and creates the filesystem to receive the new image.   While the sample script partitions the disk so it replicates the old partition table, it is possible to alter the new partition if required.  Any new changes will have to be reflected in the target server images /etc/fstab once the image has been deployed.\n",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-08-04T07:29:46.000Z",
            "version": {
                "versionLabel": "10",
                "createdBy": "opsware",
                "createdDate": "2015-08-04T07:29:46.000Z",
                "usage": "This script is intended to accompany the Insight Control server provisioning Capturing and Installing Linux System Images white paper. \n\nThis script repartitions the disk, creates logical volumes/groups and creates the filesystem to receive the new image.   While the sample script partitions the disk so it replicates the old partition table, it is possible to alter the new partition if required.  Any new changes will have to be reflected in the target server images /etc/fstab once the image has been deployed.\n",
                "current": true
            },
            "source": "#!/bin/bash\n\n## Assumes first disk /dev/sda to be used. Change if needed\ndisk=\"/dev/sda\"\n\n# Partition disk\necho \"Partitioning disk...\"\nsfdisk $disk -uM << EOF\n0,900,L,\n,2000,82\n,,L,*\nEOF\n \nwhile [ ! -e ${disk}3 ]; do sleep 1; done\n \n# Create filesystems and logical volumes\necho \"Create filesystems...\"\n \nmkfs.ext3 -j -L root ${disk}3\n\nsync\n",
            "description": "This script is intended to accompany the Insight Control server provisioning Capturing and Installing Linux System Images white paper. \n\nThis script repartitions the disk, creates logical volumes/groups and creates the filesystem to receive the new image.   While the sample script partitions the disk so it replicates the old partition table, it is possible to alter the new partition if required.  Any new changes will have to be reflected in the target server images /etc/fstab once the image has been deployed.\n",
            "status": null,
            "name": "Sample - Create New Filesystem SLES",
            "state": null,
            "eTag": "2015-08-04T07:29:46.000Z",
            "modified": "2015-08-04T07:29:46.000Z",
            "created": "2015-08-04T07:29:46.000Z",
            "category": "os-deployment-server-scripts",
            "uri": "/rest/os-deployment-server-scripts/1490001"
        },
        {
            "runAsSuperUser": true,
            "serverChanging": true,
            "codeType": "SH",
            "displayCodeType": "Unix",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "14",
                    "createdBy": "opsware",
                    "createdDate": "2015-08-04T07:29:48.000Z",
                    "usage": "This script is intended to accompany the Insight Control server provisioning Capturing and Installing Linux System Images white paper. \n\nThis script repartitions the disk, creates logical volumes/groups and creates the filesystem to receive the new image.   While the sample script partitions the disk so it replicates the old partition table, it is possible to alter the new partition if required.  Any new changes will have to be reflected in the target server images /etc/fstab once the image has been deployed.",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-08-04T07:29:48.000Z",
            "version": {
                "versionLabel": "14",
                "createdBy": "opsware",
                "createdDate": "2015-08-04T07:29:48.000Z",
                "usage": "This script is intended to accompany the Insight Control server provisioning Capturing and Installing Linux System Images white paper. \n\nThis script repartitions the disk, creates logical volumes/groups and creates the filesystem to receive the new image.   While the sample script partitions the disk so it replicates the old partition table, it is possible to alter the new partition if required.  Any new changes will have to be reflected in the target server images /etc/fstab once the image has been deployed.",
                "current": true
            },
            "source": "#!/bin/bash\n# (C) Copyright 2012-2015 Hewlett-Packard Development Company, L.P.\necho \"Partitioning disk...\"\nparted -s /dev/sda unit MiB\n \nif [ -d /sys/firmware/efi ]\nthen\n    #Partitioning for efi mode\n    parted -s /dev/sda mklabel gpt \n     \n    #Createing EFI partition\n    parted -s /dev/sda mkpart esi fat32 1 211\n    parted -s /dev/sda set 1 boot on\n     \n    #Creating boot partition\n    parted -s /dev/sda mkpart primary xfs 212 735\n     \n    #Creating LVM partition with rest of the Disk\n    parted -s /dev/sda -- mkpart primary xfs 736 -1\n    parted -s /dev/sda set 3 lvm on\nelse\n    #Partitioning for Legacy mode\n    parted -s /dev/sda mklabel msdos\n     \n    #Creating boot partition\n    parted -s /dev/sda mkpart primary 1 525\n    parted -s /dev/sda set 1 boot on\n     \n    #Creating LVM partition with rest of the Disk\n    parted -s /dev/sda -- mkpart primary xfs 526 -1\n    parted -s /dev/sda set 2 lvm on\nfi\n\n#Wait and make sure the boot partition is accessible\na=0\nwhile [ $a -lt 30 ]&&[ ! -e /dev/sda1 ]\ndo\n   sleep 1\n   a=`expr $a + 1`\ndone\n\n#Wait and make sure the LVM partition is accessible\na=0\nwhile [ $a -lt 30 ]&&[ ! -e /dev/sda3 ]\ndo\n   sleep 1\n   a=`expr $a + 1`\ndone\n\n\n# Create filesystems and logical volumes\necho \"Create logical group and volumes...\"\n \nif [ -d /sys/firmware/efi ]\nthen\n    #vFat is needed for GPT\n    mkfs.vfat -F 32 /dev/sda1\n    #Format Boot partition\n    mkfs.xfs -f -L boot /dev/sda2\n    pvcreate -ffy /dev/sda3\n    sleep 10\n    vgcreate rhel /dev/sda3\n\nelse\n    mkfs.xfs -f -L boot /dev/sda1\n    pvcreate -ffy /dev/sda2\n    sleep 10\n    vgcreate rhel /dev/sda2\nfi\n \nlvcreate --size 10G rhel --name root\n\n#Wait and make sure the root partition is accessible\na=0\nwhile [ $a -lt 30 ]&&[ ! -e /dev/rhel/root ]\ndo\n   sleep 1\n   a=`expr $a + 1`\ndone\n  \nlvcreate --size 10G rhel --name home\n\n#Wait and make sure the Home partition is accessible\na=0\nwhile [ $a -lt 30 ]&&[ ! -e /dev/rhel/home ]\ndo\n   sleep 1\n   a=`expr $a + 1`\ndone\n \nlvcreate --size 3G rhel --name swap\n\n#Wait and make sure the Swap partition is accessible\na=0\nwhile [ $a -lt 30 ]&&[ ! -e /dev/rhel/swap ]\ndo\n   sleep 1\n   a=`expr $a + 1`\ndone\n\n#Format the partition with File System\nmkfs.xfs -L root /dev/rhel/root\nmkfs.xfs -L home /dev/rhel/home\nmkswap -L swap /dev/rhel/swap",
            "description": "This script is intended to accompany the Insight Control server provisioning Capturing and Installing Linux System Images white paper. \n\nThis script repartitions the disk, creates logical volumes/groups and creates the filesystem to receive the new image.   While the sample script partitions the disk so it replicates the old partition table, it is possible to alter the new partition if required.  Any new changes will have to be reflected in the target server images /etc/fstab once the image has been deployed.",
            "status": null,
            "name": "Sample - Create New Filesystem RHEL",
            "state": null,
            "eTag": "2015-08-04T07:29:48.000Z",
            "modified": "2015-08-04T07:29:48.000Z",
            "created": "2015-08-04T07:29:48.000Z",
            "category": "os-deployment-server-scripts",
            "uri": "/rest/os-deployment-server-scripts/1510001"
        },
        {
            "runAsSuperUser": true,
            "serverChanging": true,
            "codeType": "BAT",
            "displayCodeType": "Windows .BAT",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "38",
                    "createdBy": "opsware",
                    "createdDate": "2015-08-04T07:29:48.000Z",
                    "usage": "Checks for the existence of the WIM image file.  This ensures that an existing WIM image is not accidentally overwritten if another capture build plan is run that uses the same WIM file name.  The script returns an error if the specified file name exists.  \n\nRequired Parameters:\nWIM_filename    The WIM file name and path to be checked if exists.\n\nCustom Attributes: None",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-08-04T07:29:48.000Z",
            "version": {
                "versionLabel": "38",
                "createdBy": "opsware",
                "createdDate": "2015-08-04T07:29:48.000Z",
                "usage": "Checks for the existence of the WIM image file.  This ensures that an existing WIM image is not accidentally overwritten if another capture build plan is run that uses the same WIM file name.  The script returns an error if the specified file name exists.  \n\nRequired Parameters:\nWIM_filename    The WIM file name and path to be checked if exists.\n\nCustom Attributes: None",
                "current": true
            },
            "source": "@echo off\n\n:: (C) Copyright 2013-2015 Hewlett-Packard Development Company, L.P.\n\nset filename=%1\n\nREM Make sure the file name was specified.\nif [%filename%]==[] (\n    echo The WIM File Name must be specified. 1>&2\n    exit /B 1\n)\n\nREM Get the directory component of the file name.\nfor %%F in (\"%filename%\") do set dirname=%%~dpF\n\nREM Make sure the directory exists.\nif not exist %dirname% (\n    echo The directory \"%dirname%\" does not exist. 1>&2\n    exit /B 1\n)\n\nREM Check if the file already exists.\nif exist \"%filename%\" (\n    echo The file %filename% already exists. 1>&2\n    echo Please remove or rename the existing file and re-run the Build Plan. 1>&2\n    exit /B 1\n)\n",
            "description": "Checks for the existence of the WIM image file.  This ensures that an existing WIM image is not accidentally overwritten if another capture build plan is run that uses the same WIM file name.  The script returns an error if the specified file name exists.  \n\nRequired Parameters:\nWIM_filename    The WIM file name and path to be checked if exists.\n\nCustom Attributes: None",
            "status": null,
            "name": "Prevent WIM File Overwrite",
            "state": null,
            "eTag": "2015-08-04T07:29:48.000Z",
            "modified": "2015-08-04T07:29:48.000Z",
            "created": "2015-08-04T07:29:48.000Z",
            "category": "os-deployment-server-scripts",
            "uri": "/rest/os-deployment-server-scripts/1520001"
        },
        {
            "runAsSuperUser": true,
            "serverChanging": true,
            "codeType": "SH",
            "displayCodeType": "Unix",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "3",
                    "createdBy": "opsware",
                    "createdDate": "2015-08-04T07:29:49.000Z",
                    "usage": "This script adds code to the ProLiant Driver DUD to enable SLES Multipath installations.  It must be preceeded with the ProLiant Driver package, and the contents of the driver package must be in /tmp/dud.",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-08-04T07:29:49.000Z",
            "version": {
                "versionLabel": "3",
                "createdBy": "opsware",
                "createdDate": "2015-08-04T07:29:49.000Z",
                "usage": "This script adds code to the ProLiant Driver DUD to enable SLES Multipath installations.  It must be preceeded with the ProLiant Driver package, and the contents of the driver package must be in /tmp/dud.",
                "current": true
            },
            "source": "# (C) Copyright 2012-2015 Hewlett-Packard Development Company, L.P.\n#\n# Create script to enable Multipath\n#\ncat << EOF > /tmp/S01start_multipath.sh\necho \"Probing multipath\"\n/sbin/modprobe dm-multipath\necho \"Calling /sbin/multipath\"\nsleep 2; /sbin/multipath; sleep 2; /sbin/udevadm settle\necho \"Executing /sbin/multipath -ll\"\n/sbin/multipath -ll >/tmp/multipath.log\nEOF\nchmod a+x /tmp/S01start_multipath.sh\n#\n# Add script to SLES DUD\n#\nmkdir -p /tmp/dud/linux/suse/x86_64-sles11/inst-sys\ncd /tmp/dud/linux/suse/x86_64-sles11/inst-sys\nmkdir -p usr/lib/YaST2/startup/hooks/preFirstCall\nmkdir -p usr/lib/YaST2/startup/hooks/preFirstStage-old\ncp /tmp/S01start_multipath.sh usr/lib/YaST2/startup/hooks/preFirstCall\ncp /tmp/S01start_multipath.sh usr/lib/YaST2/startup/hooks/preFirstStage-old\n",
            "description": "This script adds code to the ProLiant Driver DUD to enable SLES Multipath installations.  It must be preceeded with the ProLiant Driver package, and the contents of the driver package must be in /tmp/dud.",
            "status": null,
            "name": "Enable SLES Multipath Install",
            "state": null,
            "eTag": "2015-08-04T07:29:49.000Z",
            "modified": "2015-08-04T07:29:49.000Z",
            "created": "2015-08-04T07:29:49.000Z",
            "category": "os-deployment-server-scripts",
            "uri": "/rest/os-deployment-server-scripts/1530001"
        },
        {
            "runAsSuperUser": true,
            "serverChanging": true,
            "codeType": "SH",
            "displayCodeType": "Unix",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "11",
                    "createdBy": "opsware",
                    "createdDate": "2015-08-04T07:29:50.000Z",
                    "usage": "This script is intended to accompany the Insight Control server provisioning Capturing and Installing Linux System Images white paper. \n\nThis script adjusts for any new hardware or partition changes after the image has been deployed to the target server.  The sample script provided takes care of writing a new MBR on the disk and fixing the network adapters.\n",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-08-04T07:29:50.000Z",
            "version": {
                "versionLabel": "11",
                "createdBy": "opsware",
                "createdDate": "2015-08-04T07:29:50.000Z",
                "usage": "This script is intended to accompany the Insight Control server provisioning Capturing and Installing Linux System Images white paper. \n\nThis script adjusts for any new hardware or partition changes after the image has been deployed to the target server.  The sample script provided takes care of writing a new MBR on the disk and fixing the network adapters.\n",
                "current": true
            },
            "source": "#!/bin/bash\n# (C) Copyright 2012-2015 Hewlett-Packard Development Company, L.P. \nmount --bind /dev/ /mnt/target/dev/\n \n \n# write new MBR or GTP\nif [ -d /sys/firmware/efi ]; then\n\tchroot /mnt/target /bin/bash <<EOF\necho \"GRUB_DISABLE_LINUX_UUID=true\" >> /etc/default/grub\necho 'GRUB_USE_LINUXEFI=\"true\"' >> /etc/default/grub\n/sbin/grub2-install --target=x86_64-efi --efi-directory=/boot/efi\n/sbin/grub2-mkconfig -o /boot/efi/EFI/redhat/grub.cfg\nsed -i 's/linux16/linuxefi/g' /boot/efi/EFI/redhat/grub.cfg\nsed -i 's/initrd16/initrdefi/g' /boot/efi/EFI/redhat/grub.cfg\nEOF\n\nelse\n\tchroot /mnt/target /bin/bash <<EOF\necho \"GRUB_DISABLE_LINUX_UUID=true\" >> /etc/default/grub\n/sbin/grub2-install --skip-fs-probe --root-directory=/ /dev/sda\n/sbin/grub2-mkconfig -o /boot/grub2/grub.cfg\nEOF\nfi\n\n  \n# clean up installation.\n# Message /etc/fstab mount points if needed\n  \n##Change network configuration/setup - Remove physical anchor\n\nvar1= ls /mnt/target/etc/sysconfig/network-scripts/ifcfg-*|grep -v ifcfg-lo\nfor entry in $var1\ndo\n        rm -f $entry\ndone\n\npath=\"/mnt/target/etc/sysconfig/network-scripts/ifcfg-\"\n\nfor entry in /mnt/target/sys/class/net/*\ndo\n        name=$(basename \"$entry\")\n        if [ $name != \"lo\" ]; then\n            echo 'DEVICE=\"'$name'\"' > $path$name\n            echo 'ONBOOT=yes\nNETBOOT=yes\nIPV6INIT=no\nBOOTPROTO=dhcp\nTYPE=Ethernet\nDEFROUTE=yes\nIPV4_FAILURE_FATAL=no\nPEERDNS=yes\nPEERROUTES=yes' >> $path$name\n        fi\ndone\n\n#sed -i -e '/^HWADDR/d' -e '/^UUID/d' /mnt/target/etc/sysconfig/network-scripts/ifcfg-eth0\nrm -f /mnt/target/etc/udev/rules.d/70-persistent-net.rules\n\nexit 0",
            "description": "This script is intended to accompany the Insight Control server provisioning Capturing and Installing Linux System Images white paper. \n\nThis script adjusts for any new hardware or partition changes after the image has been deployed to the target server.  The sample script provided takes care of writing a new MBR on the disk and fixing the network adapters.\n",
            "status": null,
            "name": "Sample - Fixup RHEL Deployment",
            "state": null,
            "eTag": "2015-08-04T07:29:50.000Z",
            "modified": "2015-08-04T07:29:50.000Z",
            "created": "2015-08-04T07:29:50.000Z",
            "category": "os-deployment-server-scripts",
            "uri": "/rest/os-deployment-server-scripts/1540001"
        },
        {
            "runAsSuperUser": true,
            "serverChanging": true,
            "codeType": "PY2",
            "displayCodeType": "Python",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "69",
                    "createdBy": "opsware",
                    "createdDate": "2015-08-04T07:29:51.000Z",
                    "usage": "Unmaps the network drive that is associated with the specified drive letter.  If there is no network drive associated with the specified drive letter, this script still completes successfully.\n\nRequired Parameters:\n--driveLetter     The letter that's associated with the network drive to be unmapped.\n\nCustom Attributes:  None",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-08-04T07:29:51.000Z",
            "version": {
                "versionLabel": "69",
                "createdBy": "opsware",
                "createdDate": "2015-08-04T07:29:51.000Z",
                "usage": "Unmaps the network drive that is associated with the specified drive letter.  If there is no network drive associated with the specified drive letter, this script still completes successfully.\n\nRequired Parameters:\n--driveLetter     The letter that's associated with the network drive to be unmapped.\n\nCustom Attributes:  None",
                "current": true
            },
            "source": "#!/usr/bin/python\n\n# (C) Copyright 2013-2015 Hewlett-Packard Development Company, L.P.\n\nimport subprocess\nfrom subprocess import Popen, PIPE, STDOUT\n\nimport sys\n\nfrom optparse import OptionParser\nfrom osprov.osbp import logger\nfrom osprov.errors import ShowErrorMessage\n\nLOG = logger.getIt('unmap_network_drive')\n\n############################################################################################\n# Our parser.\n############################################################################################\n\nclass CustomParser(OptionParser):\n        \"\"\" a custom parser \"\"\"\n        def __init__(self, *args, **kwargs):\n                OptionParser.__init__(self, *args, **kwargs)\n                self.add_option(\"--driveLetter\",\n                                default=None,\n                                help=\"The drive letter of the network drive to be unmapped\")\n\n############################################################################################\n# Unmaps the network drive that's associated with the specified drive letter.\n#\n# Parameters:\n#    driveLetter - The drive letter to be unmapped.\n############################################################################################\n\ndef unmapNetworkDrive(driveLetter):\n\n\tcmd = \"net use \" + driveLetter + \":\" + \" /delete\"\n\n\tp = subprocess.Popen (cmd, stdout=subprocess.PIPE, stderr=STDOUT)\n\n\tnet_stdout = p.communicate()[0]\n\n\tretCode = p.poll()\n\n\tp.stdout.close()\n\n\tif (retCode != 0):\n\t\traise ShowErrorMessage(\"The command '%s' failed : %s\" % (cmd,net_stdout))\n\n############################################################################################\n# Returns true if the specified drive letter is assigned to a network drive; false otherwise.\n#\n# Parameters:\n#    driveLetter - The drive letter to be tested.\n############################################################################################\n\ndef isNetworkDrive(driveLetter):\n\n\tcmd = \"net use \" + driveLetter + \":\"\n\n\tp = subprocess.Popen (cmd, stdout=subprocess.PIPE, stderr=STDOUT)\n\n\tp.communicate()[0]\n\n\tretCode = p.poll()\n\n\tp.stdout.close()\n\n\tif (retCode == 0):\n\t\treturn True\n\telse:\n\t\treturn False\n\n############################################################################################\n# The main function.\n############################################################################################\n\ndef main(argv):\n\n\targs_parser = CustomParser()\n\toptions, remaining_args = args_parser.parse_args(sys.argv[1:])\n\n\tif (options.driveLetter is None):\n\t\targs_parser.error(\"The '--driveLetter=<drive letter>' option is required.\")\n\n\ttry:\n\t\tif (isNetworkDrive(options.driveLetter)):\n\t\t\tunmapNetworkDrive(options.driveLetter)\n\t\t\tprint \"Successfully unmapped network drive '%s'\" % options.driveLetter\n\t\telse:\n\t\t\tprint \"There are no network drives mapped to '%s'\" % options.driveLetter\n\texcept (ShowErrorMessage), why:\n\t\tLOG.exception(why)\n\t\tsys.stderr.write(\"Failed to unmap network drive : %s\\n\" % why)\n\t\treturn 1\n\nif __name__ == \"__main__\":\n\tsys.exit(main(sys.argv))",
            "description": "Unmaps the network drive that is associated with the specified drive letter.  If there is no network drive associated with the specified drive letter, this script still completes successfully.\n\nRequired Parameters:\n--driveLetter     The letter that's associated with the network drive to be unmapped.\n\nCustom Attributes:  None",
            "status": null,
            "name": "Unmap Network Drive",
            "state": null,
            "eTag": "2015-08-04T07:29:51.000Z",
            "modified": "2015-08-04T07:29:51.000Z",
            "created": "2015-08-04T07:29:50.000Z",
            "category": "os-deployment-server-scripts",
            "uri": "/rest/os-deployment-server-scripts/1550001"
        },
        {
            "runAsSuperUser": true,
            "serverChanging": false,
            "codeType": "PY2",
            "displayCodeType": "Python",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "14",
                    "createdBy": "opsware",
                    "createdDate": "2015-08-04T07:29:54.000Z",
                    "usage": "Checks that the server is booted into the correct WinPE version.\n\nOption:\n   --version=n  where n is 3.1, 4.0, a list of versions (\"3.1,4.0\"), or any.  The version of the booted WinPE is checked against the parameter specified.  If no option is specified, then the option defaults to 3.1\n\nRequirements:\nServer must be booted into WinPE",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-08-04T07:29:54.000Z",
            "version": {
                "versionLabel": "14",
                "createdBy": "opsware",
                "createdDate": "2015-08-04T07:29:54.000Z",
                "usage": "Checks that the server is booted into the correct WinPE version.\n\nOption:\n   --version=n  where n is 3.1, 4.0, a list of versions (\"3.1,4.0\"), or any.  The version of the booted WinPE is checked against the parameter specified.  If no option is specified, then the option defaults to 3.1\n\nRequirements:\nServer must be booted into WinPE",
                "current": true
            },
            "source": "#!/usr/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n#\n\"\"\"\n(C) Copyright 2014-2015 Hewlett-Packard Development Company, L.P.\n\"\"\"\n\nimport os\nimport sys\nfrom optparse import OptionParser\n\nEC_SUCCESS = 0\nEC_FAILED = 1\nWINPE30 = \"6.1.7600.16385\"\nWINPE31 = \"6.1.7601.17514\"\nWINPE40 = \"6.2.9200.16384\"\nWINPEMAP = {'3.1': WINPE31, '4.0': WINPE40, '3.0': WINPE30, 'any' : 'any' }\nDIRMAP = { WINPE31: '3.1', WINPE40: '4.0', WINPE30: '3.0', 'any': 'any' }\n\ndef parseArgs(args):\n    parser = OptionParser()\n    parser.add_option(\"--version\", dest=\"winpeVersion\", type=\"string\", default=\"3.1\",\n                        help=\"Check for specified WinPE version (default value is '3.1').\")\n  \n    options, args = parser.parse_args(args)\n    # Create list of options and remove any spaces\n    options.winpeVersion = map(str.strip, options.winpeVersion.split(\",\"))\n\n    if args:\n        parser.error(\"Additional positional arguments are not supported\")\n    return options, args\n\n# Validate the supplied options\ndef validateOptions(opts):\n    for o in opts.winpeVersion:\n        if not o in WINPEMAP.keys():\n           print \"--winpeVersion must be list of %s\" % WINPEMAP.keys()\n           exit(EC_FAILED)\n\ndef main():\n    opts, remArgs = parseArgs(sys.argv[1:])\n    validateOptions(opts) \n\n    # if any value is acceptable, just return success\n    if \"any\" in opts.winpeVersion:\n        return EC_SUCCESS\n\n    # Look up the WinPE version.  There should only be one file\n    # in this directory, but check just in case.\n    for dir in os.listdir(\"x:\\\\Windows\\\\Servicing\\\\Version\"):\n        if not dir.startswith(\"6\"):\n            continue\n        foundWinpe = dir\n        break\n\n    # Make sure we know about the version of WinPE found\n    if not foundWinpe in DIRMAP.keys():\n        print \"WinPE version is for OS version %s is unknown.\" % foundWinpe\n        return EC_FAILED\n\n    # Validate that the found WinPE version is acceptable.\n    if DIRMAP[foundWinpe] in opts.winpeVersion:\n        print \"Found WinPE %s.\" % DIRMAP[foundWinpe]\n        return EC_SUCCESS\n\n    # If we're here, then we don't have a matching WinPE, so\n    # we need to fail.\n    print (\"ERROR - This build plan requires that it be run in WinPE %s,\\n\" \\\n    \"but is currently running in WinPE %s. The build plan cannot continue\\n\" \\\n    \"and will now exit.\\n\"% (opts.winpeVersion,DIRMAP[foundWinpe]))\n    print (\"See the Insight Control server provisioning Installation Guide chapter\\n\" \\\n    \"'Generating and uploading WinPE to the appliance' for information on booting to different WINPE \\n\" \\\n    \"versions and how the versions relate to the OS version and server settings.\\n\\n\" \\\n    \"If you believe this build plan should work with %s version of WinPE,\\n\" \\\n    \"you can modify the parameters passed to this step to include %s WinPE version.\" % (DIRMAP[foundWinpe],DIRMAP[foundWinpe]))\n    return EC_FAILED\n\nif __name__ == \"__main__\":\n    sys.exit(main())",
            "description": "Checks that the server is booted into the correct WinPE version.\n\nOption:\n   --version=n  where n is 3.1, 4.0, a list of versions (\"3.1,4.0\"), or any.  The version of the booted WinPE is checked against the parameter specified.  If no option is specified, then the option defaults to 3.1\n\nRequirements:\nServer must be booted into WinPE",
            "status": null,
            "name": "Validate WinPE Version",
            "state": null,
            "eTag": "2015-08-04T07:29:54.000Z",
            "modified": "2015-08-04T07:29:54.000Z",
            "created": "2015-08-04T07:29:54.000Z",
            "category": "os-deployment-server-scripts",
            "uri": "/rest/os-deployment-server-scripts/1570001"
        },
        {
            "runAsSuperUser": true,
            "serverChanging": true,
            "codeType": "BAT",
            "displayCodeType": "Windows .BAT",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "26",
                    "createdBy": "opsware",
                    "createdDate": "2015-08-04T07:29:54.000Z",
                    "usage": "Installs the Windows Multipath IO Feature using ServerManagerCmd or PowerShell on a Windows production OS.  A reboot is required after this script is run.\n\nParameters:  None\n\nCustom Attributes: None",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-08-04T07:29:54.000Z",
            "version": {
                "versionLabel": "26",
                "createdBy": "opsware",
                "createdDate": "2015-08-04T07:29:54.000Z",
                "usage": "Installs the Windows Multipath IO Feature using ServerManagerCmd or PowerShell on a Windows production OS.  A reboot is required after this script is run.\n\nParameters:  None\n\nCustom Attributes: None",
                "current": true
            },
            "source": "@echo off\n\n:: (C) Copyright 2013-2015 Hewlett-Packard Development Company, L.P.\n\nset wdir=%windir%\nset FEATURE=Multipath-IO\nset RESULTFILE=\"%wdir%\\MPIOInstallResult.xml\"\n\n:: Try PowerShell if exists\nfor %%X in (powershell.exe) do (set FOUND1=%%~$PATH:X)\nif defined FOUND1 (\n   echo Import-module servermanager > \"%wdir%\\FeatureInstall.ps1\"\n   echo add-windowsfeature -Name %FEATURE% -logPath %RESULTFILE% >> \"%wdir%\\FeatureInstall.ps1\"\n   powershell.exe -ExecutionPolicy Unrestricted -NoLogo -NonInteractive -NoProfile -WindowStyle Hidden -File \"%wdir%\\FeatureInstall.ps1\"\n   set rc=%errorlevel%\n   goto EndWithFailureMessage\n)\n\n:: Try ServerManagerCmd if exists and PowerShell wasn't found\nfor %%X in (ServerManagerCmd.exe) do (set FOUND2=%%~$PATH:X)\nif defined FOUND2 (\n   ServerManagerCmd.exe -install %FEATURE% -resultPath %RESULTFILE% >> %temp%\\status.log\n   set rc=%errorlevel%\n   goto EndWithFailureMessage\n) \n\nif NOT defined rc (\n   echo PowerShell and ServerManagerCmd were not found and could not set %FEATURE%\n   set rc=99\n   goto End\n)\n\n:EndWithFailureMessage\nif NOT %rc%==0 (\n   echo PowerShell and ServerManagerCmd Add Windows Feature failed to install %FEATURE%:  error code %rc%\n   echo Refer to %RESULTFILE% log file.\n)\n\n:End\nexit /B %rc%",
            "description": "Installs the Windows Multipath IO Feature using ServerManagerCmd or PowerShell on a Windows production OS.  A reboot is required after this script is run.\n\nParameters:  None\n\nCustom Attributes: None",
            "status": null,
            "name": "Add Windows Multipath IO Feature",
            "state": null,
            "eTag": "2015-08-04T07:29:54.000Z",
            "modified": "2015-08-04T07:29:54.000Z",
            "created": "2015-08-04T07:29:54.000Z",
            "category": "os-deployment-server-scripts",
            "uri": "/rest/os-deployment-server-scripts/1580001"
        },
        {
            "runAsSuperUser": true,
            "serverChanging": true,
            "codeType": "SH",
            "displayCodeType": "Unix",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "9",
                    "createdBy": "opsware",
                    "createdDate": "2015-08-04T07:29:55.000Z",
                    "usage": "This script erases the partition table on all detected disk drives.\n\n** THIS CAUSES DATA LOSS **\n\nPrerequisites:\n- Target server runs a Linux OS.\n\nThis script is intended to be used only as a Build Plan step.",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-08-04T07:29:55.000Z",
            "version": {
                "versionLabel": "9",
                "createdBy": "opsware",
                "createdDate": "2015-08-04T07:29:55.000Z",
                "usage": "This script erases the partition table on all detected disk drives.\n\n** THIS CAUSES DATA LOSS **\n\nPrerequisites:\n- Target server runs a Linux OS.\n\nThis script is intended to be used only as a Build Plan step.",
                "current": true
            },
            "source": "#!/opt/opsware/agent/bin/python\n\n# (C) Copyright 2013-2015 Hewlett-Packard Development Company, L.P.\n\n# This script runs dd on all the devices on the server where it's run to\n# erase the partition table\n\nimport re\nimport commands\nimport subprocess\nfrom osprov.diskmgr.diskmanager import DiskManager\nfrom osprov.errors import ProcessExecutionError\nfrom osprov.osbp import logger\n\nLOG = logger.getIt(\"osprov.diskmgr\")\n\n\ndef scan():\n    '''\n    Get the list of (partitioned) hard drives on this server.\n    Uses 'parted -lm', which requires superuser permission.\n    '''\n    disks = []\n    args = [\"parted\", \"--list\", \"--machine\"]\n    # /dev/sda:36.4GB:scsi:512:512:msdos:HP LOGICAL VOLUME;\n    regex = re.compile(r\"^(/dev/[hs]d\\w+):.*:.*:\\d+:\\d+:.*:(.*)\\b|:;$\")\n    proc = subprocess.Popen(args, stdout=subprocess.PIPE)\n    for line in proc.stdout:\n        match = regex.match(line)\n        if match:\n            dev = match.group(1)\n            name = match.group(2)\n            if \"HP iLO LUN\" in name:\n                # print \"exclude %s [%s]\" % (dev, name)\n                continue    # skip Gaius flash media\n            # print \"include %s [%s]\" % (dev, name)\n            disks.append(dev)\n    return disks\n\n\ndef eraseDisk():\n    '''\n    Get the list of hard drives on this server and run dd on it\n    to zero out the first 1M bytes.\n    '''\n    hdList = scan()\n\n    for deviceName in hdList:\n        # For each device name returned, run dd on it\n\n        cmdStr = \"dd if=/dev/zero of=\" + deviceName + \" bs=8k count=128\"\n        # print \"Performing dd: Cmd String used: %s\" % cmdStr\n\n        status, output = commands.getstatusoutput(cmdStr)\n        if status != 0:\n            raise Exception(\"dd failed with exitcode %d: Msg:%s\" % (status, output))\n        print \"Successfully erased disk \" + deviceName\n\nif __name__ == \"__main__\":\n    dm = DiskManager(log=LOG)\n    dm.disable_automount()\n    dm.unmountOurs()\n    dm.unmountDisks(skipUsb=True)\n\n    inventory_disks = dm.get_disk_inventory()\n    disks = []\n\n    hdList = scan()\n\n    # filtering out Gaius flash media from disk inventory\n    for temp_disk in inventory_disks:\n        if temp_disk.getDeviceFilePath() in hdList:\n            disks.append(temp_disk)\n\n    for temp_disk in disks:\n        temp_disk.releaseAndUnload()\n\n    eraseDisk()\n\n    # refreshing kernel partition table\n    for temp_disk in disks:\n        try:\n            temp_disk.rescan()\n        except ProcessExecutionError, why:\n            print \"Warning : Rereading partition table for %s failed : %s. Reboot to refresh partition table.\" % (temp_disk.getDeviceFilePath(), why)\n",
            "description": "This script erases the partition table on all detected disk drives.\n\n** THIS CAUSES DATA LOSS **\n\nPrerequisites:\n- Target server runs a Linux OS.\n\nThis script is intended to be used only as a Build Plan step.",
            "status": null,
            "name": "Erase Server Disk",
            "state": null,
            "eTag": "2015-08-04T07:29:55.000Z",
            "modified": "2015-08-04T07:29:55.000Z",
            "created": "2015-08-04T07:29:55.000Z",
            "category": "os-deployment-server-scripts",
            "uri": "/rest/os-deployment-server-scripts/1590001"
        },
        {
            "runAsSuperUser": true,
            "serverChanging": true,
            "codeType": "BAT",
            "displayCodeType": "Windows .BAT",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "29",
                    "createdBy": "opsware",
                    "createdDate": "2015-08-04T07:29:58.000Z",
                    "usage": "Adds a target server running a Windows production OS to a Domain.  A reboot is required after this script is run.\nRequirements:  DNS needs to be configured on the target server\nParameters:  None\nRequired Custom Attributes:\n         DomainFQDN\n         DomainName\n         DomainUser\n         DomainPassword (plain text)\n         EncryptedDomainPassword (encrypted)\n         Key\n",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-08-04T07:29:58.000Z",
            "version": {
                "versionLabel": "29",
                "createdBy": "opsware",
                "createdDate": "2015-08-04T07:29:58.000Z",
                "usage": "Adds a target server running a Windows production OS to a Domain.  A reboot is required after this script is run.\nRequirements:  DNS needs to be configured on the target server\nParameters:  None\nRequired Custom Attributes:\n         DomainFQDN\n         DomainName\n         DomainUser\n         DomainPassword (plain text)\n         EncryptedDomainPassword (encrypted)\n         Key\n",
                "current": true
            },
            "source": "set DOMAIN=@DomainName@\nset DNSDOMAIN=@DomainFQDN@\nset DOMAINUSERROOT=@DomainUser@\nset DOMAINPASS=@DomainPassword@\nset KEY=@Key@\nset ENCYPTPASSWORD=@EncryptedDomainPassword@\n;@Findstr -bv ;@F \"%~f0\" |powershell.exe -ExecutionPolicy Unrestricted -NoLogo -NonInteractive -NoProfile -Command - & ;exit $LastExitCode\n\n#######################################################\n## (C) Copyright 2012-2015 Hewlett-Packard Development Company, L.P.\n## Check custom attributes\n## exit the script if any custom attribute is missing \n##############################################################\nFunction checkCA\n{\n    if (!$domain)\n    {\n        write-host \"Please provide a value for custom attribute 'DomainName' to proceed\"\n        Exit 3\n    }\n    elseif (!$dnsdomain)\n    {\n        write-host \"Please provide a value for custom attribute 'DomainFQDN' to proceed\"\n        Exit 3\n    }\n    elseif (!$domainuserroot)\n    {\n        write-host \"Please provide a value for custom attribute 'DomainUser' to proceed\"\n        Exit 3\n    }\n        \n}\n\n\n################################################################################\n#        Check DNS\n# check if DNS is configure. If DNS IP not found exit the script\n##################################################################################\nFunction checkDNS\n{\n    $colItems = Get-WmiObject Win32_NetworkAdapterConfiguration -Namespace \"root\\CIMV2\" | where{$_.IPEnabled -eq \"True\"}\n    if(!$colItems.DNSServerSearchOrder)\n    {\n        write-host \"ERROR: The target server is not configured with any DNS servers. This is required for adding to a domain.\"\n        Exit 5\n    }\n    \n}\n\n######################################################################################\n#        getCredobj\n#######################################################################################\nFunction getCredobj\n{\n    if ($key -and $encryptpassword)\n    {\n        $keyarr=$key.tocharArray()\n        $securepass = ConvertTo-SecureString -String $encryptpassword -key $keyarr\n        if ($?)\n        {\n        write-host \"Created secure string successfully from encrypted string\"\n        }\n        else\n        {\n        write-host \"ERROR:Creating secure sting from encrypted string failed.\"\n        Exit 2\n        }\n    }\n    elseif ($domainpass)\n    {\n        #No Key/Encrypted password specified using domain password as plain text\n        #\n        $securepass = ConvertTo-SecureString  $domainpass -AsPlainText -force\n        if ($?)\n        {\n        write-host \"Created secure string successfully\"\n        }\n        else\n        {\n        write-host \"ERROR: Creating secure string from plain text failed.\"\n        Exit 2\n        }\n    }\n    else\n    {\n        write-host \"Error: \"Please provide value for custom attribute Key/EncryptedDomainPassword or DomainPassword to proceed.\n        Exit 2\n    }\n    $cred = New-Object System.Management.Automation.PSCredential($domainUser,$securePass)\n    if ($?)\n    {\n        write-host \"created DomainCred obj.\"\n        return $cred\n    }\n    else\n    {\n        write-host \"Fail to create DomainCred obj.\"\n        Exit 2\n    }\n}\n\n######################################################################################\n#        Add-Computer\n#######################################################################################\nFunction addComp\n{\n\nAdd-Computer -DomainName $dnsdomain -Credential $domaincred \nif ($?)\n    {\n    write-host \"System moved to $DNSDomain Successfully\"\n    }\nelse\n    {\n    write-host \"ERROR: Script failed to moved system under $DNSDomain. Please check more error details at %windir%\\debug\\NetSetup.txt on target\"\n    Exit 1\n    }\n    \n}\n\n\n#################################\n##    Main\n############################\n\n$domain=$env:DOMAIN\nwrite-host \"Your Domain: $domain\"\n   \n$dnsdomain = $env:DNSDOMAIN\nwrite-host \"Your DNS: $dnsdomain\"\n\n$domainuserroot = $env:DOMAINUSERROOT\nwrite-host \"User: $domainuserroot\"\n\n$key=$env:KEY\n$domainpass = $env:DOMAINPASS\n$encryptpassword=$env:ENCYPTPASSWORD\n#Checking for customattribute\ncheckCA\ncheckDNS\n$domainuser = $domain+'\\'+$domainuserroot \nwrite-host \"$domainuser\"\n\n#get Credential object\n$domaincred=getCredobj\n#Call Add-Computer\naddComp",
            "description": "Adds a target server running a Windows production OS to a Domain.  A reboot is required after this script is run.\nRequirements:  DNS needs to be configured on the target server\nParameters:  None\nRequired Custom Attributes:\n         DomainFQDN\n         DomainName\n         DomainUser\n         DomainPassword (plain text)\n         EncryptedDomainPassword (encrypted)\n         Key\n",
            "status": null,
            "name": "Add Windows Server to Domain",
            "state": null,
            "eTag": "2015-08-04T07:29:58.000Z",
            "modified": "2015-08-04T07:29:58.000Z",
            "created": "2015-08-04T07:29:57.000Z",
            "category": "os-deployment-server-scripts",
            "uri": "/rest/os-deployment-server-scripts/1600001"
        },
        {
            "runAsSuperUser": false,
            "serverChanging": true,
            "codeType": "PY2",
            "displayCodeType": "Python",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "71",
                    "createdBy": "opsware",
                    "createdDate": "2015-08-04T07:30:00.000Z",
                    "usage": "Validates the media server settings from target server running Windows or Linux OS\n\nTo fully test your media server, run this step on one Windows and one Linux target.",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-08-04T07:30:00.000Z",
            "version": {
                "versionLabel": "71",
                "createdBy": "opsware",
                "createdDate": "2015-08-04T07:30:00.000Z",
                "usage": "Validates the media server settings from target server running Windows or Linux OS\n\nTo fully test your media server, run this step on one Windows and one Linux target.",
                "current": true
            },
            "source": "#!/usr/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Do not change the two lines above. See PEP 8, PEP 263.\n#\n \n \n\"\"\"\n(C) Copyright 2014-2015 Hewlett-Packard Development Company, L.P.\n\"\"\"\n \n  \nimport sys\nimport socket,tempfile\nimport re,os,platform\nfrom urllib2 import *\nimport urllib2\nimport subprocess\n  \nsys.path.append(\"/opt/opsware/pylibs\")\nfrom osprov.osbp import logger\n  \nLOG = logger.getIt(\"Validate_Media_server\")\n  \n#Test ping to given host\ndef pingHost(hostname):\n    response = subprocess.call(\"ping -w 4 \" + hostname, shell=True, stdout=subprocess.PIPE)\n    return response == 0\n      \ndef mountSMB(address, targetLocation):\n    subprocess.call(\"mkdir -p \"+targetLocation, shell=True,  stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n    response = subprocess.call(address+\" \"+targetLocation, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n    return response\n          \n#Display directories in given directory\ndef displayDir(dirPath):\n    if not os.path.exists(dirPath):\n        print \"\\tINFO - \"+dirPath+\" does not exist\"\n    else:\n        for dirName in os.listdir(dirPath):\n            if os.path.isdir(os.path.join(dirPath, dirName)) and dirName not in [\"ip\", \"spp\", \"\"]:\n                print \"\\t\",dirName\n                if not os.listdir(os.path.join(dirPath, dirName)):\n                    print \"\\t\\tINFO - The \\'\", dirName, \"\\' folder is empty\\n\"\n  \n#Check the given URI accessibility \ndef uriCheck(address):\n    return urlopen(address).code\n \n#Check write Access \ndef hasWriteAccess(filename): \n    try: \n        fd, fn = tempfile.mkstemp(dir=os.path.dirname(filename))\n        os.close(fd) \n        os.remove(fn) \n    except Exception as e:\n        return False \n    else: \n        return True\n \n#Check read Access\ndef hasReadAccess(filename):\n    try:\n        fo = open(filename,'r')\n        fo.close()\n    except:\n        return False\n    else:\n        return True\n \n#Main function\ndef main(argv):\n    if platform.system()not in [\"Linux\", \"Windows\"]:\n        print \"Validating media server on: \", platform.system(),\"\\n\"\n        print \"\\tERROR: Unsupported operating system\"\n        print \"\\tAction: Run on Windows or Linux OS\\n\"\n        sys.exit(1)\n\n    print \"Validating media server on: \", platform.system(),\"\\n\"\n    #Get Media server details\n    mediaServerPath = \"@__OPSW-Media-WinUser@@__OPSW-Media-WinPath@\"[6:]\n    mediaUser = [\"@__OPSW-Media-WinUser@\"[6:-1]]\n    mediaServerPwd = [\"@__OPSW-Media-WinPassword@\"]\n    mediaServerPath = [\"@__OPSW-Media-WinPath@\"[1:]]\n    tempDtls = mediaServerPath[0].split(\"/\")\n    mediaServerDls = mediaUser+mediaServerPwd+tempDtls\n    msIP = mediaServerDls[2]\n    isIP = False\n \n    print \"\\nCheck Media Server connection:\"\n    try:\n         socket.inet_aton(msIP)\n         isIP = True\n    except socket.error:\n        try:\n            ip = socket.gethostbyname(msIP)\n            socket.inet_aton(msIP)\n            isIP = False\n        except socket.error:\n            print \"\\tERROR - Given IP address or Hostname: \",mediaServerDls[2],\" is not correct:\\n\"\n            sys.exit(1)\n \n    #resolve media server hostname\n    if isIP:\n        try:\n            hostName = socket.gethostbyaddr(msIP)[0]\n        except socket.error:\n            print \"\\tWARNING - Failed to get media server hostname for \", mediaServerDls[2],\"\\n\"\n    else:\n        hostName = mediaServerDls[2]\n    #\n    if not isIP:\n        try:\n            msIP = socket.gethostbyname(hostName)\n            print \"\\t\", hostName, \"translates to \", msIP,\"\\n\"\n        except BaseException:\n            print \"\\tERROR - \", hostName,\"does not translate into an IP address.\"\n            print \"\"\"\\tCheck the spelling of the hostname\\n\\tVerify that a DNS server is specified in your DHCP configuration options.\\n\"\"\"\n  \n    #Ping media server IP\n    if pingHost(msIP):\n        print \"\\tping \", msIP, \" - successful\\n\"\n    else:\n        print \"\\tWARNING - Ping \", msIP, \" - Failed\"\n        print \"\"\"\\tVerify the name and IP address of your media server are correct.\\n\\tA failure is expected, if a firewall is configured on your media server.\\n\"\"\"\n  \n    #Access media server via HTTP\n    isURLOpened = False\n    print \"Starting connectivity test for HTTP\\n\"\n    httpURI = \"@__OPSW-Media-LinURI@\"\n    print \"Accessing: \", httpURI, \"\\n\"\n    response = 0\n    try:\n        response = uriCheck(httpURI)\n    except urllib2.URLError as e:\n        print \"\\tERROR - Unable to access the media server HTTP URL: %s\\n\" % (httpURI)\n        print \"\\tHTTP URL error: {0}\".format(str(e.reason))\n        print \"\"\"\\tVerify that your web server is running and properly configured.\\n\\tTry browsing to the URL listed above from a desktop web browser.\\n\"\"\"\n    except urllib2.HTTPError as e:\n        print \"\\tERROR - Unable to access the media server HTTP URL: %s\\n\" % (httpURI)\n        print \"\\tHTTP URL error({0}): {1}\".format(str(e.code), str(e.reason))\n        print \"\"\"\\tVerify that your web server is running and properly configured.\\n\\tTry browsing to the URL listed above from a desktop web browser.\\n\"\"\"\n    except Exception as e:\n        print \"\\tERROR - Unable to access the media server HTTP URL: %s\\n\" % (httpURI)\n        print \"\\tHTTP URL error: {0}\".format(\"HTTP Exception occurred \")\n        print \"\"\"\\tVerify that your web server is running and properly configured.\\n\\tTry browsing to the URL listed above from a desktop web browser.\\n\"\"\"\n \n    if response == 200:\n        isURLOpened = True\n        print \"HTTP connectivity test succeeded\\n\"\n  \n    #Mount the media server\n    mountflg = 0\n    isMounted = False\n    smbPath = \"//\"+ \"@__OPSW-Media-WinPath@\"[1:]\n    if platform.system()==\"Linux\":\n        mountPath = \"/mnt/MSmount/\"\n        mntCMD = \"mount -t cifs --verbose -o username=\"+mediaServerDls[0]+\",password=\"+mediaServerDls[1]+\",sec=ntlmv2 \"+smbPath\n        disMntCMD = \"mount -t cifs --verbose -o username=\"+mediaServerDls[0]+\",password=\"+\"********,sec=ntlmv2 \"+smbPath\n        mntSecOptions = [\"ntlm\",\"ntlmi\",\"ntlmv2i\", \"ntlmssp\", \"ntlmsspi\"]\n        print \"Mount media server via CIFS\\n\"\n        print \"Starting file share mount test\\n\"\n        try:\n            print \"Attempting mount using default security options\\n\"\n            print \"Command Used to mount:\\n\\t\", disMntCMD+\" \"+mountPath\n            resp = mountSMB(mntCMD, mountPath)\n            if resp == 0:\n                isMounted = True\n                print \"Accessing media server via CIFS - Mount successful\\n\"\n                print \"File share mount succeeded\\n\"\n            else:\n                print \"Mount Failed - trying alternate options\\n\"\n                for secopt in mntSecOptions:\n                    print \"Trying to mount with sec=\"+secopt+\" option\"\n                    mntCMD = \"mount -t cifs --verbose -o username=\"+mediaServerDls[0]+\",password=\"+mediaServerDls[1]+\",sec=\"+secopt+\" \"+smbPath\n                    disMntCMD = \"mount -t cifs --verbose -o username=\"+mediaServerDls[0]+\",password=\"+\"********\"+\",sec=\"+secopt+\" \"+smbPath\n                    print \"Command Used to mount:\\n\\t\", disMntCMD+\" \"+mountPath\n                    resp = mountSMB(mntCMD, mountPath)\n                    mountflg += 1\n                    if resp == 0:\n                        isMounted = True\n                        print \"succeeded\\n\"\n                        break\n                    else:\n                        print \"Did not succeed\\n\"\n            if not isMounted:\n                sys.exit(1)\n        except BaseException as ex:\n            print \"\\tERROR - ERROR: Accessing media server via CIFS - Mount failed\\n\\tVerify that the following are correct\"\n            print \"\\tShare name - \",smbPath\n            print \"\\tUser name - \",mediaServerDls[0]\n            print \"\\tPlease verify your credentials and other media server settings.\"\n            print \"\\tTry manually mounting the share using the commands and settings information above.\"\n            print \"\\tSee the Insight Control server provisioning Installation Guide for information on configuring your media server.\\n\"\n            sys.exit(1)\n    elif platform.system()==\"Windows\":\n        winShrPath = smbPath.replace(\"/\", \"\\\\\" )\n        try:\n            disMntCMD = \"net use Z: \"+winShrPath+\" /user:\"+mediaServerDls[0]+\" ********\"\n            print \"Command Used to mount:\\n\\t\", disMntCMD,\"\\n\"\n            res = subprocess.call(\"net use Z: \"+winShrPath+\" /user:\"+mediaServerDls[0]+\" \"+mediaServerDls[1],stdout=subprocess.PIPE, stderr=subprocess.PIPE)            \n            if res == 0:\n                print \"Accessing media server via CIFS - Mount successful\\n\"\n                print \"File share mount succeeded\\n\"\n            else:\n                sys.exit(1)\n        except BaseException as ex:\n            print \"\\tERROR - ERROR: Accessing media server via CIFS - Mount failed\\n\\tVerify that the following are correct\"\n            print \"\\tShare name - \",winShrPath\n            print \"\\tUser name - \",mediaServerDls[0]\n            print \"\\tPlease verify your credentials and other media server settings.\"\n            print \"\\tTry manually mounting the share using the commands and settings information above.\"\n            print \"\\tSee the Insight Control server provisioning Installation Guide for information on configuring your media server.\\n\"\n            sys.exit(1)\n    print \"\\n\"\n    if platform.system()==\"Linux\":\n        mediaPath = mountPath\n    elif platform.system()==\"Windows\":\n        mediaPath = \"Z:\\\\\"\n \n    #Check read and write access of mounted path\n    if hasReadAccess(mediaPath+\"hpfeatures.csv\"):\n        print \"Test file read access - Successful\\n\"\n    else:\n        #unmount the media server\n        if platform.system()==\"Linux\":\n            subprocess.call(\"umount \"+mountPath, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n        elif platform.system()==\"Windows\":\n            subprocess.call(\"net use Z: /delete /yes\", stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n        print \"Test file read access - Failed\\n\"\n        print \"\"\"\\tError : Unable to read to the media server\\n\\tMake sure your media server is configured properly and that read access is enabled for all content on the media server.\n\\tAction Required: Check and Update the permissions on your media server for User - '%s' \"\"\" % mediaServerDls[0]\n        sys.exit(1)\n    if hasWriteAccess(mediaPath+\"media\"):\n        print \"Test file write access - Successful\\n\"\n    else:\n        print \"Test file write access - Failed\\n\"\n        print \"\"\"\\tINFO: Unable to write to the media server.  Write access may have been disabled by your administrator. Write access will need to be enabled if you want to perform any image capture operations or run jobs that save logs to the media server.\n\"\"\"\n \n    mediaPath = mediaPath+\"media\"\n    #Display OS media \n    print \"The following OS Media directories were found in the media directory:\\n\"\n    displayDir(mediaPath)\n  \n    #Display SPP media\n    print \"\\n The following SPP Media directories were found in the media directory:\\n\"\n    displayDir(mediaPath+\"/spp\")\n      \n    #display IP media\n    print \"\\n The following IP Media directories were found in the media directory: \\n\"\n    #1.50\n    displayDir(mediaPath+\"/ip\")\n \n    #unmount the media server\n    if platform.system()==\"Linux\":\n        subprocess.call(\"umount \"+mountPath, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n    elif platform.system()==\"Windows\":\n        subprocess.call(\"net use Z: /delete /yes\", stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n \n    if not isURLOpened:\n        sys.exit(1)\n \n    if mountflg >0:\n        print \"*** IMPORTANT ACTION REQUIRED ***\"\n        print \"\\tMounting the file server requires that the \\\"sec=\"+secopt+\"\\\" be added to the Set Media Source\\n\\tstep in some of your build plans. See the \\\"Changing media server security options\\\" on the \\n\\ton-line help for more information.\"\n        sys.exit(1)\n \n    print \"\"\"Media Server settings have been successfully validated. No fatal errors were found.\nPlease review the job log for any warnings or informational messages that may affect your build plans.\\n\n\"\"\"\n    print \"END OF THE MEDIA SERVER VALIDATION\\n\" \nif __name__ == \"__main__\":\n    sys.exit(main(sys.argv))",
            "description": "Validates the media server settings from target server running Windows or Linux OS\n\nTo fully test your media server, run this step on one Windows and one Linux target.",
            "status": null,
            "name": "Validate Media Server",
            "state": null,
            "eTag": "2015-08-04T07:30:00.000Z",
            "modified": "2015-08-04T07:30:00.000Z",
            "created": "2015-08-04T07:30:00.000Z",
            "category": "os-deployment-server-scripts",
            "uri": "/rest/os-deployment-server-scripts/1630001"
        },
        {
            "runAsSuperUser": true,
            "serverChanging": true,
            "codeType": "SH",
            "displayCodeType": "Unix",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "12",
                    "createdBy": "opsware",
                    "createdDate": "2015-08-04T07:30:02.000Z",
                    "usage": "This script is intended to accompany the Insight Control server provisioning Capturing and Installing Linux System Images white paper. \n\nThis script deploys the previously captured Linux image.\n\nRequired Parameters: Image name\n",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-08-04T07:30:02.000Z",
            "version": {
                "versionLabel": "12",
                "createdBy": "opsware",
                "createdDate": "2015-08-04T07:30:02.000Z",
                "usage": "This script is intended to accompany the Insight Control server provisioning Capturing and Installing Linux System Images white paper. \n\nThis script deploys the previously captured Linux image.\n\nRequired Parameters: Image name\n",
                "current": true
            },
            "source": "#!/bin/bash\n#tar jxf /mnt/images/$1.tar.bz2 -C /mnt/target\ntar zxf /mnt/images/$1.tar.bz2 -C /mnt/target",
            "description": "This script is intended to accompany the Insight Control server provisioning Capturing and Installing Linux System Images white paper. \n\nThis script deploys the previously captured Linux image.\n\nRequired Parameters: Image name\n",
            "status": null,
            "name": "Sample - Deploy Linux Image",
            "state": null,
            "eTag": "2015-08-04T07:30:02.000Z",
            "modified": "2015-08-04T07:30:02.000Z",
            "created": "2015-08-04T07:30:02.000Z",
            "category": "os-deployment-server-scripts",
            "uri": "/rest/os-deployment-server-scripts/1650001"
        },
        {
            "runAsSuperUser": true,
            "serverChanging": true,
            "codeType": "SH",
            "displayCodeType": "Unix",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "37",
                    "createdBy": "opsware",
                    "createdDate": "2015-08-04T07:30:02.000Z",
                    "usage": "Updates the target server firmware using the HP SUM utility and specified SPP version.\n\nOptional Parameters:\n--spp_version=directory_name    The name of the directory containing the SPP to be installed, such as \"2014.02.0\".  If the value is blank or \"latest\", the script automatically selects the directory with the latest version as determined by sort order.\n\n--hpsum_options=\"option1 option2 ... optionN\"    HP SUM supported command-line options that are to be passed to HP SUM.  All the options must be enclosed within double quotes.  Refer to HP SUM's CLIhelp.txt documentation file for available options.\n\n--hpsum_logs_dump_dir=writable_directory_under_mounted_file_share    Copies the zipped HP SUM log files to the specified directory.  The directory must start with the mount point specified in the \"Set Media Source\" Build Plan Step.  For example, if the file share where the zipped HP SUM log file is to be copied to is mounted on \"/mnt/media\" and the destination directory is \"hpsum_logs\", then specify \"--hpsum_logs_dump_dir=/mnt/media/hpsum_logs\".\n\n--no_show_log   Don't display the \"hpsum_log.txt\" contents in the job log.\n\nRequirements:\n* Media Server mounted with Set Media Source script.\n* The directories containing the SPPs must reside on the Media Server under the \"\\Media\\spp\" directory.\n\nCustom Attributes: None",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-08-04T07:30:02.000Z",
            "version": {
                "versionLabel": "37",
                "createdBy": "opsware",
                "createdDate": "2015-08-04T07:30:02.000Z",
                "usage": "Updates the target server firmware using the HP SUM utility and specified SPP version.\n\nOptional Parameters:\n--spp_version=directory_name    The name of the directory containing the SPP to be installed, such as \"2014.02.0\".  If the value is blank or \"latest\", the script automatically selects the directory with the latest version as determined by sort order.\n\n--hpsum_options=\"option1 option2 ... optionN\"    HP SUM supported command-line options that are to be passed to HP SUM.  All the options must be enclosed within double quotes.  Refer to HP SUM's CLIhelp.txt documentation file for available options.\n\n--hpsum_logs_dump_dir=writable_directory_under_mounted_file_share    Copies the zipped HP SUM log files to the specified directory.  The directory must start with the mount point specified in the \"Set Media Source\" Build Plan Step.  For example, if the file share where the zipped HP SUM log file is to be copied to is mounted on \"/mnt/media\" and the destination directory is \"hpsum_logs\", then specify \"--hpsum_logs_dump_dir=/mnt/media/hpsum_logs\".\n\n--no_show_log   Don't display the \"hpsum_log.txt\" contents in the job log.\n\nRequirements:\n* Media Server mounted with Set Media Source script.\n* The directories containing the SPPs must reside on the Media Server under the \"\\Media\\spp\" directory.\n\nCustom Attributes: None",
                "current": true
            },
            "source": "#!/bin/sh\n# (C) Copyright 2013-2015 Hewlett-Packard Development Company, L.P.\n\n# The \"zip\" command is only available in the PXE Linux service OS from the \n# \"/opt/opsware/agent/bin\" directory, so we must add it to the path.\n# We also need \"tr\" which is located in \"/opt/opsware/agent/osprov/bin/x86\".\nPATH=${PATH}:/opt/opsware/agent/bin:/opt/opsware/agent/osprov/bin/x86\n\n# The default HP SUM log directory.  This may be overridden with the \"/logdir\" or\n# \"-logdir\" option.\nhpSumLogDir=\"/var\"\n\n# A directory that we use as a workaround for the fact that, on the PXE\n# Linux Service OS, the \"/tmp\" filesystem is small and fills up when\n# hpsum copies files to \"/tmp/hp_sum\".\nhpSumStageDir=/hp_sum\n\n# The mount point where the file share is mounted.\n# if /mnt/media not exist fall back to /mnt/ms mount point\nmountPoint=/mnt/media\nif [ ! -d \"$mountPoint\" ]\nthen\n\tmountPoint=/mnt/ms\nfi\n\n# Any additional options to HP SUM, which may be specified as a parameter\n# to this script.\nhpSumOptions=\n\n# The SPP version we want to install, which may be specified as a parameter\n# to this script.\nsppVersion=\n\n# The directory on the file share where the SPPs are stored.\nsppDir=\"$mountPoint/Media/spp\"\n\n# The relative path to the file that contains the SPP version.\nrelativePathToSppVersionFile=\"hp/swpackages/_fwdvdver.xml\"\n\n# The subdirectory on the file share where we can dump the zipped HP SUM logs.\nhpSumLogsDumpDir=\"\"\n\n# Sets the HDU_BOOTENV_SMPJTB=yes environment variable which tells HP SUM to\n# copy the files from the file share to the local system.  This is preferred\n# in order to avoid a situation where a NIC firmware update might cause the\n# mounted share connection to drop.  This can be changed using the\n# \"--hpsum_copy_files_locally\" parameter.  One reason that we may not want\n# HP SUM to copy the files locally is if there isn't enough space on the\n# target server to copy the files.\nhpSumCopyFilesLocally=\"true\"\n\n# The zip file containing the HP SUM logs.\nhpSumLogsZipFile=/tmp/hpsum_logs.zip\n\n# Show the \"Installed Components:\" section of \"hpsum_log.txt\" by default\n# unless it's disabled by the \"--no_show_log\" option.\nshowHpSumLog=1\n\n##############################################################################\n# This function returns the version of the SPP, as contained in the\n# \"hp/swpackages/_fwdvdver.xml\" file.\n##############################################################################\n\ngetSppVersion() {\n    local sppVersionPath=$1\n    set `cat ${sppVersionPath} | sed -n -e 's@.*<version>\\([0-9a-zA-Z\\.-]*\\)</version>.*@\\1@p'`\n    ver=$1\n    echo ${ver}\n}\n\n##############################################################################\n# This function returns the server ID for the target server.  Since the PXE\n# Linux Service OS does not contain the \"tr\" command, we have to remove the\n# trailing \"\\r\\n\" from the server ID contained in \"/etc/opt/opsware/agent/mid\"\n# ourselves.\n##############################################################################\n\ngetServerId()\n{\n    # Read the server ID, which will contain a trailing CR and LF.\n    local idWithCrAndLf=$(cat /etc/opt/opsware/agent/mid)\n\n    local serverId=\"\"\n\n    # Get the length.\n    len=${#idWithCrAndLf}\n\n    # Iterate through each character and build up the server ID\n    # until we reach a non-digit (e.g. CR or LF).\n    for (( i = 0; i <= ${len}; i++ ))\n    do\n        char=\"${idWithCrAndLf:${i}:1}\"\n\n        if [[ ${char} = [[:digit:]] ]]\n        then\n            serverId=\"${serverId}${char}\"\n        else\n            break;\n        fi\n    done\n\n    echo -n \"${serverId}\"\n}\n\n##############################################################################\n# This function returns the absolute path to the HP SUM detail log.\n##############################################################################\n\ngetHpSumDetailLog()\n{\n    local logFile=${hpSumLogDir}/hp/log/localhost/hpsum_detail_log.txt\n   \n    echo \"${logFile}\" \n}\n\n##############################################################################\n# This function returns the absolute path to the HP SUM log file.\n##############################################################################\n\ngetHpSumLog()\n{\n    local logFile=${hpSumLogDir}/hp/log/localhost/hpsum_log.txt\n     \n      echo \"${logFile}\"\n}\n\n##############################################################################\n# This function returns the absolute path to the HP SUM trace file.\n##############################################################################\n\ngetHpSumTraceFile()\n{\n    local logFile=/tmp/hp_sum/OpMan.trace\n\n    if [ -e \"${logFile}\" ]\n    then\n        echo \"${logFile}\"\n    fi\n}\n\n##############################################################################\n# This function returns all the log files under the \"/tmp/HPSUM\" directory\n# that was first introduced in HP SUM 6.0.  The \"/tmp/HPSUM\" directory\n# replaces the \"/tmp/hp_sum\" directory from earlier versions of HP SUM.\n##############################################################################\n\ngetOtherHpSumLogs() {\n    local logFiles=\n\n    if [ -e /tmp/HPSUM ] && [ -d /tmp/HPSUM ]\n    then\n        for logFile in `find /tmp/HPSUM -name \"*\\.log\"`\n        do\n            logFiles=\"${logFiles} ${logFile}\"\n        done\n    fi\n\n    echo $logFiles\n}\n\n##############################################################################\n# This function returns the absolute path to the HP SUM log files.\n##############################################################################\n\ngetHpSumLogs()\n{\n    local hpSumDetailLog=$(getHpSumDetailLog)\n    local hpSumLog=$(getHpSumLog)\n    local hpSumTrace=$(getHpSumTraceFile)\n    local otherHpSumLogs=$(getOtherHpSumLogs)\n    local hpSumLogs=\"${hpSumDetailLog} ${hpSumLog} ${hpSumTrace} ${otherHpSumLogs}\"\n\n    echo \"${hpSumLogs}\"\n}\n\n##############################################################################\n# This function scans the user-specified HP SUM command line options for the\n# \"/logdir\" or \"-logdir\" option, which changes the directory in which HP SUM\n# places its log files.  If the option was specified, then our script makes a\n# note of it, so that we can grab the HP SUM log files from the correct \n# location when the firmware update is complete.\n##############################################################################\n\ncheckForOverrideOfHpSumLogDir()\n{\n    local hpSumOptions=\"$1\"\n\n    # This will contain \"/logdir\" or \"-logdir\" if either form was specified\n    # in the HP SUM options.  It is only used to display a message to stdout.\n    optName=\"\"\n\n    # We'll start off assuming that the \"/logdir\" or \"-logdir\" option was not\n    # specified in the HP SUM options.\n    containsLogDir=0\n\n    # Iterate through the user-specified HP SUM options and check if the\n    # \"/logdir\" or \"-logdir\" option was specified.\n    for arg in ${hpSumOptions}\n    do\n        if [ ${containsLogDir} -eq 1 ]\n        then\n            hpSumLogDir=${arg}\n\n            # Don't break out of for-loop.  Keep going in case \"-logdir\" or\n            # \"/logdir\" was specified more than once, for whatever reason.\n            # The last one specified takes precedence over the previous ones.\n            containsLogDir=0\n\n            echo \"HP SUM log directory overridden by option '${optName} ${hpSumLogDir}'\"\n        elif [ \"${arg}\" == \"/logdir\" ] || [ \"${arg}\" == \"-logdir\" ]\n        then\n            optName=${arg}\n            containsLogDir=1\n        fi\n    done\n}\n\n##############################################################################\n# Verifies that files needed by HP SUM and its Smart Components are present\n# on th Service OS.  Intelligent Provisioning typically has all the\n# dependencies, but the SA Linux Service OS doesn't.  For the SA Linux Service\n# OS, the dependencies are adding via our Zip Packages.\n##############################################################################\n\nverifyFirmwareDependencies()\n{\n    if [ ! -e \"/etc/redhat-release\" ] && [ ! -e \"/etc/SuSE-release\" ]\n    then\n        echo \"'/etc/redhat-release'  and '/etc/SuSE-release' not found.  These files are needed by the Emulex and QLogic Smart Components.\" 1>&2\n        return 1\n    fi\n\n    if [ ! -e \"/etc/issue\" ]\n    then\n        echo \"'/etc/issue' not found.  This file is needed by the Emulex and QLogic Smart Components.\" 1>&2\n        return 1\n    fi\n\n    # The \"libsysfs.so.2\" library is needed by the Emulex Smart Component.\n    # The SA Linux Service OS has this library under \"/usr/lib64\", while the\n    # Intelligent Provisioning Service OS has it under \"/lib64\".\n    if [ ! -e \"/usr/lib64/libsysfs.so.2\" ] && [ ! -e \"/lib64/libsysfs.so.2\" ]\n    then\n        echo \"'/usr/lib64/libsysfs.so.2' not found.  This file is needed by the Emulex Smart Component.\" 1>&2\n        return 1\n    fi\n\n    # The \"/etc/hba.conf\" file, and the QLogic library it points to, is needed by the\n    # QLogic Smart Component.\n    if [ -e \"/etc/hba.conf\" ]\n    then\n        lineNum=0\n\n        while read line\n        do\n            lineNum=$(($lineNum+1))\n\n            #Skip if Comment line. & empty line.\n            if [ ! -z '$( echo \"$line\" | grep '^#' )' -o ! -z '$( echo \"$line\" | grep '^$' )' ]\n            then\n                continue\n            fi\n\n            libPath=$(echo $line | awk -F' ' '{print $2}')\n\n            if [ -z \"${libPath}\" ]\n            then\n                echo \"library path missing in line ${lineNum} of file '/etc/hba.conf'\" 1>&2\n                return 1\n            elif [ ! -e \"${libPath}\" ]\n            then\n                echo \"'/etc/hba.conf' references '${libPath}', which does not exist\" 1>&2\n                return 1\n            fi\n        done < /etc/hba.conf\n    else\n        echo \"'/etc/hba.conf' not found.  This file is needed by the QLogic Smart Component.\" 1>&2\n        return 1\n    fi\n\n    if [ ! -e \"/bin/rpm\" ]\n    then\n        echo \"'/bin/rpm' not found.  This file is needed by HP SUM.\" 1>&2\n        return 1\n    fi\n\n    if [ ! -e \"/sbin/lspci\" ]\n    then\n        echo \"'/sbin/lspci' not found.  This file is needed by the Emulex and QLogic Smart Components.\" 1>&2\n        return 1   \n    fi\n\n    if [ ! -e \"/sbin/lsmod\" ]\n    then\n        if [ ! -e \"/bin/lsmod\" ]\n        then\n            echo \"'/sbin/lsmod' or '/bin/lsmod' not found.  This file is needed by the Emulex and QLogic Smart Components.\" 1>&2\n            return 1\n        else\n            ln -s /bin/lsmod /sbin/lsmod\n        fi   \n    fi\n\n    if [ ! -e \"/usr/bin/whoami\" ]\n    then\n        echo \"'/usr/bin/whoami' not found.  This file is needed by the Emulex Smart Component.\" 1>&2\n        return 1   \n    fi\n\n    if [ ! -e \"/usr/bin/dirname\" ]\n    then\n        echo \"'/usr/bin/dirname' not found.  This file is needed by the Emulex Smart Component.\" 1>&2\n        return 1   \n    fi\n\n    if [ ! -e \"/usr/bin/ldd\" ]\n    then\n        echo \"'/usr/bin/ldd' not found.  This file is needed by the Emulex Smart Component.\" 1>&2\n        return 1   \n    fi\n\n    if [ ! -e \"/bin/usleep\" ]\n    then\n        echo \"'/bin/usleep' not found.  This file is needed by the Emulex Smart Component.\" 1>&2\n        return 1   \n    fi\n\n    if [ ! -e \"/sbin/busybox\" ]\n    then\n        if [ ! -e \"/bin/busybox\" ]\n        then\n            echo \"'/sbin/busybox' or '/bin/busybox' not found.  This file is needed by the Emulex Smart Component.\" 1>&2\n            return 1\n        else\n            ln -s /bin/busybox /sbin/busybox\n        fi\n    fi\n\n    if [ ! -e \"/sbin/ldconfig\" ]\n    then\n        echo \"'/sbin/ldconfig' not found.  This file is needed by the Emulex Smart Component.\" 1>&2\n        return 1   \n    fi\n\n    return 0\n}\n\n##############################################################################\n# Kill the python process that's running anaconda, because it seems to\n# interfere with the Emulex firmware update and causes it to fail.  If we're\n# in Intelligent Provisioning, then there will not be an anaconda process, as\n# it will only exist in the SA Linux Service OS.\n##############################################################################\n\nkillAnaconda()\n{\n    retCode=0\n\n    for pid in $(pidof python)\n    do\n        grep anaconda /proc/${pid}/cmdline > /dev/null\n\n        if [ $? -eq 0 ]\n        then\n            echo \"Killing anaconda (pid=${pid})\"\n            kill ${pid}\n\n            if [ $? -ne 0 ]\n            then\n                echo \"Failed to kill anaconda process (pid=${pid})\" 1>&2\n                retCode=1\n            fi\n\n            break\n        fi\n    done\n\n    return ${retCode}\n}\n\n##############################################################################\n# This function determines which version of the SPP to install.  Unless a\n# specific SPP version is specifed, the latest SPP, as determined by the\n# sort order, is used.\n##############################################################################\n\nfindSPPVersion ()\n{\n    if [ \"$sppVersion\" == \"\" ] || [ \"$sppVersion\" == \"latest\" ]\n    then\n        sppVersion=$(find \"${sppDir}\" -mindepth 1 -maxdepth 1 -type d -printf %f\\\\n | sort | tail -1)\n\n        if [ \"$sppVersion\" == \"\" ]\n        then\n            echo \"No SPP directories were found under '${sppDir}'\" 1>&2\n            echo \"Check your media server and verify that there is at least one directory under the '/Media/spp' directory which contains the SPP files\" 1>&2\n            echo \"SPP directories are typically named using the SPP version, for example '2012.08'\" 1>&2\n            return 1\n        fi\n        if [ ! -d \"${sppDir}/${sppVersion}\" ]\n        then\n            echo \"${sppDir}/${sppVersion} is not a directory\" 1>&2\n            return 1\n        fi\n    fi\n\n    return 0\n}\n\n##############################################################################\n# This function runs the \"hpsum\" executable contained in the SPP that's\n# mounted from the media share.\n##############################################################################\n\nrunHPSUM ()\n{\n    local retCode=0\n\n    echo \"SPP version to be installed is $sppVersion\"\n\n    sppVersionDir=\"${sppDir}/$sppVersion\"\n\n    # Check if the directory containing the SPP exists.\n    if [ ! -d \"${sppVersionDir}\" ]\n    then\n        echo \"'${sppVersionDir}' does not exist\" 1>&2\n        return 1\n    fi\n\n    sppVersionFile=\"${sppVersionDir}/${relativePathToSppVersionFile}\"\n\n    if [ -e ${sppVersionFile} ]\n    then\n        sppVersionContainedInFile=$(getSppVersion ${sppVersionFile})\n\n        if [ ! -z ${sppVersionContainedInFile} ]\n        then\n            echo \"SPP version as reported in '${relativePathToSppVersionFile}' is '${sppVersionContainedInFile}'\"\n        else\n            echo \"Could not find the SPP version in '${relativePathToSppVersionFile}'\" 1>&2\n        fi\n    else\n        echo \"'${sppVersionFile}' not found\" 1>&2\n    fi\n\n    # Check if any HP SUM options were specified.\n    if [[ ! ${hpSumOptions} =~ [^[:space:]] ]] ; then\n        echo \"No additional HP SUM arguments were specified\"\n    else\n        echo \"Additional HP SUM arguments => ${hpSumOptions}\"\n    fi\n\n    # HP SUM copies some files to \"/tmp/hp_sum\".  On the PXE Linux Service OS,\n    # the \"/tmp\" filesystem is small and cannot accomdate the HP SUM files.\n    # As a workaround, we create an \"hp_sum\" directory under the root file\n    # system and create a symlink from \"/tmp/hp_sump\" to \"/hp_sum\".\n    if [ ! -d ${hpSumStageDir} ]\n    then\n        echo \"Creating directory '${hpSumStageDir}'\"\n        mkdir ${hpSumStageDir}\n\n        if [ $? -ne 0 ]\n        then\n            echo \"Failed to create the directory '${hpSumStageDir}'\" 1>&2\n            return 1\n        fi\n    fi\n\n    echo \"Creating a symlink from '/tmp/hp_sum' to '${hpSumStageDir}'\"\n\n    # Create a symlink from \"/tmp/hp_sum\" to \"/hp_sum\" to workaround the small \"/tmp\"\n    # filesystem size in the PXE Linux Service OS.\n    ln -f -s ${hpSumStageDir} /tmp/hp_sum\n\n    if [ $? -ne 0 ]\n    then\n        echo \"Failed to create symbolic link from /tmp/hp_sum to ${hpSumStageDir}\" 1>&2\n        return 1\n    fi\n\n    # HP SUM expects the \"rpm\" binary to be under \"/bin\", but on the SA Linux Service OS\n    # the \"rpm\" binary is under \"/usr/bin\".  Therefore, we'll create a symlink from\n    # \"/bin/rpm\" to \"/usr/bin/rpm\" to prevent \"hpsum\" from failing.\n    if [ ! -e /bin/rpm ]\n    then\n        if [ -e /usr/bin/rpm ]\n        then\n            echo \"Creating a symlink from '/bin/rpm' to '/usr/bin/rpm'\"\n\n            ln -f -s /usr/bin/rpm /bin/rpm\n\n            if [ $? -ne 0 ]\n            then\n                echo \"Failed to create symbolic link from '/bin/rpm' to '/usr/bin/rpm'\" 1>&2\n                return 1\n            fi\n        fi\n    fi\n\n    # The packages directory is where the \"hpsum\" executable and the firmware\n    # files reside.  Let's make sure that it exists.\n    packagesDir=\"${sppVersionDir}/hp/swpackages\"\n\n    if [ ! -e \"${packagesDir}\" ]\n    then\n        echo \"'${packagesDir}' does not exist\"\n        return 1\n    fi\n\n    # Must be run as currently running directory\n    cd ${packagesDir}\n\n    if [ $? -ne 0 ]\n    then\n        echo \"Could not change directory to '${packagesDir}'\" 1>&2\n        return 1\n    fi\n\n    # To get HPSUM to run in offline mode, we need to set the environment variable\n    # HDU_BOOTENV_SMPJTB=yes.  This will cause HPSUM to copy the files to the temp\n    # location (/tmp/hp_sum today and /var/hp/hpsum in the future) and then execute\n    # the components from there.  The reason for doing this is to avoid a situation\n    # where the NIC over which the file share is mounted goes unresponsive while\n    # its firmware is being updated, potentially dropping the connection to the\n    # file share.\n    if [ \"${hpSumCopyFilesLocally}\" == \"true\" ]\n    then\n        echo \"Setting environment variable HDU_BOOTENV_SMPJTB=yes\"\n        export HDU_BOOTENV_SMPJTB=yes\n    fi\n\n    hp_sum_cmd=\"./hpsum /romonly /silent $hpSumOptions\"\n\n    echo \"Executing => ${hp_sum_cmd}\"\n\n    # Run HP SUM.\n    ${hp_sum_cmd}\n\n    hpSumRetCode=$?\n\n    # +--------------------------------------------------------------+\n    # |       Return code        | Value | Linux |       Text        |\n    # |--------------------------+-------+-------+-------------------|\n    # | SUCCESS_NO_REBOOT        | 0     | 0     | The installation  |\n    # |                          |       |       | was successful.   |\n    # |--------------------------+-------+-------+-------------------|\n    # |                          |       |       | The installation  |\n    # | SUCCESS_REBOOT           | 1     | 1     | was successful,   |\n    # |                          |       |       | but a reboot is   |\n    # |                          |       |       | required.         |\n    # |--------------------------+-------+-------+-------------------|\n    # |                          |       |       | The component was |\n    # | SUCCESS_NOT_REQUIRED     | 3     | 3     | current or not    |\n    # |                          |       |       | required.         |\n    # |--------------------------+-------+-------+-------------------|\n    # |                          |       |       | A general failure |\n    # | FAILURE_GENERAL          | -1    | 255   | occurred. For     |\n    # |                          |       |       | details, see the  |\n    # |                          |       |       | error log.        |\n    # |--------------------------+-------+-------+-------------------|\n    # |                          |       |       | A bad input       |\n    # | FAILURE_BAD_PARM         | -2    | 254   | parameter was     |\n    # |                          |       |       | encountered.      |\n    # |--------------------------+-------+-------+-------------------|\n    # |                          |       |       | The installation  |\n    # | FAILURE_COMPONENT_FAILED | -3    | 253   | of the component  |\n    # |                          |       |       | failed.           |\n    # +--------------------------------------------------------------+\n\n    if [ ${hpSumRetCode} -gt 3 ] || [ ${hpSumRetCode} -lt 0 ]; then\n        echo \"hpsum failed with return code ${hpSumRetCode}\"\n        retCode=${hpSumRetCode}\n    else\n        echo \"hpsum successfully completed with return code ${hpSumRetCode}\"\n        retCode=0\n    fi\n\n    echo \"hpsum logs are located at /var/hp/log unless specified otherwise by hpsum -logdir option\"\n\n    return ${retCode}\n}\n\n##############################################################################\n# Main Routine\n##############################################################################\n\necho \"Parameters to script => ${*}\"\n\n# Parse the command line arguments.\nlastOpt=\n\nfor arg in $*\ndo\n    optName=`echo $arg | awk -F'=' '{print $1;}'`\n    optValue=${arg:$((${#optName}+1))}\n\n    if [ \"${optName}\" == \"--spp_version\" ]; then\n\n        if [[ ! \"${optValue}\" =~ [^[:space:]] ]]\n        then\n            echo \"Missing argument to '--spp_version'\" 1>&2\n            exit 1\n        fi\n\n        sppVersion=${optValue}\n\n        lastOpt=\n    elif [ \"${arg:0:2}\" != \"--\" ] && [ \"${lastOpt}\" == \"--hpsum_options\" ]; then\n        hpSumOptions=\"${hpSumOptions} ${arg}\"\n    elif [ \"${optName}\" == \"--hpsum_options\" ]; then\n        if [[ ! \"${optValue}\" =~ [^[:space:]] ]]\n        then\n            echo \"Missing argument to '--hpsum_options'\" 1>&2\n            exit 1\n        fi\n\n        hpSumOptions=\"${optValue}\"\n\n        lastOpt=\"--hpsum_options\"\n    elif [ \"${optName}\" == \"--hpsum_logs_dump_dir\" ]\n    then\n        if [[ ! \"${optValue}\" =~ [^[:space:]] ]]\n        then\n            echo \"Missing argument to '--hpsum_logs_dump_dir'\" 1>&2\n            exit 1\n        fi\n\n        hpSumLogsDumpDir=\"${optValue}\"\n        lastOpt=\n    elif [ \"${optName}\" == \"--hpsum_copy_files_locally\" ]\n    then\n        if [ \"${optValue}\" == \"true\" ] || [ \"${optValue}\" == \"false\" ]\n        then\n            hpSumCopyFilesLocally=\"${optValue}\"\n        else\n            echo \"Invalid value '${optValue}' specified for script parameter '--hpsum_copy_files_locally'\" 1>&2\n            echo \"Valid values are 'true' or 'false'\" 1>&2\n            exit 1\n        fi\n    elif [ \"${optName}\" == \"--no_show_log\" ]\n    then\n        showHpSumLog=0\n    else\n        echo \"invalid option '${optName}'\" 1>&2\n        exit 1\n    fi\ndone\n\n# If we have user-specified HP SUM command line options, then check if the\n# log directory has been overridden with the \"/logdir\" or \"-logdir\" option.\n# We need to know where the log files will be placed so that we can zip them\n# up when the offline firmware update is complete.\nif [ ! -z \"${hpSumOptions}\" ]\nthen\n    checkForOverrideOfHpSumLogDir \"${hpSumOptions}\"\nfi\n\n# Locates the SPP version to be used.\nfindSPPVersion\n\nif [ $? -ne 0 ]\nthen\n    exit 1\nfi\n\n# Verify that the file dependencies for HP SUM and its Smart Components are\n# present on the Service OS.\nverifyFirmwareDependencies\n\nif [ $? -ne 0 ]\nthen\n    exit 1\nfi\n\n# Kill \"anaconda\", if running on the SA Linux Service OS, as it may interfere\n# with the Emulex firmware update and cause it to fail.\nkillAnaconda\n\nif [ $? -ne 0 ]\nthen\n    exit 1\nfi\n\nrunHPSUM\nretCode=$?\n\n# This section of code displays the \"Install Components\" section of \"hpsum_log.txt\"\n# to standard output, so that it is visible in the Insight Control Server Provisioning\n# job log.  Because the job log is limited to 10K, only a small portion of \n# \"hpsum_log.txt\" is being displayed.  The code below may be edited to show more of\n# \"hpsum_log.txt\", or for more detailed information, \"hpsum_detail_log.txt\" may be\n# used instead.  To use \"hpsum_detail_log.txt\", replace \"$(getHpSumLog)\" below with\n# \"$(getHpSumDetailLog)\".\nif [ ${showHpSumLog} -eq 1 ]\nthen\n    logFileToDisplay=$(getHpSumLog)\n\n    if [ -e ${logFileToDisplay} ]\n    then\n\t    echo \"Checking log files for installed components:\"\n        installedComponents=\"Installed Components:\"\n        deployedComponents=\"Deployed Components:\"\n\n        # Log file for HP SUM version < 6.0.1 will show \"Installed Components:\"\n        # Log file for HP SUM version >= 6.0.1 will show \"Deployed Components:\"\n        if grep \"^${installedComponents}\" ${logFileToDisplay} > /dev/null 2>&1\n        then\n            searchText=${installedComponents}\n        elif grep \"^${deployedComponents}\" ${logFileToDisplay} > /dev/null 2>&1\n        then\n            searchText=${deployedComponents}\n        else\n            searchText=\n        fi\n\n        if [ ! -z \"${searchText}\" ]\n        then\n            echo -e \"The '${searchText}' section of '${logFileToDisplay}' is as follows:\\n\"\n\n            hpSumInstalledComponents=$(awk \"/^${searchText}/ { SHOW = 1 }; SHOW == 1 { print }\" ${logFileToDisplay})\n\n            if [ -z \"${hpSumInstalledComponents}\" ]\n            then\n                echo \"Could not find '^${searchText}' in ${logFileToDisplay}\"\n            else\n                echo \"${hpSumInstalledComponents}\"\n            fi\n        else\n            echo \"WARNING: No components were installed. Check the log details for more information if you feel this is incorrect.\"\n        fi\n    else\n        echo \"'${logFileToDisplay}' not found\"\n    fi\nfi\n\necho \"Placing HP SUM log files into '${hpSumLogsZipFile}'\"\n\n# Zip up the HP SUM log files and redirecting Standard error and Standard output to /dev/null .\nzip -r ${hpSumLogsZipFile} $(getHpSumLogs) > /dev/null 2>&1\n\nif [ $? -ne 0 ]\nthen\n    echo \"Failed to create HP SUM logs zip file '${hpSumLogsZipFile}'\" 1>&2\n    exit 1\nfi\n\n# If the \"--hpsum_logs_dump_dir\" parameter was specified, then zip up the\n# HP SUM log files and place them in the specified directory.\nif [[ ${hpSumLogsDumpDir} =~ [^[:space:]] ]]\nthen\n    # If the directory where the zipped HP SUM log files is to be placed does not\n    # exist, then create it.\n    if [ ! -d ${hpSumLogsDumpDir} ]\n    then\n        echo \"The directory '${hpSumLogsDumpDir}' does not exist on file share.  Creating it.\"\n        mkdir -p ${hpSumLogsDumpDir}\n\n        if [ $? -ne 0 ]\n        then\n            echo \"Failed to create directory '${hpSumLogsDumpDir}' on file share\" 1>&2\n            echo \"Verify that the directory is writable\" 1>&2\n        fi\n    fi\n\n    serverId=$(getServerId)\n\n    timeStamp=$(date +%Y%m%d-%H%M%S)\n\n    hpSumLogsZipFileWithServerId=hpsum_logs_${serverId}_${timeStamp}.zip\n\n    pathToZipFileOnFileShare=\"${hpSumLogsDumpDir}/${hpSumLogsZipFileWithServerId}\"\n\n    echo \"Copying '${hpSumLogsZipFile}' to '${pathToZipFileOnFileShare}'\"\n\n    cp ${hpSumLogsZipFile} ${pathToZipFileOnFileShare}\n\n    if [ $? -eq 0 ]\n    then\n        echo \"Successfuly copied '${hpSumLogsZipFile}' to '${pathToZipFileOnFileShare}'\"\n    else\n        echo \"Failed to copy '${hpSumLogsZipFile}' to '${pathToZipFileOnFileShare}'\" 1>&2\n    fi\nelse\n    echo \"Since the '--hpsum_logs_dump_dir' option was not specified, the zipped HP SUM log files were not copied to the file share\"\nfi \n\nexit $retCode\n",
            "description": "Updates the target server firmware using the HP SUM utility and specified SPP version.\n\nOptional Parameters:\n--spp_version=directory_name    The name of the directory containing the SPP to be installed, such as \"2014.02.0\".  If the value is blank or \"latest\", the script automatically selects the directory with the latest version as determined by sort order.\n\n--hpsum_options=\"option1 option2 ... optionN\"    HP SUM supported command-line options that are to be passed to HP SUM.  All the options must be enclosed within double quotes.  Refer to HP SUM's CLIhelp.txt documentation file for available options.\n\n--hpsum_logs_dump_dir=writable_directory_under_mounted_file_share    Copies the zipped HP SUM log files to the specified directory.  The directory must start with the mount point specified in the \"Set Media Source\" Build Plan Step.  For example, if the file share where the zipped HP SUM log file is to be copied to is mounted on \"/mnt/media\" and the destination directory is \"hpsum_logs\", then specify \"--hpsum_logs_dump_dir=/mnt/media/hpsum_logs\".\n\n--no_show_log   Don't display the \"hpsum_log.txt\" contents in the job log.\n\nRequirements:\n* Media Server mounted with Set Media Source script.\n* The directories containing the SPPs must reside on the Media Server under the \"\\Media\\spp\" directory.\n\nCustom Attributes: None",
            "status": null,
            "name": "Update Firmware Using SPP",
            "state": null,
            "eTag": "2015-08-04T07:30:02.000Z",
            "modified": "2015-08-04T07:30:02.000Z",
            "created": "2015-08-04T07:30:02.000Z",
            "category": "os-deployment-server-scripts",
            "uri": "/rest/os-deployment-server-scripts/1660001"
        },
        {
            "runAsSuperUser": true,
            "serverChanging": true,
            "codeType": "VBS",
            "displayCodeType": "Windows VBScript",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "53",
                    "createdBy": "opsware",
                    "createdDate": "2015-08-04T07:30:04.000Z",
                    "usage": "Uninstalls HP agents and utilities that store system specific information in the registry.  There may be problems if a Windows image captured with these agents and utilities installed is deployed to another system.\n\nParameters: None\n\nCustom Attributes: None",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-08-04T07:30:04.000Z",
            "version": {
                "versionLabel": "53",
                "createdBy": "opsware",
                "createdDate": "2015-08-04T07:30:04.000Z",
                "usage": "Uninstalls HP agents and utilities that store system specific information in the registry.  There may be problems if a Windows image captured with these agents and utilities installed is deployed to another system.\n\nParameters: None\n\nCustom Attributes: None",
                "current": true
            },
            "source": "'Sysprep Imaging Preparation Script\n'vbscript\n\n'(C) Copyright 2013-2015 Hewlett-Packard Development Company, L.P.\n\ndim aNames(11)\naNames(0) = \"HP Insight Management Agents\"\naNames(1) = \"HP Lights-Out Online Configuration Utility\"\naNames(2) = \"HP ProLiant Rack Infrastructure Interface Service\"\naNames(3) = \"HP Smart Array SAS/SATA Event Notification Service\"\naNames(4) = \"HP Insight Diagnostics Online Edition for Windows\"\naNames(5) = \"HP Insight Diagnostics  Online Edition for Windows\"\naNames(6) = \"HP ProLiant Online RBSU\"\naNames(7) = \"HP Insight }lWg G[WFg\"\naNames(8) = \"HP ProLiant bN CtXgN` C^tFCX T[rX\"\naNames(9) = \"HP Smart ACSAS/SATACxgmT[rX\"\naNames(10) = \"HP Lights-Out IC[eBeB\"\n\n\nset oFSO = Wscript.CreateObject(\"Scripting.FileSystemObject\")\nset oShell = Wscript.CreateObject(\"Wscript.Shell\")\nset oRegistry = GetObject(\"winmgmts:{impersonationLevel=impersonate}!\\\\.\\root\\default:StdRegProv\")\nconst nHKLM = 2147483650\n\n\n'uninstall software\nconst sUninstallKey = \"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\"\noRegistry.EnumKey nHKLM, sUninstallKey, aKeys\nfor each sKey In aKeys\n   oRegistry.GetStringValue nHKLM, sUninstallKey & \"\\\" & sKey, \"DisplayName\", sDisplayName\n   oRegistry.GetExpandedStringValue nHKLM, sUninstallKey & \"\\\" & sKey, \"UninstallString\", sUninstallString\n   if IsNull(sDisplayName) = False and IsNull(sUninstallString) = False and IsAMatch(sDisplayName) then\n      uninstallCommand = sUninstallString & \" /passive\"\n      WScript.echo \"Uninstalling component => \" & uninstallCommand\n      oShell.Run(uninstallCommand),1,true\n   end if\nnext\n\n'Get the system drive.\n'Set WshShell = CreateObject(\"WScript.Shell\")\n'systemDrive = WshShell.ExpandEnvironmentStrings(\"%SystemDrive%\")\n\n'Create windows scheduled task which reinstalls Broadcom driver on reboot with 15 min delay \n'reinstallCommand = \"schtasks /create /sc ONSTART /tn ReinstallBroadCom  /tr \" & Chr(34) & systemDrive & \"\\\" & Chr(36) & \"oem\" & Chr(36) & \"\\components\\update_broadcom.cmd\" & Chr(34) & \" /DELAY 0015:00 /f /ru SYSTEM\"\n'WScript.echo \"Scheduling reinstalling of Broadcom driver => \" & reinstallCommand\n'oShell.Run(reinstallCommand)\n\n\nfunction IsAMatch(sString)\n   fFound = False\n   for each sName in aNames\n      if sName = sString then\n         fFound = True\n      end if\n   next\n   IsAMatch = fFound\nend function\n\n\nfunction DeleteFile (sPathExist, sPathDelete)\n   if oFSO.FileExists(sPathExist) then\n      oFSO.DeleteFile(sPathDelete), True\n   end if\nend function\n\n",
            "description": "Uninstalls HP agents and utilities that store system specific information in the registry.  There may be problems if a Windows image captured with these agents and utilities installed is deployed to another system.\n\nParameters: None\n\nCustom Attributes: None",
            "status": null,
            "name": "Uninstall HP ProLiant Utilities",
            "state": null,
            "eTag": "2015-08-04T07:30:04.000Z",
            "modified": "2015-08-04T07:30:04.000Z",
            "created": "2015-08-04T07:30:03.000Z",
            "category": "os-deployment-server-scripts",
            "uri": "/rest/os-deployment-server-scripts/1670001"
        },
        {
            "runAsSuperUser": true,
            "serverChanging": true,
            "codeType": "SH",
            "displayCodeType": "Unix",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "10",
                    "createdBy": "opsware",
                    "createdDate": "2015-08-04T07:30:04.000Z",
                    "usage": "This script is intended to accompany the Insight Control server provisioning Capturing and Installing Linux System Images white paper. \n\nThis script adjusts for any new hardware or partition changes after the image has been deployed to the target server.  The sample script provided takes care of writing a new MBR on the disk and fixing the network adapters.\n",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-08-04T07:30:04.000Z",
            "version": {
                "versionLabel": "10",
                "createdBy": "opsware",
                "createdDate": "2015-08-04T07:30:04.000Z",
                "usage": "This script is intended to accompany the Insight Control server provisioning Capturing and Installing Linux System Images white paper. \n\nThis script adjusts for any new hardware or partition changes after the image has been deployed to the target server.  The sample script provided takes care of writing a new MBR on the disk and fixing the network adapters.\n",
                "current": true
            },
            "source": "#!/bin/bash\n# (C) Copyright 2012-2015 Hewlett-Packard Development Company, L.P.\n# Mount devfs\nmount -t devtmpfs dev /mnt/target/dev\n\n# Remove old device.map file because it referred to old drive by UUID\nrm -f /mnt/target/boot/grub/device.map\n\n# write new MBR\nchroot /mnt/target /usr/sbin/grub \\\n      --device-map=/boot/grub/device.map << EOF\nroot (hd0,2)\nsetup (hd0)\nquit\nEOF\n\n# clean up installation.\n# Change network configuration/setup - Remove physical anchor\n# settings.\n\nsed -i -e '/^HWADDR/d' -e '/^UUID/d' \\\n  /mnt/target/etc/sysconfig/network/ifcfg-eth0\n\nrm -f /mnt/target/etc/udev/rules.d/70-persistent-net.rules\n\n#\n# Hostname\nexit 0\n",
            "description": "This script is intended to accompany the Insight Control server provisioning Capturing and Installing Linux System Images white paper. \n\nThis script adjusts for any new hardware or partition changes after the image has been deployed to the target server.  The sample script provided takes care of writing a new MBR on the disk and fixing the network adapters.\n",
            "status": null,
            "name": "Sample - Fixup SLES Deployment",
            "state": null,
            "eTag": "2015-08-04T07:30:04.000Z",
            "modified": "2015-08-04T07:30:04.000Z",
            "created": "2015-08-04T07:30:04.000Z",
            "category": "os-deployment-server-scripts",
            "uri": "/rest/os-deployment-server-scripts/1690001"
        },
        {
            "runAsSuperUser": true,
            "serverChanging": true,
            "codeType": "SH",
            "displayCodeType": "Unix",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "24",
                    "createdBy": "opsware",
                    "createdDate": "2015-08-04T07:30:09.000Z",
                    "usage": "Captures or sets the target server's Smart Array configuration using the hpssascripting utility.\n\nRequired Parameters:\nTo capture: -c output_filename (-internal | external) (-nofail)\nTo set: -i input_filename  (-internal | external) (-reset) (-nofail)\n-nofail is indicated if the script should not fail if a Smart Array controller is not found.\n\nCustom Attribute: None",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-08-04T07:30:09.000Z",
            "version": {
                "versionLabel": "24",
                "createdBy": "opsware",
                "createdDate": "2015-08-04T07:30:09.000Z",
                "usage": "Captures or sets the target server's Smart Array configuration using the hpssascripting utility.\n\nRequired Parameters:\nTo capture: -c output_filename (-internal | external) (-nofail)\nTo set: -i input_filename  (-internal | external) (-reset) (-nofail)\n-nofail is indicated if the script should not fail if a Smart Array controller is not found.\n\nCustom Attribute: None",
                "current": true
            },
            "source": "#!/bin/sh\n\n# (C) Copyright 2012-2015 Hewlett-Packard Development Company, L.P.\n\n# ======================================================================\n# Reads/Writes HP Smart Array configuration\n#\n# Capture parameters: -c output.ini [-internal | -external] [-nofail]\n# Deploy parameters: -i input.ini [-internal | -external] [-reset] [-nofail]\n# ======================================================================\n\nUSAGE=\"usage: $(basename $0) {-c|-i} cfg.ini [-options] [-nofail]\"\n\n# expected location of the installed HP HPSSACLI utilities\nDIR=\"/tmp/sstk/hpssacli\"\nHPSSACLI=\"${DIR}/hpssacli\"\nHPSSASCRIPTING=\"${DIR}/hpssascripting\"\n\n# In the PXE-booted Linux service OS, the \"tr\" command\n# is in a non-standard directory.  Set PATH for \"tr\".\nexport PATH=${PATH}:/opt/opsware/agent/osprov/bin/x86\n\n# Required libraries for HP SSACLI utilities\nexport LD_LIBRARY_PATH=\"$DIR\"\n\n# for each HPSSA utility:\n# - verify existence\n# - ensure executable\nfor UTIL in \"$HPSSACLI\" \"$HPSSASCRIPTING\"\ndo\n    # verify Existence\n    if [ ! -e \"$UTIL\" ]; then\n\techo \"$UTIL can not be found\" 1>&2\n\texit 1\n    fi\n    # ensure utility has eXecute permission\n    [ -x \"$UTIL\" ] || chmod +x \"$UTIL\"\ndone\n\n# specify scripting mode: -c (capture) | -i (input)\nMODE=${1:?$USAGE}\nshift\n\n# specify full path for configuration filename on target system\nCFG_FILE=${1:?$USAGE}\nshift\n\n# specify full path for error log file on target system\nERR_FILE=\"$DIR/error.log\"\n\n# validate supported mode\nif [ \"$MODE\" != \"-c\" ] && [ \"$MODE\" != \"-i\" ]; then\n    echo $USAGE 1>&2\n    exit 1\nfi\n\n# Parse additional args\nwhile [ \"$1\" != \"\" ] ; do\n    case $1 in\n    -internal|-external)\n        OPT3=$1\n\t;;\n    -reset)\n        OPT4=$1\n        ;;\n    -nofail)\n        NOFAIL=true\n        ;;\n     *)\n        echo $USAGE 1>&2\n        exit 1\n     esac\n     shift\ndone\n\n# Check for presence of controller we can reset.\nif ! $HPSSACLI controller all show > /dev/null ; then\n    echo \"No controller found. Exiting..\"\n    #No controller was found now check to see if we need to\n    #signal an error\n    if [ \"$NOFAIL\" == \"\" ]; then\n\t# nofail wasn't set, so fail\n\texit 1\n    else\n\t# nofail was set, so we can quit but signal success.\n\texit 0\n    fi\nfi\n\n# a logical drive with OS Status of LOCKED can't be reset\n# unmount logical drives to avoid error 3036 in use by OS\n\n# Run the unmount from the osprov lib.\nPYTHONPATH=/opt/opsware/pylibs2/ /opt/opsware/agent/bin/python -c \"from osprov.diskmgr.diskmanager import DiskManager; dm = DiskManager(); dm.disable_automount(); dm.unmountDisks(skipUsb=True)\"\n\n# also force unmount, to ensure everything is unmounted\nDEVS=`($HPSSACLI controller all show config detail | grep 'Mount Points' | sed -e 's/.*Mount Points:\\(.*\\)/\\1/' | tr , '\\012' | cut -d' ' -f2) 2>/dev/null`\n[ -n \"$DEVS\"  -a \"$DEVS\" != \"None\" ] && umount -v $DEVS 2>/dev/null\n\n# remove any leftover error log file; don't want old errors\nrm -f \"$ERR_FILE\"\n\n# run utility\n\"$HPSSASCRIPTING\" $MODE \"$CFG_FILE\" $OPT3 $OPT4 -e \"$ERR_FILE\"\nrc=$?\n\ncase $rc in\n   0 )\n      echo \"$HPSSASCRIPTING successful\";;\n   * )\n      # output error log on stderr\n      [ -e \"$ERR_FILE\" ] && cat \"$ERR_FILE\" 1>&2\n      echo \"$HPSSASCRIPTING failed ($rc)\" 1>&2;;\nesac\nexit $rc",
            "description": "Captures or sets the target server's Smart Array configuration using the hpssascripting utility.\n\nRequired Parameters:\nTo capture: -c output_filename (-internal | external) (-nofail)\nTo set: -i input_filename  (-internal | external) (-reset) (-nofail)\n-nofail is indicated if the script should not fail if a Smart Array controller is not found.\n\nCustom Attribute: None",
            "status": null,
            "name": "Manage Smart Array Configuration",
            "state": null,
            "eTag": "2015-08-04T07:30:09.000Z",
            "modified": "2015-08-04T07:30:09.000Z",
            "created": "2015-08-04T07:30:08.000Z",
            "category": "os-deployment-server-scripts",
            "uri": "/rest/os-deployment-server-scripts/1710001"
        },
        {
            "runAsSuperUser": true,
            "serverChanging": true,
            "codeType": "PY2",
            "displayCodeType": "Python",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "17",
                    "createdBy": "opsware",
                    "createdDate": "2015-08-04T07:30:09.000Z",
                    "usage": "Creates and executes a BAT script on the target server that installs the SPP, but does not wait for it to complete.  The BAT script stops the HP SA agent prior to installing the SPP, and starts the HP SA agent after the SPP installation is complete.  The HP SA agent is stopped while the SPP is being installed, because when the NIC firmware is updated, it may cause connection problems between the HP SA agent and the SA core.\n\nOptions:\n    --spp_version=directory_name    The name of the directory containing the SPP to be installed, such as \"2012.06.0\" or \"2013.09.0\".  If the value is blank or \"latest\", the script automatically selects the directory with the latest version as determined by sort order.\n\n    --hpsum_options=\"option1 option2 option3 ... optionN\"    HP SUM supported command-line options that are to be passed to HP SUM.  Refer to HP SUM's CLIhelp.txt documentation file for available options.\n\nRequirements:\n* Media Server must be mounted with Set Media Source script.\n* The directories containing the SPPs must reside on the Media Server under the \"\\Media\\spp\" directory.",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-08-04T07:30:09.000Z",
            "version": {
                "versionLabel": "17",
                "createdBy": "opsware",
                "createdDate": "2015-08-04T07:30:09.000Z",
                "usage": "Creates and executes a BAT script on the target server that installs the SPP, but does not wait for it to complete.  The BAT script stops the HP SA agent prior to installing the SPP, and starts the HP SA agent after the SPP installation is complete.  The HP SA agent is stopped while the SPP is being installed, because when the NIC firmware is updated, it may cause connection problems between the HP SA agent and the SA core.\n\nOptions:\n    --spp_version=directory_name    The name of the directory containing the SPP to be installed, such as \"2012.06.0\" or \"2013.09.0\".  If the value is blank or \"latest\", the script automatically selects the directory with the latest version as determined by sort order.\n\n    --hpsum_options=\"option1 option2 option3 ... optionN\"    HP SUM supported command-line options that are to be passed to HP SUM.  Refer to HP SUM's CLIhelp.txt documentation file for available options.\n\nRequirements:\n* Media Server must be mounted with Set Media Source script.\n* The directories containing the SPPs must reside on the Media Server under the \"\\Media\\spp\" directory.",
                "current": true
            },
            "source": "#!/usr/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n#\n\"\"\"\n(C) Copyright 2014-2015 Hewlett-Packard Development Company, L.P.\n\"\"\"\n\nimport sys\nimport os\nimport subprocess\n\nfrom subprocess import Popen, PIPE, STDOUT\nfrom optparse import OptionParser\n\nDEBUG=@Debug:0@\n\n# The drive letter on which the media server file share is mounted.\nmediaServerDriveLetter = None\n\n# Get the Windows \"Temp\" directory.\nwindowsSystemDrive = os.getenv(\"SystemDrive\")\nwindowsTempDir = windowsSystemDrive + \"\\\\Windows\\\\Temp\"\n\n# This is where we will copy the HP SUM applications to, so we can run\n# HP SUM from the target server instead of the remote media server\n# file share.\nlocalHpSumDir = windowsTempDir + \"\\\\LocalHpSum\"\n\n# The directory where we will stage our SPP installation scripts and\n# output files.\nicspTempDir = windowsTempDir + \"\\\\icsp\"\nhpSumScript = icspTempDir + \"\\\\hpsum_script.bat\"\nhpSumOutputFile = icspTempDir + \"\\\\hpsum_output.txt\"\nhpSumExitCodeFile = icspTempDir + \"\\\\hpsum_exit_code.txt\"\nsppInstallScript = icspTempDir + \"\\\\spp_install.bat\"\n\nsppDir = None\nsppVersionDir = None\nremoteHpSumDir= None\n\n# HP SUM 5.X uses \"hpsum.exe\", while HP SUM 6.X uses \"hpsum.bat\".\nhpSumExe = \"hpsum.exe\"\nhpSumBat = \"hpsum.bat\"\nmasterDependencyXml = \"masterdependency.xml\"\nhpSumApp = None\n\n# The options we will pass to HP SUM.  The \"/silent\" option is required.\n# Additional options may be passed in to this script using the \n# \"--hpsum_options\" parameter.\nhpSumOptions=\"/silent\"\n\n# Parses the command line arguments.\ndef parseArgs(args):\n    parser = OptionParser()\n    parser.add_option(\"--spp_version\",\n            default = \"latest\",\n            dest = \"sppVersion\",\n            help = \"The SPP version to install.\")\n    parser.add_option(\"--hpsum_options\",\n            default = \"\",\n            dest = \"hpSumOptions\",\n            help = \"Additional options to pass to hpsum.\")\n    parser.add_option(\"--media_server_drive_letter\",\n            default = \"z\",\n            dest = \"mediaServerDriveLetter\",\n            help = \"The drive letter on which the media server file share is mounted.\")\n    options, args = parser.parse_args(args)\n    if args:\n        parser.error(\"Additional positional arguments are not supported\")\n    return options, args\n\n##############################################################################\n# Writes an debug message to stdout.\n##############################################################################\n\ndef writeDebugMessage(msg):\n\n    # Write the message to stdout so that it shows up in the job output.\n    if (DEBUG):\n        print msg\n\n##############################################################################\n# Writes an info message to stdout.\n##############################################################################\n\ndef writeInfoMessage(msg):\n\n    # Write the message to stdout so that it shows up in the job output.\n    print msg\n\n##############################################################################\n# Writes an error message to stderr.\n##############################################################################\n\ndef writeErrorMessage(msg):\n\n    # Write the message to stderr so that it shows up in the job output.\n    sys.stderr.write(msg)\n\n##############################################################################\n# Returns the latest SPP version, which is determined by the directory name\n# who comes first in descending sort order.\n##############################################################################\n\ndef getLatestSppVersion():\n\n    writeDebugMessage(\"Searching for the latest SPP\")\n\n    # Get the subdirectories under the \"Media/spp\" directory.\n    sppVersions = [name for name in os.listdir(sppDir) if os.path.isdir(os.path.join(sppDir, name))]\n\n    # Sort the directories in descending order.\n    sortedSppVersions = sorted(sppVersions, reverse=True)\n\n    if (len(sortedSppVersions) == 0):\n        raise Exception(\"No SPP versions were found under the '%s' directory.\" % sppDir)\n\n    writeDebugMessage(\"Found %d SPP versions under '%s'\" % (len(sortedSppVersions),sppDir))\n    writeDebugMessage(\"Selected '%s' as latest SPP\" % sortedSppVersions[0])\n\n    # Return the first directory, which should represent the latest SPP based\n    # on sort order, assuming the name convention is \"YYYY.MM\".\n    return sortedSppVersions[0]\n\n##############################################################################\n# Creates our temporary ICSP directory on which we will land our scripts that\n# run HP SUM.\n##############################################################################\n\ndef createIcspTempDir():\n\n    writeDebugMessage(\"Creating %s\" % icspTempDir)\n\n    dirExists = False;\n\n    # Check if \"icsp\" already exists, and is a directory, not a file.  If it's\n    # a file, remove it.\n    if (os.path.exists(icspTempDir)):\n        if (os.path.isdir(icspTempDir)):\n            dirExists = True\n        else:          \n            removeFile(icspTempDir)\n\n    # If the directory didn't already exist, then create it.\n    if (not dirExists):\n        cmdArgs = [\"mkdir\", icspTempDir]\n\n        retCode, output = executeCommand(cmdArgs)\n\n        if (retCode != 0):\n            raise Exception(\"An error occurred while creating directory '%s': %s\" % (icspTempDir, output))\n\n##############################################################################\n# Create the \"LocalHpSum\" directory where we are going to copy the necessesary\n# HPSUM application files.  The firmware files and software packages will\n# remain on the media server.  The reason why we copy the HP SUM application\n# files locally, is because, otherwise, HP SUM might get a segmentation fault\n# when the NIC firmware is updated, due to loss of network connectivity with\n# the media server.  It's possible that not all pages are loaded into memory,\n# which is a problem if the NIC goes down and another page is requested.\n##############################################################################\n\ndef createLocalHpSumDir():\n\n    writeDebugMessage(\"Creating %s\" % localHpSumDir)\n\n    if (os.path.exists(localHpSumDir)):\n        if not (os.path.isdir(localHpSumDir)):\n            raise Exception(\"'%s' exists, but is not a directory.\" % localHpSumDir)\n    else:\n        cmdArgs = [\"mkdir\", localHpSumDir]\n\n        retCode, output = executeCommand(cmdArgs)\n\n        if (retCode != 0):\n            raise Exception(\"An error occurred while creating directory '%s': %s\" % (localHpSumDir, output))\n\n##############################################################################\n# Copies the HP SUM 6.X application files locally to the target server.  The\n# reason for copying the files locally, is because HP SUM will core dump if\n# it's run remotely from the media server and the NIC firmware is updated,\n# causing the network connection to be lost.\n##############################################################################\n \ndef copyHpSum6AppsToTargetServer():\n\n    global hpSumApp\n\n    createLocalHpSumDir()\n\n    fullPathToMasterDependency = remoteHpSumDir + \"\\\\\" + masterDependencyXml\n\n    # Copy the \"masterdependency.xml\" file locally to the target server.\n    cmdArgs = [\"copy\", \"/Y\", fullPathToMasterDependency, localHpSumDir]\n\n    retCode, output = executeCommand(cmdArgs)\n\n    if (retCode != 0):\n        raise Exception(\"An error occured while copying '%s' to '%s': %s\" % (fullPathToMasterDependency, localHpSumDir, output))\n\n    fullPathToHpSumBat = remoteHpSumDir + \"\\\\\" + hpSumBat\n\n    writeDebugMessage(\"Copying HP SUM 6.X files locally to target server\")\n\n    # Copy the \"hpsum.bat\" file locally to the target server.\n    cmdArgs = [\"copy\", \"/Y\", fullPathToHpSumBat, localHpSumDir]\n\n    retCode, output = executeCommand(cmdArgs)\n\n    if (retCode != 0):\n        raise Exception(\"An error occured while copying '%s' to '%s': %s\" % (fullPathToHpSumBat, localHpSumDir, output))\n\n    # These are the subdirectories needed by HP SUM to run locally to the target server.\n    subDirs = [ \"x64\", \"x86\", \"cygwin\", \"assets\"]\n\n    # Copy the subdirectories needed by HP SUM locally to the target server.\n    for dirName in subDirs:\n        fullPathToRemoteSubDir = remoteHpSumDir + \"\\\\\" + dirName\n        fullPathToLocalSubDir = localHpSumDir + \"\\\\\" + dirName\n\n        cmdArgs = [\"xcopy\", \"/s\", \"/y\", \"/i\", \"/q\", fullPathToRemoteSubDir, fullPathToLocalSubDir]\n\n        retCode, output = executeCommand(cmdArgs)\n\n        if (retCode != 0):\n            raise Exception(\"An error occured while copying '%s' to '%s': %s\" % (fullPathToRemoteSubDir, fullPathToLocalSubDir, output))\n\n##############################################################################\n# Gets the HP SUM application to call, which is different, depending on\n# whether HP SUM 6.X is being used or HP SUM 5.X is being used.\n##############################################################################\n\ndef getHpSumApp():\n\n    hpSumAppToCall = None\n\n    # HP SUM 6.X uses \"hpsum.bat\".\n    fullPathToHpSumBat = remoteHpSumDir + \"\\\\\" + hpSumBat\n\n    # HP SUM 5.X uses \"hpsum.exe\".\n    fullPathToHpSumExe = remoteHpSumDir + \"\\\\\" + hpSumExe\n\n    # HP SUM 6.X uses \"hpsum.bat\", whereas HP SUM 5.X uses \"hpsum.exe\".\n    if (os.path.exists(fullPathToHpSumBat)):\n        writeDebugMessage(\"Found %s\" % fullPathToHpSumBat)\n\n        # This is the executable that we'll call to install HP SUM 6.X.\n        hpSumAppToCall = hpSumBat\n    elif (os.path.exists(fullPathToHpSumExe)):\n        writeDebugMessage(\"Found %s\" % fullPathToHpSumExe)\n\n        # This is the executable that we'll call to install HP SUM 5.X.\n        hpSumAppToCall = hpSumExe\n    else:\n        raise Exception(\"Could not find '%s' or '%s'\" % (fullPathToHpSumBat, fullPathToHpSumExe))\n\n    return hpSumAppToCall\n\n##############################################################################\n# Removes the specified file.\n##############################################################################\n\ndef removeFile(filePath):\n\n    writeDebugMessage(\"Removing file %s\" % filePath)\n\n    cmdArgs = [\"del\", \"/q\", \"/s\", filePath]\n\n    retCode, output = executeCommand(cmdArgs)\n\n    if (retCode != 0):\n        raise Exception(\"An error occurred while removing file '%s': %s\" % (filePath, output))\n\n##############################################################################\n# Removes the specified directory.\n##############################################################################\n\ndef removeDir(dirPath):\n\n    writeDebugMessage(\"Removing directory %s\" % dirPath)\n\n    cmdArgs = [\"rmdir\", \"/q\", \"/s\", dirPath]\n\n    retCode, output = executeCommand(cmdArgs)\n\n    if (retCode != 0):\n        raise Exception(\"An error occurred while removing directory '%s': %s\" % (dirPath, output))\n\n##############################################################################\n# Removes the HP SUM temporary directory.\n##############################################################################\n\ndef removeHpSumTempDir():\n    writeDebugMessage(\"Removing HP SUM temporary directory\")\n\n    # HP SUM 5.X and HP SUM 6.X used different temporary directory, so lets\n    # check for both.\n    hpSum5TempDir = windowsTempDir + \"\\\\hp_sum\"\n    hpSum6TempDir = windowsTempDir + \"\\\\HPSUM\"\n\n    for tempDir in [ hpSum5TempDir, hpSum6TempDir]:\n        if (os.path.exists(tempDir)):\n            if (os.path.isdir(tempDir)):\n                removeDir(tempDir)\n            else:\n                removeFile(tempDir)\n\n##############################################################################\n# delimiter character (default = ' ').\n##############################################################################\n\ndef listToString(list, delimeter=' '):\n\n    str = delimeter.join(list)\n\n    return str\n\n##############################################################################\n# Executes the specified command, which must be a list contaning the \n# executable name and its arguments.\n##############################################################################\n\ndef executeCommand(cmdArgs):\n\n    cmdAsString = listToString(cmdArgs)\n\n    writeDebugMessage(\"Executing => \" + cmdAsString)\n\n    p = subprocess.Popen(cmdArgs, stdout=subprocess.PIPE, stderr=STDOUT, shell=True)\n\n    output = p.communicate()[0].strip()\n\n    retCode = p.poll()\n\n    p.stdout.close()\n\n    return retCode, output\n\n##############################################################################\n# Executes the specified command, which must be a list contaning the \n# executable name and its arguments, and returns immediately, without\n# waiting for the process to finish.\n##############################################################################\n\ndef executeCommandAndDetach(cmdArgs):\n\n    cmdAsString = listToString(cmdArgs)\n\n    writeDebugMessage(\"Executing => \" + cmdAsString)\n\n    retCode = 0\n\n    try:\n        CREATE_NO_WINDOW=0x08000000\n        CREATE_NEW_PROCESS_GROUP=0x00000200\n        CREATE_BREAKAWAY_FROM_JOB=0x01000000\n\n        p = subprocess.Popen(cmdArgs, close_fds = True, creationflags=CREATE_NO_WINDOW|CREATE_NEW_PROCESS_GROUP|CREATE_BREAKAWAY_FROM_JOB)\n\n        retCode = p.poll()\n    except (Exception), why:\n        retCode = 1\n        sys.stderr.write(\"An error occured while executing '%s': %s\" % (cmdAsString,str(why)))\n\n    return retCode\n\n##############################################################################\n# Checks if the specified directory is accessible.\n##############################################################################\n\ndef checkIfDirIsAccessible(dirPath):\n\n    if (os.path.exists(dirPath)):\n        if not (os.path.isdir(dirPath)):\n            raise Exception(\"'%s' is not a directory.\" % dirPath)\n    else:\n        raise Exception(\"The directory '%s' does not exist or the file share is not mounted.\" % dirPath)\n\n##############################################################################\n# Checks if the SPP directory is accessible.\n##############################################################################\n\ndef checkIfSppDirIsAccessible():\n\n    global sppDir\n\n    if (sppDir is not None):\n        try:\n            checkIfDirIsAccessible(sppDir)\n        except (Exception), why:\n            raise Exception(\"The SPP directory is not accessible: %s\" % why)\n    else:\n        raise Exception(\"The sppDir variable is not set\")\n\n##############################################################################\n# Checks if the SPP version directory is accessible.\n##############################################################################\n\ndef checkIfSppVersionDirIsAccessible():\n\n    global sppVersionDir\n\n    if (sppVersionDir is not None):\n        try:\n            checkIfDirIsAccessible(sppVersionDir)\n        except (Exception), why:\n            raise Exception(\"The SPP version directory is not accessible: %s\" % why)\n    else:\n        raise Exception(\"The sppVersionDir variable is not set\")\n\n##############################################################################\n# Creates the SPP installation script that runs the HP SUM installation\n# script and captures its output to a file.\n##############################################################################\n\ndef createSppInstallScript():\n\n    global hpSumScript\n    global sppInstallScript\n\n    writeDebugMessage(\"Creating %s\" % sppInstallScript)\n\n    # This is a Python here document containing the contents of the SPP \n    # installation script.  All this script does is call the HP SUM installation\n    # script.\n    scriptContents = \"\"\"\nstart /B %s\n\"\"\" % (hpSumScript)\n\n    # Write the file.\n    f = open( sppInstallScript, 'w')\n    f.write( scriptContents )\n    f.close()\n\n##############################################################################\n# Creates the HP SUM installation script that stops the SA agent, runs\n# HP SUM, and starts the SA agent again.\n##############################################################################\n\ndef createHpSumScript():\n\n    global hpSumOptions\n    global localHpSumDir\n    global remoteHpSumDir\n    global mediaServerDriveLetter\n    global hpSumApp\n    global hpSumBat\n    global hpSumOutputFile\n\n    writeDebugMessage(\"Creating %s\" % hpSumScript)\n\n    # The 'hpSumApp' variable should have been set in the function that copies\n    # the HP SUM applications locally to the target server.\n    if (hpSumApp is None):\n        raise Exception(\"hpSumApp is not set\")\n\n    # The HP SUM command we're going to run.\n    hpSumCommand = hpSumApp + \" \" + \"/use_location\" + \" \" + remoteHpSumDir + \" \" + hpSumOptions\n\n    # HP SUM 6.X uses \"hpsum.bat\" and must be run from a directory on the target server\n    # to prevent the application from crashing when the NIC firmware is updated and\n    # the media server is no longer accessible.\n    #\n    # HP SUM 5.X uses \"hpsum.exe\" and is not susceptible to crashing when the NIC\n    # firmware is updated.  We always ran it from the remote directory on the media\n    # server, so we will continue to run it that way.\n    if (hpSumApp == hpSumBat):\n        dirToExecuteHpSumFrom = localHpSumDir\n    else:\n        dirToExecuteHpSumFrom = remoteHpSumDir\n\n    # This is a Python here document containing the contents of the script that is\n    # going to stop the SA agent, run HP SUM, and start the SA agent.  The DOS\n    # variables use \"%%\", which is to escape the second \"%\", so that Python doesn't\n    # interpret it as a format character.\n    scriptContents = \"\"\"\n@echo off\nset hpSumOutputFile=%s\n\necho =========================================================== > %%hpSumOutputFile%%\necho Script Start >> %%hpSumOutputFile%%\necho TIME: %%DATE%% %%TIME%% >> %%hpSumOutputFile%%\necho =========================================================== >> %%hpSumOutputFile%%\n\necho Sleeping for 10 seconds to ensure that the build plan step has completed before stopping the SA agent >> %%hpSumOutputFile%%\nping -n 10 127.0.0.1 >nul\n\nset /a Try=1\n\n:StopSAService\necho TIME: %%DATE%% %%TIME%% >> %%hpSumOutputFile%%\necho Stopping Opsware Agent. Try: %%Try%% >> %%hpSumOutputFile%%\nsc stop OpswareAgent >> %%hpSumOutputFile%%\n\nREM Service stopped normally.\nif %%ERRORLEVEL%% EQU 0 goto SAAgentStopped\n\nREM ERROR_SERVICE_REQUEST_TIMEOUT=1053, SA Agent service stop request timed out\nREM Wait additional secs and retry\nif %%ERRORLEVEL%% EQU 1053 goto WaitAndRetry\n\nREM ERROR_SERVICE_NOT_ACTIVE=1062, SA Agent already stopped\nif %%ERRORLEVEL%% EQU 1062 goto SAAgentStopped\n\necho Failed to stop Opware Agent. Error:%%ERRORLEVEL%% >> %%hpSumOutputFile%%\nREM Attempt to start the service, don't leave target server without agent connection.\ngoto StartSAService\n\n:WaitAndRetry\nREM Wait for 40 sec for HP SA Agent service to terminate and retry\nREM Retry 3 times before exiting\nif %%Try%% == 3 goto StartSAService\nping -n 40 127.0.0.1 >nul\nset /a Try+=1\n\ngoto StopSAService\n\n:SAAgentStopped\nset dirToExecuteHpSumFrom=%s\n\necho Changing directory to '%%dirToExecuteHpSumFrom%%' >> %%hpSumOutputFile%%\ncd /D %%dirToExecuteHpSumFrom%%\n\nif %%ERRORLEVEL%% NEQ 0 (\n    echo Could not change directory to '%%dirToExecuteHpSumFrom%%' >> %%hpSumOutputFile%%\n    goto StartSAService\n)\n\necho TIME: %%DATE%% %%TIME%% >> %%hpSumOutputFile%%\n\necho Starting hpsum >> %%hpSumOutputFile%%\n\ncall %s >> %%hpSumOutputFile%%\n\nset hpSumRetCode=%%ERRORLEVEL%%\n\necho hpsum exited with return code '%%hpSumRetCode%%' >> %%hpSumOutputFile%%\n\necho TIME: %%DATE%% %%TIME%% >> %%hpSumOutputFile%%\n\necho %%hpSumRetCode%% > %s\n\n:StartSAService\necho Starting Opsware Agent >> %%hpSumOutputFile%%\n\nsc start OpswareAgent >> %%hpSumOutputFile%%\n\nif %%ERRORLEVEL%% NEQ 0 (\n    echo Failed to start Opware Agent. Error: %%ERRORLEVEL%% >> %%hpSumOutputFile%%\n    exit 1\n)\n\necho TIME: %%DATE%% %%TIME%% >> %%hpSumOutputFile%%\n\necho Changing directory to SystemDrive >> %%hpSumOutputFile%%\n\nREM Make sure we're not on the media server drive when we exit, in order\nREM to prevent any potential problem later on if the media server drive\nREM is attempted to be unmounted.  You can't unmount a drive if a process\nREM is using it.\ncd /D %%SYSTEMDRIVE%%\\\\\n\n\"\"\" % (hpSumOutputFile,dirToExecuteHpSumFrom,hpSumCommand,hpSumExitCodeFile)\n\n    # Write the file.\n    f = open( hpSumScript, 'w')\n    f.write( scriptContents )\n    f.close()\n\n##############################################################################\n# Runs the HP SUM installation.\n##############################################################################\n\ndef runHpSum():\n\n    # Create the temporary directory that will contain our scripts and the\n    # output files produced by our scripts.\n    createIcspTempDir()\n\n    # Create our HP SUM script that stops the SA agent, runs HP SUM, and \n    # starts the SA agent.\n    createHpSumScript()\n\n    # Create that script that calls our HP SUM script and captures its output\n    # to a file, for debugging purposes.\n    createSppInstallScript()\n\n    cmdArgs = [sppInstallScript]\n\n    retCode = executeCommandAndDetach(cmdArgs)\n    \n    return retCode\n\n##############################################################################\n# Main Routine.\n##############################################################################\n\ndef main():\n\n    global hpSumApp\n    global hpSumBat\n    global hpSumOptions\n    global sppDir\n    global sppVersionDir\n    global remoteHpSumDir\n    global mediaServerDriveLetter\n\n    retCode = 0\n\n    options, remaining_args = parseArgs(sys.argv[1:])\n\n    try:\n        # Get the drive letter that the meda server file share is mounted on.\n        mediaServerDriveLetter = options.mediaServerDriveLetter.strip()\n\n        writeDebugMessage(\"Media Server Drive Letter => %s\" % mediaServerDriveLetter)\n\n        # The directory on the media server where the SPPs are stored.\n        sppDir = mediaServerDriveLetter + \":\" + \"\\\\Media\\\\spp\"\n\n        # Verify that the directory is accessible.  If the media server file share\n        # was manually mounted by the user, it may not be accessible to the build plan,\n        # even though you can see it mounted from Windows.  This could cause HP SUM\n        # to hang.\n        checkIfSppDirIsAccessible()\n\n        # Check which SPP to use. If it's \"latest\", select the latest SPP from the\n        # available SPPs under the \"Media/spp\" directory.  It is expected that the\n        # SPPs are stored under \"Media/spp\", with a directory name of \"YYYY.MM\",\n        # such that the latest SPP has the highest value, according to sort order.\n        if (options.sppVersion.lower() == \"latest\"):\n            writeInfoMessage(\"SPP version is 'latest'\")\n            sppVersion = getLatestSppVersion()\n            writeInfoMessage(\"Latest SPP version is '%s'\" % sppVersion)\n            sppVersionDir = sppDir + \"\\\\\" + sppVersion\n        else:\n            writeInfoMessage(\"SPP version is '%s'\" % options.sppVersion)\n            sppVersionDir = sppDir + \"\\\\\" + options.sppVersion\n            checkIfSppVersionDirIsAccessible()\n\n        # The remote HP SUM directory is \"hp\\swpackages\" under the SPP version\n        # directory.\n        remoteHpSumDir = sppVersionDir + \"\\\\hp\\\\swpackages\"\n\n        # Append any additional HP SUM options to the \"/silent\" option that we\n        # already require.\n        hpSumOptions += \" \" + options.hpSumOptions\n\n        writeInfoMessage(\"HP SUM options => %s\" % hpSumOptions)\n\n        hpSumApp = getHpSumApp()\n\n        # Remove the old HP SUM temporary directory, if exists.\n        removeHpSumTempDir()\n\n        # If the HP SUM application is \"hpsum.bat\", than means we're using\n        # HP SUM 6.X, which must be run from the target server.  So, we must\n        # copy the necessary application files over from the media server to\n        # the target server.\n        if (hpSumApp == hpSumBat):\n            copyHpSum6AppsToTargetServer()\n\n        # Run HP SUM.\n        retCode = runHpSum()\n    except (Exception), why:\n        retCode = 1\n        sys.stderr.write(\"%s\" % why)\n\n    return retCode\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n",
            "description": "Creates and executes a BAT script on the target server that installs the SPP, but does not wait for it to complete.  The BAT script stops the HP SA agent prior to installing the SPP, and starts the HP SA agent after the SPP installation is complete.  The HP SA agent is stopped while the SPP is being installed, because when the NIC firmware is updated, it may cause connection problems between the HP SA agent and the SA core.\n\nOptions:\n    --spp_version=directory_name    The name of the directory containing the SPP to be installed, such as \"2012.06.0\" or \"2013.09.0\".  If the value is blank or \"latest\", the script automatically selects the directory with the latest version as determined by sort order.\n\n    --hpsum_options=\"option1 option2 option3 ... optionN\"    HP SUM supported command-line options that are to be passed to HP SUM.  Refer to HP SUM's CLIhelp.txt documentation file for available options.\n\nRequirements:\n* Media Server must be mounted with Set Media Source script.\n* The directories containing the SPPs must reside on the Media Server under the \"\\Media\\spp\" directory.",
            "status": null,
            "name": "Install Windows SPP In Background",
            "state": null,
            "eTag": "2015-08-04T07:30:09.000Z",
            "modified": "2015-08-04T07:30:09.000Z",
            "created": "2015-08-04T07:30:09.000Z",
            "category": "os-deployment-server-scripts",
            "uri": "/rest/os-deployment-server-scripts/1720001"
        },
        {
            "runAsSuperUser": true,
            "serverChanging": true,
            "codeType": "SH",
            "displayCodeType": "Unix",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "10",
                    "createdBy": "opsware",
                    "createdDate": "2015-08-04T07:30:13.000Z",
                    "usage": "This script is intended to accompany the Insight Control server provisioning Capturing and Installing Linux System Images white paper. \n\nThis Script fixes the disk in preparation for writing a new partition table.  The sample script provided only deals with LVM2 volumes and groups.  If your system is different, then the script will need to be modified to work with your file system types.\n",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-08-04T07:30:13.000Z",
            "version": {
                "versionLabel": "10",
                "createdBy": "opsware",
                "createdDate": "2015-08-04T07:30:13.000Z",
                "usage": "This script is intended to accompany the Insight Control server provisioning Capturing and Installing Linux System Images white paper. \n\nThis Script fixes the disk in preparation for writing a new partition table.  The sample script provided only deals with LVM2 volumes and groups.  If your system is different, then the script will need to be modified to work with your file system types.\n",
                "current": true
            },
            "source": "#!/bin/bash\n\n#\n# (C) Copyright 2014-2015 Hewlett-Packard Development Company, L.P.\n#\n\necho \"Removing Logical Volumes...\"\nLVS=`lvs | grep -v \"Data%\" | awk '{print \"/dev/\" $2 \"/\" $1}'`\nfor LV in $LVS\ndo\n\tlvremove -f $LV\ndone\n\necho \"Removing Volume Groups...\"\nVGS=`lvs | grep -v \"Data%\" | awk '{print $2}' | sort -u`\nfor VG in $VGS\ndo\n\tvgchange -a n $VG\n\tvgremove -f $VG\ndone\n\n# wipe MBR and partition table.\ndd if=/dev/zero of=/dev/sda bs=512 count=1\n",
            "description": "This script is intended to accompany the Insight Control server provisioning Capturing and Installing Linux System Images white paper. \n\nThis Script fixes the disk in preparation for writing a new partition table.  The sample script provided only deals with LVM2 volumes and groups.  If your system is different, then the script will need to be modified to work with your file system types.\n",
            "status": null,
            "name": "Sample - Remove RHEL Old Partitions",
            "state": null,
            "eTag": "2015-08-04T07:30:13.000Z",
            "modified": "2015-08-04T07:30:13.000Z",
            "created": "2015-08-04T07:30:13.000Z",
            "category": "os-deployment-server-scripts",
            "uri": "/rest/os-deployment-server-scripts/1740001"
        },
        {
            "runAsSuperUser": true,
            "serverChanging": true,
            "codeType": "BAT",
            "displayCodeType": "Windows .BAT",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "31",
                    "createdBy": "opsware",
                    "createdDate": "2015-08-04T07:30:14.000Z",
                    "usage": "Configure NIC Teaming for Windows 2012 or later.\n(C) Copyright 2013 Hewlett-Packard Development Company, L.P.\n\nRequirements:\n* Minimum  2 members required for NIC Teaming.\n* Member should not be part of any other Team.\n\nRequired Parameters:\n* Field Name  lists the NIC characteristic that will be specified in the other parameters.  \n   Valid field names are:\n   Name\n   InterfaceDescription\n   ifIndex\n   Status\n   MacAddress\n   LinkSpeed\n\n* Values - The value(s) to be checked for that corresponds to the specified Field Name parameter.  \n* Note that no extra spaces should be used when specifying parameters.\n\nSample parameters values:\nStatus,Up         \t :  Teams all NICs that are active\nName,Ethernet,Ethernet 3 :  Teams the first and third NIC\n\nCustom Attributes:  None",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-08-04T07:30:14.000Z",
            "version": {
                "versionLabel": "31",
                "createdBy": "opsware",
                "createdDate": "2015-08-04T07:30:14.000Z",
                "usage": "Configure NIC Teaming for Windows 2012 or later.\n(C) Copyright 2013 Hewlett-Packard Development Company, L.P.\n\nRequirements:\n* Minimum  2 members required for NIC Teaming.\n* Member should not be part of any other Team.\n\nRequired Parameters:\n* Field Name  lists the NIC characteristic that will be specified in the other parameters.  \n   Valid field names are:\n   Name\n   InterfaceDescription\n   ifIndex\n   Status\n   MacAddress\n   LinkSpeed\n\n* Values - The value(s) to be checked for that corresponds to the specified Field Name parameter.  \n* Note that no extra spaces should be used when specifying parameters.\n\nSample parameters values:\nStatus,Up         \t :  Teams all NICs that are active\nName,Ethernet,Ethernet 3 :  Teams the first and third NIC\n\nCustom Attributes:  None",
                "current": true
            },
            "source": "## (C) Copyright 2012-2015 Hewlett-Packard Development Company, L.P.\nset  SEARCHFIELD=%1\nset  SEARCHPATTERN=%*\n\n;@Findstr -bv ;@F \"%~f0\" |powershell.exe -ExecutionPolicy Unrestricted -NoLogo -NonInteractive -NoProfile -Command  - & goto:eof\n\n## -------------------------------------------------------------------------------\n## Create-NICTeam\n## -------------------------------------------------------------------------------\n\nFunction Create-NicTeam ([string[]] $Members, [string]$TeamName)\n{\n$ListofTeams = Get-NetLbfoTeam\nif ($ListofTeams)\n{\nforeach ( $Team in $ListofTeams)\n{\nif ($Team.Name -eq $TeamName)\n{\nwrite-host \"Team $TeamName already exists - No action needed\"\nreturn\n}\n}\n}\nif ( $ListofNetworkNames.Count -gt 1)\n{\nwrite-host \" Creating new team $TeamName\"\n\nNew-NetLBfoTeam -AsJob -Name $TeamName -TeamMembers $Members -TeamingMode SwitchIndependent -LoadBalancingAlgorithm TransportPorts -confirm:$false\nreturn\n}\nelse\n{\nwrite-host \" There is less than 2 members in the Team list for $TeamName. Cannot create team\"\n}\n}\n## -------------------------------------------------------------------------------\n## Main Entry\n## -------------------------------------------------------------------------------\n\n$field=$env:SEARCHFIELD\nif ( $field -gt 0){write-host \"Parameter value found.\"}else{write-host \"Parameter value Not found. Exiting\"}\n \n$value=$env:SEARCHPATTERN\nif ( $value -gt 0){$valueSplit = $value.split(\",\")}else{write-host \"Parameter value Not found. Exiting\"}\n\nif ( $valueSplit.count -gt 1){$NetArray=$valueSplit[1..($valueSplit.count-1)]}else{write-host \" Network Adapter input Not found. Exiting\"}\n\n\nwrite-host \"Field used: $field\"\nwrite-host \"Network Adapter used: $NetArray\"\n\n$TeamMembers = @()\n$TeamName = \"Team-by-\"+\"$field\"\n$value=\"*\"+\"$value\"+\"*\"\n$NetAdapters = @()\n$ListofNetworkNames = @()\n\n\n$(ForEach($Element in $NetArray) {Get-NetAdapter | where $field -like $Element}) | set-variable NetAdapters\necho $NetAdapters\n\nif ( $NetAdapters.Count -gt 0){write-host \" Network Adapter found.\"}else{write-host \" Network Adapter Not found. Exiting\"}\nForeach ($Net in $NetAdapters){$ListofNetworkNames += $Net.Name}\nif ($ListofNetworkNames.Count -gt 0){Create-NicTeam -Members $ListofNetworkNames -TeamName $TeamName}\n",
            "description": "Configure NIC Teaming for Windows 2012 or later.\n(C) Copyright 2013 Hewlett-Packard Development Company, L.P.\n\nRequirements:\n* Minimum  2 members required for NIC Teaming.\n* Member should not be part of any other Team.\n\nRequired Parameters:\n* Field Name  lists the NIC characteristic that will be specified in the other parameters.  \n   Valid field names are:\n   Name\n   InterfaceDescription\n   ifIndex\n   Status\n   MacAddress\n   LinkSpeed\n\n* Values - The value(s) to be checked for that corresponds to the specified Field Name parameter.  \n* Note that no extra spaces should be used when specifying parameters.\n\nSample parameters values:\nStatus,Up         \t :  Teams all NICs that are active\nName,Ethernet,Ethernet 3 :  Teams the first and third NIC\n\nCustom Attributes:  None",
            "status": null,
            "name": "Configure NIC Teaming for Windows",
            "state": null,
            "eTag": "2015-08-04T07:30:14.000Z",
            "modified": "2015-08-04T07:30:14.000Z",
            "created": "2015-08-04T07:30:14.000Z",
            "category": "os-deployment-server-scripts",
            "uri": "/rest/os-deployment-server-scripts/1750001"
        },
        {
            "runAsSuperUser": true,
            "serverChanging": true,
            "codeType": "PY2",
            "displayCodeType": "Python",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "301",
                    "createdBy": "opsware",
                    "createdDate": "2015-08-04T07:30:15.000Z",
                    "usage": "Remaps the volumes to new drive letters, starting with \"C\".  Network drives are not remapped since those drive letters are explicitly assigned.  The \"X\" drive is reserved for WinPE and is not remapped either.\n\nOptional Parameters:\n--reservedDriveLetters=\"letter1 letter2 ... letterN\"    A space separated list of drive letters that are not to be assigned during the remapping.\n\nCustom Attributes:  None",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-08-04T07:30:15.000Z",
            "version": {
                "versionLabel": "301",
                "createdBy": "opsware",
                "createdDate": "2015-08-04T07:30:15.000Z",
                "usage": "Remaps the volumes to new drive letters, starting with \"C\".  Network drives are not remapped since those drive letters are explicitly assigned.  The \"X\" drive is reserved for WinPE and is not remapped either.\n\nOptional Parameters:\n--reservedDriveLetters=\"letter1 letter2 ... letterN\"    A space separated list of drive letters that are not to be assigned during the remapping.\n\nCustom Attributes:  None",
                "current": true
            },
            "source": "#!/usr/bin/python\n\n############################################################################################\n# (C) Copyright 2013-2015 Hewlett-Packard Development Company, L.P.\n#\n# This script performs the following steps:\n#\n# 1. Gets the list of logical disks using \"win32com\". Network drives and WinPE (drive \"X:\")\n#    are not included in the list because they must not be remapped.\n# 2. Since the VID drives show up with an interface type of \"USB\", they are moved to the\n#    end of the list, so that they are mapped last when the new drive letters are assigned.\n# 3. Unmaps the logical disks from their associated drive letter.\n# 4. Maps the local disks to a drive letter, starting with the letter \"C\", in the same\n#    order in which they were found.  If the drive letter is being used by a network drive,\n#    or the drive letter is in the \"--reservedDriveLetters\" parameter, then the next letter\n#    will by tried, and so on.\n#\n############################################################################################\n\nimport subprocess\nfrom subprocess import Popen, PIPE, STDOUT\n\nimport sys\nimport re\nimport win32com.client \n\nfrom osprov.osbp import logger\nfrom osprov.errors import ShowErrorMessage\nfrom optparse import OptionParser\n\nDRIVE_TYPE_UNKNOWN = 0\nDRIVE_TYPE_NO_ROOT_DIRECTORY = 1\nDRIVE_TYPE_REMOVABLE_DISK = 2\nDRIVE_TYPE_LOCAL_DISK = 3\nDRIVE_TYPE_NETWORK_DRIVE = 4\nDRIVE_TYPE_COMPACT_DISC = 5\nDRIVE_TYPE_RAM_DISK = 6\n\nLOG = logger.getIt('remap_windows_drives')\n\n############################################################################################\n# Class to parse command line arguments.\n############################################################################################\n\nclass CustomParser(OptionParser):\n\t\"\"\" a custom parser \"\"\"\n\tdef __init__(self, *args, **kwargs):\n\t\tOptionParser.__init__(self, *args, **kwargs)\n\t\tself.add_option(\"--reservedDriveLetters\",\n\t\t\t\thelp=\"A space-separated list of drive letters that should not be used when remapping the drives\")\n\n############################################################################################\n# A disk class to hold some basic information about the disks.\n############################################################################################\n\nclass MyDisk:\n\tdef __init__(self):\n\t\tself.volumeName = None\n\t\tself.driveLetter = None\n\t\tself.label = None\n\t\tself.driveType = DRIVE_TYPE_UNKNOWN\n\t\tself.serialNum = None\n\t\tself.interfaceType = None\n\t\tself.size = None\n\t\n\tdef setVolumeName(self, volumeName):\n\t\tself.volumeName = volumeName\n\n\tdef setDriveLetter(self, driveLetter):\n\t\tself.driveLetter = driveLetter\n\n\tdef setLabel(self, label):\n\t\tself.label = label\n\n\tdef setDriveType(self, driveType):\n\t\tself.driveType = driveType\n\n\tdef setSerialNum(self, serialNum):\n\t\tself.serialNum = serialNum\n\n\tdef setInterfaceType(self, interfaceType):\n\t\tself.interfaceType = interfaceType\n\n\tdef setSize(self, size):\n\t\tself.size = size\n\n\tdef getVolumeName(self):\n\t\treturn self.volumeName\n\n\tdef getDriveLetter(self):\n\t\treturn self.driveLetter\n\n\tdef getLabel(self):\n\t\treturn self.label\n\n\tdef getDriveType(self):\n\t\treturn self.driveType\n\n\tdef getSerialNum(self):\n\t\treturn self.serialNum\n\n\tdef getInterfaceType(self):\n\t\treturn self.interfaceType\n\n\tdef getSize(self):\n\t\treturn self.size\n\n############################################################################################\n# Returns a different sequential drive letter each time its called, starting with \"C\".\n############################################################################################\n\ndef getNextDriveLetter():\n\tif not hasattr(getNextDriveLetter, \"letter\"):\n\t\tgetNextDriveLetter.letter = 'C'  # it doesn't exist yet, so initialize it\n\telif (getNextDriveLetter.letter is not None):\n\t\tif (getNextDriveLetter.letter == 'Z'):\n\t\t\tgetNextDriveLetter.letter = None\n\t\telse:\n\t\t\tgetNextDriveLetter.letter = chr(ord(getNextDriveLetter.letter)+1)\n\n\treturn getNextDriveLetter.letter\n\n############################################################################################\n# Returns a description for the specified drive type.\n#\n# Parameters:\n#     driveType - The numeric drive type\n#\n# Returns:\n#     The description associated with the numeric drive type.\n#\n############################################################################################\n\ndef driveTypeToDescription(driveType):\n\n\tdescription = \"Unknown\"\n\n\tif (driveType is not None):\n\t\tif (driveType == DRIVE_TYPE_UNKNOWN):\n\t\t\tdescription = \"Unknown\"\n\t\telif (driveType == DRIVE_TYPE_NO_ROOT_DIRECTORY):\n\t\t\tdescription = \"No Root Directory\"\n\t\telif (driveType == DRIVE_TYPE_REMOVABLE_DISK):\n\t\t\tdescription = \"Removable Disk\"\n\t\telif (driveType == DRIVE_TYPE_LOCAL_DISK):\n\t\t\tdescription = \"Local Disk\"\n\t\telif (driveType == DRIVE_TYPE_NETWORK_DRIVE):\n\t\t\tdescription = \"Network Drive\"\n\t\telif (driveType == DRIVE_TYPE_COMPACT_DISC):\n\t\t\tdescription = \"Compact Disc\"\n\t\telif (driveType == DRIVE_TYPE_RAM_DISK):\n\t\t\tdescription = \"RAM Disk\"\n\n\treturn description\n\n############################################################################################\n# Shows some basic information about the specified disks to assist with troubleshooting.\n#\n# Parameters:\n#     logicalDisks - The list of logical disks on the system\n#\n############################################################################################\n\ndef showLogicalDisks(logicalDisks):\n\n\tvolumeNum = 0\n\n        print \"%-8s %-3s %-15s %-15s %-10s %-15s %-10s\" % (\"\", \"\", \"\", \"Drive\", \"Interface\", \"\", \"\")\n        print \"%-8s %-3s %-15s %-15s %-10s %-15s %-10s\" % (\"Volume #\", \"Ltr\", \"Label\", \"Type\", \"Type\", \"Size\", \"Serial Number\")\n        print \"%-8s %-3s %-15s %-15s %-10s %-15s %-10s\" % (\"--------\", \"---\", \"---------------\", \"---------------\", \"----------\", \"---------------\", \"----------\")\n\n\tfor logicalDisk in logicalDisks:\n\t\tif (logicalDisk.getDriveLetter() is not None):\n\t\t\tdriveLetter = logicalDisk.getDriveLetter()\n\t\telse:\n\t\t\tdriveLetter = \"\"\n\n\t\tif (logicalDisk.getLabel() is not None):\n\t\t\tlabel = logicalDisk.getLabel()\n\t\telse:\n\t\t\tlabel = \"\"\n\n\t\tif (logicalDisk.getInterfaceType() is not None):\n\t\t\tinterfaceType = logicalDisk.getInterfaceType()\n\t\telse:\n\t\t\tinterfaceType = \"\"\n\n\t\tif (logicalDisk.getSize() is not None):\n\t\t\tsize = logicalDisk.getSize()\n\t\telse:\n\t\t\tsize = \"\"\n\n\t\tif (logicalDisk.getSerialNum() is not None):\n\t\t\tserialNum = logicalDisk.getSerialNum()\n\t\telse:\n\t\t\tserialNum = \"\"\n\n\t\tprint \"%-8s %-3s %-15s %-15s %-10s %15s %-10s\" % (volumeNum, driveLetter, label, driveTypeToDescription(logicalDisk.getDriveType()), interfaceType, size, serialNum)\n\n\t\tvolumeNum += 1\n\n############################################################################################\n# Returns a list of the logical disks on the system.  Network drives and WinPE (drive \"X:\")\n# are not included in the list because they must not be remapped.\n############################################################################################\n\ndef getLogicalDisks():\n\t\n\t# The list of logical disks that we need to remap.\n\tlogicalDisks = []\t\n\n\t# The drive letters that are in use by a network drive or WinPE.  When we remap the\t\n\t# disks to a new drive letter, these drive letters will not used during the\t\n\t# remapping, since they are already in use.\n\tdriveLettersInUse = []\t\n\n\tstrComputer = \".\" \n\tobjWMIService = win32com.client.Dispatch(\"WbemScripting.SWbemLocator\") \n\tobjSWbemServices = objWMIService.ConnectServer(strComputer,\"root\\cimv2\") \n\tcolItems= objSWbemServices.ExecQuery(\"Select * from Win32_LogicalDisk\")\t\n\n\t# Create a list of the logical drives, but skip the network drives and the \"X:\"\n\t# drive, since that is reserved for WinPE.  The drive letters for any drives\n\t# we skip will be stored in the \"driveLettersInUse\" list, so that we know\n\t# that we can't use those letters when we are remapping the drives.\n\tfor objItem in colItems:\n\t\tif (objItem.Caption is None) or (len(objItem.Caption.strip()) == 0):\n\t\t\t# We are only interested in remapping drives that are already\n\t\t\t# mapped to a drive letter. It doesn't seem that our query\n\t\t\t# to Win32_LogicalDisk returns any logical disks that don't\n\t\t\t# have a drive letter assigned anyway, but we test for it\n\t\t\t# just as a precaution.\n\t\t\tprint \"Skipping drive with label '%s' because it's not mapped to a drive letter\" % objItem.VolumeName\n\t\telif (objItem.Caption == \"X:\"):\n\t\t\tprint \"Skipping drive '%s' which is reserved for WinPE\" % objItem.Caption\n\t\t\tdriveLettersInUse.append(objItem.Caption.replace(\":\", \"\"))\n\t\telif (objItem.driveType == DRIVE_TYPE_NETWORK_DRIVE):\n\t\t\tprint \"Skipping drive '%s' which is a network drive\" % objItem.Caption\n\t\t\tdriveLettersInUse.append(objItem.Caption.replace(\":\", \"\"))\t\n\t\telse:\n\t\t\tlogicalDisk = MyDisk()\n\t\t\tlogicalDisk.setDriveLetter(objItem.Caption)\n\t\t\tlogicalDisk.setLabel(objItem.VolumeName)\n\t\t\tlogicalDisk.setDriveType(objItem.DriveType)\n\t\t\tlogicalDisk.setSize(objItem.Size)\n\t\t\tlogicalDisk.setSerialNum(objItem.VolumeSerialNumber)\n\n\t\t\t# Get the interface type as reported by the \"diskpart\"\n\t\t\t# utility. The interface type is needed to help us identify\n\t\t\t# the VID drives, which show up with an interface type of\n\t\t\t# \"USB\".\n\t\t\tinterfaceType = getInterfaceTypeFromDriveLetter(logicalDisk.getDriveLetter().replace(\":\", \"\"))\n\t\t\tlogicalDisk.setInterfaceType(interfaceType)\n\n\t\t\t# Get the volume name that's mapped to the specified\n\t\t\t# drive letter.\n\t\t\tvolumeName = getVolumeNameFromDriveLetter(logicalDisk.getDriveLetter());\n\t\t\tlogicalDisk.setVolumeName(volumeName)\n\n\t\t\tlogicalDisks.append(logicalDisk)\n\n   \treturn logicalDisks, driveLettersInUse\n\n############################################################################################\n# Returns the \"diskpart\" volume number associated with the specified drive letter.\n#\n# Parameters:\n#     driveLetter - The drive letter\n#\n############################################################################################\n\ndef getVolumeNumFromDriveLetter(driveLetter):\n\n\tvolumeNumber = None\n\n\tdiskpartCmd = \"list volume\\n\"\n\n\t# Run \"diskpart\" and list the volumes.\n\tp = subprocess.Popen(['diskpart'],stdout=PIPE,stderr=STDOUT,stdin=PIPE)\n\n\t# Get the stdout/stderr of the command.\n\tdiskpart_stdout = p.communicate(input=diskpartCmd)[0]\n\n\tretCode = p.poll()\n\n\tp.stdout.close()\n\n\t# This regular expression extracts the volume number associated with the drive\n\t# letter if there's a match. The \"(\\d+)\" is what puts the volume number for the\n\t# matching drive letter in the variable \"result.group(1)\".\n\tpattern = re.compile(r\"^\\s*Volume\\s*(\\d+)\\s*\" + driveLetter + \"\\s*.*\")\n\n\tfor line in diskpart_stdout.splitlines():\n\t\tresult = pattern.search(line)\n\n\t\tif result:\n\t\t\tvolumeNumber = result.group(1)\n\t\t\tbreak\n\n\treturn volumeNumber\n\n############################################################################################\n# Returns the volume name associated with the specified drive letter.\n#\n# Parameters:\n#     driveLetter - The drive letter\n#\n############################################################################################\n\ndef getVolumeNameFromDriveLetter(driveLetter):\n\n\tvolumeName = None\n\n\tmountPoint = driveLetter + \"\\\\\"\n\n\t# Use the \"mountvol\" command to list the volume name for the specified mount point.\n\tp = subprocess.Popen ([\"mountvol\", mountPoint, \"/L\"], stdout=subprocess.PIPE, stderr=STDOUT)\n\tmountvol_stdout = p.communicate()[0].strip()\n\n\tretCode = p.poll()\n\n\tp.stdout.close()\n\n\tif (retCode != 0):\n\t\traise ShowErrorMessage(\"An error occurred while executing 'mountvol %s %s' : %s\" % (mountPoint, \"\\L\", mountvol_stdout))\n\telse:\n\t\tvolumeName = mountvol_stdout\n\n\treturn volumeName\n\n############################################################################################\n# Returns the interface type (e.g. \"USB\", \"FIBRE\", \"RAID\", etc) associated with the\n# specified drive letter.  We have to first map the drive letter to the volume number as\n# reported by \"diskpart\".  Once we have the volume number, we can select the volume in\n# \"diskpart\" and tell it to give us the details for the disk.  The details will report the\n# interface type in the \"Type :\" field, so we must parse the output of the details and\n# extract the value from the \"Type :\" field.\n#\n# Parameters:\n#     driveLetter - The drive letter\n#\n############################################################################################\n\ndef getInterfaceTypeFromDriveLetter(driveLetter):\n\n\tdriveType = None\n\n\t# Get the volume number, as reported by \"diskpart\", that's associated with the\n\t# drive letter.\n\tvolumeNum = getVolumeNumFromDriveLetter(driveLetter)\n\n\tif (volumeNum is not None):\n\t\t# Tell \"diskpart\" to give us the details for the disk associated with the\n\t\t# specified volume number.  The details contain a \"Type :\" field that has\n\t\t# the interface type of the disk.\n\t\tdiskpartCmd = \"select volume \" + str(volumeNum) + \"\\n\" + \"detail disk\" + \"\\n\"\n\n\t\tp = subprocess.Popen(['diskpart'],stdout=PIPE,stderr=STDOUT,stdin=PIPE)\n\n\t\t# Get the stdout/stderr of the command.\n\t\tdiskpart_stdout = p.communicate(input=diskpartCmd)[0]\n\n\t\tretCode = p.poll()\n\n\t\tp.stdout.close()\n\n\t\t# This regular expression extracts the interface type from the \"Type :\"\n\t\t# field, if there's a match. The \"(.+)\" is what puts the interface type\n\t\t# in the variable \"result.group(1)\".\n\t\tpattern = re.compile(r\"^\\s*Type\\s*:\\s*(.+)\\s*$\")\n\n\t\tfor line in diskpart_stdout.splitlines():\n\t\t\tresult = pattern.search(line)\n\n\t\t\tif result:\n\t\t\t\tdriveType = result.group(1)\n\t\t\t\tbreak\n\n\treturn driveType\n\n############################################################################################\n# Moves any USB drives to the end of the list of logical disks.\n#\n# Parameters:\n#     logicalDisks - The list of logical disks on the system\n#\n############################################################################################\n\ndef moveUsbDrivesToEndOfList(logicalDisks):\n\n        reorderedLogicalDisks = []\n\n\tusbDisks = []\n\n\t# Remove any VID disks from the logical disk list.\n        for logicalDisk in logicalDisks:\n\t\tif (logicalDisk.getInterfaceType() == \"USB\"):\n\t\t\t # Append the disk to the USB list.\n\t\t\tusbDisks.append(logicalDisk)\n\t\telse:\n\t\t\t# Append the disk to the reordered logical disk list.\n\t\t\treorderedLogicalDisks.append(logicalDisk)\n\n\t# Put back the USB disks at the end of the reordered logical disk list.\n\tfor usbDisk in usbDisks:\n\t\treorderedLogicalDisks.append(usbDisk)\n\n        return reorderedLogicalDisks\n\n############################################################################################\n# Assigns drive letters to the unmapped disks.\n#\n# Parameters:\n#    unmappedDisks - The disks that are not mapped to a drive letter.\n#    reservedDriveLetters - A list of drive letters that are in use or resevered, so that we\n#                           don't try to assign one of those drive letters to an unmapped\n#                           disk.\n############################################################################################\n\ndef assignDriveLetters(unmappedDisks, reservedDriveLetters):\n\n \tprint \"Assigning drive letters\"\n\n\tprint \"The following drive letters are reserved or in use : \" + ','.join(reservedDriveLetters)\n\n        volumeNum = 0\n\n\tfor disk in unmappedDisks:\n               # Only map a drive letter to a local disk.  Disks on a SAN should be identified\n                # as local disks.\n                if (disk.getDriveType() == DRIVE_TYPE_LOCAL_DISK):\n\t\t\t# Get a drive letter that's not reserved or is already in use by another disk.\n\t\t\tdriveLetter = getNextDriveLetter()\n\t\t\twhile ((driveLetter is not None) and (driveLetter in reservedDriveLetters)):\n\t\t\t\tprint \"Drive letter '%s' is reserved or is in use.  Trying next drive letter.\" % driveLetter\n\t\t\t\tdriveLetter = getNextDriveLetter()\n\n\t\t\t# Map the disk to the drive letter.\n\t\t\tif (driveLetter is not None):\n\t\t\t\tmountPoint = driveLetter + \":\\\\\"\n\t\t\t\tprint \"Remapping volume '%s' as drive letter '%s'\" % (disk.getVolumeName(),driveLetter)\n\n\t\t\t\tp = subprocess.Popen ([\"mountvol\", mountPoint, disk.getVolumeName()], stdout=subprocess.PIPE, stderr=STDOUT)\n\n\t\t\t\t# Get the stdout/stderr of the command.\n\t\t\t\tmountvol_stdout = p.communicate()[0]\n\n\t\t\t\tretCode = p.poll()\n\n\t\t\t\tp.stdout.close()\n\n\t\t\t\tif (retCode != 0):\n\t\t\t\t\tprint \"AN ERROR OCCURRED\"\n\t\t\t\t\traise ShowErrorMessage(\"An error occurred while executing 'mountvol %s %s' : %s\" % (mountPoint, disk.getVolumeName(), mountvol_stdout))\n\t\t\t\telse:\n\t\t\t\t\t# Update the drive letter. This is done so we\n\t\t\t\t\t# can display the new drive letter assignments\n\t\t\t\t\t# when we're done with the remapping.\n\t\t\t\t\tdisk.setDriveLetter(driveLetter)\n\t\t\telse:\n\t\t\t\traise ShowErrorMessage(\"No more drive letters to assign to volume '%s'\" % disk.getVolumeName())\n                else:\n\t\t\t# Clear the drive letter, since we're not going to remap this drive.\n\t\t\t# This is done so that when we display the remapped drives, we can\n\t\t\t# see that this drive wasn't mapped to a letter.\n\t\t\tdisk.setDriveLetter(None)\n\n                        print \"Not remapping volume '%s' because its drive type is '%s'\" % (disk.getVolumeName(),driveTypeToDescription(disk.getDriveType()))\n\n\t\tvolumeNum += 1\n\n############################################################################################\n# Remove the drive letters from the specified list of disks.\n#\n# Parameters:\n#     logicalDisks - The list of logical disks on the system\n#\n############################################################################################\n\ndef removeDriveLetters(logicalDisks):\n\n \tprint \"Removing drive letters\"\n\n\tfor disk in logicalDisks:\n\t\tmountPoint = disk.getDriveLetter() + \"\\\\\"\n\n\t\tprint \"Removing mount point '%s' for volume '%s'\" % (mountPoint,disk.getVolumeName())\n\n\t\t# Remove the volume mount point, effectively removing the drive letter from\n\t\t# the volume. \n\t\tp = subprocess.Popen ([\"mountvol\", mountPoint, \"/D\"], stdout=subprocess.PIPE, stderr=STDOUT)\n\t\tmountvol_stdout = p.communicate()[0].strip()\n\n\t\tretCode = p.poll()\n\n\t\tp.stdout.close()\n\n\t\tif (retCode != 0):\n\t\t\tprint \"AN ERROR OCCURRED\"\n\t\t\traise ShowErrorMessage(\"An error occurred while executing 'mountvol %s %s' : %s\" % (mountPoint, \"\\D\", mountvol_stdout))\n\n############################################################################################\n# Remaps the specific disks so that their drive letters begin with \"C:\", \"D:\", \"E:\", etc.\n#\n# Parameters:\n#    logicalDisks - The list of disks that are to be remapped.\n#    reservedDriveLetters - A list of drive letters that are in use or resevered, so that we\n#                           don't try to assign one of those drive letters to an unmapped\n#                           disk.\n############################################################################################\n\ndef remapDrives(logicalDisks, reservedDriveLetters):\n\n\tremoveDriveLetters(logicalDisks)\n\n\tassignDriveLetters(logicalDisks, reservedDriveLetters)\n\n############################################################################################\n# The main function.\n############################################################################################\n\ndef main(argv):\n\n\treservedDriveLetters = []\n\n\ttry:\n        \targs_parser = CustomParser()\n        \toptions, remaining_args = args_parser.parse_args(sys.argv[1:])\n\n\t\tif (options.reservedDriveLetters is not None):\n\t\t\t# Remove any occurrence of \":\", since the SystemDrive custom\n\t\t\t# attribute may be used in the parameter and it contains a \":\"\n\t\t\t# after the drive letter.\n\t\t\ttempDriveLetters = options.reservedDriveLetters.replace(':', '')\n\n\t\t\t# Collapse multiple spaces between the letters into a single space,\n\t\t\t# then split the string and create a list of drive letters.\n\t\t\trex = re.compile(r'\\W+')\t\n\t\t\ttempDriveLetters = rex.sub(' ', tempDriveLetters)\n\n\t\t\treservedDriveLetters = rex.sub(' ', tempDriveLetters).split(' ')\n\n\t\tlogicalDisks, driveLettersInUse = getLogicalDisks()\n\n\t\t# Add the drive letters assigned to network drives and WinPE to the list\n\t\t# of reserved letters.\n\t\treservedDriveLetters.extend(driveLettersInUse)\n\n\t\t# Convert drive letters to uppercase.\n\t\treservedDriveLetters = [x.upper() for x in reservedDriveLetters]\n\n\t\tprint \"Disks before remapping\"\n\n\t\tshowLogicalDisks(logicalDisks)\n\n\t\tlogicalDisks = moveUsbDrivesToEndOfList(logicalDisks)\n\n\t\tremapDrives(logicalDisks, reservedDriveLetters)\n\n\t\tprint \"Disks after remapping\"\n\n\t\tshowLogicalDisks(logicalDisks)\n\texcept (ShowErrorMessage), why:\n\t\tLOG.exception(why)\n\t\tsys.stderr.write(\"Failed to remap Windows drives: %s\\n\" % why)\n\t\treturn 1\n\nif __name__ == \"__main__\":\n\tsys.exit(main(sys.argv))",
            "description": "Remaps the volumes to new drive letters, starting with \"C\".  Network drives are not remapped since those drive letters are explicitly assigned.  The \"X\" drive is reserved for WinPE and is not remapped either.\n\nOptional Parameters:\n--reservedDriveLetters=\"letter1 letter2 ... letterN\"    A space separated list of drive letters that are not to be assigned during the remapping.\n\nCustom Attributes:  None",
            "status": null,
            "name": "Remap Windows Drives",
            "state": null,
            "eTag": "2015-08-04T07:30:15.000Z",
            "modified": "2015-08-04T07:30:15.000Z",
            "created": "2015-08-04T07:30:15.000Z",
            "category": "os-deployment-server-scripts",
            "uri": "/rest/os-deployment-server-scripts/1770001"
        },
        {
            "runAsSuperUser": true,
            "serverChanging": true,
            "codeType": "SH",
            "displayCodeType": "Unix",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "19",
                    "createdBy": "opsware",
                    "createdDate": "2015-08-04T07:30:16.000Z",
                    "usage": "This script is intended to accompany the Insight Control server provisioning Capturing and Installing Linux System Images white paper. \n\nThis script captures the target servers image and transfers it to a location on the Media Server.  \n\nRequired Parameters: Image name",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-08-04T07:30:16.000Z",
            "version": {
                "versionLabel": "19",
                "createdBy": "opsware",
                "createdDate": "2015-08-04T07:30:16.000Z",
                "usage": "This script is intended to accompany the Insight Control server provisioning Capturing and Installing Linux System Images white paper. \n\nThis script captures the target servers image and transfers it to a location on the Media Server.  \n\nRequired Parameters: Image name",
                "current": true
            },
            "source": "#!/bin/sh\ncd /mnt/target\n\n#tar jcf /mnt/images/$1.tar.bz2 .\n#verify tar zcf /mnt/images/$1.tar.gz .\ntar zcf /mnt/images/$1.tar.bz2 .\nexit $?\n",
            "description": "This script is intended to accompany the Insight Control server provisioning Capturing and Installing Linux System Images white paper. \n\nThis script captures the target servers image and transfers it to a location on the Media Server.  \n\nRequired Parameters: Image name",
            "status": null,
            "name": "Sample - Capture Linux Server Image",
            "state": null,
            "eTag": "2015-08-04T07:30:16.000Z",
            "modified": "2015-08-04T07:30:16.000Z",
            "created": "2015-08-04T07:30:16.000Z",
            "category": "os-deployment-server-scripts",
            "uri": "/rest/os-deployment-server-scripts/1780001"
        },
        {
            "runAsSuperUser": true,
            "serverChanging": true,
            "codeType": "PY2",
            "displayCodeType": "Python",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "35",
                    "createdBy": "opsware",
                    "createdDate": "2015-08-04T07:30:16.000Z",
                    "usage": "Script searches for the special embedded SD card or USB device on ProLiant servers.  If the card is found, the custom attribute 'boot_disk' is set to the device associated with the card.  The 'boot_disk' CA is used in the \"Create Stub Partition\" step to force the creation of the initial installation OS boot partition on a specific disk.\n\nThis step will not clear boot_disk if the CA is set, but no device is found.\n\nOption:\n--embeddedDevice=EMBEDDEDDEVICE : The name of embedded device to be detected for OS deployment. If not specified, either embedded SD-CARD or USB will be detected if present.\n     Possible values:\n                 sd_card\n                     - It is used to detect embedded SD-CARD on the target server.\n                 usb\n                     - It is used to detect embedded USB on the target server.\n     \nCustom Attributes: sets 'boot_disk' (Copied from /Opsware/Tools/Build Plans/Steps/ProLiant/Find SD Card on Server id:1570001)",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-08-04T07:30:16.000Z",
            "version": {
                "versionLabel": "35",
                "createdBy": "opsware",
                "createdDate": "2015-08-04T07:30:16.000Z",
                "usage": "Script searches for the special embedded SD card or USB device on ProLiant servers.  If the card is found, the custom attribute 'boot_disk' is set to the device associated with the card.  The 'boot_disk' CA is used in the \"Create Stub Partition\" step to force the creation of the initial installation OS boot partition on a specific disk.\n\nThis step will not clear boot_disk if the CA is set, but no device is found.\n\nOption:\n--embeddedDevice=EMBEDDEDDEVICE : The name of embedded device to be detected for OS deployment. If not specified, either embedded SD-CARD or USB will be detected if present.\n     Possible values:\n                 sd_card\n                     - It is used to detect embedded SD-CARD on the target server.\n                 usb\n                     - It is used to detect embedded USB on the target server.\n     \nCustom Attributes: sets 'boot_disk' (Copied from /Opsware/Tools/Build Plans/Steps/ProLiant/Find SD Card on Server id:1570001)",
                "current": true
            },
            "source": "#!/usr/bin/python\n# (C) Copyright 2013-2015 Hewlett-Packard Development Company, L.P.\n\nimport os\nimport sys\nimport re\nimport optparse\n\nfrom osprov.osbp import logger\nfrom osprov.diskmgr import const\nfrom osprov.util import process\nfrom osprov.diskmgr.diskmanager import DiskManager, LinuxDiskManager\nfrom osprov.diskmgr.disk import Disk\nfrom osprov.diskmgr.disk import LinuxDisk\nfrom osprov.parsers.proc_partitions import ProcPartitionsParser\n\nfrom osprov.server.local import ThisLocalServer\n\nfrom osprov import helpers\n\nID_BUS = re.compile(\"E: ID_BUS=*\")\nID_VENDOR = re.compile(\"E: ID_VENDOR=*\")\nID_MODEL = re.compile(\"E: ID_MODEL=*\")\nBOOT_DISK_CA = \"boot_disk\"\n\nLOG = logger.getIt(\"osprov.diskmgr\")\n\ndef getEmbeddedDeviceOption() :\n    \"\"\" Parse the embedded device parameters \"\"\"\n\n    parser = optparse.OptionParser()\n\n    parser.add_option(\"--embeddedDevice\", default = \"auto\",\n                       help = \"It is the name of embedded device to be detected for \\\n                       OS deployment. If not specified, it will search for either \\\n                       embedded SD-CARD or USB.\\\n                       Example: --embeddedDevice=sd_card or --embeddedDevice=usb.\")\n\n    return parser.parse_args()\n\ndef setBootDiskCA(targetServer, deviceName):\n    # if device name specified, then set the CA for the \n    # target server to it.  This will over ride the options in \n    # the \"Create Stub Partition\" step and force the use of the \n    # disk to be used as the target.\n    if deviceName:\n        serverRef = targetServer.getServerRef()\n        twistServer = targetServer.twistServer\n        twistServer.server.ServerService.setCustAttr(serverRef,\n            BOOT_DISK_CA, deviceName)   \n\n# Find all disks and then loop through them looking for \n# any disks that match the criteria used to designate an \n# embedded SD card or USB.\n\ndef getBootDisk(device):\n    # Find all disks.\n    disks = []\n    print \"Finding all disks..\"\n    procPartitions = ProcPartitionsParser(open(const.PROC_PARTITIONS, \"r\")).info()\n    for deviceName,major,minor,blocs in procPartitions:\n        if \"loop\" in deviceName:\n            continue\n        if LinuxDiskManager.mod_map.has_key(major):\n            if minor % LinuxDiskManager.mod_map[major] == 0:\n                disks.append(LinuxDisk(deviceName, major, minor))\n        elif minor == 0:\n            disks.append(LinuxDisk(deviceName, major, minor))\n    \n    if not disks:\n\t# No disks found, just return.\n\tprint \"No disks found at all!!\"\n\treturn None\n\n    bootDiskPath = \"\"\n    print \"Looking for matching disks..\"\n    for disk in disks:\n        hpvendor = False\n        hpilo = False\n        usb = False\n        sdcard = False\n        usb_model = False\n        diskpath = disk.getDeviceFilePath()\n        devInfoOutput = process.getStdout([\"udevadm\", \"info\", \"-q\", \"all\", \"-n\",\n                diskpath], log=LOG)\n        for line in devInfoOutput.split('\\n'):\n            match = ID_BUS.match(line)\n            if match and \"usb\" in line:\n                # Disk is a USB disk\n                usb = True\n            match = ID_VENDOR.match(line)\n            if match and \"HP_iLO\" in line:\n                # Disk is embedded\n                hpilo = True\n            elif match and \"HP\" in line:\n                # Device vendor is HP\n                hpvendor = True\n            match = ID_MODEL.match(line)\n            if match and \"Internal_SD-CARD\" in line:\n                # Disk is an embedded SD card.\n                sdcard = True\n                print \"Detected Embedded SD-CARD\"\n            elif match and \"USB_RAID_LUN\" in line:\n                # Disk is an embedded USB.\n                usb_model = True\n                print \"Detected Embedded USB\"\n            \n        # if criteria met, add disk to list else drop it.\n        if (usb and sdcard and hpilo and device==1) or (usb and hpvendor and usb_model and device==2):\n            # Search for the device based on user specified name.\n            print \"  %s matched criteria\" % diskpath\n            bootDiskPath = diskpath\n            break\n        # If embeddedDevice parameter is not specified, then search for either SD-CARD or USB.\n        elif (usb and sdcard and hpilo and device==0) or (usb and hpvendor and usb_model and device==0):\n            print \" %s matched criteria\" % diskpath\n            bootDiskPath = diskpath\n            break\n        else:\n            print \"  %s did not match criteria\" % diskpath\n    \n    return bootDiskPath\n\ndef main():\n    (options, remainder) = getEmbeddedDeviceOption()\n\n    #device is the integer variable defined for user specific embedded device.\n    #Example : device = 1 for embedded SD-CARD, device = 2 for embedded USB and device = 0 for both.  \n    if options.embeddedDevice == \"auto\" :\n        device = 0\n        print \"Looking for either embedded SD-CARD or USB\"\n    elif options.embeddedDevice == \"sd_card\" :\n        device = 1\n        print \"Looking for embedded SD-CARD\"\n    elif options.embeddedDevice == \"usb\" :\n        device = 2\n        print \"Looking for embedded USB device\"\n    else :\n        print \"Please specify the valid option for embeddedDevice parameter. Use --help for more details.\"\n        sys.exit(1)\n\n    bootDisk = getBootDisk(device)\n    if not bootDisk:\n        if (device == 1 or device == 2):\n            print \"User specified embedded device not found\"\n        else:\n            print \"No embedded SD-CARD or USB drives found\"\n        sys.exit(1)\n    else:\n        print \"Setting boot_disk to %s\" % bootDisk\n        targetServer = ThisLocalServer()\n        setBootDiskCA(targetServer, bootDisk)\n        \nif __name__ == \"__main__\":\n    main()",
            "description": "Script searches for the special embedded SD card or USB device on ProLiant servers.  If the card is found, the custom attribute 'boot_disk' is set to the device associated with the card.  The 'boot_disk' CA is used in the \"Create Stub Partition\" step to force the creation of the initial installation OS boot partition on a specific disk.\n\nThis step will not clear boot_disk if the CA is set, but no device is found.\n\nOption:\n--embeddedDevice=EMBEDDEDDEVICE : The name of embedded device to be detected for OS deployment. If not specified, either embedded SD-CARD or USB will be detected if present.\n     Possible values:\n                 sd_card\n                     - It is used to detect embedded SD-CARD on the target server.\n                 usb\n                     - It is used to detect embedded USB on the target server.\n     \nCustom Attributes: sets 'boot_disk' (Copied from /Opsware/Tools/Build Plans/Steps/ProLiant/Find SD Card on Server id:1570001)",
            "status": null,
            "name": "Find SD Card on Server",
            "state": null,
            "eTag": "2015-08-04T07:30:16.000Z",
            "modified": "2015-08-04T07:30:16.000Z",
            "created": "2015-08-04T07:30:16.000Z",
            "category": "os-deployment-server-scripts",
            "uri": "/rest/os-deployment-server-scripts/1790001"
        },
        {
            "runAsSuperUser": true,
            "serverChanging": true,
            "codeType": "PY2",
            "displayCodeType": "Python",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "13",
                    "createdBy": "opsware",
                    "createdDate": "2015-08-04T07:30:17.000Z",
                    "usage": "Reports the results of the SPP installation, by collecting the HP SUM return code from a file left behind by the \"Install Windows SPP In Background\" step.\n\nOptions:\n    --fail_on_warning  Causes the build plan step to fail if the HP SUM return code is -3, which means that there were some components that could not be installed.\n\nRequirements:\n* The \"Install Windows SPP In Background\" step must have been previously run.\n",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-08-04T07:30:17.000Z",
            "version": {
                "versionLabel": "13",
                "createdBy": "opsware",
                "createdDate": "2015-08-04T07:30:17.000Z",
                "usage": "Reports the results of the SPP installation, by collecting the HP SUM return code from a file left behind by the \"Install Windows SPP In Background\" step.\n\nOptions:\n    --fail_on_warning  Causes the build plan step to fail if the HP SUM return code is -3, which means that there were some components that could not be installed.\n\nRequirements:\n* The \"Install Windows SPP In Background\" step must have been previously run.\n",
                "current": true
            },
            "source": "#!/usr/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n#\n\"\"\"\n(C) Copyright 2014-2015 Hewlett-Packard Development Company, L.P.\n\"\"\"\n\nimport sys\nimport os\nfrom optparse import OptionParser\n\nwindowsSystemDrive = os.getenv(\"SystemDrive\")\nwindowsTempDir = windowsSystemDrive + \"\\\\Windows\\\\Temp\"\nlocalHpSumDir = windowsTempDir + \"\\\\LocalHpSum\"\nicspTempDir = windowsTempDir + \"\\\\icsp\"\nhpSumExitCodeFile = icspTempDir + \"\\\\hpsum_exit_code.txt\"\n\n##############################################################################\n# Parses the command line arguments.\n##############################################################################\n\ndef parseArgs(args):\n    parser = OptionParser()\n    parser.add_option(\"--fail_on_warning\",\n            action = \"store_true\",\n            default = False,\n            dest = \"failOnWarning\",\n            help=\"Causes the build plan step to fail if hpsum could not install one of the components\")\n    options, args = parser.parse_args(args)\n    if args:\n        parser.error(\"Additional positional arguments are not supported\")\n    return options, args\n\n##############################################################################\n# Returns the HP SUM return code.\n##############################################################################\n\ndef getHpSumExitCode():\n\n    exitCode = \"0\";\n\n    if (os.path.exists(hpSumExitCodeFile)):\n        try:\n            f = open( hpSumExitCodeFile, 'r')\n\n            contents = f.read();\n\n            exitCode = contents.strip()\n\n            f.close();\n        except (Exception), why:\n            raise Exception(\"An error occurred while reading '%s': %s\" % (hpSumExitCodeFile,why))\n    else:\n        raise Exception(\"'%s' not found\" % hpSumExitCodeFile)\n\n    return exitCode\n\n##############################################################################\n# Main Routine\n##############################################################################\n\ndef main():\n\n    retCode = 0\n\n    options, remaining_args = parseArgs(sys.argv[1:])\n\n    # If this is set to True, then a \"-3\" returned by HP SUM will result in\n    # the build plan step returning an error.\n    failOnWarning = options.failOnWarning\n\n    try:\n        hpSumExitCode = getHpSumExitCode()\n\n        print \"HP SUM return code is '%s'\" % hpSumExitCode\n\n        if (hpSumExitCode == \"0\"):\n            print \"The installation was successful\"\n        elif (hpSumExitCode == \"1\"):\n            print \"The installation was successful, but a reboot is required\"\n        elif (hpSumExitCode == \"3\"):\n            print \"The component was current or not required\"\n        elif (hpSumExitCode == \"-1\"):\n            print \"A general failure occurred.  For details, see the error log.\"\n            retCode = 1\n        elif (hpSumExitCode == \"-2\"):\n            print \"A bad input parameter was encountered\"\n            retCode = 1\n        elif (hpSumExitCode == \"-3\"):\n            print \"The installation of the component failed\"\n            if (failOnWarning):\n                retCode = 1\n        else:\n            print \"Unknown HP SUM return code\"\n            retCode = 1\n    except (Exception), why:\n        retCode = 1\n        sys.stderr.write(\"%s\" % why)\n\n    return retCode\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n",
            "description": "Reports the results of the SPP installation, by collecting the HP SUM return code from a file left behind by the \"Install Windows SPP In Background\" step.\n\nOptions:\n    --fail_on_warning  Causes the build plan step to fail if the HP SUM return code is -3, which means that there were some components that could not be installed.\n\nRequirements:\n* The \"Install Windows SPP In Background\" step must have been previously run.\n",
            "status": null,
            "name": "Report Windows SPP Installation Results",
            "state": null,
            "eTag": "2015-08-04T07:30:17.000Z",
            "modified": "2015-08-04T07:30:17.000Z",
            "created": "2015-08-04T07:30:17.000Z",
            "category": "os-deployment-server-scripts",
            "uri": "/rest/os-deployment-server-scripts/1800001"
        },
        {
            "runAsSuperUser": true,
            "serverChanging": true,
            "codeType": "SH",
            "displayCodeType": "Unix",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "12",
                    "createdBy": "opsware",
                    "createdDate": "2015-08-04T07:30:17.000Z",
                    "usage": "This script is intended to accompany the Insight Control server provisioning Capturing and Installing Linux System Images white paper. \n\nThis script sets up the target server to re-install the HP SA Agent after the server has rebooted for the first time into production. \n\nRequired Parameters: IP address of the appliance\n",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-08-04T07:30:17.000Z",
            "version": {
                "versionLabel": "12",
                "createdBy": "opsware",
                "createdDate": "2015-08-04T07:30:17.000Z",
                "usage": "This script is intended to accompany the Insight Control server provisioning Capturing and Installing Linux System Images white paper. \n\nThis script sets up the target server to re-install the HP SA Agent after the server has rebooted for the first time into production. \n\nRequired Parameters: IP address of the appliance\n",
                "current": true
            },
            "source": "#!/bin/bash\n# (C) Copyright 2012-2015 Hewlett-Packard Development Company, L.P.\nicspip=\"@@REPLACE_ME@@\"\n\nif [ \"$icspip\" == \"@@REPLACE_ME@@\" ]; then\n\n# script is running on server as part of deployment\n# need to set it up so that it runs after rebooting\n# deployed server.\n   if [ -f \"$0\" ]; then\n      sed -i -e \"s/=\\\"@@REPLACE_ME@@/=\\\"$1/\" $0\n      # copy server into /rc{3,5}.d to run on startup.\n      cp $0 /mnt/target/etc/rc.d/rc3.d/S40hpsa_agent_installer\n      cp $0 /mnt/target/etc/rc.d/rc5.d/S40hpsa_agent_installer\n      rm -rf /mnt/target/etc/opt/opsware/agent/mid\n      rm -rf /mnt/target/var/opt/opsware/crypto/agent\n      cp -R /var/opt/opsware/crypto/agent \\\n        /mnt/target/var/opt/opsware/crypto\n      cp /etc/opt/opsware/agent/mid \\\n        /mnt/target/etc/opt/opsware/agent/mid\n   else\n      echo \"Could not find script $0\"\n      exit 1\n   fi\n   rm -rf /mnt/target/etc/rc*.d/*opsware*\n   echo \"Done creating installation script for post reboot agent\\\n   installation..\"\n   exit 0\n else\n   cp /etc/rc.d/rc3.d/S40hpsa_agent_installer /tmp\n   rm -rf /etc/rc.d/rc?.d/S40hpsa_agent_installer\n fi\n\nlogfile=/tmp/Migrate.log\n\ncd /tmp\n\nfilename=\"\"\n\necho \"**************************************************\" >> $logfile\necho \"******************** Start ***********************\" >> $logfile\necho \"**************************************************\" >> $logfile\n\necho `date` >> $logfile\nuname -a | grep 86_64\nif [ $? -eq 1 ] ; then\n   echo \"Cannot migrate x86 target\" >> $logfile\n   exit \"11\"\nfi\n\nif [ -e /etc/redhat-release ] ; then\n    cat /etc/redhat-release | grep \"6.*\"\n    if [ $? -eq 0 ] ; then\n       echo \"found RHEL6\" >> $logfile\n       filename=\"opsware-agent-LINUX-6SERVER-X86_64\"\n    fi\n    cat /etc/redhat-release | grep \"5.*\"\n    if [ $? -eq 0 ] ; then\n       echo \"found RHEL5\" >> $logfile\n       filename=\"opsware-agent-LINUX-5SERVER-X86_64\"\n    fi\nfi\nif [ -e /etc/SuSE-release ] ; then\n     cat /etc/SuSE-release | grep -i \"version = 11\"\n     if [ $? -eq 0 ] ; then\n        echo \"found sles11\" >> $logfile\n        filename=\"opsware-agent-LINUX-SLES-11-X86_64\"\n     fi\n\n     cat /etc/SuSE-release | grep -i \"version = 10\"\n     if [ $? -eq 0 ] ; then\n         echo \"found sles10\" >> $logfile\n         filename=\"opsware-agent-LINUX-SLES-10-X86_64\"\n     fi\n\nfi\n\necho \"File to Download -> $filename\" >> $logfile\n## Wait for NIC to come up properly\nsleep 60\nif [ -n \"$filename\" ] ; then\n\n   wget http://$icspip:8081/$filename >> $logfile\n   if [ -e \"$filename\" ] ; then\n      chmod +x $filename\n      echo \"Execute ./$filename -s --opsw_gw_list $icspip:3001\" \\\n      >> $logfile\n      ./$filename -s --settime --force_full_hw_reg --force_sw_reg \\\n      --opsw_gw_list $icspip:3001 >> $logfile\n   else\n      echo \"Download failed for http://$icspip:8081/$filename\" \\\n      >> $logfile\n     exit \"1\"\n   fi\nelse\n    echo \"Download failed for http://$icspip:8081/$filename\" \\\n    >> $logfile\nexit \"1\"\nfi\n\nexit 0\n",
            "description": "This script is intended to accompany the Insight Control server provisioning Capturing and Installing Linux System Images white paper. \n\nThis script sets up the target server to re-install the HP SA Agent after the server has rebooted for the first time into production. \n\nRequired Parameters: IP address of the appliance\n",
            "status": null,
            "name": "Sample - Re-Install SLES HP SA Agent",
            "state": null,
            "eTag": "2015-08-04T07:30:17.000Z",
            "modified": "2015-08-04T07:30:17.000Z",
            "created": "2015-08-04T07:30:17.000Z",
            "category": "os-deployment-server-scripts",
            "uri": "/rest/os-deployment-server-scripts/1810001"
        },
        {
            "runAsSuperUser": true,
            "serverChanging": true,
            "codeType": "PY2",
            "displayCodeType": "Python",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "24",
                    "createdBy": "opsware",
                    "createdDate": "2015-08-04T07:30:18.000Z",
                    "usage": "Configures the boot device by applying the configuration specified in the HBA_Config multi-line custom attribute to the Emulex CNA, Emulex HBA or Qlogic HBA.\n\nOptional Parameters:\n\n--displayHbaOnly - Show the HBAs on the target server, but don't apply the configuration.\n",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-08-04T07:30:18.000Z",
            "version": {
                "versionLabel": "24",
                "createdBy": "opsware",
                "createdDate": "2015-08-04T07:30:18.000Z",
                "usage": "Configures the boot device by applying the configuration specified in the HBA_Config multi-line custom attribute to the Emulex CNA, Emulex HBA or Qlogic HBA.\n\nOptional Parameters:\n\n--displayHbaOnly - Show the HBAs on the target server, but don't apply the configuration.\n",
                "current": true
            },
            "source": "#!/usr/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n#\n\"\"\"\n(C) Copyright 2013-2015 Hewlett-Packard Development Company, L.P.\n\"\"\"\n############################################################################################\n# Configures the boot device by applying the configuration specified in the HBA_Config \n# multi-line custom attribute to the QLogic or Emulex HBA.\n#\n# The HBA_Config custom attribute should contain the following tag/value pairs; one per line.\n#\n# BootWWPN-HBA0 - Target Controller's WWPN. This is required.\n# BootLUN-HBA0 - The LUN.  This is required.\n# WWPN-HBA0 - The HBA's WWPN.  This is optional.  If not specified, the configuration will\n#             be applied to first HBA.\n# SelectBootEnable-HBA0 - Set to \"1\" to enable selectable boot on QLogic or disable AutoScan\n#                         on Emulex. Set to \"0\" to disable selectable boot on QLogic and\n#                         enable AutoScan on Emulex. This is optional.  The default value\n#                         is \"1\".\n# HostAdapterBiosEnable-HBA0 - Set to \"1\" to enable the host adapter BIOS or \"0\" to disable.\n#                              This is optional. The default value is \"1\".\n#\n# To configure a second HBA, use \"-HBA1\" in the tag names.\n#\n# Optional Parameters:\n#\n# --displayHbaOnly - Show the HBAs on the target server, but don't apply the configuration.\n#\n############################################################################################\n\nimport sys\nimport re\nimport subprocess\nimport os.path\nfrom subprocess import Popen, PIPE, STDOUT\nfrom optparse import OptionParser\nfrom osprov.osbp import logger\nfrom osprov.errors import ShowErrorMessage\n\n# The QLogic and Emulex utilities.\nQLOGIC_CMD = \"/opt/hba/qlogic/sbin/QConvergeConsoleCLI/qaucli\"\nEMULEX_CMD = \"/opt/hba/emulex/sbin/ocmanager/hbacmd\"\n\nHBA_CONFIG_CA_NAME = \"HBA_Config\"\nHBA_CONFIG_CA_VALUE = \"\"\"@HBA_Config@\"\"\"\n\n# These are the tags that appear in the \"HBA_Config\" custom attribute.\nBOOT_WWPN_HBA_TAG = \"BootWWPN-HBA\"\nBOOT_WWNN_HBA_TAG = \"BootWWNN-HBA\"\nBOOT_LUN_HBA_TAG = \"BootLUN-HBA\"\nWWPN_HBA_TAG = \"WWPN-HBA\"\nSELECT_BOOT_ENABLE_TAG = \"SelectBootEnable-HBA\"\nHOST_ADAPTER_BIOS_ENABLE_TAG = \"HostAdapterBiosEnable-HBA\"\n\nQLOGIC_DEFAULT_SELECTABLE_BOOT_ENABLE = \"1\"\nEMULEX_DEFAULT_AUTOSCAN_ENABLE = \"0\"\nDEFAULT_HOST_ADAPTER_BIOS_ENABLE = \"1\"\n\nEMULEX = 0\nQLOGIC = 1\n\nDEBUG=@Debug:0@\n\nLOG = logger.getIt('manage_hba_qlogic_configuration')\n\n############################################################################################\n# Class to parse command line arguments.\n############################################################################################\n\ndef parseArgs(args):\n\t\"\"\" parse and normalise arguments for the script \"\"\"\n\tparser = OptionParser()\n\tparser.add_option(\"--displayHbaOnly\",\n\t\t\taction = \"store_true\",\n\t\t\tdest = \"displayHbaOnly\",\n\t\t\thelp = \"Only display the HBAs, but don't apply configuration.\")\n\toptions, args = parser.parse_args(args)\n\tif args:\n\t\tparser.error(\"Additional positional arguments are not supported\")\n\treturn options, args\n\n############################################################################################\n# Class to hold some basic information about the target SAN controller that the HBA is\n# connected to.\n############################################################################################\n\nclass TargetSanInfo:\n\n\tdef __init__(self):\n\t\tself.targetWWNN = None\n\t\tself.targetWWPN = None\n\t\tself.linkStatus = None\n\t\tself.numLuns = None\n\n\tdef setTargetWWNN(self, targetWWNN):\n\t\tself.targetWWNN = targetWWNN.upper().replace(\"-\", \":\")\n\n\tdef setTargetWWPN(self, targetWWPN):\n\t\tself.targetWWPN = targetWWPN.upper().replace(\"-\", \":\")\n\n\tdef setNumLuns(self, numLuns):\n\t\tself.numLuns = numLuns\n\n\tdef getTargetWWNN(self):\n\t\treturn self.targetWWNN\n\n\tdef getTargetWWPN(self):\n\t\treturn self.targetWWPN\n\n\tdef getNumLuns(self):\n\t\treturn self.numLuns\n\n###########################################################################\n# A class to hold some basic information about the boot device that the\n# HBA is configured to boot from.\n###########################################################################\n\nclass BootDevice:\n\n\tdef __init__(self, targetWWPN, lun):\n\t\tself.targetWWPN = targetWWPN.upper().replace(\"-\",\":\")\n\t\tself.lun = lun\n\n\tdef setTargetWWPN(self, targetWWPN):\n\t\tself.targetWWPN = targetWWPN.upper().replace(\"-\",\":\")\n\n\tdef setLun(self, lun):\n\t\tself.lun = lun\n\n\tdef getTargetWWPN(self):\n\t\treturn self.targetWWPN\n\n\tdef getLun(self):\n\t\treturn self.lun\n\n###########################################################################\n# A class to hold some basic QLogic HBA information.\n#\n# Set setter methods for the WWPN will convert the WWPN to uppercase and\n# change the delimiter to a \":\".  QLogic WWPNs use a \"-\" delimeter and\n# the Emulex WWPNs use a \":\" delimeter.  So, for comparison purposes we\n# will use upper case characters and a \":\" delimeter, but when running\n# a QLogic command that requires the WWPN, we will change the delimeter\n# back to \"-\", as the QLogic utility does not accept a \":\".\n###########################################################################\n\nclass HBAInfo:\n\n\tdef __init__(self):\n\t\tself.model = None\n\t\tself.portNum = None\n\t\tself.hbaInstance = None\n\t\tself.hbaWWPN = None\n\t\tself.linkStatus = None\n\t\tself.targetSanInfoList = None\n\t\tself.selectableBootEnable = None\n\t\tself.hostAdapterEnableBios = None\n\t\tself.primaryBootDevice = None\n\n\tdef setModel(self, model):\n\t\tself.model = model\n\n\tdef setInstance(self, hbaInstance):\n\t\tself.hbaInstance = hbaInstance\n\n\tdef setPortNum(self, portNum):\n\t\tself.portNum = portNum\n\n\tdef setHbaWWPN(self, hbaWWPN):\n\t\tself.hbaWWPN = hbaWWPN.upper().upper().replace(\"-\",\":\")\n\n\tdef setLinkStatus(self, linkStatus):\n\t\tself.linkStatus = linkStatus\n\n\tdef addTargetSanInfo(self, targetSanInfo):\n\t\tif (self.targetSanInfoList is None):\n\t\t\tself.targetSanInfoList = []\n\n\t\tself.targetSanInfoList.append(targetSanInfo)\n\n\tdef setTargetSanInfoList(self, targetSanInfoList):\n\t\tself.targetSanInfoList = targetSanInfoList\n\n\tdef setSelectableBootEnable(self, selectableBootEnable):\n\t\tself.selectableBootEnable = selectableBootEnable\n\n\tdef setHostAdapterEnableBios(self, hostAdapterEnableBios):\n\t\tself.hostAdapterEnableBios = hostAdapterEnableBios\n\n\tdef setPrimaryBootDevice(self, primaryBootDevice):\n\t\tself.primaryBootDevice = primaryBootDevice\n\n\tdef getModel(self):\n\t\treturn self.model\n\n\tdef getHbaInstance(self):\n\t\treturn self.hbaInstance\n\n\tdef getPortNum(self):\n\t\treturn self.portNum\n\n\tdef getHbaWWPN(self):\n\t\treturn self.hbaWWPN\n\n\tdef getLinkStatus(self):\n\t\treturn self.linkStatus\n\n\tdef getTargetSanInfoList(self):\n\t\treturn self.targetSanInfoList\n\n\tdef getSelectableBootEnable(self):\n\t\treturn self.selectableBootEnable\n\n\tdef getHostAdapterEnableBios(self):\n\t\treturn self.hostAdapterEnableBios\n\n\tdef getPrimaryBootDevice(self):\n\t\treturn self.primaryBootDevice\n\n###########################################################################\n# A class to hold the user-specified settings that are to be applied to\n# the HBA.\n###########################################################################\n\nclass UserHBA:\n\n\tdef __init__(self):\n\t\tself.tagNum = None\n\t\tself.hbaWWPN = None\n\t\tself.targetWWPN = None\n\t\tself.targetWWNN = None\n\t\tself.lun = None\n\t\tself.selectableBootEnable = None\n\t\tself.hostAdapterBiosEnable = None\n\n\tdef setTagNum(self, tagNum):\n\t\tself.tagNum = tagNum\n\n\tdef setHbaWWPN(self, hbaWWPN):\n\t\tself.hbaWWPN = hbaWWPN.upper().replace(\"-\",\":\")\n\n\tdef setTargetWWPN(self, targetWWPN):\n\t\tself.targetWWPN = targetWWPN.upper().replace(\"-\",\":\")\n\n\tdef setTargetWWNN(self, targetWWNN):\n\t\tself.targetWWNN = targetWWNN.upper().replace(\"-\",\":\")\n\n\tdef setLun(self, lun):\n\t\tself.lun = lun\n\n\tdef setSelectableBootEnable(self, selectableBootEnable):\n\t\tself.selectableBootEnable = selectableBootEnable\n\n\tdef setHostAdapterEnableBios(self, hostAdapterBiosEnable):\n\t\tself.hostAdapterBiosEnable = hostAdapterBiosEnable\n\n\tdef getTagNum(self):\n\t\treturn self.tagNum\n\n\tdef getHbaWWPN(self):\n\t\treturn self.hbaWWPN\n\n\tdef getTargetWWPN(self):\n\t\treturn self.targetWWPN\n\n\tdef getTargetWWNN(self):\n\t\treturn self.targetWWNN\n\n\tdef getLun(self):\n\t\treturn self.lun\n\n\tdef getSelectableBootEnable(self):\n\t\treturn self.selectableBootEnable\n\n\tdef getHostAdapterEnableBios(self):\n\t\treturn self.hostAdapterBiosEnable\n\n###########################################################################\n# Returns a string representation of the list.\n#\n# Parameters:\n#    list - The list to be converted to a string.\n#    delimeter - The character to use as the delimeter (default = ' ').\n###########################################################################\n\ndef listToString(list, delimeter=' '):\n\n\tstr = delimeter.join(list)\n\n\treturn str\n\n###########################################################################\n# Executes the specified command.\n#\n# Parameters:\n#    cmdArgs - The command to be executed, specified as a list.\n#\n###########################################################################\n\ndef executeCommand(cmdArgs):\n\n\tcmdAsString = listToString(cmdArgs)\n\n\tif (DEBUG):\n\t\tprint \"Executing => \", cmdAsString\n\n\tp = subprocess.Popen(cmdArgs, stdout=subprocess.PIPE, stderr=STDOUT)\n\n\toutput = p.communicate()[0].strip()\n\n\tretCode = p.poll()\n\n\tp.stdout.close()\n\n\treturn retCode, output\n\n###########################################################################\n# Returns the string \"as-is\", if it's value is not \"None\", otherwise\n# it returns an empty string so that when it gets displayed, we don't\n# see \"None\" in the output.  The keyword \"None\" means that the variable\n# has no value (e.g. null) in Python.\n###########################################################################\n\ndef toDisplayValue(str):\n\n\tdisplayStr = \"\"\n\n\tif (str is not None):\n\t\tdisplayStr = str\n\n\treturn displayStr\n\n###########################################################################\n# Displays the HBAs found on the system.\n###########################################################################\n\ndef showHBAs(hbaList):\n\n\tfmtStrHdr  = \"%-4s %-4s %-23s %-12s %-7s %-10s %-23s %-3s\"\n\tfmtStrBody = \"%4s %4s %-23s %-12s %7s %10s %-23s %3s\"\n\n\tprint fmtStrHdr % (\"\", \"\", \"\", \"Link\", \"Enable\", \"Selectable\", \"Primary Boot\", \"\")\n\tprint fmtStrHdr % (\"HBA#\", \"Port\", \"HBA WWPN\", \"Status\", \"BIOS\", \"Boot\", \"Port Name\", \"LUN\")\n\tprint fmtStrHdr % (\"----\", \"----\", \"-----------------------\", \"------------\", \"-------\", \"----------\", \"-----------------------\", \"---\")\n\n\tif (hbaList is None):\n\t\treturn\n\n\thbaNum = 0\n\n\tfor hba in hbaList:\n\n\t\tportNum = toDisplayValue(hba.getPortNum())\n\n\t\thbaWWPN = toDisplayValue(hba.getHbaWWPN())\n\n\t\tlinkStatus = toDisplayValue(hba.getLinkStatus())\n\n\t\tenableBios = toDisplayValue(hba.getHostAdapterEnableBios())\n\n\t\tselectableBoot = toDisplayValue(hba.getSelectableBootEnable())\n\n\t\tif (hba.getPrimaryBootDevice() is not None):\n\t\t\tprimaryBootDevice = hba.getPrimaryBootDevice()\n\n\t\t\tprimaryBootPortName = toDisplayValue(primaryBootDevice.getTargetWWPN())\n\n\t\t\tlun = toDisplayValue(primaryBootDevice.getLun())\n\t\telse:\n\t\t\tprimaryBootPortName = \"\"\n\t\t\tlun = \"\"\n\n\t\tprint fmtStrBody % (hbaNum, portNum, hbaWWPN, linkStatus, enableBios, selectableBoot, primaryBootPortName, lun)\n\n\t\thbaNum += 1\n\n##################################################################################\n#\n# BEGIN QLOGIC-SPECIFIC CODE\n#\n##################################################################################\n\n##################################################################################\n# Enables/Disables the BIOS on the QLogic HBA.\n#\n# Parameters:\n#    hbaWWPN - The WWPN of the HBA on which to enable/disable the BIOS.\n#    enable - Set to \"1\" to enable or \"0\" to disable.\n##################################################################################\n\ndef qlogicSetEnableBios(hbaWWPN, enable):\n\n\t# Since the \"HostAdapterBiosEnable-HBA\" tag is optional, we'll default\n\t# it to enabled if the user didn't specify it in the \"HBA_Config\" C.A.\n\tif (enable is None):\n\t\tenable = DEFAULT_HOST_ADAPTER_BIOS_ENABLE\n\n\tif (DEBUG):\n\t\tif (enable):\n\t\t\tprint \"Enabling BIOS on QLogic HBA ...\"\n\t\telse:\n\t\t\tprint \"Disabling BIOS on QLogic HBA ...\"\n\n\tcmdArgs = [QLOGIC_CMD, \"-pr\", \"fc\", \"-n\", hbaWWPN.replace(\":\",\"-\"), \"EB\", enable]\n\n\tretCode, output = executeCommand(cmdArgs)\n\n\tif (retCode != 0):\n\t\traise ShowErrorMessage(\"An error occurred while executing '%s' : %s\" % (listToString(cmdArgs), output))\n\n##################################################################################\n# Returns the value of the Enables Host HBA BIOS setting on the QLogic HBA.\n##################################################################################\n\ndef qlogicGetEnableBios(hbaWWPN):\n\n\tcmdArgs = [QLOGIC_CMD, \"-c\", hbaWWPN.replace(\":\",\"-\")]\n\n\tretCode, output = executeCommand(cmdArgs)\n\n\tif (retCode != 0):\n\t\traise ShowErrorMessage(\"An error occurred while executing '%s' : %s\" % (listToString(cmdArgs), output))\n\n\tenableBiosPattern = re.compile(r\"^Enable Host HBA BIOS\\s*:\\s+([\\S]+)\\s*$\")\n\n\tenableBios = None\n\n\tfor line in output.splitlines():\n\t\tresult = enableBiosPattern.search(line)\n\n\t\tif result:\n\t\t\tenableBios = result.group(1)\n\n\t\t\tif (enableBios.lower() == \"enabled\"):\n\t\t\t\tenableBios = \"1\"\n\t\t\telse:\n\t\t\t\tenableBios = \"0\"\n\n\t\t\tbreak\n\n\treturn enableBios\n\n##################################################################################\n# Enables/Disables the Selectable Boot on the QLogic HBA.\n#\n# +--------------------------------------------------------------------------+\n# | Enable |    WWPN/LUN    | Device Boot                                    |\n# |--------------------------------------------------------------------------|\n# |   No   |        X       | BIOS configures the first disk drive it finds  |\n# |        |                | as boot device.                                |\n# |--------------------------------------------------------------------------|\n# |   Yes  | None specified | BIOS configures the first disk drive it finds  |\n# |        |                | that is also a LUN 0 as boot device.           |\n# |--------------------------------------------------------------------------|\n# |   Yes  |    Specified   | BIOS scans through the specified Boot WWPN/LUN |\n# |        |                | list until it finds a disk drive.  This is     |\n# |        |                | configured as boot device.                     |\n# +--------------------------------------------------------------------------+\n#\n# Parameters:\n#    hbaWWPN - The WWPN of the HBA on which to set the selectable boot.\n#    enable - Set to \"1\" to enable or \"0\" to disable.\n##################################################################################\n\ndef qlogicSetSelectableBootEnable(hbaWWPN, enable):\n\n\t# Since the \"SelectBootEnable-HBA\" tag is optional, we'll default\n\t# it to enabled if the user didn't specify it in the \"HBA_Config\" C.A.\n\tif (enable is None):\n\t\tenable = QLOGIC_DEFAULT_SELECTABLE_BOOT_ENABLE\n\n\tif (enable == \"0\"):\n\t\tif (DEBUG):\n\t\t\tprint \"Disabling Selectable Boot on QLogic HBA ...\"\n\t\tenableArg = \"disable\"\n\telse:\n\t\tif (DEBUG):\n\t\t\tprint \"Enabling Selectable Boot on QLogic HBA ...\"\n\t\tenableArg = \"enable\"\n\n\tcmdArgs = [QLOGIC_CMD, \"-pr\", \"fc\", \"-e\", hbaWWPN.replace(\":\",\"-\"), enableArg]\n\n\tretCode, output = executeCommand(cmdArgs)\n\n\tif (retCode != 0):\n\t\traise ShowErrorMessage(\"An error occurred while executing '%s' : %s\" % (listToString(cmdArgs), output))\n\n##################################################################################\n# Sets the primary boot device (Target WWPN/LUN) on the QLogic HBA.\n#\n# Parameters:\n#    hbaWWPN - The WWPN of the HBA on which the primary boot device is to be set.\n#    targetWWNN - The target's World Wide Node Name (The ID of the SAN).\n#    targetWWPN - The target's World Wide Port Name (The ID of the Controller)\n#                 that is to be set as the primary boot device.\n#    lunId - The LUN ID on the Target WWPN that is to be set as the primary boot\n#            device.\n##################################################################################\n\ndef qlogicSetPrimaryBootDevice(hbaWWPN, targetWWNN, targetWWPN, lunId):\n\n\t# The QLogic utility requires the target WWNN parameter for some reason.\n\t# If the user didn't specify it in the \"BootWWNN-HBA\" tag, then default\n\t# it to all zeroes and hope it works.\n\tif (targetWWNN is None):\n\t\ttargetWWNN = \"00-00-00-00-00-00-00-00\"\n\n\t\tif (DEBUG):\n\t\t\tprint \"No targetWWNN was specified for targetWWPN '%s'.  Defaulting to '%s'.\" % (targetWWPN,targetWWNN) \n\n\t# Set first boot device (primary) to the specified target WWPN and LUN.\n\tcmdArgs = [QLOGIC_CMD, \"-pr\", \"fc\", \"-e\", hbaWWPN.replace(\":\",\"-\"), targetWWNN.replace(\":\",\"-\"), targetWWPN.replace(\":\",\"-\"), lunId, \"prim\"]\n\n\tretCode, output = executeCommand(cmdArgs)\n\n\tif (retCode != 0):\n\t\traise ShowErrorMessage(\"An error occurred while executing '%s' : %s\" % (listToString(cmdArgs), output))\n\n##################################################################################\n# Returns the primary boot device (Target WWPN/LUN) for the QLogic HBA with the\n# specified WWPN.\n#\n# Parameters:\n#    hbaWWPN - The WWPN of the HBA that we want the primary boot device for.\n##################################################################################\n\ndef qlogicGetPrimaryBootDevice(hbaWWPN):\n\n\tcmdArgs = [QLOGIC_CMD, \"-pr\", \"fc\", \"-e\", hbaWWPN.replace(\":\",\"-\"), \"view\"]\n\n\tretCode, output = executeCommand(cmdArgs)\n\n\tif (retCode != 0):\n\t\traise ShowErrorMessage(\"An error occurred while executing '%s' : %s\" % (listToString(cmdArgs), output))\n\n\tselectableBootPattern = re.compile(r\"^Selectable Boot\\s*:\\s+([\\S]+)\\s*$\")\n\tbootDevicePattern = re.compile(r\"^([\\S]{2}-[\\S]{2}-[\\S]{2}-[\\S]{2}-[\\S]{2}-[\\S]{2}-[\\S]{2}-[\\S]{2})\\s+([\\d]+)\\s*$\")\n\n\tselectableBoot = None\n\ttargetWWPN = None\n\tlun = None\n\n\tfor line in output.splitlines():\n\t\tresult = selectableBootPattern.search(line)\n\n\t\tif result:\n\t\t\tselectableBoot = result.group(1)\n\n\t\t\tif (selectableBoot.lower() == \"enabled\"):\n\t\t\t\tselectableBoot = \"1\"\n\t\t\telse:\n\t\t\t\tselectableBoot = \"0\"\n\n\t\t# The first boot device we find is the primary one,\n\t\t# so if there's a match, then break out of the loop.\n\t\tresult = bootDevicePattern.search(line)\n\n\t\tif result:\n\t\t\ttargetWWPN = result.group(1)\n\t\t\tlun = result.group(2)\n\t\t\tbreak\n\n\tprimaryBootDevice = BootDevice(targetWWPN, lun)\n\n\treturn selectableBoot, primaryBootDevice\n\n##################################################################################\n# Configures the Emulex HBA specified by \"hba\" with the user-supplied HBA\n# configuration specified by \"userHba\".\n#\n# Parameters:\n#    userHba - The user-supplied HBA configuration from the \"HBA_Config\" custom\n#              attribute.\n#    hba - The QLogic HBA to which the user-supplied HBA configuration is to be\n#          applied.\n##################################################################################\n\ndef qlogicConfigureHBA(userHba, hba):\n\n\t# When this setting is disabled, the ROM BIOS on the HBA is disabled,\n\t# freeing space in upper memory.  This setting must be enabled if you\n\t# are booting from an FC disk drive attached to the HBA.\n\tqlogicSetEnableBios(hba.getHbaWWPN(), userHba.getHostAdapterEnableBios())\n\n\t# Enable the Boot From SAN.\n\tqlogicSetSelectableBootEnable(hba.getHbaWWPN(), userHba.getSelectableBootEnable())\n\n\t# Tell the HBA what the primary target WWPN and LUN it should boot from.\n\tqlogicSetPrimaryBootDevice(hba.getHbaWWPN(), userHba.getTargetWWNN(), userHba.getTargetWWPN(), userHba.getLun())\n\n##################################################################################\n# Returns a list of the QLogic HBAs found on the system.\n##################################################################################\n\ndef qlogicGetHBAs():\n\n\tcmdArgs = [QLOGIC_CMD, \"-pr\", \"fc\", \"-t\"]\n\n\tretCode, output = executeCommand(cmdArgs)\n\n\tif (retCode != 0) and (retCode != 119):\n\t\traise ShowErrorMessage(\"An error occurred while executing '%s' : %s\" % (listToString(cmdArgs), output))\n\n\thbaInstancePattern = re.compile(r\"^HBA\\s+Instance\\s+([\\d]+)\\s*:\\s+([\\S]+)\\s+Port\\s+([\\d]+)\\s+WWPN\\s+([\\S]+)\\s+.*$\")\n\tlinkStatusPattern = re.compile(r\"^Link\\s*:\\s+(\\S{1}.*\\S*)\\s*$\")\n\ttargetPathPattern = re.compile(r\"^Path\\s*:\\s+([\\S]+)\\s*$\")\n\ttargetWWNNPattern = re.compile(r\"^Node Name\\s*:\\s+([\\S]+)\\s*$\")\n\ttargetWWPNPattern = re.compile(r\"^Port Name\\s*:\\s+([\\S]+)\\s*$\")\n\tnumLunsPattern = re.compile(r\"^LUN Count\\(s\\)\\s*:\\s+([\\S]+)\\s*$\")\n\n\thbaList = []\n\n\thba = None\n\ttargetSanInfo = None\n\n\tfor line in output.splitlines():\n\t\tresult = hbaInstancePattern.search(line)\n\n\t\tif result:\n\t\t\tif (hba is not None):\n\t\t\t\tif (targetSanInfo is not None):\n\t\t\t\t\thba.addTargetSanInfo(targetSanInfo)\n\t\t\t\t\ttargetSanInfo = None\n\t\t\t\thbaList.append(hba)\n\n\t\t\thbaInstance = result.group(1)\n\t\t\tmodel = result.group(2)\n\t\t\tportNum = result.group(3)\n\t\t\thbaWWPN = result.group(4)\n\n\t\t\thba = HBAInfo()\n\t\t\thba.setInstance(hbaInstance)\n\t\t\thba.setModel(model)\n\t\t\thba.setPortNum(portNum)\n\t\t\thba.setHbaWWPN(hbaWWPN)\n\n\t\t\tenableBios = qlogicGetEnableBios(hbaWWPN)\n\n\t\t\tselectableBoot, primaryBootDevice = qlogicGetPrimaryBootDevice(hbaWWPN)\n\n\t\t\thba.setSelectableBootEnable(selectableBoot)\n\t\t\thba.setHostAdapterEnableBios(enableBios)\n\t\t\thba.setPrimaryBootDevice(primaryBootDevice)\n\n\t\t\tcontinue\n\n\t\tresult = linkStatusPattern.search(line)\n\n\t\tif result:\n\t\t\tlinkStatus = result.group(1)\n\n\t\t\tif (hba is not None):\n\t\t\t\thba.setLinkStatus(linkStatus)\n\t\t\tcontinue\n\n\t\t# When we see \"Path\", that signals the start of the\n\t\t# target information.  Each HBA port may show one or\n\t\t# more targets, so we must collect each target\n\t\t# information and add it to the HBA record.\n\t\tresult = targetPathPattern.search(line)\n\n\t\tif result:\n\t\t\tif (hba is not None):\n\t\t\t\tif (targetSanInfo is not None):\n\t\t\t\t\thba.addTargetSanInfo(targetSanInfo)\n\t\t\t\ttargetSanInfo = TargetSanInfo()\n\t\t\tcontinue\n\n\t\t# Check if the line contains the target WWNN (Node Name).\n\t\tresult = targetWWNNPattern.search(line)\n\n\t\tif result:\n\t\t\ttargetWWNN = result.group(1)\n\n\t\t\tif (targetSanInfo is not None):\n\t\t\t\ttargetSanInfo.setTargetWWNN(targetWWNN)\n\t\t\tcontinue\n\n\t\t# Check if the line contains the target WWPN (Port Name).\n\t\tresult = targetWWPNPattern.search(line)\n\n\t\tif result:\n\t\t\ttargetWWPN = result.group(1)\n\n\t\t\tif (targetSanInfo is not None):\n\t\t\t\ttargetSanInfo.setTargetWWPN(targetWWPN)\n\t\t\tcontinue\n\n\t\t# Check if the line contains the number of LUNs on target.\n\t\tresult = numLunsPattern.search(line)\n\n\t\tif result:\n\t\t\tnumLuns = result.group(1)\n\n\t\t\tif (targetSanInfo is not None):\n\t\t\t\ttargetSanInfo.setNumLuns(numLuns)\n\t\t\tcontinue\n\n\tif (hba is not None):\n\t\tif (targetSanInfo is not None):\n\t\t\thba.addTargetSanInfo(targetSanInfo)\n\n\t\thbaList.append(hba)\n\n\treturn hbaList\n\n##################################################################################\n# Performs a simple test to check if there's a QLogic HBA card installed.  Returns\n# True if there is, false otherwise.  This is needed because the \"qaucli\" command\n# will report an error if there are no HBAs.\n##################################################################################\n\ndef qlogicTestForHBA():\n\n\tcmdArgs = [QLOGIC_CMD, \"-pr\", \"fc\", \"-g\"]\n\n\tretCode, output = executeCommand(cmdArgs)\n\n\tif (retCode == 0):\n\t\treturn True\n\telse:\n\t\tif (DEBUG):\n\t\t\tprint \"retCode => \", retCode\n\t\t\tprint \"output => \", output\n\n\t\treturn False\n\n##################################################################################\n#\n# END QLOGIC-SPECIFIC CODE\n#\n##################################################################################\n\n##################################################################################\n#\n# BEGIN EMULEX-SPECIFIC CODE\n#\n##################################################################################\n\n##################################################################################\n# Enables/Disables the BIOS on the Emulex HBA.\n#\n# Parameters:\n#    hbaWWPN - The WWPN of the HBA on which to enable/disable the BIOS.\n#    enable - Set to \"1\" to enable or \"0\" to disable.\n##################################################################################\n\ndef emulexSetEnableBios(hbaWWPN, enable, hbaModel):\n\n\t# Since the \"HostAdapterBiosEnable-HBA\" tag is optional, we'll default\n\t# it to enabled if the user didn't specify it in the \"HBA_Config\" C.A.\n\tif (enable is None):\n\t\tenable = DEFAULT_HOST_ADAPTER_BIOS_ENABLE\n\n\tif (enable == \"0\"):\n\t\tif (DEBUG):\n\t\t\tprint \"Disabling BIOS on Emulex HBA ...\"\n\t\tenableArg = \"D\"\n\telse:\n\t\tif (DEBUG):\n\t\t\tprint \"Enabling BIOS on Emulex HBA ...\"\n\t\tenableArg = \"E\"\n\n\tcmdArgs = [EMULEX_CMD, \"EnableBootCode\", hbaWWPN, enableArg]\n\n\tretCode, output = executeCommand(cmdArgs)\n\t\n\tif (retCode == 251):\n\t\t \n\t\tprint \"Could not enable the boot code on HBA with model %s.\" % hbaModel\n\t\tprint \"This is expected if the HBA is an Emulex OneConnect-based adapter, as the boot code will always be enabled on these adapters.\"\n\telse:\n\t    if (retCode != 0):\n\t\t    raise ShowErrorMessage(\"An error occurred while executing '%s' : %s\" % (listToString(cmdArgs), output))\n\n##################################################################################\n# Enables/Disables the Boot From SAN on the Emulex HBA.\n#\n# Parameters:\n#    hbaWWPN - The WWPN of the HBA on which to enable the Boot From SAN.\n#    enable - Set to \"1\" to enable or \"0\" to disable.\n##################################################################################\n\ndef emulexSetEnableBootFromSan(hbaWWPN, enable):\n\n\t# We do not have a tag on the \"HBA_Config\" custom attribute to\n\t# specifically set the boot from SAN, so we use the value of the\n\t# \"HostAdapterBiosEnable-HBA\" tag.  If it is not set, then we\n\t# use its default value.\n\tif (enable is None):\n\t\tenable = DEFAULT_HOST_ADAPTER_BIOS_ENABLE\n\n\tif (DEBUG):\n\t\tif (enable == \"0\"):\n\t\t\tprint \"Disabling Boot From SAN on Emulex HBA ...\"\n\t\telse:\n\t\t\tprint \"Enabling Boot From SAN on Emulex HBA ...\"\n\n\t# Set first boot device to the specified target WWPN.\n\tcmdArgs = [EMULEX_CMD, \"SetBootParams\", hbaWWPN, \"X86\", \"EnableBootFromSAN\", enable]\n\n\tretCode, output = executeCommand(cmdArgs)\n\n\tif (retCode != 0):\n\t\traise ShowErrorMessage(\"An error occurred while executing '%s' : %s\" % (listToString(cmdArgs), output))\n\n##################################################################################\n# Sets the primary boot device (Target WWPN/LUN) on the Emulex HBA.\n#\n# Parameters:\n#    hbaWWPN - The WWPN of the HBA on which the primary boot device is to be set.\n#    targetWWPN - The target's World Wide Port Name (The ID of the Controller)\n#                 that is to be set as the primary boot device.\n#    lunId - The LUN ID on the Target WWPN that is to be set as the primary boot\n#            device.\n##################################################################################\n\ndef emulexSetPrimaryBootDevice(hbaWWPN, targetWWPN, lun):\n\n\tif (DEBUG):\n\t\tprint \"Setting Primary Boot Device on Emulex HBA ...\"\n\n\t# Set first boot device (primary) to the specified target WWPN and LUN.\n\tcmdArgs = [EMULEX_CMD, \"SetBootParams\", hbaWWPN, \"X86\", \"targetwwpn\", targetWWPN, \"bootdev\", \"0\"]\n\n\tretCode, output = executeCommand(cmdArgs)\n\n\tif (retCode != 0):\n\t\traise ShowErrorMessage(\"An error occurred while executing '%s' : %s\" % (listToString(cmdArgs), output))\n\n\t# Set first boot device to the specified target WWPN.\n\tcmdArgs = [EMULEX_CMD, \"SetBootParams\", hbaWWPN, \"X86\", \"lun\", lun, \"bootdev\", \"0\"]\n\n\tretCode, output = executeCommand(cmdArgs)\n\n\tif (retCode != 0):\n\t\traise ShowErrorMessage(\"An error occurred while executing '%s' : %s\" % (listToString(cmdArgs), output))\n\n##################################################################################\n# Returns values of the \"EnableAdapterBoot\", \"EnableBootFromSAN\" parameters,\n# along with the primary boot device (TargetWWPN/LUN).\n#\n# Parameters:\n#    hbaWWPN - The WWPN of the HBA whose boot parameters we wish to retrieve.\n##################################################################################\n\ndef emulexGetBootParams(hbaWWPN):\n\n\tcmdArgs = [EMULEX_CMD, \"GetBootParams\", hbaWWPN, \"X86\"]\n\n\tretCode, output = executeCommand(cmdArgs)\n\n\tif (retCode != 0):\n\t\tif (DEBUG):\n\t\t\tprint \"No boot parameters found for HBA WWPN '%s'\" % hbaWWPN\n\t\treturn None, None, None, None\n\n\tenableAdapterBootPattern = re.compile(r\"^\\s*EnableAdapterBoot\\s+(\\d+)\\s+(\\S{1}.*\\S*)\\s*$\")\n\tenableBootFromSanPattern = re.compile(r\"^\\s*EnableBootFromSAN\\s+(\\d+)\\s+(\\S{1}.*\\S*)\\s*$\")\n\tautoScanPattern = re.compile(r\"^\\s*AutoScan\\s+(\\d+)\\s+(\\S{1}.*\\S*)\\s*$\")\n\tbootDevicePattern = re.compile(r\"^\\s*\\d+\\s+(\\d+)\\s+\\S+\\s+([\\S]{2}:[\\S]{2}:[\\S]{2}:[\\S]{2}:[\\S]{2}:[\\S]{2}:[\\S]{2}:[\\S]{2})\\s*$\")\n\n\tenableAdapterBoot = None\n\tenableBootFromSan = None\n\tautoScan = None\n\ttargetWWPN = None\n\tlun = None\n\n\tfor line in output.splitlines():\n\n\t\tresult = enableAdapterBootPattern.search(line)\n\n\t\tif result:\n\t\t\tenableAdapterBoot = result.group(1)\n\t\t\tcontinue\n\n\t\tresult = enableBootFromSanPattern.search(line)\n\n\t\tif result:\n\t\t\tenableBootFromSan = result.group(1)\n\t\t\tcontinue\n\n\t\tresult = autoScanPattern.search(line)\n\n\t\tif result:\n\t\t\tautoScan = result.group(1)\n\t\t\tcontinue\n\n\t\t# Once we find the primary boot device (targetWWPN/LUN)\n\t\t# for this HBA then we're done, since it is one of the\n\t\t# last pieces of data in the output.\n\t\tresult = bootDevicePattern.search(line)\n\n\t\tif result:\n\t\t\tlun = result.group(1)\n\t\t\ttargetWWPN = result.group(2)\n\t\t\tbreak\n\n\tprimaryBootDevice = BootDevice(targetWWPN,lun)\n\n\treturn enableAdapterBoot, enableBootFromSan, autoScan, primaryBootDevice\n\n###########################################################################\n# Enables/Disable the AutoScan.  If being enabled, we only implement the\n# first option, which is \"Any first device\".\n#\n# Auto scan options:\n#    Autoscan disabled - default\n#    Any first device - The first adapter issues a Name Server Inquiry and\n#                       the first D_ID from the inquiry becomes the boot\n#                       device.  The adapter attempts to log in to a public\n#                       loop first.  If it fails, it logs in to a private\n#                       loop.  The first successfully scanned device\n#                       becomes the boot device.  This device only is\n#                       exported to the multi-boot menu.\n#    First LUN 0 device\n#    First NOT LUN 0 device (device other than LUN 0)\n#\n###########################################################################\n\ndef emulexSetAutoScanEnable(hbaWWPN, enable):\n\n\t# Since the \"SelectBootEnable-HBA\" tag is optional, we'll default\n\t# AutoScan to disabled if the user didn't specify it in the\n\t# \"HBA_Config\" C.A.\n\tif (enable is None):\n\t\tenable = EMULEX_DEFAULT_AUTO_SCAN_ENABLE\n\n\tif (DEBUG):\n\t\tif (enable == \"0\"):\n\t\t\tprint \"Disabling AutoScan on Emulex HBA ...\"\n\t\telse:\n\t\t\tprint \"Enabling AutoScan on Emulex HBA ...\"\n\n\t# Set Auto Scan value.\n\tcmdArgs = [EMULEX_CMD, \"SetBootParams\", hbaWWPN, \"X86\", \"AutoScan\", enable]\n\n\tretCode, output = executeCommand(cmdArgs)\n\n\tif (retCode != 0):\n\t\traise ShowErrorMessage(\"An error occurred while executing '%s' : %s\" % (listToString(cmdArgs), output))\n\n###########################################################################\n# Returns the state of the HBA port (e.g. \"Operational\", \"Link Down\", etc).\n###########################################################################\n\ndef emulexGetPortState(hbaWWPN):\n\n\tportState = None\n\n\tcmd = [EMULEX_CMD, \"PortAttrib\", hbaWWPN]\n\n\tretCode, output = executeCommand(cmd)\n\n\tif (retCode != 0):\n\t\traise ShowErrorMessage(\"An error occurred while executing '%s' : %s\" % (listToString(cmdArgs), output))\n\n\tportStatePattern = re.compile(r\"^Port State\\s*:\\s+(\\S{1}.*\\S*)\\s*$\")\n\n\tfor line in output.splitlines():\n\t\tresult = portStatePattern.search(line)\n\n\t\tif result:\n\t\t\tportState = result.group(1)\n\n\treturn portState\n\n##################################################################################\n# Returns a list of the Emulex HBAs found on the system.\n##################################################################################\n\ndef emulexGetHBAs():\n\n\tcmd = [EMULEX_CMD, \"ListHBAs\", \"local\"]\n\n\tretCode, output = executeCommand(cmd)\n\n\tif (retCode != 0):\n\t\traise ShowErrorMessage(\"An error occurred while executing '%s' : %s\" % (listToString(cmdArgs), output))\n\n\tportWWNPattern = re.compile(r\"^Port WWN\\s*:\\s+([\\S]+)\\s*$\")\n\tportMACPattern = re.compile(r\"^Permanent MAC\\s*:\\s+([\\S]+)\\s*$\")\n\tportTypePattern = re.compile(r\"^Port Type\\s*:\\s+([\\S]+)\\s*$\")\n\tportNumberPattern = re.compile(r\"^Port Number\\s*:\\s+([\\S]+)\\s*$\")\n\tmodelPattern = re.compile(r\"^Model\\s*:\\s+([\\S]+)\\s*$\")\n\n\thbaList = []\n\n\thba = None\n\n\tignoreHba = False\n\n\tfor line in output.splitlines():\n\t\t# The line containing the WWPN will usually mark the beginning of a\n\t\t# new Emulex adapter record.  Not all Emulex adapters are HBAs or CNAs,\n\t\t# however.  Some Emulex adapters are NICs, which will start with the\n\t\t# MAC address line.  We'll check for NICs further down.\n\t\tresult = portWWNPattern.search(line)\n\n\t\tif result:\n\t\t\t# Ok, so we've encountered the start of an HBA record.\n\t\t\t# This code checks if we have a pending HBA record that\n\t\t\t# needs to be added to the list of HBAs before we create\n\t\t\t# the new HBA record.\n\t\t\tif (hba is not None):\n\t\t\t\tif (not ignoreHba):\n\t\t\t\t\thbaList.append(hba)\n\n\t\t\tignoreHba = False\n\n\t\t\thbaWWPN = result.group(1)\n\n\t\t\tif (DEBUG):\n\t\t\t\tprint \"Found HBA with WWPN '%s'\" % hbaWWPN\n\n\t\t\thba = HBAInfo()\n\t\t\thba.setHbaWWPN(hbaWWPN)\n\n\t\t\tportState = emulexGetPortState(hbaWWPN)\n\n\t\t\thba.setLinkStatus(portState)\n\n\t\t\tenableAdapterBoot, enableBootFromSan, autoScan, primaryBootDevice = emulexGetBootParams(hbaWWPN)\n\n\t\t\t# If an HBA does not have any boot parameters, then we\n\t\t\t# ignore it.  Perhaps it is not a Fibre Channel HBA.\n\t\t\tif (enableAdapterBoot is not None):\n\t\t\t\t# In Emulex, having AutoScan disabled, is equivalent\n\t\t\t\t# of having SelectableBoot enabled in QLogic, and\n\t\t\t\t# vice versa.  Although, when enabled, AutoScan may\n\t\t\t\t# have 3 different values, we only implement the\n\t\t\t\t# first value, which is to boot from any first device.\n\t\t\t\tif (autoScan == \"0\"):\n\t\t\t\t\tselectableBootEnable = \"1\"\n\t\t\t\telse:\n\t\t\t\t\tselectableBootEnable = \"0\"\n\n\t\t\t\thba.setSelectableBootEnable(selectableBootEnable)\n\t\t\t\thba.setHostAdapterEnableBios(enableAdapterBoot)\n\t\t\t\thba.setPrimaryBootDevice(primaryBootDevice)\n\t\t\telse:\n\t\t\t\tif (DEBUG):\n\t\t\t\t\tprint \"Ignoring HBA '%s' because it has no boot parameters\" % hbaWWPN\n\t\t\t\tignoreHba = True\n\t\telse:\n\t\t\t# Is this a MAC address instead of a WWPN?\n\t\t\tresult = portMACPattern.search(line)\n\n\t\t\t# Skip over Emulex adapters which are NICs, not HBAs, such as the \"554FLB\".\n\t\t\tif result:\n\t\t\t\t# Ok, so we've encountered the start of a NIC record,\n\t\t\t\t# which we don't care about. This code checks if we \n\t\t\t\t# have a pending HBA record that needs to be added to\n\t\t\t\t# the list of HBAs.\n\t\t\t\tif (hba is not None):\n\t\t\t\t\tif (not ignoreHba):\n\t\t\t\t\t\thbaList.append(hba)\n\n\t\t\t\tportMAC = result.group(1)\n\n\t\t\t\t# This is a NIC, not an HBA, so ignore all the remaining\n\t\t\t\t# lines until we hit the start of the next record.\n\t\t\t\tignoreHba = True\n\n\t\t\t\t# We're not creating a new HBA record, because this\n\t\t\t\t# is a NIC, not an HBA.\n\t\t\t\thba = None\n\n\t\t\t\tif (DEBUG):\n\t\t\t\t\tprint \"Ignoring NIC with MAC address '%s'\" % portMAC\n\n\t\tif (not ignoreHba):\n\t\t\tresult = portTypePattern.search(line)\n\n\t\t\tif result:\n\t\t\t\tportType = result.group(1)\n\n                                # This is an Emulex NIC, not an HBA.\n\t\t\t\tif (portType == \"NIC\"):\n\t\t\t\t\tif (DEBUG):\n\t\t\t\t\t\tprint \"Ignoring NIC device\"\n\n\t\t\t\t\tignoreHba = True\n\n\t\tif (not ignoreHba) and (hba is not None):\n\t\t\tresult = portNumberPattern.search(line)\n\n\t\t\tif result:\n\t\t\t\tportNum = result.group(1)\n\n\t\t\t\thba.setPortNum(portNum)\n\n\t\t\tresult = modelPattern.search(line)\n\n\t\t\tif result:\n\t\t\t\tmodel = result.group(1)\n\n\t\t\t\thba.setModel(model)\n\n\tif (hba is not None):\n\t\tif (not ignoreHba):\n\t\t\thbaList.append(hba)\n\n\treturn hbaList\n\n##################################################################################\n# Configures the Emulex HBA specified by \"hba\" with the user-supplied HBA\n# configuration specified by \"userHba\".\n#\n# Parameters:\n#    userHba - The user-supplied HBA configuration from the \"HBA_Config\" custom\n#              attribute.\n#    hba - The Emulex HBA to which the user-supplied HBA configuration is to be\n#          applied.\n##################################################################################\n\ndef emulexConfigureHBA(userHba, hba):\n\n\t# Enables/disables the boot code on the adapter.  If the boot code is\n\t# disabled, the adapter will not boot from SAN, regardless of the value\n\t# for the EnableBootFromSan boot param.  If it is enabled, the adapter\n\t# boot from the SAN if the EnableBootFromSan parameter is also enabled.\n\temulexSetEnableBios(hba.getHbaWWPN(), userHba.getHostAdapterEnableBios(), hba.getModel())\n\n\t# Enable the Boot From SAN if the Host Adapter Enable BIOS is set.\n\temulexSetEnableBootFromSan(hba.getHbaWWPN(), userHba.getHostAdapterEnableBios())\n\n\t# Set the \"AutoScan\" option in Emulex does the opposite of what the\n\t# \"SelectableBoot\" option does in QLogic, we have to enable \"AutoScan\"\n\t# if \"SelectableBoot\" is disabled and vice versa.\n\tif (userHba.getSelectableBootEnable() == \"0\"):\n\t\tautoScan = \"1\"  # Boot from first successfully scanned device.\n\telse:\n\t\tautoScan = \"0\"  # Boot from primary target WWPN/LUN in device list.\t\t\n\n\temulexSetAutoScanEnable(hba.getHbaWWPN(), autoScan)\n\n\t# Tell the HBA what the primary target WWPN and LUN it should boot from.\n\temulexSetPrimaryBootDevice(hba.getHbaWWPN(), userHba.getTargetWWPN(), userHba.getLun())\n\n##################################################################################\n# Performs a simple test to check if there's a Emulex HBA card installed.  Returns\n# True if there is, false otherwise.  This is needed because the \"hbacmd\" command\n# will report an error if there are no HBAs.\n##################################################################################\n\ndef emulexTestForHBA():\n\n\tcmdArgs = [EMULEX_CMD, \"ListHBAs\", \"local\"]\n\n\tretCode, output = executeCommand(cmdArgs)\n\n\tif (retCode == 0):\n\t\treturn True\n\telse:\n\t\tif (DEBUG):\n\t\t\tprint \"retCode => \", retCode\n\t\t\tprint \"output => \", output\n\n\t\treturn False\n\n##################################################################################\n#\n# END EMULEX-SPECIFIC CODE\n#\n##################################################################################\n\n##################################################################################\n# Searches the list of user-specified HBA configuration settings and returns the\n# record, if any, that matches the specified tag number.\n#\n# For example, tags with the same tag number, such as \"BootWWPN-HBA0\", \n# \"BootLUN-HBA0\", \"WWPN-HBA0\", etc, are all stored in the same record, so that if\n# we encounter \"SelectBootEnable-HBA0\" as we're parsing the \"HBA_Config\" custom\n# attribute, it can be added to the same record.\n##################################################################################\n\ndef findUserHbaByTagNumber(userHbaList, tagNum):\n\n\tuserHbaToReturn = None\n\n\tfor userHba in userHbaList:\n\t\tif (userHba.getTagNum() == tagNum):\n\t\t\tuserHbaToReturn = userHba\n\t\t\tbreak\n\n\treturn userHbaToReturn\n\n##################################################################################\n# Searches the list of HBAs and returns the one whose WWPN matches the specified\n# WWPN.\n##################################################################################\n\ndef getHbaByWWPN(hbaList, hbaWWPN):\n\n\tfor hba in hbaList:\n\t\tif (hba.getHbaWWPN() is not None):\n\t\t\tif (hba.getHbaWWPN() == hbaWWPN):\n\t\t\t\treturn hba\n\n\treturn None\n\n##################################################################################\n# Returns the HBA whose order in the list matches the specified HBA number.\n#\n# For example, if \"hbaNumber\" is 0, it returns the first HBA in the list. If\n# \"hbaNumber\" is 1, then it returns the second HBA in the list, and so on.\n##################################################################################\n\ndef getHbaByHbaNumber(hbaList, hbaNumber):\n\n\tcount = 0\n\n\tfor hba in hbaList:\n\t\tif (count == hbaNumber):\n\t\t\treturn hba\n\t\telse:\n\t\t\tcount += 1\n\n\treturn None\n\n##################################################################################\n# Returns True if the specified WWPN or WWNN is in one of the two acceptable\n# formats, False otherwise.\n##################################################################################\n\ndef validateWWN(value):\n\t# The WWPN and WWNN can be in only one of these two formats:\n\t#\n\t#     XX:XX:XX:XX:XX:XX:XX:XX\n\t#\n\t#     or\n\t#\n\t#     XX-XX-XX-XX-XX-XX-XX-XX\n\twwnPattern = re.compile(r\"^[0-9a-fA-F]{2}[:-][0-9a-fA-F]{2}[:-][0-9a-fA-F]{2}[:-][0-9a-fA-F]{2}[:-][0-9a-fA-F]{2}[:-][0-9a-fA-F]{2}[:-][0-9a-fA-F]{2}[:-][0-9a-fA-F]{2}$\")\n\n\tisValid = False\n\n\tresult = wwnPattern.search(value)\n\n\tif result:\n\t\tisValid = True\n\n\treturn isValid\n\n##################################################################################\n# Parses the \"HBA_Config\" custom attribute and returns a list of user-specified\n# HBA configuration settings.\n##################################################################################\n\ndef getUserHbaListFromCustomAttribute():\n\n\tcommentPattern = re.compile(r\"^#.*\")\n\ttagPattern = re.compile(r\"^([\\S-]+)(\\d)+$\")\n\n\tuserHbaList = []\n\n\t# Parse the custom attribute by line.\n\tfor line in HBA_CONFIG_CA_VALUE.splitlines():\n\n\t\t# Skip comment line.\n\t\tresult = commentPattern.search(line)\n\n\t\tif result:\n\t\t\tcontinue\n\n\t\t# Skip empty lines.\n\t\tif len(line.strip()) == 0:\n\t\t\tcontinue\n\n\t\t# Get the tag/value pair.\n\t\ttagVal = line.split(\"=\")\n\n\t\t# The left-hand side of the \"=\" sign will contain the tag name and tag number.\n\t\ttag = tagVal[0].strip()\n\n\t\t# Verify that the value is not empty.\n\t\tif (len(tagVal) > 1) and (len(tagVal[1].strip())) > 0:\n\t\t\tvalue = tagVal[1].strip()\n\t\telse:\n\t\t\traise ShowErrorMessage(\"Custom attribute '%s' has tag '%s' with no value\" % (HBA_CONFIG_CA_NAME,tag))\n\n\t\t# The tag name must end in a number.\n\t\tresult = tagPattern.search(tag)\n\n\t\tif result:\n\t\t\t# Get the tag name.\n\t\t\ttagName = result.group(1)\n\n\t\t\t# Get the tag number, which represents the HBA #.\n\t\t\ttagNum = int(result.group(2))\n\t\telse:\n\t\t\traise ShowErrorMessage(\"Custom attribute '%s' has an invalid tag '%s'\" % (HBA_CONFIG_CA_NAME,tag))\n\n\t\t# Only tags numbers from \"0\" to \"4\" are supported.\n\t\tif (tagNum < 0) or (tagNum > 3):\n\t\t\traise ShowErrorMessage(\"Custom attribute '%s' has an invalid tag '%s'\" % (HBA_CONFIG_CA_NAME,tag))\n\n\t\tfoundHba = True\n\n\t\t# Check if we have already created a record to hold the\n\t\t# user-specified configuration for this HBA number.\n\t\tuserHba = findUserHbaByTagNumber(userHbaList, tagNum)\n\n\t\t# We don't have a record to store this HBA's configuration,\n\t\t# so create one.\n\t\tif (userHba is None):\n\t\t\tuserHba = UserHBA()\n\t\t\tfoundHba = False\n\n\t\t# Validate the tag names. Issue an error if it's not one\n\t\t# of the valid tag names or if we encounter a duplicate\n\t\t# tag name.\n\t\tif (tagName == BOOT_WWPN_HBA_TAG):\n\t\t\tif (userHba.getTargetWWPN() is None):\n\t\t\t\tif (validateWWN(value)):\n\t\t\t\t\tuserHba.setTargetWWPN(value)\n\t\t\t\telse:\n\t\t\t\t\traise ShowErrorMessage(\"Custom attribute '%s' has an invalid value '%s' for tag '%s'\" % (HBA_CONFIG_CA_NAME,value,tag))\n\t\t\telse:\n\t\t\t\traise ShowErrorMessage(\"Custom attribute '%s' has duplicate tag '%s'\" % (HBA_CONFIG_CA_NAME,tag))\n\t\telif (tagName == BOOT_WWNN_HBA_TAG):\n\t\t\tif (userHba.getTargetWWNN() is None):\n\t\t\t\tif (validateWWN(value)):\n\t\t\t\t\tuserHba.setTargetWWNN(value)\n\t\t\t\telse:\n\t\t\t\t\traise ShowErrorMessage(\"Custom attribute '%s' has an invalid value '%s' for tag '%s'\" % (HBA_CONFIG_CA_NAME,value,tag))\n\t\t\telse:\n\t\t\t\traise ShowErrorMessage(\"Custom attribute '%s' has duplicate tag '%s'\" % (HBA_CONFIG_CA_NAME,tag))\n\t\telif (tagName == BOOT_LUN_HBA_TAG):\n\t\t\tif (userHba.getLun() is None):\n\t\t\t\tuserHba.setLun(value)\n\t\t\telse:\n\t\t\t\traise ShowErrorMessage(\"Custom attribute '%s' has duplicate tag '%s'\" % (HBA_CONFIG_CA_NAME,tag))\n\t\telif (tagName == WWPN_HBA_TAG):\n\t\t\tif (userHba.getHbaWWPN() is None):\n\t\t\t\tif (validateWWN(value)):\n\t\t\t\t\tuserHba.setHbaWWPN(value)\n\t\t\t\telse:\n\t\t\t\t\traise ShowErrorMessage(\"Custom attribute '%s' has an invalid value '%s' for tag '%s'\" % (HBA_CONFIG_CA_NAME,value,tag))\n\t\t\telse:\n\t\t\t\traise ShowErrorMessage(\"Custom attribute '%s' has duplicate tag '%s'\" % (HBA_CONFIG_CA_NAME,tag))\n\t\telif (tagName == SELECT_BOOT_ENABLE_TAG):\n\t\t\tif (userHba.getSelectableBootEnable() is None):\n\t\t\t\tif (value == \"0\") or (value == \"1\"):\n\t\t\t\t\tuserHba.setSelectableBootEnable(value)\n\t\t\t\telse:\n\t\t\t\t\traise ShowErrorMessage(\"Custom attribute '%s' has tag '%s' with invalid value '%s'\" % (HBA_CONFIG_CA_NAME,tag, value))\n\t\t\telse:\n\t\t\t\traise ShowErrorMessage(\"Custom attribute '%s' has duplicate tag '%s'\" % (HBA_CONFIG_CA_NAME,tag))\n\t\telif (tagName == HOST_ADAPTER_BIOS_ENABLE_TAG):\n\t\t\tif (userHba.getHostAdapterEnableBios() is None):\n\t\t\t\tif (value == \"0\") or (value == \"1\"):\n\t\t\t\t\tuserHba.setHostAdapterEnableBios(value)\n\t\t\t\telse:\n\t\t\t\t\traise ShowErrorMessage(\"Custom attribute '%s' has tag '%s' with invalid value '%s'\" % (HBA_CONFIG_CA_NAME,tag, value))\n\t\t\telse:\n\t\t\t\traise ShowErrorMessage(\"Custom attribute '%s' has duplicate tag '%s'\" % (HBA_CONFIG_CA_NAME,tag))\n\t\telse:\n\t\t\traise ShowErrorMessage(\"Custom attribute '%s' has an invalid tag '%s'\" % (HBA_CONFIG_CA_NAME,tag))\n\n\t\t# If we didn't already have an entry for this HBA in the list\n\t\t# then add it.\n\t\tif (not foundHba):\n\t\t\tuserHba.setTagNum(tagNum)\n\t\t\tuserHbaList.append(userHba)\n\n\tif (len(userHbaList) > 0):\n\t\t# Verify that the \"BootWWPN-HBA\" and \"BootLUN-HBA\" tags were specified\n\t\t# for each user-supplied HBA configuration in the \"HBA_Config\"\n\t\t# custom attribute.\n\t\tfor hba in userHbaList:\n\t\t\tif (hba.getTargetWWPN() is None):\n\t\t\t\tmissingTag = BOOT_WWPN_HBA + str(hba.getTagNum())\n\t\t\t\traise ShowErrorMessage(\"Custom attribute '%s' is missing tag '%s'\" % (HBA_CONFIG_CA_NAME, missingTag))\n\t\t\telif (hba.getLun() is None):\n\t\t\t\tmissingTag = BOOT_LUN_HBA + str(hba.getTagNum())\n\t\t\t\traise ShowErrorMessage(\"Custom attribute '%s' is missing tag '%s'\" % (HBA_CONFIG_CA_NAME, missingTag))\n\telse:\n\t\traise ShowErrorMessage(\"Custom attribute '%s' does not contain any HBAs to configure\" % HBA_CONFIG_CA_NAME)\n\n\treturn userHbaList\n\n##################################################################################\n# Configures the HBAs specified by \"hbaList\" with the user-supplied HBA\n# configuration specified by \"userHbaList\".\n#\n# For each user-supplied HBA configuration, if the user specified the\n# \"WWPN-HBA\" tag in the \"HBA_Config\" custom attribute, then the configuration\n# parameters will be applied to the HBA whose WWPN matches the value specified\n# in the \"WWPN-HBA\" tag.  If the \"WWPN-HBA\" tag was not specified, then the\n# configuration parameters will be applied to the HBA whose order in the HBA list\n# matches the tag number of the \"BOOT-WWPN\" tag, which can be \"0\" or \"1\". For\n# example, if the tag number is \"0\", then the configuration parameters will be\n# applied to the first HBA in the list.  If the tag number is \"1\", then the\n# configuration parameters will be applied to the second HBA in the list.\n#\n# Parameters:\n#    adapterId - Used to identify the manufacturer of the HBA.  Can be either\n#                EMULEX or QLOGIC.\n#    userHbaList - The user-supplied list of HBA configurations from the\n#                  \"HBA_Config\" custom attribute.\n#    hbaList - The Emulex or QLogic HBAs to which the user-supplied HBA\n#              configuration is to be applied.\n##################################################################################\n\ndef configureHBAs(adapterId, userHbaList, hbaList):\n\n\tfor userHba in userHbaList:\n\t\t# If the user provided the HBA's WWPN, then we'll apply the\n\t\t# boot settings to that HBA.  Otherwise, we'll apply it to\n\t\t# the adapter whose order in the list matches the number of\n\t\t# the tag.  In other words, BootWWPN-HBA0 will get applied\n\t\t# to the first adapter and BootWWPN-HBA1 will get applied\n\t\t# to the second adapter.\n\t\tif (userHba.getHbaWWPN() is not None):\n\t\t\thba = getHbaByWWPN(hbaList, userHba.getHbaWWPN())\n\n\t\t\tif (hba is None):\n\t\t\t\traise ShowErrorMessage(\"Cannot configure HBA #%s because the server does not have an HBA with WWPN '%s'\" % (userHba.getTagNum(), userHba.getHbaWWPN()))\n\t\telse:\n\t\t\tif (DEBUG):\n\t\t\t\tprint \"No WWPN-HBA tag was specified for HBA #%s\" % userHba.getTagNum()\n\n\t\t\thba = getHbaByHbaNumber(hbaList, userHba.getTagNum());\n\n\t\t\tif (hba is None):\n\t\t\t\traise ShowErrorMessage(\"Cannot configure HBA #%s because the server has %s HBA(s)\" % (userHba.getTagNum(), len(hbaList)))\n\n\t\t\tif (DEBUG):\n\t\t\t\tprint \"HBA #%s has WWPN '%s'\" % (userHba.getTagNum(), hba.getHbaWWPN())\n\n\t\tif (adapterId == EMULEX):\n\t\t\temulexConfigureHBA(userHba, hba)\n\t\telif (adapterId == QLOGIC):\n\t\t\tqlogicConfigureHBA(userHba, hba)\n\t\telse:\n\t\t\traise ShowErrorMessage(\"Invalid adapter ID '%d' passed to configureHBAs()\" % adapterId)\n\n##################################################################################\n# Main Routine\n##################################################################################\n\ndef main():\n\n\toptions, remaining_args = parseArgs(sys.argv[1:])\n\n\t# Both the Emulex and QLogic packages must be installed on the\n\t# system, regardless of whether the HBA exists or not.\n\tif (not os.path.exists(EMULEX_CMD)):\n\t\tmsg  = \"'%s' does not exist\" % EMULEX_CMD\n\t\tmsg += \"\\n\"\n\t\tmsg += \"Please verify that the package containing the Emulex utilities is in your Build Plan.\"\n\t\tLOG.exception(msg)\n\t\tsys.stderr.write(\"%s\\n\" % msg)\n\t\treturn 1\n\telif (not os.path.exists(QLOGIC_CMD)):\n\t\tmsg  = \"'%s' does not exist\" % QLOGIC_CMD\n\t\tmsg += \"\\n\"\n\t\tmsg += \"Please verify that the package containing the QLogic utilities is in your Build Plan.\"\n\t\tLOG.exception(msg)\n\t\tsys.stderr.write(\"%s\\n\" % msg)\n\t\treturn 1\n\n\t# Count the number of HBAs we find on the system.  If we don't find\n\t# at least one HBA, then we will issue an error.\n\thbaCount = 0\n\n\ttry:\n\t\t# Test if there's an Emulex HBA card on the system.\n\t\tif (emulexTestForHBA()):\n\t\t\t# Fetch the Emulex HBAs.\n\t\t\temulexHbaList = emulexGetHBAs()\n\t\telse:\n\t\t\temulexHbaList = None\n\n\t\tif (emulexHbaList is not None) and (len(emulexHbaList) != 0):\n\t\t\tprint \"Emulex HBAs:\\n\"\n\t\t\tshowHBAs(emulexHbaList)\n\t\t\tprint \"\\n\"\n\n\t\t\tif (not options.displayHbaOnly):\n\t\t\t\t# Parse the \"HBA_Config\" custom attribute and extract\n\t\t\t\t# the HBA configuration information.\n\t\t\t\tuserHbaList = getUserHbaListFromCustomAttribute()\n\n\t\t\t\t# Configure the Emulex HBAs with the user-specified\n\t\t\t\t# HBA configuration settings.\n\t\t\t\tconfigureHBAs(EMULEX, userHbaList, emulexHbaList)\n\n\t\t\t\t# Fetch the Emulex HBAs again.\n\t\t\t\temulexHbaList = emulexGetHBAs()\n\n\t\t\t\tprint \"Emulex HBAs After Applying Configuration:\\n\"\n\t\t\t\tshowHBAs(emulexHbaList)\n\t\t\t\tprint \"\\n\"\n\n\t\t\thbaCount += 1\n\n\t\t# Test if there's an QLogic HBA card on the system.\n\t\tif (qlogicTestForHBA()):\n\t\t\t# Fetch the QLogic HBAs.\n\t\t\tqlogicHbaList = qlogicGetHBAs()\n\t\telse:\n\t\t\tqlogicHbaList = None\n\n\t\tif (qlogicHbaList is not None) and (len(qlogicHbaList) != 0):\n\t\t\tprint \"QLogic HBAs:\\n\"\n\t\t\tshowHBAs(qlogicHbaList)\n\t\t\tprint \"\\n\"\n\n\t\t\tif (not options.displayHbaOnly):\n\t\t\t\t# Parse the \"HBA_Config\" custom attribute and extract\n\t\t\t\t# the HBA configuration information.\n\t\t\t\tuserHbaList = getUserHbaListFromCustomAttribute()\n\n\t\t\t\t# Configure the QLogic HBAs with the user-specified\n\t\t\t\t# HBA configuration settings.\n\t\t\t\tconfigureHBAs(QLOGIC, userHbaList, qlogicHbaList)\n\n\t\t\t\t# Fetch the QLogic HBAs again.\n\t\t\t\tqlogicHbaList = qlogicGetHBAs()\n\n\t\t\t\tprint \"QLogic HBAs After Applying Configuration:\\n\"\n\t\t\t\tshowHBAs(qlogicHbaList)\n\t\t\t\tprint \"\\n\"\n\n\t\t\thbaCount += 1\n\n\t\t# Issue an error if no HBAs are installed on the system.\n\t\tif (hbaCount == 0):\n\t\t\tmsg = \"No Emulex or QLogic HBAs found\"\n\t\t\tLOG.exception(msg)\n\t\t\tsys.stderr.write(\"%s\\n\" % msg)\n\t\t\treturn 1\n\n\texcept (ShowErrorMessage), why:\n\t\tLOG.exception(why)\n\t\tsys.stderr.write(\"%s\\n\" % why)\n\t\treturn 1\n\nif __name__ == \"__main__\":\n\tsys.exit(main())",
            "description": "Configures the boot device by applying the configuration specified in the HBA_Config multi-line custom attribute to the Emulex CNA, Emulex HBA or Qlogic HBA.\n\nOptional Parameters:\n\n--displayHbaOnly - Show the HBAs on the target server, but don't apply the configuration.\n",
            "status": null,
            "name": "Configure Fibre Channel HBA Boot Device",
            "state": null,
            "eTag": "2015-08-04T07:30:18.000Z",
            "modified": "2015-08-04T07:30:18.000Z",
            "created": "2015-08-04T07:30:17.000Z",
            "category": "os-deployment-server-scripts",
            "uri": "/rest/os-deployment-server-scripts/1820001"
        },
        {
            "runAsSuperUser": true,
            "serverChanging": true,
            "codeType": "BAT",
            "displayCodeType": "Windows .BAT",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "54",
                    "createdBy": "opsware",
                    "createdDate": "2015-08-04T07:30:19.000Z",
                    "usage": "Unmounts the drives containing the Intelligent Provisioning WinPE drivers for ProLiant Gen8 servers .This will ensure the Windows setup utility to use the drivers in the ProLiant Drivers zip package during the Windows installation\n\n\nParameters: None\n\nCustom Attributes: None\n",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-08-04T07:30:19.000Z",
            "version": {
                "versionLabel": "54",
                "createdBy": "opsware",
                "createdDate": "2015-08-04T07:30:19.000Z",
                "usage": "Unmounts the drives containing the Intelligent Provisioning WinPE drivers for ProLiant Gen8 servers .This will ensure the Windows setup utility to use the drivers in the ProLiant Drivers zip package during the Windows installation\n\n\nParameters: None\n\nCustom Attributes: None\n",
                "current": true
            },
            "source": "@echo off\n\n:: (C) Copyright 2013-2015 Hewlett-Packard Development Company, L.P.\n:: Unmount the drives containing Intelligent Provisioning WinPE drivers \necho Checking for existence of Intelligent Provisioning WinPE driver Volume to unmount\nset flag=0\nfor %%d in (c d e f g h i j k l m n o p q r s t u v w y ) do (\nif exist %%d:\\$WinPEdriver$\\ (\n    echo Found drive %%d that contains Intelligent Provisioning WinPE drivers\n    set flag=1\n    mountvol %%d: /p\n    if NOT %errorlevel%==0 (\n        echo Failed to unmount the drive %%d that contains Intelligent Provisioning WinPE drivers\n\t\n    )else  (\n\techo Successfully unmounted the drive %%d that contains Intelligent Provisioning WinPE drivers\n\t\n    )\n  )\n)\n\n\nif %flag%==0 (\n    echo No drive found that contains Intelligent Provisioning WinPE drivers,skipping unmounting\n)",
            "description": "Unmounts the drives containing the Intelligent Provisioning WinPE drivers for ProLiant Gen8 servers .This will ensure the Windows setup utility to use the drivers in the ProLiant Drivers zip package during the Windows installation\n\n\nParameters: None\n\nCustom Attributes: None\n",
            "status": null,
            "name": "Unmount Intelligent Provisioning WinPE Drive",
            "state": null,
            "eTag": "2015-08-04T07:30:19.000Z",
            "modified": "2015-08-04T07:30:19.000Z",
            "created": "2015-08-04T07:30:19.000Z",
            "category": "os-deployment-server-scripts",
            "uri": "/rest/os-deployment-server-scripts/1850001"
        },
        {
            "runAsSuperUser": true,
            "serverChanging": true,
            "codeType": "SH",
            "displayCodeType": "Unix",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "82",
                    "createdBy": "opsware",
                    "createdDate": "2015-08-04T07:30:22.000Z",
                    "usage": "Installs the HP Service Pack for ProLiant on Linux production OS using the HP SUM utility and specified SPP version.\n\nOptional Parameters:\n--spp_version=directory_name    The name of the directory containing the SPP to be installed, such as \"2014.02.0\".  If the value is blank or \"latest\", the script automatically selects the directory with the latest version as determined by sort order.\n\n--hpsum_options=\"option1 option2 option3 ... optionN\"    HP SUM supported command-line options that are to be passed to HP SUM.  Refer to HP SUM's CLIhelp.txt documentation file for available options.\n\n--fail_on_warning : When specified, the script will fail on receiving the error code 253. When absent, the script will be successful for the error code 253. \n\nRequirements:\n* Media Server mounted with Set Media Source script.\n* The directories containing the SPPs must reside on the Media Server under the \"\\Media\\spp\" directory.\n\nCustom Attributes: None",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-08-04T07:30:22.000Z",
            "version": {
                "versionLabel": "82",
                "createdBy": "opsware",
                "createdDate": "2015-08-04T07:30:22.000Z",
                "usage": "Installs the HP Service Pack for ProLiant on Linux production OS using the HP SUM utility and specified SPP version.\n\nOptional Parameters:\n--spp_version=directory_name    The name of the directory containing the SPP to be installed, such as \"2014.02.0\".  If the value is blank or \"latest\", the script automatically selects the directory with the latest version as determined by sort order.\n\n--hpsum_options=\"option1 option2 option3 ... optionN\"    HP SUM supported command-line options that are to be passed to HP SUM.  Refer to HP SUM's CLIhelp.txt documentation file for available options.\n\n--fail_on_warning : When specified, the script will fail on receiving the error code 253. When absent, the script will be successful for the error code 253. \n\nRequirements:\n* Media Server mounted with Set Media Source script.\n* The directories containing the SPPs must reside on the Media Server under the \"\\Media\\spp\" directory.\n\nCustom Attributes: None",
                "current": true
            },
            "source": "#!/bin/sh\n\n# (C) Copyright 2013-2015 Hewlett-Packard Development Company, L.P.\n\n# Globals\n# Media Server mount point location\n# if /mnt/media not exist fall back to /mnt/ms mount point\nmountpoint=/mnt/media\nif [ ! -d \"$mountpoint\" ]\nthen\n\tmountpoint=/mnt/ms\nfi\n\nhpsumargs=\nsppversion=\n\n#Flag to be used in case --fail_on_warning is specified.\nfailonwarning=0\n#Flag to be used in case -logdir is specified.\nlogdir_specified=0\n#Variable to save the new logdir specified.\nnew_logdir=\"/var/hp/log\"\n\n# ====================\n# Determine SPP Version to install\n# Globals set:  sppversion\n# ====================\nFindSPPVersion ()\n{       \n   if [ \"$sppversion\" == \"\" ] || [ \"$sppversion\" == \"latest\" ]; then\n\n      sppversion=$(find \"$mountpoint/Media/spp\" -mindepth 1 -maxdepth 1 -type d -printf %f\\\\n | sort | tail -1)\n\n      if [ \"$sppversion\" == \"\" ]; then\n         echo \"Did not find an SPP Version on the media server\"\n         return 999\n      fi\n      if [ ! -d \"$mountpoint/Media/spp/$sppversion\" ]; then\n         echo \"$mountpoint/Media/spp/$sppversion is not a directory\"\n         return 999\n      fi\n   fi\n   return 0\n}\n\n# ====================\n# Run HPSUM\n# Globals used:  hpsumargs, sppversion\n# ====================\nRunHPSUM ()\n{\n   if [ ! -d \"$mountpoint/Media/spp/$sppversion\" ]; then\n      echo \"$mountpoint/Media/spp/$sppversion does not exist\"\n      return 999\n   fi\n\n   echo \"SPP version to be installed is $sppversion\"\n   echo \"Additional hpsum arguments are $hpsumargs\"\n   # Must be run as currently running directory\n   cd $mountpoint/Media/spp/$sppversion/hp/swpackages\n\n   ./hpsum --silent $hpsumargs\n   rc=$?\n    if [ $rc -gt 3 ] || [ $rc -lt 0 ]; then\n        echo \"SPP hpsum failed: error code $rc\"\n        if [[ $rc -lt 0 ]]; then\n            rc=$(( 256 + $rc ))\n        fi\n      \t  case \"$rc\" in\n\t      255)\n    \t\t  echo \"A general failure occurred. For details, see the error log.\";;\n\t      254)\n    \t\t  echo \"A bad input parameter was encountered.\";;\n              253)\n                  if [ $failonwarning -eq 1 ];then\n\t\t\techo \"ERROR - One or more components failed to install\"\n                        echo \"fail_on_warning is set\"\n       \t\t  else\n\t\t\techo \"WARNING - One or more of the smart components failed to install.\"\n\t\t\techo \"Depending on your system configuration, this may be expected behavior.\"\n\t\t\techo \"To verify the installation, check the hpsum logs located at $new_logdir unless specified otherwise by hpsum -logdir option.\"\n\t\t\techo \"To fail the build plan when these warnings occur, specify the --fail_on_warning option to this step.\"\n\t\t\treturn 0\n\t\t  fi\n\t\t\t;;\n\t  esac\n    \n    echo \"hpsum logs are located at $new_logdir unless specified otherwise by hpsum -logdir option.\"\n    return $rc\n    fi\n    if [ $rc -ge 0 ] || [ $rc -le 3 ]; then\n        case \"$rc\" in\n\t      0)\n    \t\t  echo \"SPP hpsum ran successfully: return code $rc\";;\n\t      1)\n    \t\t  echo \"The installation was successful,but a reboot is required: return code $rc\";;\n              3)\n    \t\t  echo \"The component was current or not required: return code $rc\";;\n\tesac\n    \n    echo \"hpsum logs are located at $new_logdir unless specified otherwise by hpsum -logdir option.\"\n    return 0\n    fi\n}\n\n# ====================\n# Unmount media server\n# Globals used:  mountpoint\n# ====================\nUnmountMediaServer()\n{\n   # Unmount media server drive\n   cd /\n   umount \"$mountpoint\"\n   return 0\n}\n\n# ====================\n# MAIN\n# ====================\n\n# Determine what calling arguments\n# Globals set:  hpsumargs, sppversion\n\nopt=0\nfor i in $*\ndo\n    # Get string to left of =\n    leftstr=${i%=*}\n    # Get string to right of =\n    rightstr=${i##*=}\n    case \"$leftstr\" in\n        \"--spp_version\")\n            sppversion=$rightstr;;\n    \"--hpsum_options\")\n        hpsumargs=$rightstr;;\n    \"--fail_on_warning\")\n       failonwarning=1;;\n    *)\n        if [ $i == \"-logdir\" ];then\n            logdir_specified=1\n            hpsumargs=\"$hpsumargs $i\"\n        elif [ $logdir_specified -eq 1 ]; then\n            hpsumargs=\"$hpsumargs \\\"$i\\\"\"\n            new_logdir=\"\\\"$i\\\"\"\n            logdir_specified=0\n        else\n            hpsumargs=\"$hpsumargs $i\"\n        fi\n        ;;\n    esac\ndone\n\n\nFindSPPVersion\nreturncode=$?\n\nif [ $returncode -eq 0 ]; then\n    RunHPSUM\n    returncode=$?\nfi\nUnmountMediaServer\n\nexit $returncode\n",
            "description": "Installs the HP Service Pack for ProLiant on Linux production OS using the HP SUM utility and specified SPP version.\n\nOptional Parameters:\n--spp_version=directory_name    The name of the directory containing the SPP to be installed, such as \"2014.02.0\".  If the value is blank or \"latest\", the script automatically selects the directory with the latest version as determined by sort order.\n\n--hpsum_options=\"option1 option2 option3 ... optionN\"    HP SUM supported command-line options that are to be passed to HP SUM.  Refer to HP SUM's CLIhelp.txt documentation file for available options.\n\n--fail_on_warning : When specified, the script will fail on receiving the error code 253. When absent, the script will be successful for the error code 253. \n\nRequirements:\n* Media Server mounted with Set Media Source script.\n* The directories containing the SPPs must reside on the Media Server under the \"\\Media\\spp\" directory.\n\nCustom Attributes: None",
            "status": null,
            "name": "Install Linux SPP",
            "state": null,
            "eTag": "2015-08-04T07:30:22.000Z",
            "modified": "2015-08-04T07:30:22.000Z",
            "created": "2015-08-04T07:30:22.000Z",
            "category": "os-deployment-server-scripts",
            "uri": "/rest/os-deployment-server-scripts/1870001"
        },
        {
            "runAsSuperUser": true,
            "serverChanging": true,
            "codeType": "PY2",
            "displayCodeType": "Python",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "21",
                    "createdBy": "opsware",
                    "createdDate": "2015-08-04T07:30:24.000Z",
                    "usage": "Deletes any custom boot options that were created in the UEFI boot menu by OSs that have been previously installed or manually by the user.  Boot options that were created by the ROM for devices that were discovered on the system are not deleted.  This script can only be run on a Linux OS that has the efibootmgr utility.",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-08-04T07:30:24.000Z",
            "version": {
                "versionLabel": "21",
                "createdBy": "opsware",
                "createdDate": "2015-08-04T07:30:24.000Z",
                "usage": "Deletes any custom boot options that were created in the UEFI boot menu by OSs that have been previously installed or manually by the user.  Boot options that were created by the ROM for devices that were discovered on the system are not deleted.  This script can only be run on a Linux OS that has the efibootmgr utility.",
                "current": true
            },
            "source": "#!/usr/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n#\n\"\"\"\n(C) Copyright 2014-2015 Hewlett-Packard Development Company, L.P.\n\"\"\"\n\nimport sys\nimport re\nimport subprocess\nimport os.path\nfrom sys import platform as _platform\nfrom subprocess import Popen, PIPE, STDOUT\nfrom osprov import ilo\nfrom osprov.osbp import logger\nfrom osprov.errors import ShowErrorMessage\nfrom osprov.server.local import ThisLocalServer\n\nDEBUG=@Debug:0@\n\nlog = logger.getIt(\"Delete UEFI Custom Boot Options\")\n\n# Writes an debug message to stdout and the logger.\ndef writeDebugMessage(msg):\n\n    # Write the message to stdout so that it shows up in the job output.\n    if (DEBUG):\n        print msg\n\n    # Write the message to the logger so that it shows up in the log files.\n    log.debug(msg);\n\n# Writes an info message to stdout and the logger.\ndef writeInfoMessage(msg):\n\n    # Write the message to stdout so that it shows up in the job output.\n    print msg\n\n    # Write the message to the logger so that it shows up in the log files.\n    log.info(msg);\n\n# Writes an error message to stderr and the logger.\ndef writeErrorMessage(msg):\n\n    # Write the message to stderr so that it shows up in the job output.\n    sys.stderr.write(msg)\n\n    # Write the message to the logger so that it shows up in the log files.\n    log.error(msg);\n\n# Converts the specified list to a string that is delimited by the specified\n# delimiter character (default = ' ').\ndef listToString(list, delimeter=' '):\n\n    str = delimeter.join(list)\n\n    return str\n\n# Executes the specified command, which must be a list contaning the \n# executable name and its arguments.\ndef executeCommand(cmdArgs):\n\n    cmdAsString = listToString(cmdArgs)\n\n    writeDebugMessage(\"Executing => %s\" % cmdAsString)\n\n    p = subprocess.Popen(cmdArgs, stdout=subprocess.PIPE, stderr=STDOUT)\n\n    output = p.communicate()[0].strip()\n\n    retCode = p.poll()\n\n    p.stdout.close()\n\n    return retCode, output\n\n# Adds a boot option for ESXi to the top of the UEFI Boot Order.\ndef getBootOptions():\n\n    cmdArgs = [\"efibootmgr\", \"-v\"]\n\n    retCode, output = executeCommand(cmdArgs)\n\n    if (retCode != 0):\n        writeErrorMessage(\"Failed to get the list of boot options\")\n        raise ShowErrorMessage(\"An error occurred while executing '%s' : %s\" % (listToString(cmdArgs), output))\n\n    return output.splitlines()\n\n# Returns the list of custom boot options.\ndef getCustomBootOptions():\n\n    # Initialize custom boot options list.\n    customBootOptions = []\n\n    bootOptions = getBootOptions();\n\n    if (len(bootOptions) > 0):\n        customBootOptionPattern = re.compile(r\"^Boot[0-9A-Za-z]{4}.*File\\(.+\\).*$\")\n\n        for bootOption in bootOptions:\n            result = customBootOptionPattern.search(bootOption)\n\n            if result:\n                writeDebugMessage(\"customBootOption = %s\" % bootOption)\n                customBootOptions.append(bootOption)\n    else:\n        writeErrorMessage(\"No boot options found\")\n        raise ShowErrorMessage(\"No boot options found\");\n\n    return customBootOptions\n\n# Deletes the boot option that corresponds to the specified boot option ID.\ndef deleteBootOption(bootOptionID):\n\n    cmdArgs = [\"efibootmgr\", \"--inactive\", \"--bootnum\", bootOptionID]\n\n    retCode, output = executeCommand(cmdArgs)\n\n    if (retCode == 0):\n        writeDebugMessage(\"Successfully inactivated boot option ID '%s'\" % bootOptionID)\n    else:\n        writeErrorMessage(\"Failed to inactivate boot option ID '%s'\" % bootOptionID)\n        raise ShowErrorMessage(\"An error occurred while executing '%s' : %s\" % (listToString(cmdArgs), output))\n\n    cmdArgs = [\"efibootmgr\", \"--delete-bootnum\", \"--bootnum\", bootOptionID]\n\n    retCode, output = executeCommand(cmdArgs)\n\n    if (retCode == 0):\n        writeDebugMessage(\"Successfully deleted boot option ID '%s'\" % bootOptionID)\n    else:\n        writeErrorMessage(\"Failed to deleted boot option ID '%s'\" % bootOptionID)\n        raise ShowErrorMessage(\"An error occurred while executing '%s' : %s\" % (listToString(cmdArgs), output))\n\n# Deletes the custom boot options.\ndef deleteCustomBootOptions():\n\n    # Get the list of custom boot options.\n    customBootOptions = getCustomBootOptions();\n\n    if (len(customBootOptions) == 0):\n        writeInfoMessage(\"No custom boot options found\")\n        return 0\n\n    # Extract the \"####\" ID from \"Boot####\".\n    bootOptionIdPattern = re.compile(r\"^[Bb][Oo][Oo][Tt]([0-9A-Za-z]{4}).*\")\n\n    # Delete all the custom boot options using their \"####\" ID.\n    for customBootOption in customBootOptions:\n        result = bootOptionIdPattern.search(customBootOption)\n\n        if result:\n            writeInfoMessage(\"Deleting custom boot option => %s\" % customBootOption)\n\n            bootOptionID = result.group(1)\n\n            deleteBootOption(bootOptionID)\n\n# Returns \"True\" if the server is in UEFI mode; \"False\" otherwise.\ndef isServerInUefiMode():\n\n    targetServer = ThisLocalServer()\n\n    iloServer = ilo.getIlo(targetServer, log=log)\n\n    currentBootMode = iloServer.getCurrentBootMode()\n\n    uefiPattern = re.compile(r\".*UEFI.*\")\n\n    result = uefiPattern.search(currentBootMode)\n\n    if result:\n        uefiMode = True\n    else:\n        uefiMode = False\n\n    return uefiMode\n\n# Returns \"True\" if the OS is supported; \"False\" otherwise.  Currently this script can\n# only be run on Linux OSs which provide the \"efibootmgr\" utility.\ndef checkIfOsIsSupported():\n\n    if (DEBUG):\n        print \"_platform = %s\" % _platform\n\n    if _platform == \"linux\" or _platform == \"linux2\" or _platform == \"linux-x86_64\":\n        return True\n    else:\n        return False\n\n# Main Routine\ndef main():\n\n    if (checkIfOsIsSupported()):\n        if (isServerInUefiMode()):\n            writeDebugMessage(\"Boot Mode is UEFI\")\n            deleteCustomBootOptions()\n        else:\n            print \"Boot Mode is not UEFI.  Skipping this step.\"\n    else:\n        writeErrorMessage(\"This script can only be run on Linux\\n\")\n        return 1\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n",
            "description": "Deletes any custom boot options that were created in the UEFI boot menu by OSs that have been previously installed or manually by the user.  Boot options that were created by the ROM for devices that were discovered on the system are not deleted.  This script can only be run on a Linux OS that has the efibootmgr utility.",
            "status": null,
            "name": "Delete UEFI Custom Boot Options",
            "state": null,
            "eTag": "2015-08-04T07:30:24.000Z",
            "modified": "2015-08-04T07:30:24.000Z",
            "created": "2015-08-04T07:30:23.000Z",
            "category": "os-deployment-server-scripts",
            "uri": "/rest/os-deployment-server-scripts/1890001"
        },
        {
            "runAsSuperUser": true,
            "serverChanging": true,
            "codeType": "SH",
            "displayCodeType": "Unix",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "12",
                    "createdBy": "opsware",
                    "createdDate": "2015-08-04T07:30:24.000Z",
                    "usage": "This script is intended to accompany the Insight Control server provisioning Capturing and Installing Linux System Images white paper. \n\nThis script sets up the target server to re-install the HP SA Agent after the server has rebooted for the first time into production\n\nRequired Parameters: IP address of the appliance\n",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-08-04T07:30:24.000Z",
            "version": {
                "versionLabel": "12",
                "createdBy": "opsware",
                "createdDate": "2015-08-04T07:30:24.000Z",
                "usage": "This script is intended to accompany the Insight Control server provisioning Capturing and Installing Linux System Images white paper. \n\nThis script sets up the target server to re-install the HP SA Agent after the server has rebooted for the first time into production\n\nRequired Parameters: IP address of the appliance\n",
                "current": true
            },
            "source": "#!/bin/bash\n# (C) Copyright 2012-2015 Hewlett-Packard Development Company, L.P.\nicspip=\"@@REPLACE_ME@@\"\n \nif [ \"$icspip\" == \"@@REPLACE_ME@@\" ]; then\n    # script is running on server as part of deployment\n    # need to set it up so that it runs after rebooting\n    # deployed server.\n    if [ -f \"$0\" ]; then\n        sed -i -e \"s/=\\\"@@REPLACE_ME@@/=\\\"$1/\" $0\n        cp $0 /mnt/target/etc/init.d/hpsa_agent_installer\n        # copy server into /rc{3,5}.d to run on startup.\n        cp $0 /mnt/target/etc/rc3.d/S40hpsa_agent_installer\n        cp $0 /mnt/target/etc/rc5.d/S40hpsa_agent_installer\n \n        rm -rf /mnt/target/etc/opt/opsware/agent/mid\n        rm -rf /mnt/target/var/opt/opsware/crypto/agent\n        cp -R /var/opt/opsware/crypto/agent \\\n                /mnt/target/var/opt/opsware/crypto\n        cp /etc/opt/opsware/agent/mid \\\n                /mnt/target/etc/opt/opsware/agent/mid\n    else\n        echo \"Could not find script $0\"\n        exit 1\n    fi\n    rm -rf /mnt/target/etc/rc*.d/*opsware*\n    echo \"Done creating installation script for post reboot agent installation..\"\n    exit 0\nelse\n    cp /etc/rc3.d/S40hpsa_agent_installer /tmp\n    rm -rf /etc/rc?.d/S40hpsa_agent_installer\n    rm -rf /etc/init.d/hpsa_agent_installer\nfi\n \nlogfile=/tmp/Migrate.log\ncd /tmp\nfilename=\"\"\necho \"**************************************************\" >> $logfile\necho \"***********  Start    ****************************\" >> $logfile\necho \"**************************************************\" >> $logfile\necho `date` >> $logfile\nuname -a | grep 86_64 \nif [ $? -eq 1 ] ; then\n    echo \"Cannot migrate x86 target\" >> $logfile\n    exit \"11\"\nfi\nif [ -e /etc/redhat-release ] ; then\n        cat /etc/redhat-release | grep \"7.*\"\n        if [ $? -eq 0 ] ; then\n                echo \"found RHEL7\" >> $logfile\n                filename=\"opsware-agent-LINUX-7SERVER-X86_64\"\n        fi\n        cat /etc/redhat-release | grep \"6.*\"\n        if [ $? -eq 0 ] ; then\n                echo \"found RHEL6\" >> $logfile\n                filename=\"opsware-agent-LINUX-6SERVER-X86_64\"\n        fi\n        cat /etc/redhat-release | grep \"5.*\"\n        if [ $? -eq 0 ] ; then\n                echo \"found RHEL5\" >> $logfile\n                filename=\"opsware-agent-LINUX-5SERVER-X86_64\"\n        fi\nfi\nif [ -e /etc/SuSE-release ] ; then\n        cat /etc/SuSE-release | grep -i \"version = 11\"\n        if [ $? -eq 0 ] ; then\n                echo \"found sles11\" >> $logfile\n                filename=\"opsware-agent-LINUX-SLES-11-X86_64\"\n        fi\n        cat /etc/SuSE-release | grep -i \"version = 10\"\n        if [ $? -eq 0 ] ; then\n                echo \"found sles10\" >> $logfile\n                filename=\"opsware-agent-LINUX-SLES-10-X86_64\"\n        fi\nfi\necho \"File to Download -> $filename\" >> $logfile\n \nif [ -n \"$filename\" ] ; then\n \n     # Print diagnostic messages and wait for network to come up, before downloading.\n     echo \"START NETWORK DIAGNOSTIC INFO\"\n     ifconfig -a\n     netstat -rn\n     for i in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 ; do\n          python -c \"import socket; s = socket.socket(socket.AF_INET, socket.SOCK_STREAM); s.settimeout(10); s.connect(('$icspip', 3001)); print 'Gateway $gw listening on port $port'\"\n          if [ $? -eq 0 ] ; then break; \n          fi\n          sleep 1\n     done\n     echo \"END NETWORK DIAGNOSTIC INFO\"\n \n     wget http://$icspip:8081/$filename >> $logfile\n     if [ -e \"$filename\" ] ; then\n          chmod +x $filename\n          echo \"Execute ./$filename -s --opsw_gw_list $icspip:3001\" \\\n             >> $logfile\n          ./$filename -s --settime --force_full_hw_reg \\\n        --force_sw_reg --opsw_gw_list $icspip:3001 >> $logfile\n     else\n                       echo \"Download failed for http://$icspip:8081/$filename\" \\\n                             >> $logfile\n          exit \"1\"\n     fi\nelse\n     echo \"Download failed for http://$icspip:8081/$filename\" \\\n          >> $logfile\n     exit \"1\"\nfi\nexit 0\n",
            "description": "This script is intended to accompany the Insight Control server provisioning Capturing and Installing Linux System Images white paper. \n\nThis script sets up the target server to re-install the HP SA Agent after the server has rebooted for the first time into production\n\nRequired Parameters: IP address of the appliance\n",
            "status": null,
            "name": "Sample - Re-Install RHEL HP SA Agent",
            "state": null,
            "eTag": "2015-08-04T07:30:24.000Z",
            "modified": "2015-08-04T07:30:24.000Z",
            "created": "2015-08-04T07:30:24.000Z",
            "category": "os-deployment-server-scripts",
            "uri": "/rest/os-deployment-server-scripts/1900001"
        },
        {
            "runAsSuperUser": true,
            "serverChanging": true,
            "codeType": "SH",
            "displayCodeType": "Unix",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "14",
                    "createdBy": "opsware",
                    "createdDate": "2015-08-04T07:30:24.000Z",
                    "usage": "Resets the target server's BIOS system configuration to factory default settings using the rbsureset utility.\n\nParameters: None\n\nCustom Attribute: None",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-08-04T07:30:24.000Z",
            "version": {
                "versionLabel": "14",
                "createdBy": "opsware",
                "createdDate": "2015-08-04T07:30:24.000Z",
                "usage": "Resets the target server's BIOS system configuration to factory default settings using the rbsureset utility.\n\nParameters: None\n\nCustom Attribute: None",
                "current": true
            },
            "source": "#!/bin/sh\n\n# (C) Copyright 2013-2015 Hewlett-Packard Development Company, L.P.\n\nUTIL=rbsureset\nDIR=\"/tmp/sstk\"\n\nif [ ! -f \"$DIR/$UTIL\" ]; then\n   echo \"$DIR/$UTIL can not be found\" 1>&2\n   exit 1\nfi\n\nchmod +x \"$DIR/$UTIL\"\n\n# Run Utility\n\"$DIR/$UTIL\"\nrc=$?\n\ncase $rc in\n   0 )\n      echo \"$UTIL successful\";;\n   127 )\n      echo \"$UTIL failed ($rc): Missing library in automation\" 1>&2;;\n   * )\n      echo \"$UTIL failed ($rc)\" 1>&2 ;;\nesac\nexit $rc",
            "description": "Resets the target server's BIOS system configuration to factory default settings using the rbsureset utility.\n\nParameters: None\n\nCustom Attribute: None",
            "status": null,
            "name": "Reset System Configuration",
            "state": null,
            "eTag": "2015-08-04T07:30:24.000Z",
            "modified": "2015-08-04T07:30:24.000Z",
            "created": "2015-08-04T07:30:24.000Z",
            "category": "os-deployment-server-scripts",
            "uri": "/rest/os-deployment-server-scripts/1910001"
        },
        {
            "runAsSuperUser": true,
            "serverChanging": true,
            "codeType": "SH",
            "displayCodeType": "Unix",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "7",
                    "createdBy": "opsware",
                    "createdDate": "2015-08-04T07:30:25.000Z",
                    "usage": "Executing conrep for SMBIOS modification.\n\nArguments\n$1 = capture/deploy switch (-s or -l)\n$2 = input/output filename\n$3 = template file (optional for deployment, needed for conrep capture)",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-08-04T07:30:25.000Z",
            "version": {
                "versionLabel": "7",
                "createdBy": "opsware",
                "createdDate": "2015-08-04T07:30:25.000Z",
                "usage": "Executing conrep for SMBIOS modification.\n\nArguments\n$1 = capture/deploy switch (-s or -l)\n$2 = input/output filename\n$3 = template file (optional for deployment, needed for conrep capture)",
                "current": true
            },
            "source": "#!/bin/sh\n\n# (C) Copyright 2013-2015 Hewlett-Packard Development Company, L.P.\n\nUTIL=conrep\nDIR=\"/tmp/sstk\"\nMODE=$1\nFILE=$2\n\nTEMPLATEFILE=\"\"\nif [ ! -z $3 ]; then\n\tTEMPLATEFILE=\"-x$DIR/$3\"\nelse\n\tTEMPLATEFILE=\"-x$DIR/conrep.xml\"\nfi\n\nif [ ! -f \"$DIR/$UTIL\" ]; then\n\techo \"$DIR/$UTIL can not be found\" 1>&2\n\texit 1\nfi\n\nchmod +x \"$DIR/$UTIL\"\n\n##Run Conrep\n\n\"$DIR/$UTIL\" $MODE -f \"$FILE\" \"$TEMPLATEFILE\"\nrc=$?\n\ncase $rc in\n   0 )\n\t\techo \"$UTIL successful\";;\n   127 )\n\t\techo \"$UTIL failed ($rc): Missing library in automation\" 1>&2;;\n   134 )\n\t\techo \"$UTIL failed ($rc): Corrupted custom post message\" 1>&2 ;;\n   * )\n\t\techo \"$UTIL failed ($rc)\" 1>&2 ;;\nesac\nexit $rc\n",
            "description": "Executing conrep for SMBIOS modification.\n\nArguments\n$1 = capture/deploy switch (-s or -l)\n$2 = input/output filename\n$3 = template file (optional for deployment, needed for conrep capture)",
            "status": null,
            "name": "Manage System Configuration",
            "state": null,
            "eTag": "2015-08-04T07:30:25.000Z",
            "modified": "2015-08-04T07:30:25.000Z",
            "created": "2015-08-04T07:30:25.000Z",
            "category": "os-deployment-server-scripts",
            "uri": "/rest/os-deployment-server-scripts/1920001"
        },
        {
            "runAsSuperUser": true,
            "serverChanging": true,
            "codeType": "BAT",
            "displayCodeType": "Windows .BAT",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "7",
                    "createdBy": "opsware",
                    "createdDate": "2015-08-04T07:30:26.000Z",
                    "usage": "Verifies that the ImageX package contains 'imagex.exe'.  The ImageX package that comes with the appliance does not contain 'imagex.exe' because Microsoft Windows PE and WAIK license agreements do not permit this.  In order to add 'imagex.exe' to the ImageX package, WinPE must be uploaded to the appliance.\n\nRequirements:\n\n* The ImageX package must have already been installed in the '<SystemDrive>\\HPPROVTEMP' directory in a previous Build Plan step\n   if the target server is in the production OS, or in \"X:\\Windows\\System32\" if the target server is in WinPE.  The '<SystemDrive>\\HPPROVTEMP' directory is removed after the contents of the ImageX package have been verified.",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-08-04T07:30:26.000Z",
            "version": {
                "versionLabel": "7",
                "createdBy": "opsware",
                "createdDate": "2015-08-04T07:30:26.000Z",
                "usage": "Verifies that the ImageX package contains 'imagex.exe'.  The ImageX package that comes with the appliance does not contain 'imagex.exe' because Microsoft Windows PE and WAIK license agreements do not permit this.  In order to add 'imagex.exe' to the ImageX package, WinPE must be uploaded to the appliance.\n\nRequirements:\n\n* The ImageX package must have already been installed in the '<SystemDrive>\\HPPROVTEMP' directory in a previous Build Plan step\n   if the target server is in the production OS, or in \"X:\\Windows\\System32\" if the target server is in WinPE.  The '<SystemDrive>\\HPPROVTEMP' directory is removed after the contents of the ImageX package have been verified.",
                "current": true
            },
            "source": "@echo off\r\n\r\n:: (C) Copyright 2013-2015 Hewlett-Packard Development Company, L.P.\r\n\r\nset imagexValidated=0\r\n\r\nREM When run from production Windows, this script expects that the ImageX package \r\nREM was previously extracted to \"\\HPPROVTEMP\" on the system drive so that its\r\nREM contents can be checked to see if 'imagex.exe' present.\r\nREM\r\nREM WARNING: DO NOT CHANGE THIS DIRECTORY. IT AND ITS SUBDIRECTORIES AND FILES\r\nREM          ARE RECURSIVELY REMOVED AT THE END OF THIS SCRIPT.  SPECIFYING\r\nREM          A DIFFERENT DIRECTORY MAY CAUSE DAMAGE TO YOUR SYSTEM.\r\nset hpProvTempDir=%SystemDrive%\\HPPROVTEMP\r\n\r\nREM In WinPE, it is expected that \"imagex.exe\" will always be extracted to\r\nREM the \"X:\\Windows\\System32\".\r\nset winPeSystemDir=X:\\Windows\\System32\r\n\r\nREM If the ImageX package was extracted to \"\\HPPROVTEMP\", then the directory will exist.\r\nif exist \"%hpProvTempDir%\" (\r\n    REM Check if 'imagex.exe' is in the ImageX package.  The ImageX package\r\n    REM will not contain 'imagex.exe' until WinPE is uploaded to the appliance.\r\n    if exist \"%hpProvTempDir%\\imagex.exe\" (\r\n        echo '%hpProvTempDir%\\imagex.exe' exists\r\n\r\n        set imagexValidated=1\r\n    ) else (\r\n        echo '%hpProvTempDir%\\imagex.exe' was not found\r\n    )\r\n\r\n    echo Removing directory '%hpProvTempDir%'\r\n\r\n    REM Remove the temporary directory where the ImageX package contents were\r\n    REM extracted to.\r\n    rmdir /S /Q %hpProvTempDir%\r\n\r\n    if %errorlevel% neq 0 (\r\n        echo Failed to remove '%hpProvTempDir%' 1>&2\r\n    )\r\n)\r\n\r\nREM If \"imagex.exe\" was not extracted to \"\\HPPROVTEMP\" on the system drive of\r\nREM the production OS, then check for it in \"X:\\Windows\\System32\", in case we're\r\nREM in WinPE.\r\nif \"%imagexValidated%\" == \"0\" (\r\n    if exist \"%winPeSystemDir%\" (\r\n        if exist \"%winPeSystemDir%\\imagex.exe\" (\r\n            echo '%winPeSystemDir%\\imagex.exe' exists\r\n\r\n            set imagexValidated=1\r\n        ) else (\r\n            echo '%winPeSystemDir%\\imagex.exe' was not found.\r\n        )\r\n    ) else (\r\n        echo The directory '%winPeSystemDir%' does not exist.\r\n    )\r\n)\r\n\r\nif \"%imagexValidated%\" == \"1\" (\r\n    exit /B 0\r\n) else (\r\n    echo The ImageX package in this Build Plan does not contain 'imagex.exe'. 1>&2\r\n    echo In order to add 'imagex.exe' to the ImageX package, WinPE must be 1>&2\r\n    echo uploaded to the appliance. 1>&2\r\n\r\n    exit /B 1\r\n)\r\n\r\n",
            "description": "Verifies that the ImageX package contains 'imagex.exe'.  The ImageX package that comes with the appliance does not contain 'imagex.exe' because Microsoft Windows PE and WAIK license agreements do not permit this.  In order to add 'imagex.exe' to the ImageX package, WinPE must be uploaded to the appliance.\n\nRequirements:\n\n* The ImageX package must have already been installed in the '<SystemDrive>\\HPPROVTEMP' directory in a previous Build Plan step\n   if the target server is in the production OS, or in \"X:\\Windows\\System32\" if the target server is in WinPE.  The '<SystemDrive>\\HPPROVTEMP' directory is removed after the contents of the ImageX package have been verified.",
            "status": null,
            "name": "Validate ImageX Package Contents",
            "state": null,
            "eTag": "2015-08-04T07:30:26.000Z",
            "modified": "2015-08-04T07:30:26.000Z",
            "created": "2015-08-04T07:30:26.000Z",
            "category": "os-deployment-server-scripts",
            "uri": "/rest/os-deployment-server-scripts/1930001"
        },
        {
            "runAsSuperUser": true,
            "serverChanging": true,
            "codeType": "SH",
            "displayCodeType": "Unix",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "23",
                    "createdBy": "opsware",
                    "createdDate": "2015-08-04T07:30:27.000Z",
                    "usage": "This script will set one time PXE boot.  It is intended for servers migrated from IC Server Deployment.",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-08-04T07:30:27.000Z",
            "version": {
                "versionLabel": "23",
                "createdBy": "opsware",
                "createdDate": "2015-08-04T07:30:27.000Z",
                "usage": "This script will set one time PXE boot.  It is intended for servers migrated from IC Server Deployment.",
                "current": true
            },
            "source": "#!/bin/sh\n# (C) Copyright 2013-2015 Hewlett-Packard Development Company, L.P.\n\n# Script uses the /sbin/hpbootcfg utility to set a one time PXE boot\n\nif [ -x /sbin/hpbootcfg ]; then\n  /sbin/hpbootcfg -P\n  if [ $? -ne 0 ]; then\n     echo \"Setting of one time PXE boot failed\"\n     exit 1\n  fi\nelse\n  echo \"Required utility /sbin/hpbootcfg does not exist\"\n  exit 1\nfi",
            "description": "This script will set one time PXE boot.  It is intended for servers migrated from IC Server Deployment.",
            "status": null,
            "name": "Set One Time PXE Boot",
            "state": null,
            "eTag": "2015-08-04T07:30:27.000Z",
            "modified": "2015-08-04T07:30:27.000Z",
            "created": "2015-08-04T07:30:27.000Z",
            "category": "os-deployment-server-scripts",
            "uri": "/rest/os-deployment-server-scripts/1940001"
        },
        {
            "runAsSuperUser": true,
            "serverChanging": true,
            "codeType": "SH",
            "displayCodeType": "Unix",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "34",
                    "createdBy": "opsware",
                    "createdDate": "2015-08-04T07:30:28.000Z",
                    "usage": "Updates the target server's (Gen8 or above)  Intelligent Provisioning firmware with specified Intelligent Provisioning media.\n\nOptional Parameters:\n--ip_version=directory_name    The name of the directory containing the Intelligent Provisioning media to be installed, such as \"1.60\".  If the value is blank or \"latest\", the script automatically selects the directory with the latest version as determined by sort order.\n\nRequirements:\n* Media Server mounted with Set Media Source script.\n* The directories containing the extracted HP Intelligent Provisioning ISO must reside on the Media Server under the \"\\Media\\ip\" directory.\n",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-08-04T07:30:28.000Z",
            "version": {
                "versionLabel": "34",
                "createdBy": "opsware",
                "createdDate": "2015-08-04T07:30:28.000Z",
                "usage": "Updates the target server's (Gen8 or above)  Intelligent Provisioning firmware with specified Intelligent Provisioning media.\n\nOptional Parameters:\n--ip_version=directory_name    The name of the directory containing the Intelligent Provisioning media to be installed, such as \"1.60\".  If the value is blank or \"latest\", the script automatically selects the directory with the latest version as determined by sort order.\n\nRequirements:\n* Media Server mounted with Set Media Source script.\n* The directories containing the extracted HP Intelligent Provisioning ISO must reside on the Media Server under the \"\\Media\\ip\" directory.\n",
                "current": true
            },
            "source": "#!/bin/bash\n\n#(C) Copyright 2014-2015 Hewlett-Packard Development Company, L.P.\n\nmountPoint=/mnt/media\nif [ ! -d \"$mountPoint\" ];\nthen\n   mountPoint=/mnt/ms\nfi\n\nipFolder=\"$mountPoint/Media/ip/\"\nipVersion=\nblobUpdateNeeded=1\n\nif [ ! -d \"$mountPoint/Media/ip\" ]; then\n   echo \"The 'Media/ip' directory was not found on the Media Server.\" 1>&2\n   echo \"Make sure that this directory exists and that a subdirectory containing the extracted Intelligent Provisioning media also exists.\" 1>&2\n   exit 2\nfi\n\n#Create /tmp/ip\nipInitrd=/tmp/ip\nmkdir -p $ipInitrd\n\n##############################################################################\n# This function determines which version of the IP to install.  Unless a\n# specific IP version is specifed, the latest IP, as determined by the\n# sort order, is used.\n##############################################################################\n\nfindIPVersion()\n{\n    if [ \"$ipVersion\" == \"\" ] || [ \"$ipVersion\" == \"latest\" ]\n    then\n        ipVersion=$(find \"${ipFolder}\" -mindepth 1 -maxdepth 1 -type d -printf %f\\\\n | sort | tail -1)\n\n        if [ \"$ipVersion\" == \"\" ]\n        then\n            echo \"No IP directories were found under '${ipFolder}'\" 1>&2\n            echo \"Check your media server and verify that there is at least one directory under the '/Media/ip' directory which contains the IP files\" 1>&2\n            echo \"IP directories are typically named using the IP version, for example '1.60'\" 1>&2\n            return 1\n        fi\n    fi\n\n    ipVersionDir=${ipFolder}/${ipVersion}\n\n    # Check for a valid Intelligent Provisioning firmware directory.\n    if [ ! -e \"${ipVersionDir}\" ]\n    then\n        echo \"'${ipVersionDir}' does not exist\" 1>&2\n        return 1\n    elif [ ! -d \"${ipVersionDir}\" ]\n    then\n        echo \"'${ipVersionDir}' is not a directory\" 1>&2\n        return 1\n    fi\n    \n    echo \"IP folder to use: $ipVersion\"\n    return 0\n}\n\nextractInitrd() {\n#Extract IP's initrd.img into /tmp/ip\n  cd $ipInitrd\n  output=$(xz -d < \"$ipFolder/$ipVersion/system/initrd.img\" 2>&1 | cpio -id 2>&1)\n\n  if [ $? != 0 ]; then\n     echo \"Unable to access files from Intelligent Provisioning media\"\n     echo ${output}\n     return 1\n  fi\n}\n\n# Writes the specified blob, with several retries in case of a failure.\nwriteBlob() {\n    blobName=$1\n    fileName=$2\n\n    retCode=0\n\n    output=\"\"\n\n    count=0\n\n    # Try to write the blob up to 5 times.\n    while [ ${count} -lt 5 ]\n    do\n        cmd=\"hpblob -w -k ${blobName} -f ${fileName}\"\n\n        output=$(${cmd} 2>&1)\n\n        retCode=$?\n\n        if [ $retCode -eq 0 ]\n        then\n            break\n        else\n            echo \"'${cmd}' failed with exit code ${retCode}\" 1>&2\n            count=$(($count + 1))\n            sleep 10\n        fi\n    done\n\n    if [ ${count} -ge 5 ]\n    then\n        echo \"Failed to write blob '${blobName}' after ${count} tries\" 1>&2\n        echo ${output} 1>&2\n        retCode=1\n    fi\n\n    return ${retCode}\n}\n\n# Sets the SSNETWORK blob to do DHCP.\nwriteSsnetworkBlobForDhcp() {\n    echo \"<network><device>eth0</device><mode>dhcp</mode><staticip></staticip><staticmask></staticmask><staticgateway></staticgateway><staticdns></staticdns><repo_type>0</repo_type><repo_url></repo_url><proxyip></proxyip><proxyport></proxyport></network>\" > /tmp/net\n\n    writeBlob SSNETWORK /tmp/net || return 1\n\n    return 0\n}\n\ngetIpVersion() {\n\n    local ipManifestFile=$ipFolder/$ipVersion/ip/manifest.json\n\n    if [ -e ${ipManifestFile} ]\n    then\n        set `cat \"${ipManifestFile}\" |  sed -n -e 's!\"version\":\"\\([0-9][0-9.]*\\)\".*!\\1!p'` > /dev/null\n\n        ipVersion=$1\n    else\n        cd $ipFolder/$ipVersion/system\n\n        temp=$(ls HPIP*|cut -d'.' -f1)\n\n        ipVersion=${temp:4}\n    fi\n\n    echo ${ipVersion}\n}\n\n# Returns 0 if the server is a Gen8; otherwise returns 1.\nisGen8Server() {\n    retCode=1\n\n    productName=$(dmidecode -s system-product-name)\n\n    if [ ! -z \"${productName}\" ]\n    then\n        if [[ \"${productName}\" =~ [Gg][Ee][Nn]8 ]]\n        then\n            retCode=0\n        fi\n    else\n        echo \"error: dmidecode did not return the product name\" 1>&2\n    fi\n\n    return ${retCode}\n}\n\n# Returns 0 if the server is a Gen9; otherwise returns 1.\nisGen9Server() {\n    retCode=1\n\n    productName=$(dmidecode -s system-product-name)\n\n    if [ ! -z \"${productName}\" ]\n    then\n        if [[ \"${productName}\" =~ [Gg][Ee][Nn]9 ]]\n        then\n            retCode=0\n        fi\n    else\n        echo \"error: dmidecode did not return the product name\" 1>&2\n    fi\n\n    return ${retCode}\n}\n\n#Clean iLO blob store\nupdateBlobs() {\n    local ipManifestFile=$ipFolder/$ipVersion/ip/manifest.json\n\n#    touch /tmp/nothing\n#    cd /tmp\n\n#    writeBlob SSLOCALE /tmp/nothing || return 1\n#    writeBlob SSEULA /tmp/nothing || return 1\n#    writeBlob SSERS /tmp/nothing || return 1\n#    writeBlob SSOPTIN /tmp/nothing || return 1\n\n    cd $ipFolder/$ipVersion/system\n\n    temp=$(ls HPIP*|cut -d'.' -f1)\n    ipversion=${temp:4}\n    buildate=$(ls HPIP*|cut -d'.' -f2)\n    buildver=$(ls HPIP*|cut -d'.' -f3)\n\n    echo \"<ip><version>$ipversion</version><build_date>$buildate</build_date><build_ver>$buildver</build_ver></ip>\" > /tmp/ver.xml\n\n    echo \"Updating SMARTSTART_FLASH\"\n\n    writeBlob SMARTSTART_FLASH /tmp/ver.xml || return 1\n\n    # Starting with Intelligent Provisioning version 1.60, the \"manifest.json\" file\n    # comes in the ISO.  The contents of this file is what is typically contained\n    # in the SMARTSTART_MANIFEST blob, which includes the Intelligent Provisioning\n    # version.\n    if [ -e ${ipManifestFile} ]\n    then\n        set `cat \"${ipManifestFile}\" |  sed -n -e 's!\"version\":\"\\([0-9][0-9.]*\\)\".*!\\1!p'` > /dev/null\n\n        versionInManifest=$1\n\n        echo \"Version: ${versionInManifest}\"\n\n        echo \"Updating SMARTSTART_MANIFEST\"\n\n        writeBlob SMARTSTART_MANIFEST ${ipManifestFile}  || return 1\n    else\n        # The \"manifest.json\" file was not found.  This is probably a version of\n        # Intelligent Provisioning that's earlier than 1.60.  We'll use the IP\n        # version and build number we extracted from the \"system/HPIP*\" filename\n        # and create the manifest information ourselves.\n\n        echo \"'${ipManifestFile}' not found\"\n\n        # Put the \".\" in the version after the first digit.\n        ipversion=\"${ipversion:0:1}.${ipversion:1:${#ipversion}}\"\n\n        echo \"Version: ${ipversion}.${buildver}\"\n\n        manifest=\"$(cat <<EOF      \n{\n\"package\":[\n{\n    \"group\":\"ip\",\n    \"dname\":\"Intelligent Provisioning\",\n    \"version\":\"${ipversion}.${buildver}\",\n    \"checked\":\"--\"\n}\n]\n}\nEOF\n)\"\n\n        echo \"Updating SMARTSTART_MANIFEST\"\n\n        echo \"${manifest}\" > /tmp/manifest.json\n\n        writeBlob SMARTSTART_MANIFEST /tmp/manifest.json  || return 1\n    fi\n\n    return 0\n}\n\n#Enable ilo devices\nenableiLOdevices() {\n  xmlsmif < $ipInitrd/etc/gaiusmount.xml > /dev/null\n  if [ \"$?\" -ne \"0\" ]; then\n     echo \"Unable to enable iLO Devices\"\n     return 1\n  fi\n}\n\n##############################################################################\n# Main Routine\n##############################################################################\n\necho \"Parameters to script => ${*}\"\n\n# Parse the command line arguments.\nlastOpt=\nfor arg in $*\ndo\n    optName=`echo $arg | awk -F'=' '{print $1;}'`\n    optValue=${arg:$((${#optName}+1))}\n\n    if [ \"${optName}\" == \"--ip_version\" ]; then\n\n        if [[ ! \"${optValue}\" =~ [^[:space:]] ]]\n        then\n            echo \"Missing argument to '--ip_version'\" 1>&2\n            exit 1\n        fi\n\n        ipVersion=${optValue}\n\n        lastOpt=\n    else\n        echo \"invalid option '${optName}'\" 1>&2\n        exit 1\n    fi\ndone\n\n#Locate the IP Version to use\nfindIPVersion\nif [ $? -ne 0 ]\nthen\n  exit 1\nfi\n\n# Extract the IP provided initrd to get needed files\nextractInitrd\nif [ $? -ne 0 ]\nthen\n  exit 2\nfi\n\n#Do necessary soft links\nexport PATH=$PATH:$ipInitrd/bin\nexport LD_LIBRARY_PATH=$ipInitrd/usr/lib64\n\n#simple hack to avoid unwanted plymouth not found error messages\necho > $ipInitrd/bin/plymouth\nchmod 755 $ipInitrd/bin/plymouth\n\n#Enable iLO Devices\nenableiLOdevices\nif [ $? -ne 0 ]\nthen\n  exit 2\nfi\n\ncd $ipInitrd\n\n# Determine the Intelligent Provisioning version contained in this ISO.\nipVersionInISO=$(getIpVersion)\n\nif [ -z ${ipVersionInISO} ]\nthen\n    echo \"Could not determine the Intelligent Provisioning version for the ISO\" 1>&2\n    exit 1\nelse\n    echo \"IP Version In ISO => ${ipVersionInISO}\"\nfi\n\n# gaius arguments common to Intelligent Provisioning 1.XX and 2.00.\ngaiusArgs=\"${ipFolder}/${ipVersion}/ip/gaius.img.gz ${ipFolder}/${ipVersion}/ip/vid.img.gz\"\n\n# Is this a Gen9 server?\nif isGen9Server\nthen\n    # Intelligent Provisioning 2.XX can only be installed on Gen9 servers, so make\n    # sure that this version of Intelligent Provisioning is 2.XX.\n    if [[ \"${ipVersionInISO}\" =~ ^2\\..+ ]]\n    then\n        bigVidImage=\"${ipFolder}/${ipVersion}/ip/bigvid.img.gz\"\n\n        # The \"gaius\" command in Intelligent Provisioning V2.00 requires \n        # \"bigvid.img.gz\" as the 3rd argument.  If \"bigvid.img.gz\" is present \n        # on the media, then it's assumed that Intelligent Provisioning V2.00\n        # or greater is being used, and we'll append it to the arguments.\n        if [ -e \"${bigVidImage}\" ]\n        then\n            # Intelligent Provisioning V2.00 or greater will update the \n            # SMARTSTART_FLASH and SMARTSTART_MANIFEST blobs automatically.\n            blobUpdateNeeded=0\n\n            # In Intelligent Provisioning V2.00, the \"-b\" option was added so \n            # that the SMARTSTART_MANIFEST and SMARTSTART_FLASH options are \n            # updated automatically.\n            gaiusArgs=\"-b ${ipFolder}/${ipVersion} ${gaiusArgs} ${bigVidImage}\"\n        else\n            echo \"${bigVidImage} not found\"\n        fi\n    else\n        echo \"Intelligent Provisioning version '${ipVersionInISO}' is not supported on Gen9 servers\" 1>&2\n        exit 1\n    fi\nelif isGen8Server\nthen\n    # Intelligent Provisioning 1.XX can only be installed on Gen8 servers, so make\n    # sure that this version of Intelligent Provisioning is 1.XX.\n    if  ! [[ \"${ipVersionInISO}\" =~ ^1\\..+ ]]\n    then\n        echo \"Intelligent Provisioning version '${ipVersionInISO}' is not supported on Gen8 servers\" 1>&2\n        exit 1\n    fi\nelse\n    echo \"Intelligent Provisioning is only supported on Gen8 servers or newer\" 1>&2\n    exit 1\nfi\n\n# Makes sure Intelligent Provisioning is set up for DHCP on a NICs.\nwriteSsnetworkBlobForDhcp\n\nif [ $? != 0 ]\nthen\n    echo \"Failed to update the SSNETWORK blob\" 1>&2\n    exit 1\nfi\n\necho \"Start Time: $(date)\"\n\necho \"Executing: gaius ${gaiusArgs}\"\n\n#Start the actual Update process\noutput=$(gaius ${gaiusArgs} 2>&1)\n\nretCode=$?\n\necho \"End Time: $(date)\"\n\nif [ ${retCode} -eq 0 ]\nthen\n    echo \"Successfully updated Intelligent Provisioning firmware\"\nelse\n    echo \"Failed to update Intelligent Provisioning firmware\" 1>&2\n    echo ${output} 1>&2\n    exit 9\nfi\n\nsync\n\n# Our script should only update the SMARTSTART_FLASH and SMARTSTART_MANIFEST blobs\n# if we're using Intelligent Provisioning V1.XX.  Starting with Intelligent Provisioning\n# V2.00, the \"gaius\" command will update the blobs automatically.\nif [ ${blobUpdateNeeded} -eq 1 ]\nthen\n    # Update HP Blob store to reset values\n    updateBlobs\n\n    if [ $? != 0 ]\n    then\n        echo \"Failed to update blobs\" 1>&2\n        exit 1\n    fi\nfi\n\nexit 0",
            "description": "Updates the target server's (Gen8 or above)  Intelligent Provisioning firmware with specified Intelligent Provisioning media.\n\nOptional Parameters:\n--ip_version=directory_name    The name of the directory containing the Intelligent Provisioning media to be installed, such as \"1.60\".  If the value is blank or \"latest\", the script automatically selects the directory with the latest version as determined by sort order.\n\nRequirements:\n* Media Server mounted with Set Media Source script.\n* The directories containing the extracted HP Intelligent Provisioning ISO must reside on the Media Server under the \"\\Media\\ip\" directory.\n",
            "status": null,
            "name": "Update Intelligent Provisioning Firmware",
            "state": null,
            "eTag": "2015-08-04T07:30:28.000Z",
            "modified": "2015-08-04T07:30:28.000Z",
            "created": "2015-08-04T07:30:28.000Z",
            "category": "os-deployment-server-scripts",
            "uri": "/rest/os-deployment-server-scripts/1960001"
        },
        {
            "runAsSuperUser": true,
            "serverChanging": true,
            "codeType": "SH",
            "displayCodeType": "Unix",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "10",
                    "createdBy": "opsware",
                    "createdDate": "2015-08-04T07:30:31.000Z",
                    "usage": "This script is intended to accompany the Insight Control server provisioning Capturing and Installing Linux System Images white paper. \n\nThis script mounts the filesystem so the image can be written to it.  \n",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-08-04T07:30:31.000Z",
            "version": {
                "versionLabel": "10",
                "createdBy": "opsware",
                "createdDate": "2015-08-04T07:30:31.000Z",
                "usage": "This script is intended to accompany the Insight Control server provisioning Capturing and Installing Linux System Images white paper. \n\nThis script mounts the filesystem so the image can be written to it.  \n",
                "current": true
            },
            "source": "#!/bin/bash\n\n#\n# (C) Copyright 2014-2015 Hewlett-Packard Development Company, L.P.\n#\n\n#Now mount new setup.\nmkdir -p /mnt/target\nmount /dev/sda2 /mnt/target\n",
            "description": "This script is intended to accompany the Insight Control server provisioning Capturing and Installing Linux System Images white paper. \n\nThis script mounts the filesystem so the image can be written to it.  \n",
            "status": null,
            "name": "Sample - Mount SLES Filesystem",
            "state": null,
            "eTag": "2015-08-04T07:30:31.000Z",
            "modified": "2015-08-04T07:30:31.000Z",
            "created": "2015-08-04T07:30:31.000Z",
            "category": "os-deployment-server-scripts",
            "uri": "/rest/os-deployment-server-scripts/1990001"
        },
        {
            "runAsSuperUser": true,
            "serverChanging": true,
            "codeType": "BAT",
            "displayCodeType": "Windows .BAT",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "57",
                    "createdBy": "opsware",
                    "createdDate": "2015-08-04T07:30:33.000Z",
                    "usage": "Installs the Windows Hyper-V Role using ServerManagerCmd or PowerShell on a Windows production OS.  A reboot is required after this script is run.\n\nParameters:  None\n\nCustom Attributes: None",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-08-04T07:30:33.000Z",
            "version": {
                "versionLabel": "57",
                "createdBy": "opsware",
                "createdDate": "2015-08-04T07:30:33.000Z",
                "usage": "Installs the Windows Hyper-V Role using ServerManagerCmd or PowerShell on a Windows production OS.  A reboot is required after this script is run.\n\nParameters:  None\n\nCustom Attributes: None",
                "current": true
            },
            "source": "@echo off\n\n:: (C) Copyright 2013-2015 Hewlett-Packard Development Company, L.P.\n\nset wdir=%windir%\nset FEATURE=Hyper-V\nset RESULTFILE=\"%wdir%\\HVInstallResult.xml\"\n\n:: Try PowerShell if exists\nfor %%X in (powershell.exe) do (set FOUND1=%%~$PATH:X)\nif defined FOUND1 (\n   echo Import-module servermanager > \"%wdir%\\FeatureInstall.ps1\"\n   echo add-windowsfeature -Name %FEATURE% -logPath %RESULTFILE% >> \"%wdir%\\FeatureInstall.ps1\"\n   powershell.exe -ExecutionPolicy Unrestricted -NoLogo -NonInteractive -NoProfile -WindowStyle Hidden -File \"%wdir%\\FeatureInstall.ps1\"\n   set rc=%errorlevel%\n   goto EndWithFailureMessage\n)\n\n:: Try ServerManagerCmd if exists and PowerShell wasn't found\nfor %%X in (ServerManagerCmd.exe) do (set FOUND2=%%~$PATH:X)\nif defined FOUND2 (\n   ServerManagerCmd.exe -install %FEATURE% -resultPath %RESULTFILE% >> %temp%\\status.log\n   set rc=%errorlevel%\n   goto EndWithFailureMessage\n) \n\nif NOT defined rc (\n   echo PowerShell and ServerManagerCmd were not found and could not set %FEATURE%\n   set rc=99\n   goto End\n)\n\n:EndWithFailureMessage\nif NOT %rc%==0 (\n   echo PowerShell and ServerManagerCmd Add Windows Feature failed to install %FEATURE%:  error code %rc%\n   echo Refer to %RESULTFILE% log file.\n)\n\n:End\nexit /B %rc%",
            "description": "Installs the Windows Hyper-V Role using ServerManagerCmd or PowerShell on a Windows production OS.  A reboot is required after this script is run.\n\nParameters:  None\n\nCustom Attributes: None",
            "status": null,
            "name": "Add Windows Hyper-V Role",
            "state": null,
            "eTag": "2015-08-04T07:30:33.000Z",
            "modified": "2015-08-04T07:30:33.000Z",
            "created": "2015-08-04T07:30:32.000Z",
            "category": "os-deployment-server-scripts",
            "uri": "/rest/os-deployment-server-scripts/2000001"
        },
        {
            "runAsSuperUser": true,
            "serverChanging": true,
            "codeType": "SH",
            "displayCodeType": "Unix",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "11",
                    "createdBy": "opsware",
                    "createdDate": "2015-08-04T07:30:33.000Z",
                    "usage": "This script is intended to accompany the Insight Control server provisioning Capturing and Installing Linux System Images white paper. \n\nThis script unmounts all mounted partitions. The LinuxPE service OS automatically mounts partitions on the disk as part of its startup process.  Before the disks can be repartitioned, all mounts need to be removed.\n",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-08-04T07:30:33.000Z",
            "version": {
                "versionLabel": "11",
                "createdBy": "opsware",
                "createdDate": "2015-08-04T07:30:33.000Z",
                "usage": "This script is intended to accompany the Insight Control server provisioning Capturing and Installing Linux System Images white paper. \n\nThis script unmounts all mounted partitions. The LinuxPE service OS automatically mounts partitions on the disk as part of its startup process.  Before the disks can be repartitioned, all mounts need to be removed.\n",
                "current": true
            },
            "source": "#!/bin/bash\n\n#\n# (C) Copyright 2014-2015 Hewlett-Packard Development Company, L.P.\n#\n\n#\n# Unmount all disk mounts so that we can work on the disks\n#\necho \"Unmounting hard disk partitions...\"\nMNTS=`awk '{print $2}' < /etc/mtab | sort -r`\nfor MNT in $MNTS\ndo\nif echo $MNT | grep -qE '((sd|hd)[a-z]{1,2}[1-9]+|cciss/c[0-9]d[0-9])' \n\tthen\n\t\tumount $MNT\n\tfi\n\tif echo $MNT | grep -qE '^/mnt/(mapper|local_root|by-uuid|by-label)'\n\tthen\n\t\tumount $MNT\n\tfi\ndone\n",
            "description": "This script is intended to accompany the Insight Control server provisioning Capturing and Installing Linux System Images white paper. \n\nThis script unmounts all mounted partitions. The LinuxPE service OS automatically mounts partitions on the disk as part of its startup process.  Before the disks can be repartitioned, all mounts need to be removed.\n",
            "status": null,
            "name": "Sample - Unmount RHEL Disk Partitions",
            "state": null,
            "eTag": "2015-08-04T07:30:33.000Z",
            "modified": "2015-08-04T07:30:33.000Z",
            "created": "2015-08-04T07:30:33.000Z",
            "category": "os-deployment-server-scripts",
            "uri": "/rest/os-deployment-server-scripts/2020001"
        },
        {
            "runAsSuperUser": true,
            "serverChanging": true,
            "codeType": "SH",
            "displayCodeType": "Unix",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "12",
                    "createdBy": "opsware",
                    "createdDate": "2015-08-04T07:30:34.000Z",
                    "usage": "This script is intended to accompany the Insight Control server provisioning Capturing and Installing Linux System Images white paper. \n\nThis script creates a target directory (/mnt/target) and then mounts the target servers image to /mnt/target.  The example script below uses a standard RH6.3 installation with only two mount points.  If the servers /etc/fstab indicates more than just /boot and /root as mount points, then the script will need to be modified to reflect the mount points of the image to be captured.\n\nIMPORTANT:  Do not mount a swap partition.  Reviewing the target servers /etc/fstab file will provide information on what partitions are swap.\n",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-08-04T07:30:34.000Z",
            "version": {
                "versionLabel": "12",
                "createdBy": "opsware",
                "createdDate": "2015-08-04T07:30:34.000Z",
                "usage": "This script is intended to accompany the Insight Control server provisioning Capturing and Installing Linux System Images white paper. \n\nThis script creates a target directory (/mnt/target) and then mounts the target servers image to /mnt/target.  The example script below uses a standard RH6.3 installation with only two mount points.  If the servers /etc/fstab indicates more than just /boot and /root as mount points, then the script will need to be modified to reflect the mount points of the image to be captured.\n\nIMPORTANT:  Do not mount a swap partition.  Reviewing the target servers /etc/fstab file will provide information on what partitions are swap.\n",
                "current": true
            },
            "source": "#!/bin/bash\n# (C) Copyright 2012-2015 Hewlett-Packard Development Company, L.P.\nmkdir -p /mnt/target\nrootLoc=$(ls /dev/mapper/|grep root) \nmount \"/dev/mapper/$rootLoc\" /mnt/target\n \nmkdir -p /mnt/target/home\nhomeLoc=$(ls /dev/mapper/|grep home) \nmount /dev/mapper/$homeLoc /mnt/target/home\n \nif [ -d /sys/firmware/efi ]\nthen\n    mkdir -p /mnt/target/boot\n    mount /dev/sda2 /mnt/target/boot \n     \n    mkdir -p /mnt/target/boot/efi\n    mount /dev/sda1 /mnt/target/boot/efi\nelse\n    mkdir -p /mnt/target/boot\n    mount /dev/sda1 /mnt/target/boot\nfi",
            "description": "This script is intended to accompany the Insight Control server provisioning Capturing and Installing Linux System Images white paper. \n\nThis script creates a target directory (/mnt/target) and then mounts the target servers image to /mnt/target.  The example script below uses a standard RH6.3 installation with only two mount points.  If the servers /etc/fstab indicates more than just /boot and /root as mount points, then the script will need to be modified to reflect the mount points of the image to be captured.\n\nIMPORTANT:  Do not mount a swap partition.  Reviewing the target servers /etc/fstab file will provide information on what partitions are swap.\n",
            "status": null,
            "name": "Sample - Mount RHEL Filesystem",
            "state": null,
            "eTag": "2015-08-04T07:30:34.000Z",
            "modified": "2015-08-04T07:30:34.000Z",
            "created": "2015-08-04T07:30:34.000Z",
            "category": "os-deployment-server-scripts",
            "uri": "/rest/os-deployment-server-scripts/2030001"
        },
        {
            "runAsSuperUser": true,
            "serverChanging": true,
            "codeType": "SH",
            "displayCodeType": "Unix",
            "isCustomerContent": false,
            "allVersions": [
                {
                    "versionLabel": "79",
                    "createdBy": "opsware",
                    "createdDate": "2015-08-04T07:30:34.000Z",
                    "usage": "Unmounts all the partitions belonging to the boot disk.\n\nBy default, the boot disk is computed as the first hard drive listed in /proc/partitions.\n\nOptional Custom Attributes:\n\nboot_disk - The absolute path to the device file for the boot disk.  For example, /dev/sda.",
                    "current": true
                }
            ],
            "currentVersionChangedBy": "opsware",
            "currentVersionChangedDate": "2015-08-04T07:30:34.000Z",
            "version": {
                "versionLabel": "79",
                "createdBy": "opsware",
                "createdDate": "2015-08-04T07:30:34.000Z",
                "usage": "Unmounts all the partitions belonging to the boot disk.\n\nBy default, the boot disk is computed as the first hard drive listed in /proc/partitions.\n\nOptional Custom Attributes:\n\nboot_disk - The absolute path to the device file for the boot disk.  For example, /dev/sda.",
                "current": true
            },
            "source": "#!/opt/opsware/agent/bin/python\n# -*- mode: Python; tab-width: 4; indent-tabs-mode: nil; -*-\n# ex: set tabstop=4 :\n# Please do not change the two lines above. See PEP 8, PEP 263.\n#\n\"\"\"\nUnmounts all the partitions belonging to the boot disk.\n\nBy default, the boot disk is computed as the first hard drive listed in\n/proc/partitions.\n\n(C) Copyright 2013-2015 Hewlett-Packard Development Company, L.P.\n\"\"\"\n\nimport os\nimport sys\nimport re\n\nfrom osprov.util import process\nfrom osprov.errors import ShowErrorMessage\nfrom osprov.osbp import logger\nfrom osprov.diskmgr.diskmanager import DiskManager\n\nEC_SUCCESS = 0\nEC_NO_BOOT_DISK = 10\nEC_FAILED_TO_MOUNT = 11\nEC_IN_USE = 12\n\nBOOT_DISK = \"@boot_disk@\" #ScriptWeaver will parametrize this data at run time\n\n# We don't need the object byt by getting it, it will get set up\nLOG = logger.getIt(\"osprov.diskmgr\")\n\n#######################################################################\n# Returns True if the specified device is mounted on the specified\n# mount point.\n#######################################################################\n\ndef isDeviceMountedOnMountPoint(deviceName, mountPoint):\n\n\tmountOutput = process.getStdout(\"mount\")\n\n\tif mountOutput is not None:\n\t\tmountRE = re.compile(\"^%s\\s+on\\s+%s\\s+.*\" % (deviceName,mountPoint))\n\n\t\tlines = mountOutput.splitlines()\n\n\t\tfor line in lines:\n\t\t\tmatch = mountRE.match(line)\n\t \t\tif match:\n\t\t\t\treturn True\n\n\treturn False\n\n#######################################################################\n# Counts the number of devices mounted on the specified mount point.\n#######################################################################\n\ndef countDevicesMountedOnMountPoint(mountPoint):\n\n\tcount = 0\n\n\tmountOutput = process.getStdout(\"mount\")\n\n\tif mountOutput is not None:\n\t\tmountRE = re.compile(\"^\\S+\\s+on\\s+%s\\s+.*\" % mountPoint)\n\n\t\tlines = mountOutput.splitlines()\n\n\t\tfor line in lines:\n\t\t\tmatch = mountRE.match(line)\n\t \t\tif match:\n\t\t\t\tcount += 1\n\n\treturn count\n\n#######################################################################\n# Unmounts all the partitions belonging to the specified disk.\n#######################################################################\n\ndef unmountAllPartitions(disk):\n\n\tprint \"Unmounting partitions for disk '%s'\" % disk.deviceName\n\n\t# Get all the partitions belonging to this disk.\n\tfor partition in disk.getPartitions():\n\n\t\tprint \"Checking if partition '%s' is mounted\" % partition.getDeviceFilePath()\n\n\t\t# Get all the mount points on which the partition is mounted.\n\t\tmountPoints = partition.getMountPoints()\n\n\t\tif (len(mountPoints) == 0):\n\t\t\tprint \"Partition '%s' is not mounted anywhere\" % partition.getDeviceFilePath()\n\t\t\tcontinue\n\t\telse:\n\t\t\tprint \"Partition '%s' has %d mount points\" % (partition.getDeviceFilePath(), len(mountPoints))\n\n\t\t# Unmount the partition from each mount point on which it is mounted.\n\t\tfor mountPoint in mountPoints:\n\t\t\ttry:\n\t\t\t\tprint \"Unmounting '%s' from '%s'\" % (partition.getDeviceFilePath(), mountPoint)\n\n\t\t\t\t# Count the number of devices that are mounted on this mount point.\n\t\t\t\tcount = countDevicesMountedOnMountPoint(mountPoint)\n\n\t\t\t\tprint \"There are %d devices mounted on %s\" % (count, mountPoint)\n\n\t\t\t\ti = 0\n\n\t\t\t\t# Since there may be other devices mounted on the same\n\t\t\t\t# mount point, we need to keep unmounting devices from the\n\t\t\t\t# mount point, until our partition is unmounted.\n\t\t\t\twhile (i < count):\n\t\t\t\t\t# Is the partition unmounted?\n\t\t\t\t\tif isDeviceMountedOnMountPoint(partition.getDeviceFilePath(), mountPoint):\n\t\t\t\t\t\tprint \"Attempt #%d\" % (i+1)\n\t\t\t\t\t\tprocess.runIt(\"umount '%s'\" % mountPoint, quiet=True, log=LOG)\n\t\t\t\t\t\ti += 1\n\t\t\t\t\telse:\n\t\t\t\t\t\t# The partition is no longer mounted on the mount point.\n\t\t\t\t\t\tbreak\n\n\t\t\t\t# If we've tried to unmount every device mounted on the mount point,\n\t\t\t\t# but the partition is still mounted, then issue an error.\n\t\t\t\tif isDeviceMountedOnMountPoint(partition.getDeviceFilePath(), mountPoint):\n\t\t\t\t\traise ShowErrorMessage(\"Could not unmount device '%s' from '%s'\" % (partition.getDeviceFilePath(), mountPoint))\n\n\t\t\t\tprint \"Successfully unmounted '%s' from '%s'\" % (partition.getDeviceFilePath(), mountPoint)\n\n\t\t\texcept OSError:\n\t\t\t\traise ShowErrorMessage(\n\t\t\t\t\t\"Could not unmount filesystem mounted at '%s'.\"\\\n\t\t\t\t\t\" Ensure no shell sessions are using files under this\"\\\n\t\t\t\t\t\" mount point.\"\n\t\t\t\t\t% mountPoint, EC_IN_USE)\n\n#######################################################################\n# Main Routine.\n#######################################################################\n\ndef main():\n\t\"\"\"Main entry point when executed as a script from the command line\"\"\"\n\ttry:\n\t\tdm = DiskManager()\n\t\tdm.disable_automount()\n\t\tdm.unmountOurs()\n\n\t\tdisks = dm.get_disk_inventory(BOOT_DISK)\n\n\t\tbootDisks = [disk for disk in disks if disk.isBootDisk]\n\t\tif not bootDisks:\n\t\t\tprint \"Could not identify the system's boot disk\"\n\t\t\treturn EC_NO_BOOT_DISK\n\t\tbootDisk = bootDisks[0]\n\n\t\tunmountAllPartitions(bootDisk)\n\n\texcept ShowErrorMessage, info:\n\t\tprint info.args[0]\n\t\treturn info.args[1]\n\treturn EC_SUCCESS\n\nif __name__ == \"__main__\":\n\tsys.exit(main())\n",
            "description": "Unmounts all the partitions belonging to the boot disk.\n\nBy default, the boot disk is computed as the first hard drive listed in /proc/partitions.\n\nOptional Custom Attributes:\n\nboot_disk - The absolute path to the device file for the boot disk.  For example, /dev/sda.",
            "status": null,
            "name": "Unmount All Boot Disk Partitions",
            "state": null,
            "eTag": "2015-08-04T07:30:34.000Z",
            "modified": "2015-08-04T07:30:34.000Z",
            "created": "2015-08-04T07:30:34.000Z",
            "category": "os-deployment-server-scripts",
            "uri": "/rest/os-deployment-server-scripts/2040001"
        }
    ],
    "nextPageUri": null,
    "start": 0,
    "prevPageUri": null,
    "total": 98,
    "count": 98,
    "eTag": null,
    "modified": null,
    "created": null,
    "category": null,
    "uri": null
}
